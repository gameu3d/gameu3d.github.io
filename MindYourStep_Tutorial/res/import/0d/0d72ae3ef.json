[{"__type__":"cc.EffectAsset","_name":"builtin-standard","techniques":[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs:vert|standard-fs:frag","properties":{"tilingOffset":{"value":[1,1,0,0],"type":16},"albedo":{"value":[1,1,1,1],"inspector":{"type":"color"},"type":16},"albedoScale":{"value":[1,1,1,0],"type":16},"pbrParams":{"value":[0.8,0.6,1,1],"type":16},"pbrScale":{"value":[1,1,1,1],"type":16},"emissive":{"value":[0,0,0,1],"inspector":{"type":"color"},"type":16},"emissiveScale":{"value":[1,1,1,1],"type":16},"albedoMap":{"value":"grey","type":28},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"emissiveMap":{"value":"grey","type":28}}}]},{"name":"transparent","passes":[{"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"program":"builtin-standard|standard-vs:vert|standard-fs:frag","depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"value":[1,1,0,0],"type":16},"albedo":{"value":[1,1,1,1],"inspector":{"type":"color"},"type":16},"albedoScale":{"value":[1,1,1,0],"type":16},"pbrParams":{"value":[0.8,0.6,1,1],"type":16},"pbrScale":{"value":[1,1,1,1],"type":16},"emissive":{"value":[0,0,0,1],"inspector":{"type":"color"},"type":16},"emissiveScale":{"value":[1,1,1,1],"type":16},"albedoMap":{"value":"grey","type":28},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"emissiveMap":{"value":"grey","type":28}}}]}],"shaders":[{"hash":157415429,"glsl3":{"vert":"\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nstruct StandardAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\n\nin vec3 a_position;\nin vec3 a_normal;\nin vec3 a_tangent;\n\nvoid CCDecode (out StandardAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n\n#if CC_USE_SKINNING\n\nin vec4 a_weights;\nin vec4 a_joints;\n\n#if CC_USE_SKINNING == 1\n  uniform CCSkinning {\n    vec4 cc_jointsData[30 * 3];\n  };\n#else\n  uniform CCSkinningTexture {\n    vec4 cc_jointsTextureSizeInv;\n  };\n  uniform sampler2D cc_jointsTexture;\n#endif\n\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\n\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n\n}\n\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\n\nvoid CCSkin(inout vec3 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position = VectorTransformQuat(position * S, R) + T;\n}\n\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n\n#endif\n\nstruct StandardVertInput {\n  highp vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\n\nvoid CCAttrToInput (in StandardAttributes attr, out StandardVertInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\n\nvoid CCVertInput (out StandardVertInput In) {\n  StandardAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\n\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n\n  vec4 pbrParams;\n\n  vec4 pbrScale;\n\n  vec4 emissive;\n  vec4 emissiveScale;\n};\n\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n#endif\n\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n\n  vec4 pos = cc_matWorld * vec4(In.position, 1.0);\n\n  v_position = pos.xyz;\n  v_normal = (cc_matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = (cc_matWorldIT * vec4(In.tangent, 0.0)).xyz;\n    v_bitangent = cross(v_tangent, v_normal);\n  #endif\n\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n\n  return cc_matViewProj * pos;\n}\n\nvoid main() { gl_Position = vert(); }\n","frag":"\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n\n  vec4 cc_sphereLitSizeRange[2];\n\n  vec4 cc_sphereLitColor[2];\n\n  highp vec4 cc_spotLitPos[2];\n\n  vec4 cc_spotLitSizeRangeAngle[2];\n\n  vec4 cc_spotLitDir[2];\n\n  vec4 cc_spotLitColor[2];\n\n};\n\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\n\n#endif\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n\n  float factor2 = factor * factor;\n\n  float factor3 = factor2 * factor2;\n\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\n\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\n\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\n\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\n\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\n\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n\n  return lighting;\n}\n\nstruct StandardSurface {\n\n  vec3 albedo;\n  float alpha;\n\n  vec3 position;\n  vec3 normal;\n\n  float roughness;\n  float metallic;\n  float occlusion;\n\n  vec3 emissive;\n};\n\nvec4 CCStandardShading (StandardSurface s) {\n\n  vec3 diffuse = s.albedo * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo, s.metallic);\n\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(s.normal, V)), 0.001);\n  float NL = max(dot(s.normal, L), 0.001);\n  float NH = max(dot(s.normal, H), 0.0);\n\n  specular = BRDFApprox(specular, s.roughness, NV);\n\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, s.normal);\n\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n\n  finalColor += CalcDynamicLighting(s.position, s.normal, V, diffuse, specular, s.roughness);\n\n  float fAmb = dot(s.normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, s.normal));\n    vec3 env = SRGBToLinear(texture(cc_environment, R).rgb) * cc_ambientSky.w;\n    finalColor += env * specular;\n  #endif\n\n  finalColor = finalColor * s.occlusion;\n\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n\n  return vec4(finalColor, s.alpha);\n}\n\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\n\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n\n  vec4 pbrParams;\n\n  vec4 pbrScale;\n\n  vec4 emissive;\n  vec4 emissiveScale;\n};\n\nin vec3 v_position;\n\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  in vec2 v_uv;\n#endif\n\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n#endif\n\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor.rgb * albedoScale.xyz;\n  s.alpha = albedo.a;\n\n  #if USE_ALPHA_TEST\n    if(s.alpha < albedoScale.w)\n      discard;\n  #endif\n\n  s.normal = normalize(v_normal);\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal = normalize(\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * s.normal);\n  #endif\n\n  s.position = v_position;\n\n  #if USE_PBR_MAP\n    vec4 pbr = texture(pbrMap, v_uv);\n  #else\n    vec4 pbr = pbrParams;\n  #endif\n  pbr *= pbrScale;\n  s.roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  s.metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  s.occlusion = pbr.AO_CHANNEL;\n\n  s.emissive = emissive.rgb * emissiveScale.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n}\n\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\n\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"},"glsl1":{"vert":"\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\n\nstruct StandardAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec3 a_tangent;\n\nvoid CCDecode (out StandardAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n\n#if CC_USE_SKINNING\n\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n\n#if CC_USE_SKINNING == 1\n  uniform vec4 cc_jointsData[90];\n\n#else\n  uniform vec4 cc_jointsTextureSizeInv;\n  uniform sampler2D cc_jointsTexture;\n#endif\n\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture2D(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture2D(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture2D(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\n\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n\n}\n\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\n\nvoid CCSkin(inout vec3 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position = VectorTransformQuat(position * S, R) + T;\n}\n\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n\n#endif\n\nstruct StandardVertInput {\n  highp vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\n\nvoid CCAttrToInput (in StandardAttributes attr, out StandardVertInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\n\nvoid CCVertInput (out StandardVertInput In) {\n  StandardAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\n\nuniform vec4 tilingOffset;\n\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n#endif\n\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n\n  vec4 pos = cc_matWorld * vec4(In.position, 1.0);\n\n  v_position = pos.xyz;\n  v_normal = (cc_matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = (cc_matWorldIT * vec4(In.tangent, 0.0)).xyz;\n    v_bitangent = cross(v_tangent, v_normal);\n  #endif\n\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n\n  return cc_matViewProj * pos;\n}\n\nvoid main() { gl_Position = vert(); }\n","frag":"\nprecision mediump float;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\n\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\n\n#endif\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n\n  float factor2 = factor * factor;\n\n  float factor3 = factor2 * factor2;\n\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\n\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\n\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\n\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\n\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\n\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n\n  return lighting;\n}\n\nstruct StandardSurface {\n\n  vec3 albedo;\n  float alpha;\n\n  vec3 position;\n  vec3 normal;\n\n  float roughness;\n  float metallic;\n  float occlusion;\n\n  vec3 emissive;\n};\n\nvec4 CCStandardShading (StandardSurface s) {\n\n  vec3 diffuse = s.albedo * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo, s.metallic);\n\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(s.normal, V)), 0.001);\n  float NL = max(dot(s.normal, L), 0.001);\n  float NH = max(dot(s.normal, H), 0.0);\n\n  specular = BRDFApprox(specular, s.roughness, NV);\n\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, s.normal);\n\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n\n  finalColor += CalcDynamicLighting(s.position, s.normal, V, diffuse, specular, s.roughness);\n\n  float fAmb = dot(s.normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, s.normal));\n    vec3 env = SRGBToLinear(textureCube(cc_environment, R).rgb) * cc_ambientSky.w;\n    finalColor += env * specular;\n  #endif\n\n  finalColor = finalColor * s.occlusion;\n\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n\n  return vec4(finalColor, s.alpha);\n}\n\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\n\nuniform vec4 albedo;\nuniform vec4 albedoScale;\nuniform vec4 pbrParams;\nuniform vec4 pbrScale;\nuniform vec4 emissive;\nuniform vec4 emissiveScale;\n\nvarying vec3 v_position;\n\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  varying vec2 v_uv;\n#endif\n\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor.rgb * albedoScale.xyz;\n  s.alpha = albedo.a;\n\n  #if USE_ALPHA_TEST\n    if(s.alpha < albedoScale.w)\n      discard;\n  #endif\n\n  s.normal = normalize(v_normal);\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal = normalize(\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * s.normal);\n  #endif\n\n  s.position = v_position;\n\n  #if USE_PBR_MAP\n    vec4 pbr = texture2D(pbrMap, v_uv);\n  #else\n    vec4 pbr = pbrParams;\n  #endif\n  pbr *= pbrScale;\n  s.roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  s.metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  s.occlusion = pbr.AO_CHANNEL;\n\n  s.emissive = emissive.rgb * emissiveScale.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n}\n\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\n\nvoid main() { gl_FragColor = frag(); }\n"},"builtins":{"globals":{"blocks":["CCGlobal"],"samplers":["cc_environment"]},"locals":{"blocks":["CCLocal","CCSkinning","CCSkinningTexture","CCForwardLight"],"samplers":["cc_jointsTexture"]}},"defines":[{"name":"CC_USE_SKINNING","type":"number","defines":[],"range":[0,3]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"ROUGHNESS_CHANNEL","type":"string","defines":[],"options":["r","g","b","a"]},{"name":"METALLIC_CHANNEL","type":"string","defines":[],"options":["g","r","b","a"]},{"name":"AO_CHANNEL","type":"string","defines":[],"options":["b","r","g","a"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","members":[{"name":"tilingOffset","type":16,"count":1,"size":16},{"name":"albedo","type":16,"count":1,"size":16},{"name":"albedoScale","type":16,"count":1,"size":16},{"name":"pbrParams","type":16,"count":1,"size":16},{"name":"pbrScale","type":16,"count":1,"size":16},{"name":"emissive","type":16,"count":1,"size":16},{"name":"emissiveScale","type":16,"count":1,"size":16}],"size":112,"defines":[],"binding":0}],"samplers":[{"name":"albedoMap","type":28,"count":1,"defines":["USE_ALBEDO_MAP"],"binding":30},{"name":"normalMap","type":28,"count":1,"defines":["USE_NORMAL_MAP"],"binding":31},{"name":"pbrMap","type":28,"count":1,"defines":["USE_PBR_MAP"],"binding":32},{"name":"emissiveMap","type":28,"count":1,"defines":["USE_EMISSIVE_MAP"],"binding":33}],"dependencies":{},"name":"builtin-standard|standard-vs:vert|standard-fs:frag"}]},{"__type__":"cc.Material","_effectAsset":{"__uuid__":"1brw/JvvpFnIvdrxpFCgMZ"}}]