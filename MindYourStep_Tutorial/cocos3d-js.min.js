var cc_modular = function(exports) {
    "use strict";
    function _typeof(obj) {
        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        })(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
            "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Constructor;
    }
    function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    function _inherits(subClass, superClass) {
        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: !0,
                configurable: !0
            }
        }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        })(o);
    }
    function _setPrototypeOf(o, p) {
        return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            return o.__proto__ = p, o;
        })(o, p);
    }
    function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _possibleConstructorReturn(self, call) {
        return !call || "object" != typeof call && "function" != typeof call ? _assertThisInitialized(self) : call;
    }
    function _superPropBase(object, property) {
        for (;!Object.prototype.hasOwnProperty.call(object, property) && null !== (object = _getPrototypeOf(object)); ) ;
        return object;
    }
    function _get(target, property, receiver) {
        return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function _get(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (base) {
                var desc = Object.getOwnPropertyDescriptor(base, property);
                return desc.get ? desc.get.call(receiver) : desc.value;
            }
        })(target, property, receiver || target);
    }
    function set(target, property, value, receiver) {
        return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function set(target, property, value, receiver) {
            var desc, base = _superPropBase(target, property);
            if (base) {
                if ((desc = Object.getOwnPropertyDescriptor(base, property)).set) return desc.set.call(receiver, value), 
                !0;
                if (!desc.writable) return !1;
            }
            if (desc = Object.getOwnPropertyDescriptor(receiver, property)) {
                if (!desc.writable) return !1;
                desc.value = value, Object.defineProperty(receiver, property, desc);
            } else _defineProperty(receiver, property, value);
            return !0;
        })(target, property, value, receiver);
    }
    function _set(target, property, value, receiver, isStrict) {
        if (!set(target, property, value, receiver || target) && isStrict) throw new Error("failed to set property");
        return value;
    }
    function _toConsumableArray(arr) {
        return function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
        }(arr) || function _iterableToArray(iter) {
            if (Symbol.iterator in Object(iter) || "[object Arguments]" === Object.prototype.toString.call(iter)) return Array.from(iter);
        }(arr) || function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
        }();
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
        descriptor && Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        return Object.keys(descriptor).forEach(function(key) {
            desc[key] = descriptor[key];
        }), desc.enumerable = !!desc.enumerable, desc.configurable = !!desc.configurable, 
        ("value" in desc || desc.initializer) && (desc.writable = !0), desc = decorators.slice().reverse().reduce(function(desc, decorator) {
            return decorator(target, property, desc) || desc;
        }, desc), context && void 0 !== desc.initializer && (desc.value = desc.initializer ? desc.initializer.call(context) : void 0, 
        desc.initializer = void 0), void 0 === desc.initializer && (Object.defineProperty(target, property, desc), 
        desc = null), desc;
    }
    var _global = "undefined" == typeof window ? global : window, cc$1 = _global.cc = _global.cc || {};
    function defineMacro(name, defaultValue) {
        void 0 === _global[name] && (_global[name] = defaultValue);
    }
    cc$1.internal = cc$1.internal || {}, defineMacro("CC_BUILD", !1), _global.CC_BUILD = !0, 
    _global.CC_TEST = !1, _global.CC_EDITOR = !1, _global.CC_PREVIEW = !1, _global.CC_DEV = !1, 
    _global.CC_DEBUG = !1, _global.CC_JSB = !1, _global.CC_WECHATGAME_SUB = !1, _global.CC_WECHATGAME = !1, 
    _global.CC_QQPLAY = !1, _global.CC_RUNTIME = !1, _global.CC_SUPPORT_JIT = !0;
    _global.CocosEngine = cc$1.ENGINE_VERSION = "2.0.0 alpha";
    var logList = null, ccLog = console.log, ccWarn = console.log, ccError = console.log, ccAssert = console.log;
    function formatString(message) {
        for (var _len = arguments.length, optionalParams = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) optionalParams[_key - 1] = arguments[_key];
        return cc.js.formatStr.apply(null, [ message ].concat(optionalParams));
    }
    function log(message) {
        for (var _len2 = arguments.length, optionalParams = new Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) optionalParams[_key2 - 1] = arguments[_key2];
        return ccLog.apply(void 0, [ message ].concat(optionalParams));
    }
    function warn(message) {
        for (var _len3 = arguments.length, optionalParams = new Array(1 < _len3 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) optionalParams[_key3 - 1] = arguments[_key3];
        return ccWarn.apply(void 0, [ message ].concat(optionalParams));
    }
    function error(message) {
        for (var _len4 = arguments.length, optionalParams = new Array(1 < _len4 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) optionalParams[_key4 - 1] = arguments[_key4];
        return ccError.apply(void 0, [ message ].concat(optionalParams));
    }
    function assert(value, message) {
        for (var _len5 = arguments.length, optionalParams = new Array(2 < _len5 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) optionalParams[_key5 - 2] = arguments[_key5];
        return ccAssert.apply(void 0, [ value, message ].concat(optionalParams));
    }
    function _resetDebugSetting(mode) {
        if (ccLog = ccWarn = ccError = ccAssert = function ccAssert() {}, mode !== DebugMode.NONE) {
            if (mode > DebugMode.ERROR) {
                var logToWebPage = function logToWebPage(msg) {
                    if (cc.game.canvas) {
                        if (!logList) {
                            var logDiv = document.createElement("Div");
                            logDiv.setAttribute("id", "logInfoDiv"), logDiv.setAttribute("width", "200"), logDiv.setAttribute("height", cc.game.canvas.height);
                            var logDivStyle = logDiv.style;
                            logDivStyle.zIndex = "99999", logDivStyle.position = "absolute", logDivStyle.top = logDivStyle.left = "0", 
                            (logList = document.createElement("textarea")).setAttribute("rows", "20"), logList.setAttribute("cols", "30"), 
                            logList.setAttribute("disabled", "true");
                            var logListStyle = logList.style;
                            logListStyle.backgroundColor = "transparent", logListStyle.borderBottom = "1px solid #cccccc", 
                            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px", 
                            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none", 
                            logListStyle.padding = "0px", logListStyle.margin = "0px", logDiv.appendChild(logList), 
                            cc.game.canvas.parentNode.appendChild(logDiv);
                        }
                        logList.value = logList.value + msg + "\r\n", logList.scrollTop = logList.scrollHeight;
                    }
                };
                ccError = function ccError(message) {
                    for (var _len6 = arguments.length, optionalParams = new Array(1 < _len6 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) optionalParams[_key6 - 1] = arguments[_key6];
                    logToWebPage("ERROR :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }, ccAssert = function ccAssert(condition, message) {
                    if (!condition) {
                        for (var _len7 = arguments.length, optionalParams = new Array(2 < _len7 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) optionalParams[_key7 - 2] = arguments[_key7];
                        logToWebPage("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                    }
                }, mode !== DebugMode.ERROR_FOR_WEB_PAGE && (ccWarn = function ccWarn(message) {
                    for (var _len8 = arguments.length, optionalParams = new Array(1 < _len8 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) optionalParams[_key8 - 1] = arguments[_key8];
                    logToWebPage("WARN :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }), mode === DebugMode.INFO_FOR_WEB_PAGE && (ccLog = function ccLog(message) {
                    for (var _len9 = arguments.length, optionalParams = new Array(1 < _len9 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) optionalParams[_key9 - 1] = arguments[_key9];
                    logToWebPage(formatString.apply(void 0, [ message ].concat(optionalParams)));
                });
            } else console && console.log.apply && (console.error || (console.error = console.log), 
            console.warn || (console.warn = console.log), ccError = console.error.bind ? console.error.bind(console) : function(message) {
                for (var _len10 = arguments.length, optionalParams = new Array(1 < _len10 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) optionalParams[_key10 - 1] = arguments[_key10];
                return console.error.apply(console, [ message ].concat(optionalParams));
            }, ccAssert = function ccAssert(condition, message) {
                if (!condition) {
                    for (var _len11 = arguments.length, optionalParams = new Array(2 < _len11 ? _len11 - 2 : 0), _key11 = 2; _key11 < _len11; _key11++) optionalParams[_key11 - 2] = arguments[_key11];
                    var errorText = formatString.apply(void 0, [ message ].concat(optionalParams));
                    throw new Error(errorText);
                }
            });
            mode !== DebugMode.ERROR && (ccWarn = console.warn.bind ? console.warn.bind(console) : function(message) {
                for (var _len12 = arguments.length, optionalParams = new Array(1 < _len12 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) optionalParams[_key12 - 1] = arguments[_key12];
                return console.warn.apply(console, [ message ].concat(optionalParams));
            }), mode === DebugMode.INFO && (ccLog = console.log.bind ? console.log.bind(console) : function ccLog(message) {
                for (var _len14 = arguments.length, optionalParams = new Array(1 < _len14 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) optionalParams[_key14 - 1] = arguments[_key14];
                return console.log.apply(console, [ message ].concat(optionalParams));
            });
        }
    }
    function _throw(error_) {
        var stack = error_.stack;
        error(stack || error_);
    }
    function getTypedFormatter(type) {
        return function(id) {
            for (var msg = "".concat(type, " ").concat(id, ", please go to ").concat("https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md", "#").concat(id, " to see details."), _len15 = arguments.length, args = new Array(1 < _len15 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) args[_key15 - 1] = arguments[_key15];
            return 0 === args.length ? msg : msg + " Arguments: " + args.join(", ");
        };
    }
    var logFormatter = getTypedFormatter("Log");
    function logID(id) {
        for (var _len16 = arguments.length, optionalParams = new Array(1 < _len16 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) optionalParams[_key16 - 1] = arguments[_key16];
        log(logFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
    var warnFormatter = getTypedFormatter("Warning");
    function warnID(id) {
        for (var _len17 = arguments.length, optionalParams = new Array(1 < _len17 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) optionalParams[_key17 - 1] = arguments[_key17];
        warn(warnFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
    var errorFormatter = getTypedFormatter("Error");
    function errorID(id) {
        for (var _len18 = arguments.length, optionalParams = new Array(1 < _len18 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) optionalParams[_key18 - 1] = arguments[_key18];
        error(errorFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
    var DebugMode, assertFormatter = getTypedFormatter("Assert");
    function assertID(condition, id) {
        if (!condition) {
            for (var _len19 = arguments.length, optionalParams = new Array(2 < _len19 ? _len19 - 2 : 0), _key19 = 2; _key19 < _len19; _key19++) optionalParams[_key19 - 2] = arguments[_key19];
            assert(!1, assertFormatter.apply(void 0, [ id ].concat(optionalParams)));
        }
    }
    function getError(errorId, param) {
        return errorFormatter(errorId, param);
    }
    function setDisplayStats(displayStats) {
        cc.profiler && (displayStats ? cc.profiler.showStats() : cc.profiler.hideStats(), 
        cc.game.config.showFPS = !!displayStats);
    }
    !function(DebugMode) {
        DebugMode[DebugMode.NONE = 0] = "NONE", DebugMode[DebugMode.INFO = 1] = "INFO", 
        DebugMode[DebugMode.WARN = 2] = "WARN", DebugMode[DebugMode.ERROR = 3] = "ERROR", 
        DebugMode[DebugMode.INFO_FOR_WEB_PAGE = 4] = "INFO_FOR_WEB_PAGE", DebugMode[DebugMode.WARN_FOR_WEB_PAGE = 5] = "WARN_FOR_WEB_PAGE", 
        DebugMode[DebugMode.ERROR_FOR_WEB_PAGE = 6] = "ERROR_FOR_WEB_PAGE";
    }(DebugMode || (DebugMode = {}));
    var debug = Object.freeze({
        log: log,
        warn: warn,
        error: error,
        assert: assert,
        _resetDebugSetting: _resetDebugSetting,
        _throw: _throw,
        logID: logID,
        warnID: warnID,
        errorID: errorID,
        assertID: assertID,
        get DebugMode() {
            return DebugMode;
        },
        getError: getError,
        isDisplayStats: function isDisplayStats() {
            return !!cc.profiler && cc.profiler.isShowingStats();
        },
        setDisplayStats: setDisplayStats
    }), EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/, DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/, NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
    function join() {
        for (var result = "", _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) segments[_key] = arguments[_key];
        for (var _i = 0; _i < segments.length; _i++) {
            result = (result + ("" === result ? "" : "/") + segments[_i]).replace(/(\/|\\\\)$/, "");
        }
        return result;
    }
    function extname(path) {
        var temp = EXTNAME_RE.exec(path);
        return temp ? temp[1] : "";
    }
    function mainFileName(fileName) {
        if (fileName) {
            var idx = fileName.lastIndexOf(".");
            if (-1 !== idx) return fileName.substring(0, idx);
        }
        return fileName;
    }
    function basename(path, extName) {
        var index = path.indexOf("?");
        0 < index && (path = path.substring(0, index));
        var result = /(\/|\\)([^\/\\]+)$/g.exec(path.replace(/(\/|\\)$/, ""));
        if (!result) return "";
        var baseName = result[2];
        return extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase() ? baseName.substring(0, baseName.length - extName.length) : baseName;
    }
    function dirname(path) {
        var temp = DIRNAME_RE.exec(path);
        return temp ? temp[2] : "";
    }
    function changeExtname(path, extName) {
        extName = extName || "";
        var index = path.indexOf("?"), tempStr = "";
        return 0 < index && (tempStr = path.substring(index), path = path.substring(0, index)), 
        (index = path.lastIndexOf(".")) < 0 ? path + extName + tempStr : path.substring(0, index) + extName + tempStr;
    }
    function changeBasename(path, baseName, isSameExt) {
        if (0 === baseName.indexOf(".")) return changeExtname(path, baseName);
        var index = path.indexOf("?"), tempStr = "", ext = isSameExt ? extname(path) : "";
        return 0 < index && (tempStr = path.substring(index), path = path.substring(0, index)), 
        index = (index = path.lastIndexOf("/")) <= 0 ? 0 : index + 1, path.substring(0, index) + baseName + ext + tempStr;
    }
    function _normalize(url) {
        for (var oldUrl = url = String(url); url = (oldUrl = url).replace(NORMALIZE_RE, ""), 
        oldUrl.length !== url.length; ) ;
        return url;
    }
    function stripSep(path) {
        return path.replace(/[\/\\]$/, "");
    }
    function getSeperator() {
        return cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/";
    }
    var path = Object.freeze({
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        getSeperator: getSeperator
    });
    cc.log = log, cc.warn = warn, cc.error = error, cc.assert = assert, cc._throw = _throw, 
    cc.logID = logID, cc.warnID = warnID, cc.errorID = errorID, cc.assertID = assertID, 
    cc.debug = debug, cc.path = {
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        get sep() {
            return getSeperator();
        }
    };
    var _d2r = Math.PI / 180, _r2d = 180 / Math.PI;
    function clamp(val, min, max) {
        if (max < min) {
            var temp = min;
            min = max, max = temp;
        }
        return val < min ? min : max < val ? max : val;
    }
    function clamp01(val) {
        return val < 0 ? 0 : 1 < val ? 1 : val;
    }
    function lerp(from, to, ratio) {
        return from + (to - from) * ratio;
    }
    function toRadian(a) {
        return a * _d2r;
    }
    function toDegree(a) {
        return a * _r2d;
    }
    var random = Math.random;
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }
    function randomRangeInt(min, max) {
        return Math.floor(randomRange(min, max));
    }
    function pseudoRandom(seed) {
        return (seed = (9301 * seed + 49297) % 233280) / 233280;
    }
    function pseudoRandomRange(seed, min, max) {
        return pseudoRandom(seed) * (max - min) + min;
    }
    function repeat(t, length) {
        return t - Math.floor(t / length) * length;
    }
    function pingPong(t, length) {
        return t = repeat(t, 2 * length), t = length - Math.abs(t - length);
    }
    function inverseLerp(from, to, value) {
        return (value - from) / (to - from);
    }
    function sign(v) {
        return (0 < v) - (v < 0);
    }
    function countTrailingZeros(v) {
        var c = 32;
        return (v &= -v) && c--, 65535 & v && (c -= 16), 16711935 & v && (c -= 8), 252645135 & v && (c -= 4), 
        858993459 & v && (c -= 2), 1431655765 & v && (c -= 1), c;
    }
    var REVERSE_TABLE = new Array(256);
    !function(tab) {
        for (var i = 0; i < 256; ++i) {
            var v = i, r = i, s = 7;
            for (v >>>= 1; v; v >>>= 1) r <<= 1, r |= 1 & v, --s;
            tab[i] = r << s & 255;
        }
    }(REVERSE_TABLE);
    var bits = Object.freeze({
        INT_BITS: 32,
        INT_MAX: 2147483647,
        INT_MIN: -1 << 31,
        sign: sign,
        abs: function abs(v) {
            var mask = v >> 31;
            return (v ^ mask) - mask;
        },
        min: function min(x, y) {
            return y ^ (x ^ y) & -(x < y);
        },
        max: function max(x, y) {
            return x ^ (x ^ y) & -(x < y);
        },
        isPow2: function isPow2(v) {
            return !(v & v - 1 || !v);
        },
        log2: function log2(v) {
            var r, shift;
            return r = (65535 < v) << 4, r |= shift = (255 < (v >>>= r)) << 3, r |= shift = (15 < (v >>>= shift)) << 2, 
            (r |= shift = (3 < (v >>>= shift)) << 1) | (v >>>= shift) >> 1;
        },
        log10: function log10(v) {
            return 1e9 <= v ? 9 : 1e8 <= v ? 8 : 1e7 <= v ? 7 : 1e6 <= v ? 6 : 1e5 <= v ? 5 : 1e4 <= v ? 4 : 1e3 <= v ? 3 : 100 <= v ? 2 : 10 <= v ? 1 : 0;
        },
        popCount: function popCount(v) {
            return 16843009 * ((v = (858993459 & (v -= v >>> 1 & 1431655765)) + (v >>> 2 & 858993459)) + (v >>> 4) & 252645135) >>> 24;
        },
        countTrailingZeros: countTrailingZeros,
        nextPow2: function nextPow2$1(v) {
            return v += 0 === v, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, 
            1 + (v |= v >>> 16);
        },
        prevPow2: function prevPow2(v) {
            return v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, (v |= v >>> 16) - (v >>> 1);
        },
        parity: function parity(v) {
            return v ^= v >>> 16, v ^= v >>> 8, v ^= v >>> 4, 27030 >>> (v &= 15) & 1;
        },
        reverse: function reverse(v) {
            return REVERSE_TABLE[255 & v] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
        },
        interleave2: function interleave2(x, y) {
            return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x &= 65535) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y &= 65535) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
        },
        deinterleave2: function deinterleave2(v, n) {
            return (v = 65535 & ((v = 16711935 & ((v = 252645135 & ((v = 858993459 & ((v = v >>> n & 1431655765) | v >>> 1)) | v >>> 2)) | v >>> 4)) | v >>> 16)) << 16 >> 16;
        },
        interleave3: function interleave3(x, y, z) {
            return x = 1227133513 & ((x = 3272356035 & ((x = 251719695 & ((x = 4278190335 & ((x &= 1023) | x << 16)) | x << 8)) | x << 4)) | x << 2), 
            (x |= (y = 1227133513 & ((y = 3272356035 & ((y = 251719695 & ((y = 4278190335 & ((y &= 1023) | y << 16)) | y << 8)) | y << 4)) | y << 2)) << 1) | (z = 1227133513 & ((z = 3272356035 & ((z = 251719695 & ((z = 4278190335 & ((z &= 1023) | z << 16)) | z << 8)) | z << 4)) | z << 2)) << 2;
        },
        deinterleave3: function deinterleave3(v, n) {
            return (v = 1023 & ((v = 4278190335 & ((v = 251719695 & ((v = 3272356035 & ((v = v >>> n & 1227133513) | v >>> 2)) | v >>> 4)) | v >>> 8)) | v >>> 16)) << 22 >> 22;
        },
        nextCombination: function nextCombination(v) {
            var t = v | v - 1;
            return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
        }
    }), vec2 = function() {
        function vec2() {
            var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
            _classCallCheck(this, vec2), this.x = void 0, this.y = void 0, this.x = x, this.y = y;
        }
        return _createClass(vec2, null, [ {
            key: "create",
            value: function create() {
                return new vec2(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0);
            }
        }, {
            key: "zero",
            value: function zero(out) {
                return out.x = 0, out.y = 0, out;
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new vec2(a.x, a.y);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y) {
                return out.x = x, out.y = y, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.x = a.x + b.x, out.y = a.y + b.y, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.x = a.x - b.x, out.y = a.y - b.y, out;
            }
        }, {
            key: "sub",
            value: function sub(out, a, b) {
                return vec2.subtract(out, a, b);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.x = a.x * b.x, out.y = a.y * b.y, out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return vec2.multiply(out, a, b);
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.x = a.x / b.x, out.y = a.y / b.y, out;
            }
        }, {
            key: "div",
            value: function div(out, a, b) {
                return vec2.divide(out, a, b);
            }
        }, {
            key: "ceil",
            value: function ceil(out, a) {
                return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out;
            }
        }, {
            key: "floor",
            value: function floor(out, a) {
                return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out;
            }
        }, {
            key: "min",
            value: function min(out, a, b) {
                return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out;
            }
        }, {
            key: "max",
            value: function max(out, a, b) {
                return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out;
            }
        }, {
            key: "round",
            value: function round(out, a) {
                return out.x = Math.round(a.x), out.y = Math.round(a.y), out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out;
            }
        }, {
            key: "distance",
            value: function distance(a, b) {
                var x = b.x - a.x, y = b.y - a.y;
                return Math.sqrt(x * x + y * y);
            }
        }, {
            key: "dist",
            value: function dist(a, b) {
                return vec2.distance(a, b);
            }
        }, {
            key: "squaredDistance",
            value: function squaredDistance(a, b) {
                var x = b.x - a.x, y = b.y - a.y;
                return x * x + y * y;
            }
        }, {
            key: "sqrDist",
            value: function sqrDist(a, b) {
                return vec2.squaredDistance(a, b);
            }
        }, {
            key: "magnitude",
            value: function magnitude(a) {
                var x = a.x, y = a.y;
                return Math.sqrt(x * x + y * y);
            }
        }, {
            key: "mag",
            value: function mag(a) {
                return vec2.magnitude(a);
            }
        }, {
            key: "squaredMagnitude",
            value: function squaredMagnitude(a) {
                var x = a.x, y = a.y;
                return x * x + y * y;
            }
        }, {
            key: "sqrMag",
            value: function sqrMag(a) {
                return vec2.squaredMagnitude(a);
            }
        }, {
            key: "negate",
            value: function negate(out, a) {
                return out.x = -a.x, out.y = -a.y, out;
            }
        }, {
            key: "inverse",
            value: function inverse(out, a) {
                return out.x = 1 / a.x, out.y = 1 / a.y, out;
            }
        }, {
            key: "inverseSafe",
            value: function inverseSafe(out, a) {
                var x = a.x, y = a.y;
                return Math.abs(x) < 1e-6 ? out.x = 0 : out.x = 1 / x, Math.abs(y) < 1e-6 ? out.y = 0 : out.y = 1 / a.y, 
                out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var x = a.x, y = a.y, len = x * x + y * y;
                return 0 < len && (len = 1 / Math.sqrt(len), out.x = a.x * len, out.y = a.y * len), 
                out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y;
            }
        }, {
            key: "cross",
            value: function cross(out, a, b) {
                return out.x = out.y = 0, out.z = a.x * b.y - a.y * b.x, out;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(out, a, b, t) {
                var ax = a.x, ay = a.y;
                return out.x = ax + t * (b.x - ax), out.y = ay + t * (b.y - ay), out;
            }
        }, {
            key: "random",
            value: function random$$1(out, scale) {
                scale = scale || 1;
                var r = 2 * random() * Math.PI;
                return out.x = Math.cos(r) * scale, out.y = Math.sin(r) * scale, out;
            }
        }, {
            key: "transformMat3",
            value: function transformMat3(out, a, m) {
                var x = a.x, y = a.y;
                return out.x = m.m00 * x + m.m03 * y + m.m06, out.y = m.m01 * x + m.m04 * y + m.m07, 
                out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, a, m) {
                var x = a.x, y = a.y;
                return out.x = m.m00 * x + m.m04 * y + m.m12, out.y = m.m01 * x + m.m05 * y + m.m13, 
                out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "vec2(".concat(a.x, ", ").concat(a.y, ")");
            }
        }, {
            key: "array",
            value: function array(out, v) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return a.x === b.x && a.y === b.y;
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                var a0 = a.x, a1 = a.y, b0 = b.x, b1 = b.y;
                return Math.abs(a0 - b0) <= 1e-6 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= 1e-6 * Math.max(1, Math.abs(a1), Math.abs(b1));
            }
        }, {
            key: "angle",
            value: function angle(a, b) {
                vec2.normalize(v2_1, a), vec2.normalize(v2_2, b);
                var cosine = vec2.dot(v2_1, v2_2);
                return 1 < cosine ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
            }
        } ]), vec2;
    }();
    vec2.ZERO = Object.freeze(new vec2(0, 0)), vec2.ONE = Object.freeze(new vec2(1, 1)), 
    vec2.NEG_ONE = Object.freeze(new vec2(-1, -1));
    var v2_1 = vec2.create(), v2_2 = vec2.create(), vec3 = function() {
        function vec3() {
            var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, z = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            _classCallCheck(this, vec3), this.x = void 0, this.y = void 0, this.z = void 0, 
            this.x = x, this.y = y, this.z = z;
        }
        return _createClass(vec3, null, [ {
            key: "create",
            value: function create() {
                return new vec3(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0);
            }
        }, {
            key: "zero",
            value: function zero(out) {
                return out.x = 0, out.y = 0, out.z = 0, out;
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new vec3(a.x, a.y, a.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out.z = a.z, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y, z) {
                return out.x = x, out.y = y, out.z = z, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out;
            }
        }, {
            key: "sub",
            value: function sub(out, a, b) {
                return vec3.subtract(out, a, b);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return vec3.multiply(out, a, b);
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out;
            }
        }, {
            key: "div",
            value: function div(out, a, b) {
                return vec3.divide(out, a, b);
            }
        }, {
            key: "ceil",
            value: function ceil(out, a) {
                return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out;
            }
        }, {
            key: "floor",
            value: function floor(out, a) {
                return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
                out;
            }
        }, {
            key: "min",
            value: function min(out, a, b) {
                return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
                out;
            }
        }, {
            key: "max",
            value: function max(out, a, b) {
                return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
                out;
            }
        }, {
            key: "round",
            value: function round(out, a) {
                return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
                out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                out;
            }
        }, {
            key: "distance",
            value: function distance(a, b) {
                var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
                return Math.sqrt(x * x + y * y + z * z);
            }
        }, {
            key: "dist",
            value: function dist(a, b) {
                return vec3.distance(a, b);
            }
        }, {
            key: "squaredDistance",
            value: function squaredDistance(a, b) {
                var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
                return x * x + y * y + z * z;
            }
        }, {
            key: "sqrDist",
            value: function sqrDist(a, b) {
                return vec3.squaredDistance(a, b);
            }
        }, {
            key: "magnitude",
            value: function magnitude(a) {
                var x = a.x, y = a.y, z = a.z;
                return Math.sqrt(x * x + y * y + z * z);
            }
        }, {
            key: "mag",
            value: function mag(a) {
                return vec3.magnitude(a);
            }
        }, {
            key: "squaredMagnitude",
            value: function squaredMagnitude(a) {
                var x = a.x, y = a.y, z = a.z;
                return x * x + y * y + z * z;
            }
        }, {
            key: "sqrMag",
            value: function sqrMag(a) {
                return vec3.squaredMagnitude(a);
            }
        }, {
            key: "negate",
            value: function negate(out, a) {
                return out.x = -a.x, out.y = -a.y, out.z = -a.z, out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out;
            }
        }, {
            key: "invertSafe",
            value: function invertSafe(out, a) {
                var x = a.x, y = a.y, z = a.z;
                return Math.abs(x) < 1e-6 ? out.x = 0 : out.x = 1 / x, Math.abs(y) < 1e-6 ? out.y = 0 : out.y = 1 / y, 
                Math.abs(z) < 1e-6 ? out.z = 0 : out.z = 1 / z, out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var x = a.x, y = a.y, z = a.z, len = x * x + y * y + z * z;
                return 0 < len && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len, out.z = z * len), 
                out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z;
            }
        }, {
            key: "cross",
            value: function cross(out, a, b) {
                var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
                return out.x = ay * bz - az * by, out.y = az * bx - ax * bz, out.z = ax * by - ay * bx, 
                out;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(out, a, b, t) {
                var ax = a.x, ay = a.y, az = a.z;
                return out.x = ax + t * (b.x - ax), out.y = ay + t * (b.y - ay), out.z = az + t * (b.z - az), 
                out;
            }
        }, {
            key: "random",
            value: function random$$1(out, scale) {
                scale = scale || 1;
                var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
                out.z = cosTheta * scale, out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, a, m) {
                var x = a.x, y = a.y, z = a.z, rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
                return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw, 
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw, out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw, 
                out;
            }
        }, {
            key: "transformMat4Normal",
            value: function transformMat4Normal(out, a, m) {
                var x = a.x, y = a.y, z = a.z, rhw = m.m03 * x + m.m07 * y + m.m11 * z;
                return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw, 
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw, out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw, 
                out;
            }
        }, {
            key: "transformMat3",
            value: function transformMat3(out, a, m) {
                var x = a.x, y = a.y, z = a.z;
                return out.x = x * m.m00 + y * m.m03 + z * m.m06, out.y = x * m.m01 + y * m.m04 + z * m.m07, 
                out.z = x * m.m02 + y * m.m05 + z * m.m08, out;
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(out, a, q) {
                var x = a.x, y = a.y, z = a.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                return out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, 
                out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, out;
            }
        }, {
            key: "rotateX",
            value: function rotateX(out, v, o, a) {
                var px = v.x - o.x, py = v.y - o.y, pz = v.z - o.z, cos = Math.cos(a), sin = Math.sin(a), rx = px, ry = py * cos - pz * sin, rz = py * sin + pz * cos;
                return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
            }
        }, {
            key: "rotateY",
            value: function rotateY(out, v, o, a) {
                var px = v.x - o.x, py = v.y - o.y, pz = v.z - o.z, cos = Math.cos(a), sin = Math.sin(a), rx = pz * sin + px * cos, ry = py, rz = pz * cos - px * sin;
                return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(out, v, o, a) {
                var px = v.x - o.x, py = v.y - o.y, pz = v.z - o.z, cos = Math.cos(a), sin = Math.sin(a), rx = px * cos - py * sin, ry = px * sin + py * cos, rz = pz;
                return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "vec3(".concat(a.x, ", ").concat(a.y, ", ").concat(a.z, ")");
            }
        }, {
            key: "array",
            value: function array(out, v) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z;
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                var epsilon = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1e-6, a0 = a.x, a1 = a.y, a2 = a.z, b0 = b.x, b1 = b.y, b2 = b.z;
                return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2));
            }
        }, {
            key: "angle",
            value: function angle(a, b) {
                vec3.normalize(v3_1, a), vec3.normalize(v3_2, b);
                var cosine = vec3.dot(v3_1, v3_2);
                return 1 < cosine ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
            }
        }, {
            key: "projectOnPlane",
            value: function projectOnPlane(out, a, n) {
                return vec3.subtract(out, a, vec3.project(out, a, n));
            }
        }, {
            key: "project",
            value: function project(out, a, b) {
                var sqrLen = vec3.squaredMagnitude(b);
                return sqrLen < 1e-6 ? vec3.set(out, 0, 0, 0) : vec3.scale(out, b, vec3.dot(a, b) / sqrLen);
            }
        } ]), vec3;
    }();
    vec3.UNIT_X = Object.freeze(new vec3(1, 0, 0)), vec3.UNIT_Y = Object.freeze(new vec3(0, 1, 0)), 
    vec3.UNIT_Z = Object.freeze(new vec3(0, 0, 1)), vec3.ZERO = Object.freeze(new vec3(0, 0, 0)), 
    vec3.ONE = Object.freeze(new vec3(1, 1, 1)), vec3.NEG_ONE = Object.freeze(new vec3(-1, -1, -1));
    var v3_1 = vec3.create(), v3_2 = vec3.create(), vec4 = function() {
        function vec4() {
            var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, z = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, w = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, vec4), this.x = void 0, this.y = void 0, this.z = void 0, 
            this.w = void 0, this.x = x, this.y = y, this.z = z, this.w = w;
        }
        return _createClass(vec4, null, [ {
            key: "create",
            value: function create() {
                return new vec4(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1);
            }
        }, {
            key: "zero",
            value: function zero(out) {
                return out.x = 0, out.y = 0, out.z = 0, out.w = 0, out;
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new vec4(a.x, a.y, a.z, a.w);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
            }
        }, {
            key: "set",
            value: function set(out, x, y, z, w) {
                return out.x = x, out.y = y, out.z = z, out.w = w, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out.w = a.w + b.w, 
                out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out.w = a.w - b.w, 
                out;
            }
        }, {
            key: "sub",
            value: function sub(out, a, b) {
                return vec4.subtract(out, a, b);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out.w = a.w * b.w, 
                out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return vec4.multiply(out, a, b);
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out.w = a.w / b.w, 
                out;
            }
        }, {
            key: "div",
            value: function div(out, a, b) {
                return vec4.divide(out, a, b);
            }
        }, {
            key: "ceil",
            value: function ceil(out, a) {
                return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out.w = Math.ceil(a.w), 
                out;
            }
        }, {
            key: "floor",
            value: function floor(out, a) {
                return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
                out.w = Math.floor(a.w), out;
            }
        }, {
            key: "min",
            value: function min(out, a, b) {
                return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
                out.w = Math.min(a.w, b.w), out;
            }
        }, {
            key: "max",
            value: function max(out, a, b) {
                return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
                out.w = Math.max(a.w, b.w), out;
            }
        }, {
            key: "round",
            value: function round(out, a) {
                return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
                out.w = Math.round(a.w), out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                out.w = a.w + b.w * scale, out;
            }
        }, {
            key: "distance",
            value: function distance(a, b) {
                var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
            }
        }, {
            key: "dist",
            value: function dist(a, b) {
                return vec4.distance(a, b);
            }
        }, {
            key: "squaredDistance",
            value: function squaredDistance(a, b) {
                var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
                return x * x + y * y + z * z + w * w;
            }
        }, {
            key: "sqrDist",
            value: function sqrDist(a, b) {
                return vec4.squaredDistance(a, b);
            }
        }, {
            key: "magnitude",
            value: function magnitude(a) {
                var x = a.x, y = a.y, z = a.z, w = a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
            }
        }, {
            key: "mag",
            value: function mag(a) {
                return vec4.magnitude(a);
            }
        }, {
            key: "squaredMagnitude",
            value: function squaredMagnitude(a) {
                var x = a.x, y = a.y, z = a.z, w = a.w;
                return x * x + y * y + z * z + w * w;
            }
        }, {
            key: "sqrMag",
            value: function sqrMag(a) {
                return vec4.squaredMagnitude(a);
            }
        }, {
            key: "negate",
            value: function negate(out, a) {
                return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = -a.w, out;
            }
        }, {
            key: "inverse",
            value: function inverse(out, a) {
                return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out.w = 1 / a.w, out;
            }
        }, {
            key: "inverseSafe",
            value: function inverseSafe(out, a) {
                var x = a.x, y = a.y, z = a.z, w = a.w;
                return Math.abs(x) < 1e-6 ? out.x = 0 : out.x = 1 / x, Math.abs(y) < 1e-6 ? out.y = 0 : out.y = 1 / y, 
                Math.abs(z) < 1e-6 ? out.z = 0 : out.z = 1 / z, Math.abs(w) < 1e-6 ? out.w = 0 : out.w = 1 / w, 
                out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var x = a.x, y = a.y, z = a.z, w = a.w, len = x * x + y * y + z * z + w * w;
                return 0 < len && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len, out.z = z * len, 
                out.w = w * len), out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(out, a, b, t) {
                var ax = a.x, ay = a.y, az = a.z, aw = a.w;
                return out.x = ax + t * (b.x - ax), out.y = ay + t * (b.y - ay), out.z = az + t * (b.z - az), 
                out.w = aw + t * (b.w - aw), out;
            }
        }, {
            key: "random",
            value: function random$$1(out, scale) {
                scale = scale || 1;
                var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
                out.z = cosTheta * scale, out.w = 0, out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, a, m) {
                var x = a.x, y = a.y, z = a.z, w = a.w;
                return out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w, out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w, 
                out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w, out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w, 
                out;
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(out, a, q) {
                var x = a.x, y = a.y, z = a.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                return out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, 
                out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, out.w = a.w, out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "vec4(".concat(a.x, ", ").concat(a.y, ", ").concat(a.z, ", ").concat(a.w, ")");
            }
        }, {
            key: "array",
            value: function array(out, v) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out[ofs + 3] = v.w, 
                out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w, b0 = b.x, b1 = b.y, b2 = b.z, b3 = b.w;
                return Math.abs(a0 - b0) <= 1e-6 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= 1e-6 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= 1e-6 * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= 1e-6 * Math.max(1, Math.abs(a3), Math.abs(b3));
            }
        } ]), vec4;
    }();
    vec4.ZERO = Object.freeze(new vec4(0, 0, 0, 0)), vec4.ONE = Object.freeze(new vec4(1, 1, 1, 1)), 
    vec4.NEG_ONE = Object.freeze(new vec4(-1, -1, -1, -1));
    var mat3 = function() {
        function mat3() {
            var m00 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, m01 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, m02 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m03 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, m04 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, m05 = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, m06 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, m07 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, m08 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 1;
            _classCallCheck(this, mat3), this.m00 = void 0, this.m01 = void 0, this.m02 = void 0, 
            this.m03 = void 0, this.m04 = void 0, this.m05 = void 0, this.m06 = void 0, this.m07 = void 0, 
            this.m08 = void 0, this.m00 = m00, this.m01 = m01, this.m02 = m02, this.m03 = m03, 
            this.m04 = m04, this.m05 = m05, this.m06 = m06, this.m07 = m07, this.m08 = m08;
        }
        return _createClass(mat3, null, [ {
            key: "create",
            value: function create() {
                return new mat3(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 1);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
                out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out;
            }
        }, {
            key: "set",
            value: function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m10, out.m04 = m11, 
                out.m05 = m12, out.m06 = m20, out.m07 = m21, out.m08 = m22, out;
            }
        }, {
            key: "identity",
            value: function identity(out) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
                out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
            }
        }, {
            key: "transpose",
            value: function transpose(out, a) {
                if (out === a) {
                    var a01 = a.m01, a02 = a.m02, a12 = a.m05;
                    out.m01 = a.m03, out.m02 = a.m06, out.m03 = a01, out.m05 = a.m07, out.m06 = a02, 
                    out.m07 = a12;
                } else out.m00 = a.m00, out.m01 = a.m03, out.m02 = a.m06, out.m03 = a.m01, out.m04 = a.m04, 
                out.m05 = a.m07, out.m06 = a.m02, out.m07 = a.m05, out.m08 = a.m08;
                return out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
                return det ? (det = 1 / det, out.m00 = b01 * det, out.m01 = (-a22 * a01 + a02 * a21) * det, 
                out.m02 = (a12 * a01 - a02 * a11) * det, out.m03 = b11 * det, out.m04 = (a22 * a00 - a02 * a20) * det, 
                out.m05 = (-a12 * a00 + a02 * a10) * det, out.m06 = b21 * det, out.m07 = (-a21 * a00 + a01 * a20) * det, 
                out.m08 = (a11 * a00 - a01 * a10) * det, out) : null;
            }
        }, {
            key: "determinant",
            value: function determinant(a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m03, b11 = b.m04, b12 = b.m05, b20 = b.m06, b21 = b.m07, b22 = b.m08;
                return out.m00 = b00 * a00 + b01 * a10 + b02 * a20, out.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22, out.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21, out.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20, out.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22, out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return mat3.multiply(out, a, b);
            }
        }, {
            key: "translate",
            value: function translate(out, a, v) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, x = v.x, y = v.y;
                return out.m00 = a00, out.m01 = a01, out.m02 = a02, out.m03 = a10, out.m04 = a11, 
                out.m05 = a12, out.m06 = x * a00 + y * a10 + a20, out.m07 = x * a01 + y * a11 + a21, 
                out.m08 = x * a02 + y * a12 + a22, out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, v) {
                var x = v.x, y = v.y;
                return out.m00 = x * a.m00, out.m01 = x * a.m01, out.m02 = x * a.m02, out.m03 = y * a.m03, 
                out.m04 = y * a.m04, out.m05 = y * a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
                out;
            }
        }, {
            key: "rotate",
            value: function rotate(out, a, rad) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c * a00 + s * a10, out.m01 = c * a01 + s * a11, out.m02 = c * a02 + s * a12, 
                out.m03 = c * a10 - s * a00, out.m04 = c * a11 - s * a01, out.m05 = c * a12 - s * a02, 
                out.m06 = a20, out.m07 = a21, out.m08 = a22, out;
            }
        }, {
            key: "fromMat4",
            value: function fromMat4(out, a) {
                return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m04, out.m04 = a.m05, 
                out.m05 = a.m06, out.m06 = a.m08, out.m07 = a.m09, out.m08 = a.m10, out;
            }
        }, {
            key: "fromViewUp",
            value: function fromViewUp(out, view, up) {
                return vec3.sqrMag(view) < 1e-12 ? (mat3.identity(out), out) : (up = up || vec3.UNIT_Y, 
                vec3.normalize(v3_1$1, vec3.cross(v3_1$1, up, view)), vec3.sqrMag(v3_1$1) < 1e-12 ? mat3.identity(out) : (vec3.cross(v3_2$1, view, v3_1$1), 
                mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z)), 
                out);
            }
        }, {
            key: "fromTranslation",
            value: function fromTranslation(out, v) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
                out.m06 = v.x, out.m07 = v.y, out.m08 = 1, out;
            }
        }, {
            key: "fromScaling",
            value: function fromScaling(out, v) {
                return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = v.y, out.m05 = 0, 
                out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
            }
        }, {
            key: "fromRotation",
            value: function fromRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = -s, out.m04 = c, out.m05 = 0, 
                out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(out, q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return out.m00 = 1 - yy - zz, out.m03 = yx - wz, out.m06 = zx + wy, out.m01 = yx + wz, 
                out.m04 = 1 - xx - zz, out.m07 = zy - wx, out.m02 = zx - wy, out.m05 = zy + wx, 
                out.m08 = 1 - xx - yy, out;
            }
        }, {
            key: "inverseTransposeMat4",
            value: function inverseTransposeMat4(out, a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
                out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
                out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
                out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
                out) : null;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "mat3(".concat(a.m00, ", ").concat(a.m01, ", ").concat(a.m02, ", ").concat(a.m03, ", ").concat(a.m04, ", ").concat(a.m05, ", ").concat(a.m06, ", ").concat(a.m07, ", ").concat(a.m08, ")");
            }
        }, {
            key: "array",
            value: function array(out, m) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
                out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
                out[ofs + 8] = m.m08, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
                out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
                out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
                out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
                out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out;
            }
        }, {
            key: "sub",
            value: function sub(out, a, b) {
                return mat3.subtract(out, a, b);
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
                out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
                out.m08 = a.m08 * b, out;
            }
        }, {
            key: "multiplyScalarAndAdd",
            value: function multiplyScalarAndAdd(out, a, b, scale) {
                return out.m00 = a.m00 + b.m00 * scale, out.m01 = a.m01 + b.m01 * scale, out.m02 = a.m02 + b.m02 * scale, 
                out.m03 = a.m03 + b.m03 * scale, out.m04 = a.m04 + b.m04 * scale, out.m05 = a.m05 + b.m05 * scale, 
                out.m06 = a.m06 + b.m06 * scale, out.m07 = a.m07 + b.m07 * scale, out.m08 = a.m08 + b.m08 * scale, 
                out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08, b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08;
                return Math.abs(a0 - b0) <= 1e-6 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= 1e-6 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= 1e-6 * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= 1e-6 * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= 1e-6 * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= 1e-6 * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= 1e-6 * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= 1e-6 * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= 1e-6 * Math.max(1, Math.abs(a8), Math.abs(b8));
            }
        } ]), mat3;
    }(), v3_1$1 = vec3.create(0, 0, 0), v3_2$1 = vec3.create(0, 0, 0), quat = function() {
        function quat() {
            var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, z = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, w = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, quat), this.x = void 0, this.y = void 0, this.z = void 0, 
            this.w = void 0, this.x = x, this.y = y, this.z = z, this.w = w;
        }
        return _createClass(quat, null, [ {
            key: "create",
            value: function create() {
                return new quat(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new quat(a.x, a.y, a.z, a.w);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return vec4.copy(out, a);
            }
        }, {
            key: "set",
            value: function set(out, x, y, z, w) {
                return out.x = x, out.y = y, out.z = z, out.w = w, out;
            }
        }, {
            key: "identity",
            value: function identity(out) {
                return out.x = 0, out.y = 0, out.z = 0, out.w = 1, out;
            }
        }, {
            key: "rotationTo",
            value: function rotationTo(out, a, b) {
                var dot = vec3.dot(a, b);
                return dot < -.999999 ? (vec3.cross(v3_1$2, vec3.UNIT_X, a), vec3.magnitude(v3_1$2) < 1e-6 && vec3.cross(v3_1$2, vec3.UNIT_Y, a), 
                vec3.normalize(v3_1$2, v3_1$2), quat.fromAxisAngle(out, v3_1$2, Math.PI), out) : .999999 < dot ? (out.x = 0, 
                out.y = 0, out.z = 0, out.w = 1, out) : (vec3.cross(v3_1$2, a, b), out.x = v3_1$2.x, 
                out.y = v3_1$2.y, out.z = v3_1$2.z, out.w = 1 + dot, quat.normalize(out, out));
            }
        }, {
            key: "getAxisAngle",
            value: function getAxisAngle(outAxis, q) {
                var rad = 2 * Math.acos(q.w), s = Math.sin(rad / 2);
                return outAxis.z = 0 !== s ? (outAxis.x = q.x / s, outAxis.y = q.y / s, q.z / s) : (outAxis.x = 1, 
                outAxis.y = 0), rad;
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = b.x, by = b.y, bz = b.z, bw = b.w;
                return out.x = ax * bw + aw * bx + ay * bz - az * by, out.y = ay * bw + aw * by + az * bx - ax * bz, 
                out.z = az * bw + aw * bz + ax * by - ay * bx, out.w = aw * bw - ax * bx - ay * by - az * bz, 
                out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return quat.multiply(out, a, b);
            }
        }, {
            key: "scale",
            value: function scale(out, a, b) {
                return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
            }
        }, {
            key: "scaleAndAdd",
            value: function scaleAndAdd(out, a, b, scale) {
                return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
                out.w = a.w + b.w * scale, out;
            }
        }, {
            key: "rotateX",
            value: function rotateX(out, a, rad) {
                rad *= .5;
                var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = Math.sin(rad), bw = Math.cos(rad);
                return out.x = ax * bw + aw * bx, out.y = ay * bw + az * bx, out.z = az * bw - ay * bx, 
                out.w = aw * bw - ax * bx, out;
            }
        }, {
            key: "rotateY",
            value: function rotateY(out, a, rad) {
                rad *= .5;
                var ax = a.x, ay = a.y, az = a.z, aw = a.w, by = Math.sin(rad), bw = Math.cos(rad);
                return out.x = ax * bw - az * by, out.y = ay * bw + aw * by, out.z = az * bw + ax * by, 
                out.w = aw * bw - ay * by, out;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(out, a, rad) {
                rad *= .5;
                var ax = a.x, ay = a.y, az = a.z, aw = a.w, bz = Math.sin(rad), bw = Math.cos(rad);
                return out.x = ax * bw + ay * bz, out.y = ay * bw - ax * bz, out.z = az * bw + aw * bz, 
                out.w = aw * bw - az * bz, out;
            }
        }, {
            key: "rotateAround",
            value: function rotateAround(out, rot, axis, rad) {
                return quat.invert(qt_1, rot), vec3.transformQuat(v3_1$2, axis, qt_1), quat.fromAxisAngle(qt_1, v3_1$2, rad), 
                quat.multiply(out, rot, qt_1), out;
            }
        }, {
            key: "rotateAroundLocal",
            value: function rotateAroundLocal(out, rot, axis, rad) {
                return quat.fromAxisAngle(qt_1, axis, rad), quat.multiply(out, rot, qt_1), out;
            }
        }, {
            key: "calculateW",
            value: function calculateW(out, a) {
                var x = a.x, y = a.y, z = a.z;
                return out.x = x, out.y = y, out.z = z, out.w = Math.sqrt(Math.abs(1 - x * x - y * y - z * z)), 
                out;
            }
        }, {
            key: "dot",
            value: function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(out, a, b, t) {
                var ax = a.x, ay = a.y, az = a.z, aw = a.w;
                return out.x = ax + t * (b.x - ax), out.y = ay + t * (b.y - ay), out.z = az + t * (b.z - az), 
                out.w = aw + t * (b.w - aw), out;
            }
        }, {
            key: "slerp",
            value: function slerp(out, a, b, t) {
                var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = b.x, by = b.y, bz = b.z, bw = b.w, scale0 = 0, scale1 = 0, cosom = ax * bx + ay * by + az * bz + aw * bw;
                if (cosom < 0 && (cosom = -cosom, bx = -bx, by = -by, bz = -bz, bw = -bw), 1e-6 < 1 - cosom) {
                    var omega = Math.acos(cosom), sinom = Math.sin(omega);
                    scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom;
                } else scale0 = 1 - t, scale1 = t;
                return out.x = scale0 * ax + scale1 * bx, out.y = scale0 * ay + scale1 * by, out.z = scale0 * az + scale1 * bz, 
                out.w = scale0 * aw + scale1 * bw, out;
            }
        }, {
            key: "sqlerp",
            value: function sqlerp(out, a, b, c, d, t) {
                return quat.slerp(qt_1, a, d, t), quat.slerp(qt_2, b, c, t), quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t)), 
                out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w, dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3, invDot = dot ? 1 / dot : 0;
                return out.x = -a0 * invDot, out.y = -a1 * invDot, out.z = -a2 * invDot, out.w = a3 * invDot, 
                out;
            }
        }, {
            key: "conjugate",
            value: function conjugate(out, a) {
                return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = a.w, out;
            }
        }, {
            key: "magnitude",
            value: function magnitude(a) {
                var x = a.x, y = a.y, z = a.z, w = a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
            }
        }, {
            key: "mag",
            value: function mag(a) {
                return quat.magnitude(a);
            }
        }, {
            key: "squaredMagnitude",
            value: function squaredMagnitude(a) {
                var x = a.x, y = a.y, z = a.z, w = a.w;
                return x * x + y * y + z * z + w * w;
            }
        }, {
            key: "sqrMag",
            value: function sqrMag(a) {
                return quat.squaredMagnitude(a);
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var x = a.x, y = a.y, z = a.z, w = a.w, len = x * x + y * y + z * z + w * w;
                return 0 < len && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len, out.z = z * len, 
                out.w = w * len), out;
            }
        }, {
            key: "fromAxes",
            value: function fromAxes(out, xAxis, yAxis, zAxis) {
                return mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z), 
                quat.normalize(out, quat.fromMat3(out, m3_1));
            }
        }, {
            key: "fromViewUp",
            value: function fromViewUp(out, view, up) {
                return mat3.fromViewUp(m3_1, view, up), quat.normalize(out, quat.fromMat3(out, m3_1));
            }
        }, {
            key: "fromAxisAngle",
            value: function fromAxisAngle(out, axis, rad) {
                rad *= .5;
                var s = Math.sin(rad);
                return out.x = s * axis.x, out.y = s * axis.y, out.z = s * axis.z, out.w = Math.cos(rad), 
                out;
            }
        }, {
            key: "fromMat3",
            value: function fromMat3(out, m) {
                var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08, trace = m00 + m11 + m22;
                if (0 < trace) {
                    var s = .5 / Math.sqrt(trace + 1);
                    out.w = .25 / s, out.x = (m21 - m12) * s, out.y = (m02 - m20) * s, out.z = (m10 - m01) * s;
                } else if (m11 < m00 && m22 < m00) {
                    var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
                    out.w = (m21 - m12) / _s, out.x = .25 * _s, out.y = (m01 + m10) / _s, out.z = (m02 + m20) / _s;
                } else if (m22 < m11) {
                    var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
                    out.w = (m02 - m20) / _s2, out.x = (m01 + m10) / _s2, out.y = .25 * _s2, out.z = (m12 + m21) / _s2;
                } else {
                    var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
                    out.w = (m10 - m01) / _s3, out.x = (m02 + m20) / _s3, out.y = (m12 + m21) / _s3, 
                    out.z = .25 * _s3;
                }
                return out;
            }
        }, {
            key: "fromEuler",
            value: function fromEuler(out, x, y, z) {
                x *= halfToRad, y *= halfToRad, z *= halfToRad;
                var sx = Math.sin(x), cx = Math.cos(x), sy = Math.sin(y), cy = Math.cos(y), sz = Math.sin(z), cz = Math.cos(z);
                return out.x = sx * cy * cz + cx * sy * sz, out.y = cx * sy * cz + sx * cy * sz, 
                out.z = cx * cy * sz - sx * sy * cz, out.w = cx * cy * cz - sx * sy * sz, out;
            }
        }, {
            key: "toAxisX",
            value: function toAxisX(out, q) {
                var fy = 2 * q.y, fz = 2 * q.z;
                out.x = 1 - fy * q.y - fz * q.z, out.y = fy * q.x + fz * q.w, out.z = fz * q.x + fy * q.w;
            }
        }, {
            key: "toAxisY",
            value: function toAxisY(out, q) {
                var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
                out.x = fy * q.x - fz * q.w, out.y = 1 - fx * q.x - fz * q.z, out.z = fz * q.y + fx * q.w;
            }
        }, {
            key: "toAxisZ",
            value: function toAxisZ(out, q) {
                var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
                out.x = fz * q.x - fy * q.w, out.y = fz * q.y - fx * q.w, out.z = 1 - fx * q.x - fy * q.y;
            }
        }, {
            key: "toEuler",
            value: function toEuler(out, q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, heading = NaN, attitude = NaN, bank = NaN, test = x * y + z * w;
                if (.499999 < test && (heading = 2 * Math.atan2(x, w), attitude = Math.PI / 2, bank = 0), 
                test < -.499999 && (heading = -2 * Math.atan2(x, w), attitude = -Math.PI / 2, bank = 0), 
                isNaN(heading)) {
                    var sqx = x * x, sqy = y * y, sqz = z * z;
                    heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz), attitude = Math.asin(2 * test), 
                    bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
                }
                return out.y = toDegree(heading), out.z = toDegree(attitude), out.x = toDegree(bank), 
                out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "quat(".concat(a.x, ", ").concat(a.y, ", ").concat(a.z, ", ").concat(a.w, ")");
            }
        }, {
            key: "array",
            value: function array(out, q) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = q.x, out[ofs + 1] = q.y, out[ofs + 2] = q.z, out[ofs + 3] = q.w, 
                out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return vec4.exactEquals(a, b);
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                return vec4.equals(a, b);
            }
        } ]), quat;
    }();
    quat.IDENTITY = Object.freeze(new quat());
    var qt_1 = quat.create(), qt_2 = quat.create(), v3_1$2 = vec3.create(), m3_1 = mat3.create(), halfToRad = .5 * Math.PI / 180, mat4 = function() {
        function mat4() {
            var m00 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, m01 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, m02 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m03 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, m04 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, m05 = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, m06 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, m07 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, m08 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, m09 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, m10 = 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, m11 = 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, m12 = 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, m13 = 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, m14 = 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 0, m15 = 15 < arguments.length && void 0 !== arguments[15] ? arguments[15] : 1;
            _classCallCheck(this, mat4), this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, 
            this.m04 = 0, this.m05 = 1, this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, 
            this.m10 = 1, this.m11 = 0, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, 
            this.m00 = m00, this.m01 = m01, this.m02 = m02, this.m03 = m03, this.m04 = m04, 
            this.m05 = m05, this.m06 = m06, this.m07 = m07, this.m08 = m08, this.m09 = m09, 
            this.m10 = m10, this.m11 = m11, this.m12 = m12, this.m13 = m13, this.m14 = m14, 
            this.m15 = m15;
        }
        return _createClass(mat4, null, [ {
            key: "create",
            value: function create() {
                return new mat4(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 0, 15 < arguments.length && void 0 !== arguments[15] ? arguments[15] : 1);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
                out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out.m09 = a.m09, 
                out.m10 = a.m10, out.m11 = a.m11, out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, 
                out.m15 = a.m15, out;
            }
        }, {
            key: "set",
            value: function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m03, out.m04 = m10, 
                out.m05 = m11, out.m06 = m12, out.m07 = m13, out.m08 = m20, out.m09 = m21, out.m10 = m22, 
                out.m11 = m23, out.m12 = m30, out.m13 = m31, out.m14 = m32, out.m15 = m33, out;
            }
        }, {
            key: "identity",
            value: function identity(out) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "transpose",
            value: function transpose(out, a) {
                if (out === a) {
                    var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
                    out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a01, out.m06 = a.m09, 
                    out.m07 = a.m13, out.m08 = a02, out.m09 = a12, out.m11 = a.m14, out.m12 = a03, out.m13 = a13, 
                    out.m14 = a23;
                } else out.m00 = a.m00, out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a.m01, 
                out.m05 = a.m05, out.m06 = a.m09, out.m07 = a.m13, out.m08 = a.m02, out.m09 = a.m06, 
                out.m10 = a.m10, out.m11 = a.m14, out.m12 = a.m03, out.m13 = a.m07, out.m14 = a.m11, 
                out.m15 = a.m15;
                return out;
            }
        }, {
            key: "invert",
            value: function invert(out, a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return 0 === det ? null : (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
                out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
                out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det, out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det, 
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det, out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det, 
                out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det, out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
                out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
                out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det, out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det, 
                out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det, out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det, 
                out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det, out);
            }
        }, {
            key: "determinant",
            value: function determinant(a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
                return (a00 * a11 - a01 * a10) * (a22 * a33 - a23 * a32) - (a00 * a12 - a02 * a10) * (a21 * a33 - a23 * a31) + (a00 * a13 - a03 * a10) * (a21 * a32 - a22 * a31) + (a01 * a12 - a02 * a11) * (a20 * a33 - a23 * a30) - (a01 * a13 - a03 * a11) * (a20 * a32 - a22 * a30) + (a02 * a13 - a03 * a12) * (a20 * a31 - a21 * a30);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
                return out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
                out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
                b0 = b.m04, b1 = b.m05, b2 = b.m06, b3 = b.m07, out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
                out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
                out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b.m08, b1 = b.m09, b2 = b.m10, 
                b3 = b.m11, out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
                out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
                b0 = b.m12, b1 = b.m13, b2 = b.m14, b3 = b.m15, out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
                out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
                out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return mat4.multiply(out, a, b);
            }
        }, {
            key: "translate",
            value: function translate(out, a, v) {
                var x = v.x, y = v.y, z = v.z;
                if (a === out) out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12, out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13, 
                out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14, out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15; else {
                    var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                    out.m00 = a00, out.m01 = a01, out.m02 = a02, out.m03 = a03, out.m04 = a10, out.m05 = a11, 
                    out.m06 = a12, out.m07 = a13, out.m08 = a20, out.m09 = a21, out.m10 = a22, out.m11 = a23, 
                    out.m12 = a00 * x + a10 * y + a20 * z + a.m12, out.m13 = a01 * x + a11 * y + a21 * z + a.m13, 
                    out.m14 = a02 * x + a12 * y + a22 * z + a.m14, out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
                }
                return out;
            }
        }, {
            key: "scale",
            value: function scale(out, a, v) {
                var x = v.x, y = v.y, z = v.z;
                return out.m00 = a.m00 * x, out.m01 = a.m01 * x, out.m02 = a.m02 * x, out.m03 = a.m03 * x, 
                out.m04 = a.m04 * y, out.m05 = a.m05 * y, out.m06 = a.m06 * y, out.m07 = a.m07 * y, 
                out.m08 = a.m08 * z, out.m09 = a.m09 * z, out.m10 = a.m10 * z, out.m11 = a.m11 * z, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15, out;
            }
        }, {
            key: "rotate",
            value: function rotate(out, a, rad, axis) {
                var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                if (Math.abs(len) < 1e-6) return null;
                x *= len = 1 / len, y *= len, z *= len;
                var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c, a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
                return out.m00 = a00 * b00 + a10 * b01 + a20 * b02, out.m01 = a01 * b00 + a11 * b01 + a21 * b02, 
                out.m02 = a02 * b00 + a12 * b01 + a22 * b02, out.m03 = a03 * b00 + a13 * b01 + a23 * b02, 
                out.m04 = a00 * b10 + a10 * b11 + a20 * b12, out.m05 = a01 * b10 + a11 * b11 + a21 * b12, 
                out.m06 = a02 * b10 + a12 * b11 + a22 * b12, out.m07 = a03 * b10 + a13 * b11 + a23 * b12, 
                out.m08 = a00 * b20 + a10 * b21 + a20 * b22, out.m09 = a01 * b20 + a11 * b21 + a21 * b22, 
                out.m10 = a02 * b20 + a12 * b21 + a22 * b22, out.m11 = a03 * b20 + a13 * b21 + a23 * b22, 
                a !== out && (out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), 
                out;
            }
        }, {
            key: "rotateX",
            value: function rotateX(out, a, rad) {
                var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                return a !== out && (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m04 = a10 * c + a20 * s, 
                out.m05 = a11 * c + a21 * s, out.m06 = a12 * c + a22 * s, out.m07 = a13 * c + a23 * s, 
                out.m08 = a20 * c - a10 * s, out.m09 = a21 * c - a11 * s, out.m10 = a22 * c - a12 * s, 
                out.m11 = a23 * c - a13 * s, out;
            }
        }, {
            key: "rotateY",
            value: function rotateY(out, a, rad) {
                var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                return a !== out && (out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c - a20 * s, 
                out.m01 = a01 * c - a21 * s, out.m02 = a02 * c - a22 * s, out.m03 = a03 * c - a23 * s, 
                out.m08 = a00 * s + a20 * c, out.m09 = a01 * s + a21 * c, out.m10 = a02 * s + a22 * c, 
                out.m11 = a03 * s + a23 * c, out;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(out, a, rad) {
                var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
                return a !== out && (out.m08 = a.m08, out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, 
                out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c + a10 * s, 
                out.m01 = a01 * c + a11 * s, out.m02 = a02 * c + a12 * s, out.m03 = a03 * c + a13 * s, 
                out.m04 = a10 * c - a00 * s, out.m05 = a11 * c - a01 * s, out.m06 = a12 * c - a02 * s, 
                out.m07 = a13 * c - a03 * s, out;
            }
        }, {
            key: "fromTranslation",
            value: function fromTranslation(out, v) {
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = v.x, 
                out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
            }
        }, {
            key: "fromScaling",
            value: function fromScaling(out, v) {
                return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = v.y, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = v.z, out.m11 = 0, 
                out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromRotation",
            value: function fromRotation(out, rad, axis) {
                var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
                if (Math.abs(len) < 1e-6) return null;
                x *= len = 1 / len, y *= len, z *= len;
                var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                return out.m00 = x * x * t + c, out.m01 = y * x * t + z * s, out.m02 = z * x * t - y * s, 
                out.m03 = 0, out.m04 = x * y * t - z * s, out.m05 = y * y * t + c, out.m06 = z * y * t + x * s, 
                out.m07 = 0, out.m08 = x * z * t + y * s, out.m09 = y * z * t - x * s, out.m10 = z * z * t + c, 
                out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromXRotation",
            value: function fromXRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = c, 
                out.m06 = s, out.m07 = 0, out.m08 = 0, out.m09 = -s, out.m10 = c, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromYRotation",
            value: function fromYRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c, out.m01 = 0, out.m02 = -s, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
                out.m06 = 0, out.m07 = 0, out.m08 = s, out.m09 = 0, out.m10 = c, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromZRotation",
            value: function fromZRotation(out, rad) {
                var s = Math.sin(rad), c = Math.cos(rad);
                return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = 0, out.m04 = -s, out.m05 = c, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
                out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "fromRT",
            value: function fromRT(out, q, v) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return out.m00 = 1 - (yy + zz), out.m01 = xy + wz, out.m02 = xz - wy, out.m03 = 0, 
                out.m04 = xy - wz, out.m05 = 1 - (xx + zz), out.m06 = yz + wx, out.m07 = 0, out.m08 = xz + wy, 
                out.m09 = yz - wx, out.m10 = 1 - (xx + yy), out.m11 = 0, out.m12 = v.x, out.m13 = v.y, 
                out.m14 = v.z, out.m15 = 1, out;
            }
        }, {
            key: "getTranslation",
            value: function getTranslation(out, mat) {
                return out.x = mat.m12, out.y = mat.m13, out.z = mat.m14, out;
            }
        }, {
            key: "getScaling",
            value: function getScaling(out, mat) {
                var m00 = m3_1$1.m00 = mat.m00, m01 = m3_1$1.m01 = mat.m01, m02 = m3_1$1.m02 = mat.m02, m04 = m3_1$1.m03 = mat.m04, m05 = m3_1$1.m04 = mat.m05, m06 = m3_1$1.m05 = mat.m06, m08 = m3_1$1.m06 = mat.m08, m09 = m3_1$1.m07 = mat.m09, m10 = m3_1$1.m08 = mat.m10;
                return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
                out.y = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
                out;
            }
        }, {
            key: "getRotation",
            value: function getRotation(out, mat) {
                var trace = mat.m00 + mat.m05 + mat.m10, S = 0;
                return 0 < trace ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (mat.m06 - mat.m09) / S, 
                out.y = (mat.m08 - mat.m02) / S, out.z = (mat.m01 - mat.m04) / S) : mat.m00 > mat.m05 && mat.m00 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10), 
                out.w = (mat.m06 - mat.m09) / S, out.x = .25 * S, out.y = (mat.m01 + mat.m04) / S, 
                out.z = (mat.m08 + mat.m02) / S) : mat.m05 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10), 
                out.w = (mat.m08 - mat.m02) / S, out.x = (mat.m01 + mat.m04) / S, out.y = .25 * S, 
                out.z = (mat.m06 + mat.m09) / S) : (S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05), 
                out.w = (mat.m01 - mat.m04) / S, out.x = (mat.m08 + mat.m02) / S, out.y = (mat.m06 + mat.m09) / S, 
                out.z = .25 * S), out;
            }
        }, {
            key: "toRTS",
            value: function toRTS(m, q, v, s) {
                s.x = vec3.mag(vec3.set(v3_1$3, m.m00, m.m01, m.m02)), m3_1$1.m00 = m.m00 / s.x, 
                m3_1$1.m01 = m.m01 / s.x, m3_1$1.m02 = m.m02 / s.x, s.y = vec3.mag(vec3.set(v3_1$3, m.m04, m.m05, m.m06)), 
                m3_1$1.m03 = m.m04 / s.y, m3_1$1.m04 = m.m05 / s.y, m3_1$1.m05 = m.m06 / s.y, s.z = vec3.mag(vec3.set(v3_1$3, m.m08, m.m09, m.m10)), 
                m3_1$1.m06 = m.m08 / s.z, m3_1$1.m07 = m.m09 / s.z, m3_1$1.m08 = m.m10 / s.z, mat3.determinant(m3_1$1) < 0 && (s.x *= -1, 
                m3_1$1.m00 *= -1, m3_1$1.m01 *= -1, m3_1$1.m02 *= -1), quat.fromMat3(q, m3_1$1), 
                vec3.set(v, m.m12, m.m13, m.m14);
            }
        }, {
            key: "fromRTS",
            value: function fromRTS(out, q, v, s) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
                return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
                out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
                out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
                out.m11 = 0, out.m12 = v.x, out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
            }
        }, {
            key: "fromRTSOrigin",
            value: function fromRTSOrigin(out, q, v, s, o) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z, ox = o.x, oy = o.y, oz = o.z;
                return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
                out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
                out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
                out.m11 = 0, out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz), 
                out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz), out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz), 
                out.m15 = 1, out;
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(out, q) {
                var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                return out.m00 = 1 - yy - zz, out.m01 = yx + wz, out.m02 = zx - wy, out.m03 = 0, 
                out.m04 = yx - wz, out.m05 = 1 - xx - zz, out.m06 = zy + wx, out.m07 = 0, out.m08 = zx + wy, 
                out.m09 = zy - wx, out.m10 = 1 - xx - yy, out.m11 = 0, out.m12 = 0, out.m13 = 0, 
                out.m14 = 0, out.m15 = 1, out;
            }
        }, {
            key: "frustum",
            value: function frustum(out, left, right, bottom, top, near, far) {
                var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
                return out.m00 = 2 * near * rl, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
                out.m05 = 2 * near * tb, out.m06 = 0, out.m07 = 0, out.m08 = (right + left) * rl, 
                out.m09 = (top + bottom) * tb, out.m10 = (far + near) * nf, out.m11 = -1, out.m12 = 0, 
                out.m13 = 0, out.m14 = far * near * 2 * nf, out.m15 = 0, out;
            }
        }, {
            key: "perspective",
            value: function perspective(out, fovy, aspect, near, far) {
                var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return out.m00 = f / aspect, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
                out.m05 = f, out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = (far + near) * nf, 
                out.m11 = -1, out.m12 = 0, out.m13 = 0, out.m14 = 2 * far * near * nf, out.m15 = 0, 
                out;
            }
        }, {
            key: "ortho",
            value: function ortho(out, left, right, bottom, top, near, far) {
                var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
                return out.m00 = -2 * lr, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = -2 * bt, 
                out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 2 * nf, out.m11 = 0, 
                out.m12 = (left + right) * lr, out.m13 = (top + bottom) * bt, out.m14 = (far + near) * nf, 
                out.m15 = 1, out;
            }
        }, {
            key: "lookAt",
            value: function lookAt(out, eye, center, up) {
                var eyex = eye.x, eyey = eye.y, eyez = eye.z, upx = up.x, upy = up.y, upz = up.z, z0 = eyex - center.x, z1 = eyey - center.y, z2 = eyez - center.z, len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2), x0 = upy * (z2 *= len) - upz * (z1 *= len), x1 = upz * (z0 *= len) - upx * z2, x2 = upx * z1 - upy * z0, y0 = z1 * (x2 *= len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2)) - z2 * (x1 *= len), y1 = z2 * (x0 *= len) - z0 * x2, y2 = z0 * x1 - z1 * x0;
                return out.m00 = x0, out.m01 = y0, out.m02 = z0, out.m03 = 0, out.m04 = x1, out.m05 = y1, 
                out.m06 = z1, out.m07 = 0, out.m08 = x2, out.m09 = y2, out.m10 = z2, out.m11 = 0, 
                out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez), out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez), 
                out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez), out.m15 = 1, out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "mat4(".concat(a.m00, ", ").concat(a.m01, ", ").concat(a.m02, ", ").concat(a.m03, ", ").concat(a.m04, ", ").concat(a.m05, ", ").concat(a.m06, ", ").concat(a.m07, ", ") + "".concat(a.m08, ", ").concat(a.m09, ", ").concat(a.m10, ", ").concat(a.m11, ", ").concat(a.m12, ", ").concat(a.m13, ", ").concat(a.m14, ", ").concat(a.m15, ")");
            }
        }, {
            key: "inverseTranspose",
            value: function inverseTranspose(out, a) {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
                out.m03 = 0, out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
                out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m07 = 0, out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
                out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
                out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out) : null;
            }
        }, {
            key: "array",
            value: function array(out, m) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
                out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
                out[ofs + 8] = m.m08, out[ofs + 9] = m.m09, out[ofs + 10] = m.m10, out[ofs + 11] = m.m11, 
                out[ofs + 12] = m.m12, out[ofs + 13] = m.m13, out[ofs + 14] = m.m14, out[ofs + 15] = m.m15, 
                out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
                out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
                out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out.m09 = a.m09 + b.m09, out.m10 = a.m10 + b.m10, 
                out.m11 = a.m11 + b.m11, out.m12 = a.m12 + b.m12, out.m13 = a.m13 + b.m13, out.m14 = a.m14 + b.m14, 
                out.m15 = a.m15 + b.m15, out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
                out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
                out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out.m09 = a.m09 - b.m09, out.m10 = a.m10 - b.m10, 
                out.m11 = a.m11 - b.m11, out.m12 = a.m12 - b.m12, out.m13 = a.m13 - b.m13, out.m14 = a.m14 - b.m14, 
                out.m15 = a.m15 - b.m15, out;
            }
        }, {
            key: "sub",
            value: function sub(out, a, b) {
                return mat4.subtract(out, a, b);
            }
        }, {
            key: "multiplyScalar",
            value: function multiplyScalar(out, a, b) {
                return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
                out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
                out.m08 = a.m08 * b, out.m09 = a.m09 * b, out.m10 = a.m10 * b, out.m11 = a.m11 * b, 
                out.m12 = a.m12 * b, out.m13 = a.m13 * b, out.m14 = a.m14 * b, out.m15 = a.m15 * b, 
                out;
            }
        }, {
            key: "multiplyScalarAndAdd",
            value: function multiplyScalarAndAdd(out, a, b, scale) {
                return out.m00 = a.m00 + b.m00 * scale, out.m01 = a.m01 + b.m01 * scale, out.m02 = a.m02 + b.m02 * scale, 
                out.m03 = a.m03 + b.m03 * scale, out.m04 = a.m04 + b.m04 * scale, out.m05 = a.m05 + b.m05 * scale, 
                out.m06 = a.m06 + b.m06 * scale, out.m07 = a.m07 + b.m07 * scale, out.m08 = a.m08 + b.m08 * scale, 
                out.m09 = a.m09 + b.m09 * scale, out.m10 = a.m10 + b.m10 * scale, out.m11 = a.m11 + b.m11 * scale, 
                out.m12 = a.m12 + b.m12 * scale, out.m13 = a.m13 + b.m13 * scale, out.m14 = a.m14 + b.m14 * scale, 
                out.m15 = a.m15 + b.m15 * scale, out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                var epsilon = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1e-6, a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08, a9 = a.m09, a10 = a.m10, a11 = a.m11, a12 = a.m12, a13 = a.m13, a14 = a.m14, a15 = a.m15, b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08, b9 = b.m09, b10 = b.m10, b11 = b.m11, b12 = b.m12, b13 = b.m13, b14 = b.m14, b15 = b.m15;
                return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= epsilon * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= epsilon * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= epsilon * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= epsilon * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= epsilon * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= epsilon * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= epsilon * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= epsilon * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= epsilon * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= epsilon * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= epsilon * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= epsilon * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= epsilon * Math.max(1, Math.abs(a15), Math.abs(b15));
            }
        } ]), mat4;
    }(), v3_1$3 = new vec3(), m3_1$1 = new mat3(), color4 = function() {
        function color4() {
            var r = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, g = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1, b = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1, a = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, color4), this.r = void 0, this.g = void 0, this.b = void 0, 
            this.a = void 0, this.r = r, this.g = g, this.b = b, this.a = a;
        }
        return _createClass(color4, null, [ {
            key: "create",
            value: function create() {
                return new color4(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new color4(a.r, a.g, a.b, a.a);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return out.r = a.r, out.g = a.g, out.b = a.b, out.a = a.a, out;
            }
        }, {
            key: "set",
            value: function set(out, r, g, b, a) {
                return out.r = r, out.g = g, out.b = b, out.a = a, out;
            }
        }, {
            key: "fromHex",
            value: function fromHex(out, hex) {
                var r = (hex >> 24) / 255, g = (hex >> 16 & 255) / 255, b = (hex >> 8 & 255) / 255, a = (255 & hex) / 255;
                return out.r = r, out.g = g, out.b = b, out.a = a, out;
            }
        }, {
            key: "add",
            value: function add(out, a, b) {
                return out.r = a.r + b.r, out.g = a.g + b.g, out.b = a.b + b.b, out.a = a.a + b.a, 
                out;
            }
        }, {
            key: "subtract",
            value: function subtract(out, a, b) {
                return out.r = a.r - b.r, out.g = a.g - b.g, out.b = a.b - b.b, out.a = a.a - b.a, 
                out;
            }
        }, {
            key: "sub",
            value: function sub(out, a, b) {
                return color4.subtract(out, a, b);
            }
        }, {
            key: "multiply",
            value: function multiply(out, a, b) {
                return out.r = a.r * b.r, out.g = a.g * b.g, out.b = a.b * b.b, out.a = a.a * b.a, 
                out;
            }
        }, {
            key: "mul",
            value: function mul(out, a, b) {
                return color4.multiply(out, a, b);
            }
        }, {
            key: "divide",
            value: function divide(out, a, b) {
                return out.r = a.r / b.r, out.g = a.g / b.g, out.b = a.b / b.b, out.a = a.a / b.a, 
                out;
            }
        }, {
            key: "div",
            value: function div(out, a, b) {
                return color4.divide(out, a, b);
            }
        }, {
            key: "scale",
            value: function scale(out, a, b) {
                return out.r = a.r * b, out.g = a.g * b, out.b = a.b * b, out.a = a.a * b, out;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(out, a, b, t) {
                var ar = a.r, ag = a.g, ab = a.b, aa = a.a;
                return out.r = ar + t * (b.r - ar), out.g = ag + t * (b.g - ag), out.b = ab + t * (b.b - ab), 
                out.a = aa + t * (b.a - aa), out;
            }
        }, {
            key: "str",
            value: function str(a) {
                return "color4(".concat(a.r, ", ").concat(a.g, ", ").concat(a.b, ", ").concat(a.a, ")");
            }
        }, {
            key: "array",
            value: function array(out, a) {
                var ofs = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, scale = a instanceof cc.Color || 1 < a.a ? 1 / 255 : 1;
                return out[ofs + 0] = a.r * scale, out[ofs + 1] = a.g * scale, out[ofs + 2] = a.b * scale, 
                out[ofs + 3] = a.a * scale, out;
            }
        }, {
            key: "exactEquals",
            value: function exactEquals(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
            }
        }, {
            key: "equals",
            value: function equals$$1(a, b) {
                var a0 = a.r, a1 = a.g, a2 = a.b, a3 = a.a, b0 = b.r, b1 = b.g, b2 = b.b, b3 = b.a;
                return Math.abs(a0 - b0) <= 1e-6 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= 1e-6 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= 1e-6 * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= 1e-6 * Math.max(1, Math.abs(a3), Math.abs(b3));
            }
        }, {
            key: "hex",
            value: function hex(a) {
                return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
            }
        } ]), color4;
    }(), vmath = Object.freeze({
        bits: bits,
        vec2: vec2,
        vec3: vec3,
        vec4: vec4,
        quat: quat,
        mat3: mat3,
        mat4: mat4,
        color4: color4,
        EPSILON: 1e-6,
        equals: function equals(a, b) {
            return Math.abs(a - b) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(b));
        },
        approx: function approx(a, b, maxDiff) {
            return maxDiff = maxDiff || 1e-6, Math.abs(a - b) <= maxDiff;
        },
        clamp: clamp,
        clamp01: clamp01,
        lerp: lerp,
        toRadian: toRadian,
        toDegree: toDegree,
        random: random,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: function pseudoRandomRangeInt(seed, min, max) {
            return Math.floor(pseudoRandomRange(seed, min, max));
        },
        nextPow2: function nextPow2(val) {
            return --val, val |= val >> 1, val |= val >> 2, val |= val >> 4, val |= val >> 8, 
            val |= val >> 16, ++val;
        },
        repeat: repeat,
        pingPong: pingPong,
        inverseLerp: inverseLerp
    }), MutableForwardIterator = function() {
        function MutableForwardIterator(array) {
            _classCallCheck(this, MutableForwardIterator), this.array = array, this.i = 0;
        }
        return _createClass(MutableForwardIterator, [ {
            key: "remove",
            value: function remove(value) {
                var index = this.array.indexOf(value);
                0 <= index && this.removeAt(index);
            }
        }, {
            key: "removeAt",
            value: function removeAt(i) {
                this.array.splice(i, 1), i <= this.i && --this.i;
            }
        }, {
            key: "fastRemove",
            value: function fastRemove(value) {
                var index = this.array.indexOf(value);
                0 <= index && this.fastRemoveAt(index);
            }
        }, {
            key: "fastRemoveAt",
            value: function fastRemoveAt(i) {
                var array = this.array;
                array[i] = array[array.length - 1], --array.length, i <= this.i && --this.i;
            }
        }, {
            key: "push",
            value: function push(item) {
                this.array.push(item);
            }
        }, {
            key: "length",
            get: function get() {
                return this.array.length;
            },
            set: function set(value) {
                this.array.length = value, this.i >= value && (this.i = value - 1);
            }
        } ]), MutableForwardIterator;
    }();
    function removeAt(array, index) {
        array.splice(index, 1);
    }
    function remove(array, value) {
        var index = array.indexOf(value);
        return 0 <= index && (removeAt(array, index), !0);
    }
    function removeIf(array, predicate) {
        var index = array.findIndex(predicate);
        if (0 <= index) {
            var value = array[index];
            return removeAt(array, index), value;
        }
    }
    function contains(array, value) {
        return 0 <= array.indexOf(value);
    }
    var jsarray = Object.freeze({
        removeAt: removeAt,
        fastRemoveAt: function fastRemoveAt(array, index) {
            var length = array.length;
            index < 0 || length <= index || (array[index] = array[length - 1], array.length = length - 1);
        },
        remove: remove,
        fastRemove: function fastRemove(array, value) {
            var index = array.indexOf(value);
            0 <= index && (array[index] = array[array.length - 1], --array.length);
        },
        removeIf: removeIf,
        verifyType: function verifyType(array, type) {
            if (array && 0 < array.length) {
                var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    if (!(_ref instanceof type)) return cc.logID(1300), !1;
                }
            }
            return !0;
        },
        removeArray: function removeArray(array, minusArr) {
            for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
        },
        appendObjectsAt: function appendObjectsAt(array, addObjs, index) {
            return array.splice.apply(array, [ index, 0 ].concat(_toConsumableArray(addObjs))), 
            array;
        },
        indexOf: function indexOf(array, searchElement, fromIndex) {
            return Array.prototype.indexOf.call(array, [ searchElement, fromIndex ]);
        },
        contains: contains,
        copy: function copy(array) {
            for (var len = array.length, arr_clone = new Array(len), i = 0; i < len; i += 1) arr_clone[i] = array[i];
            return arr_clone;
        },
        MutableForwardIterator: MutableForwardIterator
    }), IDGenerator = function() {
        function IDGenerator(category) {
            _classCallCheck(this, IDGenerator), this.id = void 0, this.prefix = void 0, this.id = 0 | 998 * Math.random(), 
            this.prefix = category ? category + "." : "";
        }
        return _createClass(IDGenerator, [ {
            key: "getNewId",
            value: function getNewId() {
                return this.prefix + ++this.id;
            }
        } ]), IDGenerator;
    }();
    IDGenerator.global = new IDGenerator("global");
    var tempCIDGenerator = new IDGenerator("TmpCId.");
    function isNumber(object) {
        return "number" == typeof object || object instanceof Number;
    }
    function isString(object) {
        return "string" == typeof object || object instanceof String;
    }
    var descriptor, value = (descriptor = {
        value: void 0,
        enumerable: !1,
        writable: !1,
        configurable: !0
    }, function(object, propertyName, value_, writable, enumerable) {
        descriptor.value = value_, descriptor.writable = writable, descriptor.enumerable = enumerable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.value = void 0;
    }), getset = function() {
        var descriptor = {
            get: void 0,
            set: void 0,
            enumerable: !1
        };
        return function(object, propertyName, getter, setter, enumerable, configurable) {
            "function" != typeof setter && (enumerable = setter, setter = void 0), descriptor.get = getter, 
            descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
            Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0, 
            descriptor.set = void 0;
        };
    }(), get = function() {
        var descriptor = {
            get: void 0,
            enumerable: !1,
            configurable: !1
        };
        return function(object, propertyName, getter, enumerable, configurable) {
            descriptor.get = getter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
            Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0;
        };
    }(), set$1 = function() {
        var descriptor = {
            set: void 0,
            enumerable: !1,
            configurable: !1
        };
        return function(object, propertyName, setter, enumerable, configurable) {
            descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
            Object.defineProperty(object, propertyName, descriptor), descriptor.set = void 0;
        };
    }();
    function createMap(forceDictMode) {
        var map = Object.create(null);
        if (forceDictMode) {
            map["."] = !0, map["/"] = !0, delete map["."], delete map["/"];
        }
        return map;
    }
    function getClassName(objOrCtor) {
        if ("function" != typeof objOrCtor) return objOrCtor && objOrCtor.constructor ? getClassName(objOrCtor.constructor) : "";
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        if (objOrCtor.name && (retval = objOrCtor.name), objOrCtor.toString) {
            var arr, str = objOrCtor.toString();
            (arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/)) && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
    }
    function obsolete(object, obsoleted, newExpr, writable) {
        var extractPropName = /([^.]+)$/, oldProp = extractPropName.exec(obsoleted)[0], newProp = extractPropName.exec(newExpr)[0];
        function getter() {
            return this[newProp];
        }
        writable ? getset(object, oldProp, getter, function setter(value_) {
            this[newProp] = value_;
        }) : get(object, oldProp, getter);
    }
    function obsoletes(obj, objName, props, writable) {
        for (var obsoleted in props) {
            obsolete(obj, objName + "." + obsoleted, props[obsoleted], writable);
        }
    }
    var REGEXP_NUM_OR_STR = /(%d)|(%s)/, REGEXP_STR = /%s/;
    function formatStr(msg) {
        for (var _len = arguments.length, subst = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) subst[_key - 1] = arguments[_key];
        if (0 === arguments.length) return "";
        if (0 === subst.length) return "" + msg;
        if ("string" == typeof msg && REGEXP_NUM_OR_STR.test(msg)) for (var _i = 0; _i < subst.length; _i++) {
            var arg = subst[_i], regExpToTest = "number" == typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
            regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
        } else for (var _i2 = 0; _i2 < subst.length; _i2++) {
            msg += " " + subst[_i2];
        }
        return msg;
    }
    function shiftArguments() {
        for (var len = arguments.length - 1, args = new Array(len), i = 0; i < len; ++i) args[i] = arguments[i + 1];
        return args;
    }
    function getPropertyDescriptor(object, propertyName) {
        for (;object; ) {
            var pd = Object.getOwnPropertyDescriptor(object, propertyName);
            if (pd) return pd;
            object = Object.getPrototypeOf(object);
        }
        return null;
    }
    function _copyprop(name, source, target) {
        var pd = getPropertyDescriptor(source, name);
        pd && Object.defineProperty(target, name, pd);
    }
    function addon(object) {
        object = object || {};
        for (var _len2 = arguments.length, sources = new Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) sources[_key2 - 1] = arguments[_key2];
        for (var _i3 = 0; _i3 < sources.length; _i3++) {
            var source = sources[_i3];
            if (source) {
                if ("object" !== _typeof(source)) {
                    cc.errorID(5402, source);
                    continue;
                }
                for (var name in source) name in object || _copyprop(name, source, object);
            }
        }
        return object;
    }
    function mixin(object) {
        object = object || {};
        for (var _len3 = arguments.length, sources = new Array(1 < _len3 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) sources[_key3 - 1] = arguments[_key3];
        for (var _i4 = 0; _i4 < sources.length; _i4++) {
            var source = sources[_i4];
            if (source) {
                if ("object" !== _typeof(source)) {
                    cc.errorID(5403, source);
                    continue;
                }
                for (var name in source) _copyprop(name, source, object);
            }
        }
        return object;
    }
    function extend(cls, base) {
        for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
        return cls.prototype = Object.create(base.prototype, {
            constructor: {
                value: cls,
                writable: !0,
                configurable: !0
            }
        }), cls;
    }
    function getSuper(constructor) {
        var proto = constructor.prototype, dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
    }
    function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
            if ("function" != typeof subclass) return !1;
            if ("function" != typeof superclass) return !1;
            if (subclass === superclass) return !0;
            for (;;) {
                if (!(subclass = getSuper(subclass))) return !1;
                if (subclass === superclass) return !0;
            }
        }
        return !1;
    }
    function clear(object) {
        for (var _arr = Object.keys(object), _i5 = 0; _i5 < _arr.length; _i5++) {
            delete object[_arr[_i5]];
        }
    }
    var _idToClass = {}, _nameToClass = {};
    function _setClassId(id, constructor) {
        var key = "__cid__", table = _idToClass;
        if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
        value(constructor.prototype, key, id), id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
                var error$$1 = 'A Class already exists with the same __cid__ : "' + id + '".';
                0, cc.error(error$$1);
            } else table[id] = constructor;
        }
    }
    function setClassName(className, constructor) {
        if (function doSetClassName(id, constructor) {
            var key = "__classname__", table = _nameToClass;
            if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
            value(constructor.prototype, key, id), id) {
                var registered = table[id];
                if (registered && registered !== constructor) {
                    var error$$1 = "A Class already exists with the same " + key + ' : "' + id + '".';
                    cc.error(error$$1);
                } else table[id] = constructor;
            }
        }(className, constructor), !constructor.prototype.hasOwnProperty("__cid__")) {
            var id = className || tempCIDGenerator.getNewId();
            id && _setClassId(id, constructor);
        }
    }
    function unregisterClass() {
        for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) constructors[_key4] = arguments[_key4];
        for (var _i6 = 0; _i6 < constructors.length; _i6++) {
            var p = constructors[_i6].prototype, classId = p.__cid__;
            classId && delete _idToClass[classId];
            var classname = p.__classname__;
            classname && delete _nameToClass[classname];
        }
    }
    function _getClassById(classId) {
        return _idToClass[classId];
    }
    function getClassByName(classname) {
        return _nameToClass[classname];
    }
    function _getClassId(obj, allowTempId) {
        if (allowTempId = void 0 === allowTempId || allowTempId, "function" == typeof obj && obj.prototype.hasOwnProperty("__cid__")) return obj.prototype.__cid__;
        if (obj && obj.constructor) {
            var prototype = obj.constructor.prototype;
            if (prototype && prototype.hasOwnProperty("__cid__")) return obj.__cid__;
        }
        return "";
    }
    var Pool = function() {
        function Pool(_0, _1) {
            _classCallCheck(this, Pool), this.count = void 0, this._pool = void 0;
            var size = (this._cleanup = void 0) === _1 ? _0 : _1, cleanupFunc = void 0 === _1 ? null : _0;
            this.count = 0, this._pool = new Array(size), this._cleanup = cleanupFunc;
        }
        return _createClass(Pool, [ {
            key: "get",
            value: function get() {
                return this._get();
            }
        } ]), _createClass(Pool, [ {
            key: "_get",
            value: function _get$$1() {
                if (0 < this.count) {
                    --this.count;
                    var cache = this._pool[this.count];
                    return this._pool[this.count] = null, cache;
                }
                return null;
            }
        }, {
            key: "put",
            value: function put(obj) {
                var pool = this._pool;
                if (this.count < pool.length) {
                    if (this._cleanup && !1 === this._cleanup(obj)) return;
                    pool[this.count] = obj, ++this.count;
                }
            }
        }, {
            key: "resize",
            value: function resize(length) {
                0 <= length && (this._pool.length = length, this.count > length && (this.count = length));
            }
        } ]), Pool;
    }(), array = jsarray;
    cc.js = {
        IDGenerator: IDGenerator,
        Pool: Pool,
        array: jsarray,
        isNumber: isNumber,
        isString: isString,
        getPropertyDescriptor: getPropertyDescriptor,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear,
        value: value,
        getset: getset,
        get: get,
        set: set$1,
        unregisterClass: unregisterClass,
        getClassName: getClassName,
        setClassName: setClassName,
        getClassByName: getClassByName,
        _getClassId: _getClassId,
        _setClassId: _setClassId,
        _getClassById: _getClassById,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        createMap: createMap
    };
    for (var js = Object.freeze({
        array: array,
        IDGenerator: IDGenerator,
        Pool: Pool,
        isNumber: isNumber,
        isString: isString,
        value: value,
        getset: getset,
        get: get,
        set: set$1,
        createMap: createMap,
        getClassName: getClassName,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        getPropertyDescriptor: getPropertyDescriptor,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear,
        _idToClass: _idToClass,
        _nameToClass: _nameToClass,
        _setClassId: _setClassId,
        setClassName: setClassName,
        unregisterClass: unregisterClass,
        _getClassById: _getClassById,
        getClassByName: getClassByName,
        _getClassId: _getClassId
    }), BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/, values = new Array(123), i = 0; i < 123; ++i) values[i] = 64;
    for (var _i = 0; _i < 64; ++_i) values["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(_i)] = _i;
    var BASE64_VALUES = values;
    function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
        function define(np, propName, getter, setter) {
            var pd = Object.getOwnPropertyDescriptor(np, propName);
            if (pd) pd.get && (np[getter] = pd.get), pd.set && setter && (np[setter] = pd.set); else {
                var getterFunc = np[getter];
                getset(np, propName, getterFunc, np[setter]);
            }
        }
        for (var propName, np = ctor.prototype, _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
            var suffix = (propName = sameNameGetSets[_i2])[0].toUpperCase() + propName.slice(1);
            define(np, propName, "get" + suffix, "set" + suffix);
        }
        for (propName in diffNameGetSets) {
            var gs = diffNameGetSets[propName];
            define(np, propName, gs[0], gs[1]);
        }
    }
    function nextPOT(x) {
        return x -= 1, x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, (x |= x >> 16) + 1;
    }
    function pushToMap(map, key, value$$1, pushFront) {
        var exists = map[key];
        exists ? Array.isArray(exists) ? pushFront ? (exists.push(exists[0]), exists[0] = value$$1) : exists.push(value$$1) : map[key] = pushFront ? [ value$$1, exists ] : [ exists, value$$1 ] : map[key] = value$$1;
    }
    function clampf(value$$1, min_inclusive, max_inclusive) {
        return clamp(value$$1, min_inclusive, max_inclusive);
    }
    function clamp01$1(value$$1) {
        return clamp01(value$$1);
    }
    function lerp$1(a, b, r) {
        return lerp(a, b, r);
    }
    function degreesToRadians(angle) {
        return toRadian(angle);
    }
    function radiansToDegrees(angle) {
        return toDegree(angle);
    }
    function contains$1(refNode, otherNode) {
        if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
        if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
        var node = otherNode.parentNode;
        if (node) do {
            if (node === refNode) return !0;
            node = node.parentNode;
        } while (null !== node);
        return !1;
    }
    function isDomNode(obj) {
        return "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "function" == typeof Node ? obj instanceof Node : obj && "object" === _typeof(obj) && "number" == typeof obj.nodeType && "string" == typeof obj.nodeName;
    }
    function callInNextTick(callback, p1, p2) {
        callback && setTimeout(function() {
            callback(p1, p2);
        }, 0);
    }
    function tryCatchFunctor_EDITOR(funcName, forwardArgs, afterCall, bindArg) {
        return Function("arg", "return " + function call_FUNC_InTryCatch(_R_ARGS_) {
            try {
                target._FUNC_(_U_ARGS_);
            } catch (e) {
                cc._throw(e);
            }
        }.toString().replace(/_FUNC_/g, funcName).replace("_R_ARGS_", "target" + (forwardArgs ? ", " + forwardArgs : "")).replace("_U_ARGS_", forwardArgs || "").replace("_AFTER_CALL_", afterCall || ""))(bindArg);
    }
    function isPlainEmptyObj_DEV(obj) {
        if (!obj || obj.constructor !== Object) return !1;
        for (var k in obj) return !1;
        return !0;
    }
    function cloneable_DEV(obj) {
        return obj && "function" == typeof obj.clone && (obj.constructor && obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
    }
    function Enum(obj) {
        if ("__enums__" in obj) return obj;
        value(obj, "__enums__", null, !0);
        for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
            var key = keys[i], val = obj[key];
            if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
            var reverseKey = "" + val;
            key !== reverseKey && value(obj, reverseKey, key);
        }
        return obj;
    }
    function ccenum(enumx) {
        "__enums__" in enumx || value(enumx, "__enums__", null, !0);
    }
    cc.misc = {
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES,
        propertyDefine: propertyDefine,
        nextPOT: nextPOT,
        pushToMap: pushToMap,
        clampf: clampf,
        clamp01: clamp01$1,
        lerp: lerp$1,
        degreesToRadians: degreesToRadians,
        radiansToDegrees: radiansToDegrees,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        cloneable_DEV: cloneable_DEV
    }, Enum.isEnum = function(enumType) {
        return enumType && enumType.hasOwnProperty("__enums__");
    }, Enum.getList = function(enumDef) {
        if (enumDef.__enums__) return enumDef.__enums__;
        var enums = enumDef.__enums__ = [];
        for (var name in enumDef) {
            var value$$1 = enumDef[name];
            Number.isInteger(value$$1) && enums.push({
                name: name,
                value: value$$1
            });
        }
        return enums.sort(function(a, b) {
            return a.value - b.value;
        }), enums;
    }, cc.Enum = Enum;
    var DELIMETER = "$_$";
    function createAttrsSingle(owner, ownerConstructor, superAttrs) {
        var AttrsCtor;
        AttrsCtor = function AttrsCtor() {}, superAttrs && extend(AttrsCtor, superAttrs.constructor);
        var attrs = new AttrsCtor();
        return value(owner, "__attrs__", attrs), attrs;
    }
    function createAttrs(subclass) {
        for (var superClass, chains = cc.Class.getInheritanceChain(subclass), i = chains.length - 1; 0 <= i; i--) {
            var cls = chains[i];
            cls.hasOwnProperty("__attrs__") && cls.__attrs__ || createAttrsSingle(cls, 0, (superClass = chains[i + 1]) && superClass.__attrs__);
        }
        return createAttrsSingle(subclass, 0, (superClass = chains[0]) && superClass.__attrs__), 
        subclass.__attrs__;
    }
    function attr(constructor, propertyName, newAttributes) {
        var attrs, setter;
        if ("function" == typeof constructor) setter = (attrs = getClassAttrs(constructor)).constructor.prototype; else {
            var instance = constructor;
            if (!(attrs = instance.__attrs__)) attrs = createAttrsSingle(instance, 0, getClassAttrs(constructor = instance.constructor));
            setter = attrs;
        }
        if (void 0 === newAttributes) {
            var prefix = propertyName + DELIMETER, ret = {};
            for (var key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
            return ret;
        }
        if ("object" === _typeof(newAttributes)) for (var _key in newAttributes) 95 !== _key.charCodeAt(0) && (setter[propertyName + DELIMETER + _key] = newAttributes[_key]); else 0;
    }
    function getClassAttrs(constructor) {
        return constructor.hasOwnProperty("__attrs__") && constructor.__attrs__ || createAttrs(constructor);
    }
    function getClassAttrsProto(constructor) {
        return getClassAttrs(constructor).constructor.prototype;
    }
    function setClassAttr(ctor, propName, key, value$$1) {
        getClassAttrsProto(ctor)[propName + DELIMETER + key] = value$$1;
    }
    var CCInteger = "Integer";
    cc.Integer = CCInteger;
    var CCFloat = "Float";
    cc.Float = CCFloat;
    var CCBoolean = "Boolean";
    cc.Boolean = CCBoolean;
    var CCString = "String";
    function getTypeChecker(type, attributeName) {
        return function(constructor, mainPropertyName) {
            var propInfo = '"' + getClassName(constructor) + "." + mainPropertyName + '"', mainPropAttrs = attr(constructor, mainPropertyName);
            if (!mainPropAttrs.saveUrlAsAsset) {
                var mainPropAttrsType = mainPropAttrs.type;
                if (mainPropAttrsType !== CCInteger && mainPropAttrsType !== CCFloat || (mainPropAttrsType = "Number"), 
                mainPropAttrsType !== type) return void warnID(3604, propInfo);
            }
            if (mainPropAttrs.hasOwnProperty("default")) {
                var defaultVal = mainPropAttrs.default;
                if (void 0 !== defaultVal) if (!(Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal))) {
                    var defaultType = _typeof(defaultVal), type_lowerCase = type.toLowerCase();
                    if (defaultType === type_lowerCase) {
                        if (!mainPropAttrs.saveUrlAsAsset) if ("object" === type_lowerCase) {
                            if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) return;
                            warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                        } else "Number" !== type && warnID(3606, attributeName, propInfo, type);
                    } else {
                        if ("function" === defaultType) return;
                        type === CCString && null == defaultVal ? isChildClassOf(mainPropAttrs.ctor, cc.RawAsset) || warnID(3607, propInfo) : mainPropAttrs.ctor !== String || "string" !== defaultType && null != defaultVal ? mainPropAttrs.ctor === Boolean && "boolean" === defaultType ? (mainPropAttrs.type = CCBoolean, 
                        warnID(3609, propInfo)) : mainPropAttrs.ctor === Number && "number" === defaultType ? (mainPropAttrs.type = CCFloat, 
                        warnID(3610, propInfo)) : warnID(3611, attributeName, propInfo, defaultType) : (mainPropAttrs.type = CCString, 
                        warnID(3608, propInfo));
                    }
                    delete mainPropAttrs.type;
                }
            }
        };
    }
    function ObjectType(typeCtor) {
        return {
            type: "Object",
            ctor: typeCtor,
            _onAfterProp: void 0
        };
    }
    cc.String = CCString;
    var Attr = Object.freeze({
        DELIMETER: DELIMETER,
        createAttrsSingle: createAttrsSingle,
        createAttrs: createAttrs,
        attr: attr,
        getClassAttrs: getClassAttrs,
        getClassAttrsProto: getClassAttrsProto,
        setClassAttr: setClassAttr,
        CCInteger: CCInteger,
        CCFloat: CCFloat,
        CCBoolean: CCBoolean,
        CCString: CCString,
        getTypeChecker: getTypeChecker,
        ObjectType: ObjectType
    }), SerializableAttrs = {
        url: {
            canUsedInGet: !0
        },
        default: {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {}
    };
    function parseNotify(val, propName, notify, properties) {
        if (!val.get && !val.set) if (val.hasOwnProperty("default")) {
            var newKey = "_N$" + propName;
            val.get = function() {
                return this[newKey];
            }, val.set = function(value$$1) {
                var oldValue = this[newKey];
                this[newKey] = value$$1, notify.call(this, oldValue);
            };
            var newValue = {};
            for (var attr in properties[newKey] = newValue, SerializableAttrs) {
                var v = SerializableAttrs[attr];
                val.hasOwnProperty(attr) && (newValue[attr] = val[attr], v.canUsedInGet || delete val[attr]);
            }
        } else 0;
    }
    function checkUrl(val, className, propName, url) {
        Array.isArray(url) && 0 < url.length && (url = url[0]), val.type = url;
    }
    function parseType(val, type, className, propName) {
        if (Array.isArray(type)) {
            if (!(0 < type.length)) return cc.errorID(5508, className, propName);
            if (cc.RawAsset.isRawAssetType(type[0])) return val.url = type[0], void delete val.type;
            val.type = type = type[0];
        }
    }
    function getFullFormOfProperty(options, propname_dev, classname_dev) {
        if (options && options.constructor === Object) return null;
        if (Array.isArray(options) && 0 < options.length) {
            options[0];
            return {
                default: [],
                type: options,
                _short: !0
            };
        }
        if ("function" != typeof options) return {
            default: options,
            _short: !0
        };
        var _type = options;
        return cc.RawAsset.isRawAssetType(_type) ? {
            default: "",
            url: _type,
            _short: !0
        } : {
            default: isChildClassOf(_type, cc.ValueType) ? new _type() : null,
            type: _type,
            _short: !0
        };
    }
    function validateMethodWithProps(func, funcName, className, cls, base) {
        return "function" == typeof func || null === func;
    }
    var requiringFrames = [];
    function peek() {
        return requiringFrames[requiringFrames.length - 1];
    }
    cc._RF = {
        push: function push(module, uuid, script) {
            void 0 === script && (script = uuid, uuid = ""), requiringFrames.push({
                uuid: uuid,
                script: script,
                module: module,
                exports: module.exports,
                beh: null
            });
        },
        pop: function pop() {
            var frameInfo = requiringFrames.pop(), module = frameInfo.module, exports = module.exports;
            if (exports === frameInfo.exports) {
                for (var anykey in exports) return;
                module.exports = exports = frameInfo.cls;
            }
        },
        peek: peek
    };
    var DELIMETER$1 = DELIMETER, BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
    function pushUnique(array$$1, item) {
        array$$1.indexOf(item) < 0 && array$$1.push(item);
    }
    var deferredInitializer = {
        datas: null,
        push: function push$$1(data) {
            if (this.datas) this.datas.push(data); else {
                this.datas = [ data ];
                var self = this;
                setTimeout(function() {
                    self.init();
                }, 0);
            }
        },
        init: function init() {
            var datas = this.datas;
            if (datas) {
                for (var i = 0; i < datas.length; ++i) {
                    var data = datas[i], cls = data.cls, properties = data.props;
                    "function" == typeof properties && (properties = properties());
                    var _name = getClassName(cls);
                    properties ? declareProperties(cls, _name, properties, cls.$super, data.mixins) : errorID(3633, _name);
                }
                this.datas = null;
            }
        }
    };
    function appendProp(cls, name) {
        pushUnique(cls.__props__, name);
    }
    var tmpArray = [];
    function defineProp(cls, className, propName, val, es6) {
        var defaultValue = val.default;
        setClassAttr(cls, propName, "default", defaultValue), appendProp(cls, propName);
        var attrs = parseAttributes(cls, val, className, propName, !1);
        if (attrs) {
            for (var onAfterProp = tmpArray, i = 0; i < attrs.length; i++) {
                var attr$$1 = attrs[i];
                attr(cls, propName, attr$$1), !1 === attr$$1.serializable && pushUnique(cls.__values__, propName), 
                attr$$1._onAfterProp && onAfterProp.push(attr$$1._onAfterProp);
            }
            for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
            tmpArray.length = 0, attrs.length = 0;
        }
    }
    function defineGetSet(cls, name, propName, val, es6) {
        var getter = val.get, setter = val.set, proto = cls.prototype, d = Object.getOwnPropertyDescriptor(proto, propName), setterUndefined = !d;
        if (getter) {
            0;
            for (var attrs = parseAttributes(cls, val, name, propName, !0), i = 0; i < attrs.length; i++) attr(cls, propName, attrs[i]);
            attrs.length = 0, setClassAttr(cls, propName, "serializable", !1), es6 || get(proto, propName, getter, setterUndefined, setterUndefined);
        }
        setter && (es6 || set$1(proto, propName, setter, setterUndefined, setterUndefined));
    }
    function getDefault(defaultVal) {
        return "function" == typeof defaultVal ? defaultVal() : defaultVal;
    }
    function mixinWithInherited(dest, src, filter) {
        for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
    }
    function doDefine(className, baseClass, mixins, options) {
        var ctors, fireClass, __ctor__ = options.__ctor__, ctor = options.ctor, __es6__ = options.__ES6__;
        __es6__ ? (ctors = [ ctor ], fireClass = ctor) : (ctors = __ctor__ ? [ __ctor__ ] : function _getAllCtors(baseClass, mixins, options) {
            function getCtors(cls) {
                return CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ];
            }
            for (var ctors = [], baseOrMixins = [ baseClass ].concat(mixins), b = 0; b < baseOrMixins.length; b++) {
                var baseOrMixin = baseOrMixins[b];
                if (baseOrMixin) for (var baseCtors = getCtors(baseOrMixin), c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
            }
            var ctor = options.ctor;
            ctor && ctors.push(ctor);
            return ctors;
        }(baseClass, mixins, options), fireClass = _createCtor(ctors, baseClass, className, options), 
        value(fireClass, "extend", function(options) {
            return options.extends = this, CCClass(options);
        }, !0)), value(fireClass, "__ctors__", 0 < ctors.length ? ctors : null, !0);
        var prototype = fireClass.prototype;
        if (baseClass && (__es6__ || (extend(fireClass, baseClass), prototype = fireClass.prototype), 
        fireClass.$super = baseClass), mixins) {
            for (var _loop = function _loop(m) {
                var mixin$$1 = mixins[m];
                mixinWithInherited(prototype, mixin$$1.prototype), mixinWithInherited(fireClass, mixin$$1, function(prop) {
                    return mixin$$1.hasOwnProperty(prop) && !0;
                }), CCClass._isCCClass(mixin$$1) && mixinWithInherited(getClassAttrs(fireClass).constructor.prototype, getClassAttrs(mixin$$1).constructor.prototype);
            }, m = mixins.length - 1; 0 <= m; m--) _loop(m);
            prototype.constructor = fireClass;
        }
        return __es6__ || (prototype.__initProps__ = compileProps), setClassName(className, fireClass), 
        fireClass;
    }
    function getNewValueTypeCodeJit(value$$1) {
        for (var clsName = getClassName(value$$1), type = value$$1.constructor, res = "new " + clsName + "(", i = 0; i < type.__props__.length; i++) {
            var propVal = value$$1[type.__props__[i]];
            0, res += propVal, i < type.__props__.length - 1 && (res += ",");
        }
        return res + ")";
    }
    function escapeForJS(s) {
        return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    function compileProps(actualClass) {
        var attrs = getClassAttrs(actualClass), propList = actualClass.__props__;
        null === propList && (deferredInitializer.init(), propList = actualClass.__props__);
        var initProps = function getInitPropsJit(attrs, propList) {
            for (var F = [], func = "", i = 0; i < propList.length; i++) {
                var prop = propList[i], attrKey = prop + DELIMETER$1 + "default";
                if (attrKey in attrs) {
                    var statement = void 0;
                    statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
                    var expression = void 0, def = attrs[attrKey];
                    if ("object" === _typeof(def) && def) expression = def instanceof cc.ValueType ? getNewValueTypeCodeJit(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" == typeof def) {
                        var index = F.length;
                        F.push(def), expression = "F[" + index + "]()";
                    } else expression = "string" == typeof def ? escapeForJS(def) : def;
                    func += statement = statement + expression + ";\n";
                }
            }
            return 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
        }(attrs, propList);
        (actualClass.prototype.__initProps__ = initProps).call(this);
    }
    var _createCtor = function(ctors, baseClass, className, options) {
        var body = "return function CCClass(){\n";
        baseClass && boundSuperCalls(baseClass, options, className) && (body += "this._super=null;\n"), 
        body += "this.__initProps__(CCClass);\n";
        var ctorLen = ctors.length;
        if (0 < ctorLen) {
            0;
            var SNIPPET = "].apply(this,arguments);\n";
            if (1 === ctorLen) body += "CCClass.__ctors__[0" + SNIPPET; else {
                body += "var cs=CCClass.__ctors__;\n";
                for (var i = 0; i < ctorLen; i++) body += "cs[" + i + SNIPPET;
            }
            0;
        }
        return body += "}", Function(body)();
    };
    var superCllRegCondition = /xyz/.test(function() {}.toString()), SuperCallReg = superCllRegCondition ? /\b\._super\b/ : /.*/;
    function boundSuperCalls(baseClass, options, className) {
        var hasSuperCall = !1;
        for (var funcName in options) if (!(0 <= BUILTIN_ENTRIES.indexOf(funcName))) {
            var func = options[funcName];
            if ("function" == typeof func) {
                var pd = getPropertyDescriptor(baseClass.prototype, funcName);
                if (pd) {
                    var superFunc = pd.value;
                    if ("function" == typeof superFunc) {
                        SuperCallReg.test(func) && (hasSuperCall = !0, options[funcName] = function(superFunc, func) {
                            return function() {
                                var tmp = this._super;
                                this._super = superFunc;
                                var ret = func.apply(this, arguments);
                                return this._super = tmp, ret;
                            };
                        }(superFunc, func));
                        continue;
                    }
                }
                0;
            }
        }
        return hasSuperCall;
    }
    function declareProperties(cls, className, properties, baseClass, mixins, es6) {
        if (cls.__props__ = [], baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice()), 
        mixins) for (var m = 0; m < mixins.length; ++m) {
            var mixin$$1 = mixins[m];
            mixin$$1.__props__ && (cls.__props__ = cls.__props__.concat(mixin$$1.__props__.filter(function(x) {
                return cls.__props__.indexOf(x) < 0;
            })));
        }
        if (properties) for (var propName in function preprocessAttrs(properties, className, cls, es6) {
            for (var propName in properties) {
                var val = properties[propName], fullForm = getFullFormOfProperty(val);
                if (fullForm && (val = properties[propName] = fullForm), val) {
                    var notify = val.notify;
                    notify && parseNotify(val, propName, notify, properties), "type" in val && parseType(val, val.type, className, propName), 
                    "url" in val && checkUrl(val, 0, 0, val.url), "type" in val && val.type;
                }
            }
        }(properties, className), properties) {
            var val = properties[propName];
            "default" in val ? defineProp(cls, className, propName, val) : defineGetSet(cls, className, propName, val, es6);
        }
        var attrs = getClassAttrs(cls);
        cls.__values__ = cls.__props__.filter(function(prop) {
            return !1 !== attrs[prop + DELIMETER$1 + "serializable"];
        });
    }
    function CCClass(options) {
        var name = (options = options || {}).name, base = options.extends, mixins = options.mixins, cls = function define(className, baseClass, mixins, options) {
            var Component = cc.Component, frame = peek();
            if (frame && isChildClassOf(baseClass, Component)) {
                if (isChildClassOf(frame.cls, Component)) return errorID(3615), null;
                className = className || frame.script;
            }
            var cls = doDefine(className, baseClass, mixins, options);
            if (frame) if (isChildClassOf(baseClass, Component)) {
                var uuid = frame.uuid;
                uuid && _setClassId(uuid, cls), frame.cls = cls;
            } else isChildClassOf(frame.cls, Component) || (frame.cls = cls);
            return cls;
        }(name, base, mixins, options);
        name || (name = cc.js.getClassName(cls)), cls._sealed = !0, base && (base._sealed = !1);
        var properties = options.properties;
        "function" == typeof properties || base && null === base.__props__ || mixins && mixins.some(function(x) {
            return null === x.__props__;
        }) ? (deferredInitializer.push({
            cls: cls,
            props: properties,
            mixins: mixins
        }), cls.__props__ = cls.__values__ = null) : declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
        var staticPropName, statics = options.statics;
        if (statics) for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
        for (var funcName in options) if (!(0 <= BUILTIN_ENTRIES.indexOf(funcName))) {
            var func = options[funcName];
            validateMethodWithProps(func) && value(cls.prototype, funcName, func, !0, !0);
        }
        var editor = options.editor;
        return editor && isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor), 
        cls;
    }
    CCClass._isCCClass = function(constructor) {
        return constructor && constructor.hasOwnProperty && constructor.hasOwnProperty("__ctors__");
    }, CCClass.fastDefine = function(className, constructor, serializableFields) {
        setClassName(className, constructor);
        for (var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields), attrProtos = getClassAttrsProto(constructor), i = 0; i < props.length; i++) {
            var key = props[i];
            attrProtos[key + DELIMETER$1 + "visible"] = !1, attrProtos[key + DELIMETER$1 + "default"] = serializableFields[key];
        }
    }, CCClass.Attr = Attr, CCClass.attr = attr, CCClass.getInheritanceChain = function getInheritanceChain(constructor) {
        for (var chain = []; constructor = getSuper(constructor); ) constructor !== Object && chain.push(constructor);
        return chain;
    };
    var PrimitiveTypes = {
        Integer: "Number",
        Float: "Number",
        Boolean: "Boolean",
        String: "String"
    }, tmpAttrs = [];
    function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
        var attrsProto = null, attrsProtoKey = "";
        function getAttrsProto() {
            return attrsProtoKey = propertyName + DELIMETER$1, attrsProto = getClassAttrsProto(constructor);
        }
        tmpAttrs.length = 0;
        var result = tmpAttrs, type = attributes.type;
        if (type) {
            var primitiveType = PrimitiveTypes[type];
            primitiveType ? result.push({
                type: type,
                _onAfterProp: void 0
            }) : "Object" === type || ("object" === _typeof(type) ? Enum.isEnum(type) && result.push({
                type: "Enum",
                enumList: Enum.getList(type)
            }) : "function" == typeof type && (attributes.url ? result.push({
                type: "Object",
                ctor: type,
                _onAfterProp: void 0
            }) : result.push(attributes._short ? {
                type: "Object",
                ctor: type
            } : ObjectType(type))));
        }
        var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
            if (attributeName in attributes) {
                var val = attributes[attributeName];
                _typeof(val) === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attributeName] = val);
            }
        };
        attributes.editorOnly && ((attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = !0), 
        attributes.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = !0), 
        !1 === attributes.serializable && ((attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = !1), 
        parseSimpleAttribute("formerlySerializedAs", "string");
        var range = attributes.range;
        return range && Array.isArray(range) && 2 <= range.length && ((attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0], 
        (attrsProto || getAttrsProto())[attrsProtoKey + "max"] = range[1], 2 < range.length && ((attrsProto || getAttrsProto())[attrsProtoKey + "step"] = range[2])), 
        parseSimpleAttribute("min", "number"), parseSimpleAttribute("max", "number"), parseSimpleAttribute("step", "number"), 
        result;
    }
    CCClass.isArray = function(defaultVal) {
        return defaultVal = getDefault(defaultVal), Array.isArray(defaultVal);
    }, CCClass.getDefault = getDefault, CCClass.escapeForJS = escapeForJS, CCClass.IDENTIFIER_RE = IDENTIFIER_RE, 
    CCClass.getNewValueTypeCode = getNewValueTypeCodeJit, cc.Class = CCClass;
    var CACHE_KEY = "__ccclassCache__";
    function fNOP(ctor) {
        return ctor;
    }
    function getSubDict(obj, key) {
        return obj[key] || (obj[key] = {});
    }
    function checkCtorArgument(decorate) {
        return function(target) {
            return "function" == typeof target ? decorate(target) : function(ctor) {
                return decorate(ctor, target);
            };
        };
    }
    function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
        return function(target) {
            return function(ctor) {
                return decorate(ctor, target);
            };
        };
    }
    var checkCompArgument = _checkNormalArgument.bind(null, !1);
    function _argumentChecker(type) {
        return _checkNormalArgument.bind(null, !1);
    }
    var checkStringArgument = _argumentChecker(), checkNumberArgument = _argumentChecker();
    function getClassCache(ctor, decoratorName) {
        return getSubDict(ctor, CACHE_KEY);
    }
    function genProperty(ctor, properties, propName, options, desc, cache) {
        var fullOptions;
        options && (fullOptions = (fullOptions = getFullFormOfProperty(options)) || options);
        var prop = mixin(properties[propName] || {}, fullOptions || {});
        if (desc && (desc.get || desc.set)) {
            desc.get && (prop.get = desc.get), desc.set && (prop.set = desc.set);
        } else {
            var defaultValue;
            0;
            if (desc) desc.initializer && (defaultValue = function getDefaultFromInitializer(initializer) {
                var value$$1;
                try {
                    value$$1 = initializer();
                } catch (e) {
                    return initializer;
                }
                return "object" !== _typeof(value$$1) || null === value$$1 ? value$$1 : initializer;
            }(desc.initializer), !0); else {
                var actualDefaultValues = cache.default || (cache.default = function extractActualDefaultValues(ctor) {
                    var dummyObj;
                    try {
                        dummyObj = new ctor();
                    } catch (e) {
                        return {};
                    }
                    return dummyObj;
                }(ctor));
                actualDefaultValues.hasOwnProperty(propName) && (defaultValue = actualDefaultValues[propName], 
                !0);
            }
            0, prop.default = defaultValue;
        }
        properties[propName] = prop;
    }
    var ccclass = checkCtorArgument(function(ctor, name) {
        var base = getSuper(ctor);
        base === Object && (base = null);
        var proto = {
            name: name,
            extends: base,
            ctor: ctor,
            __ES6__: !0
        }, cache = ctor[CACHE_KEY];
        if (cache) {
            var decoratedProto = cache.proto;
            decoratedProto && mixin(proto, decoratedProto), ctor[CACHE_KEY] = void 0;
        }
        return cc.Class(proto);
    });
    function property(ctorProtoOrOptions, propName, desc) {
        var options = null;
        function normalized(ctorProto, propName, desc) {
            var cache = getClassCache(ctorProto.constructor);
            if (cache) {
                var properties = getSubDict(getSubDict(cache, "proto"), "properties");
                genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
            }
        }
        if (void 0 === propName) return options = ctorProtoOrOptions, normalized;
        normalized(ctorProtoOrOptions, propName, desc);
    }
    function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
        return argCheckFunc(function(ctor, decoratedValue) {
            var cache = getClassCache(ctor);
            if (cache) {
                var value$$1 = void 0 !== staticValue ? staticValue : decoratedValue;
                getSubDict(getSubDict(cache, "proto"), "editor")[editorPropName] = value$$1;
            }
        }, editorPropName);
    }
    function createDummyDecorator(argCheckFunc) {
        return argCheckFunc(fNOP);
    }
    var executeInEditMode = createDummyDecorator(checkCtorArgument), requireComponent = createEditorDecorator(checkCompArgument, "requireComponent"), menu = createDummyDecorator(checkStringArgument), executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder"), disallowMultiple = createDummyDecorator(checkCtorArgument), playOnFocus = createDummyDecorator(checkCtorArgument), inspector = createDummyDecorator(checkStringArgument), icon = createDummyDecorator(checkStringArgument), help = createDummyDecorator(checkStringArgument);
    var _decorator = Object.freeze({
        ccclass: ccclass,
        property: property,
        executeInEditMode: executeInEditMode,
        requireComponent: requireComponent,
        menu: menu,
        executionOrder: executionOrder,
        disallowMultiple: disallowMultiple,
        playOnFocus: playOnFocus,
        inspector: inspector,
        icon: icon,
        help: help,
        mixins: function mixins() {
            for (var mixins = [], i = 0; i < arguments.length; i++) mixins[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
            return function(ctor) {
                var cache = getClassCache(ctor);
                cache && (getSubDict(cache, "proto").mixins = mixins);
            };
        }
    }), objectsToDestroy = [];
    var _class, CCObject = function() {
        function CCObject() {
            var name = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "";
            _classCallCheck(this, CCObject), this._objFlags = void 0, this._name = void 0, this._name = name, 
            this._objFlags = 0;
        }
        return _createClass(CCObject, null, [ {
            key: "_deferredDestroy",
            value: function _deferredDestroy() {
                for (var deleteCount = objectsToDestroy.length, i = 0; i < deleteCount; ++i) {
                    var obj = objectsToDestroy[i];
                    1 & obj._objFlags || obj._destroyImmediate();
                }
                deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
            }
        } ]), _createClass(CCObject, [ {
            key: "destroy",
            value: function destroy() {
                return 1 & this._objFlags ? (cc.warnID(5e3), !1) : !(4 & this._objFlags) && (this._objFlags |= 4, 
                objectsToDestroy.push(this), !0);
            }
        }, {
            key: "_destruct",
            value: function _destruct() {
                var ctor = this.constructor, destruct = ctor.__destruct__;
                destruct || (destruct = function compileDestruct(obj, ctor) {
                    var key, shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component, idToSkip = shouldSkipId ? "_id" : null, propsToReset = {};
                    for (key in obj) if (obj.hasOwnProperty(key)) {
                        if (key === idToSkip) continue;
                        switch (_typeof(obj[key])) {
                          case "string":
                            propsToReset[key] = "";
                            break;

                          case "object":
                          case "function":
                            propsToReset[key] = null;
                        }
                    }
                    if (CCClass._isCCClass(ctor)) for (var attrs = cc.Class.Attr.getClassAttrs(ctor), propList = ctor.__props__, i = 0; i < propList.length; i++) {
                        var attrKey = (key = propList[i]) + cc.Class.Attr.DELIMETER + "default";
                        if (attrKey in attrs) {
                            if (shouldSkipId && "_id" === key) continue;
                            switch (_typeof(attrs[attrKey])) {
                              case "string":
                                propsToReset[key] = "";
                                break;

                              case "object":
                              case "function":
                                propsToReset[key] = null;
                                break;

                              case "undefined":
                                propsToReset[key] = void 0;
                            }
                        }
                    }
                    var func = "";
                    for (key in propsToReset) {
                        var statement = void 0;
                        statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
                        var val = propsToReset[key];
                        "" === val && (val = '""'), func += statement + val + ";\n";
                    }
                    return Function("o", func);
                }(this, ctor), value(ctor, "__destruct__", destruct, !0)), destruct(this);
            }
        }, {
            key: "_destroyImmediate",
            value: function _destroyImmediate() {
                1 & this._objFlags ? cc.errorID(5e3) : (this._onPreDestroy && this._onPreDestroy(), 
                this._destruct(), this._objFlags |= 1);
            }
        }, {
            key: "name",
            get: function get$$1() {
                return this._name;
            },
            set: function set(value$$1) {
                this._name = value$$1;
            }
        }, {
            key: "isValid",
            get: function get$$1() {
                return !(1 & this._objFlags);
            }
        } ]), CCObject;
    }(), prototype = CCObject.prototype;
    prototype._deserialize = null, prototype._onPreDestroy = null, CCClass.fastDefine("cc.Object", CCObject, {
        _name: "",
        _objFlags: 0
    }), value(CCObject, "Flags", {
        Destroyed: 1,
        DontSave: 8,
        EditorOnly: 16,
        Dirty: 32,
        DontDestroy: 64,
        PersistentMask: -4192741,
        Destroying: 128,
        Deactivating: 256,
        LockedInEditor: 512,
        HideInHierarchy: 1024,
        IsPreloadStarted: 8192,
        IsOnLoadStarted: 32768,
        IsOnLoadCalled: 16384,
        IsOnEnableCalled: 2048,
        IsStartCalled: 65536,
        IsEditorOnEnableCalled: 4096,
        IsPositionLocked: 1 << 21,
        IsRotationLocked: 1 << 17,
        IsScaleLocked: 1 << 18,
        IsAnchorLocked: 1 << 19,
        IsSizeLocked: 1 << 20
    }), cc.isValid = function(value$$1, strictMode) {
        return "object" === _typeof(value$$1) ? !(!value$$1 || value$$1._objFlags & (strictMode ? 5 : 1)) : void 0 !== value$$1;
    }, cc.Object = CCObject;
    var RawAsset = ccclass("cc.RawAsset")(_class = function(_CCObject) {
        function RawAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RawAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RawAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uuid = void 0, 
            Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_uuid", {
                value: "",
                writable: !0
            }), _this;
        }
        return _inherits(RawAsset, CCObject), _createClass(RawAsset, null, [ {
            key: "isRawAssetType",
            value: function isRawAssetType(ctor) {
                return isChildClassOf(ctor, cc.RawAsset) && !isChildClassOf(ctor, cc.Asset);
            }
        } ]), RawAsset;
    }()) || _class;
    cc.RawAsset = RawAsset;
    var Pool$1 = function() {
        function Pool(fn, size) {
            _classCallCheck(this, Pool), this._fn = void 0, this._idx = void 0, this._frees = void 0, 
            this._fn = fn, this._idx = size - 1, this._frees = new Array(size);
            for (var i = 0; i < size; ++i) this._frees[i] = fn();
        }
        return _createClass(Pool, [ {
            key: "alloc",
            value: function alloc() {
                this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
                var ret = this._frees[this._idx];
                return this._frees.splice(this._idx), --this._idx, ret;
            }
        }, {
            key: "free",
            value: function free(obj) {
                ++this._idx, this._frees[this._idx] = obj;
            }
        }, {
            key: "clear",
            value: function clear(fn) {
                for (var i = 0; i <= this._idx; i++) fn && fn(this._frees[i]);
                this._frees.splice(0), this._idx = -1;
            }
        }, {
            key: "_expand",
            value: function _expand(size) {
                var old = this._frees;
                this._frees = new Array(size);
                for (var len = size - old.length, i = 0; i < len; ++i) this._frees[i] = this._fn();
                for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
                this._idx += len;
            }
        } ]), Pool;
    }(), fastRemoveAt$1 = array.fastRemoveAt;
    function empty() {}
    var CallbackInfo = function() {
        function CallbackInfo() {
            _classCallCheck(this, CallbackInfo), this.callback = empty, this.target = void 0, 
            this.once = !1;
        }
        return _createClass(CallbackInfo, [ {
            key: "set",
            value: function set(callback, target, once) {
                this.callback = callback, this.target = target, this.once = !!once;
            }
        } ]), CallbackInfo;
    }(), callbackInfoPool = new Pool$1(function() {
        return new CallbackInfo();
    }, 32), CallbackList = function() {
        function CallbackList() {
            _classCallCheck(this, CallbackList), this.callbackInfos = [], this.isInvoking = !1, 
            this.containCanceled = !1;
        }
        return _createClass(CallbackList, [ {
            key: "removeByCallback",
            value: function removeByCallback(cb) {
                for (var i = 0; i < this.callbackInfos.length; ++i) {
                    var info = this.callbackInfos[i];
                    info && info.callback === cb && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                    --i);
                }
            }
        }, {
            key: "removeByTarget",
            value: function removeByTarget(target) {
                for (var i = 0; i < this.callbackInfos.length; ++i) {
                    var info = this.callbackInfos[i];
                    info && info.target === target && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                    --i);
                }
            }
        }, {
            key: "cancel",
            value: function cancel(index) {
                var info = this.callbackInfos[index];
                info && (callbackInfoPool.free(info), this.callbackInfos[index] = null), this.containCanceled = !0;
            }
        }, {
            key: "cancelAll",
            value: function cancelAll() {
                for (var i = 0; i < this.callbackInfos.length; i++) {
                    var info = this.callbackInfos[i];
                    info && (callbackInfoPool.free(info), this.callbackInfos[i] = null);
                }
                this.containCanceled = !0;
            }
        }, {
            key: "purgeCanceled",
            value: function purgeCanceled() {
                for (var i = this.callbackInfos.length - 1; 0 <= i; --i) {
                    this.callbackInfos[i] || fastRemoveAt$1(this.callbackInfos, i);
                }
                this.containCanceled = !1;
            }
        }, {
            key: "clear",
            value: function clear$$1() {
                this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1;
            }
        } ]), CallbackList;
    }(), callbackListPool = new Pool$1(function() {
        return new CallbackList();
    }, 16), CallbacksInvoker = function() {
        function CallbacksInvoker() {
            _classCallCheck(this, CallbacksInvoker), this._callbackTable = createMap(!0);
        }
        return _createClass(CallbacksInvoker, [ {
            key: "on",
            value: function on(key, callback, target, once) {
                var list = this._callbackTable[key];
                list || (list = this._callbackTable[key] = callbackListPool.alloc());
                var info = callbackInfoPool.alloc();
                info.set(callback, target, once), list.callbackInfos.push(info);
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback) {
                var target = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, list = this._callbackTable[key];
                if (!list) return !1;
                var infos = list.callbackInfos;
                if (!callback) {
                    if (list.isInvoking) {
                        var _iterator = infos, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            if (_ref) return !0;
                        }
                        return !1;
                    }
                    return 0 < infos.length;
                }
                var _iterator2 = infos, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _info = _ref2;
                    if (_info && _info.callback === callback && _info.target === target) return !0;
                }
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {
                if ("string" == typeof keyOrTarget) {
                    var list = this._callbackTable[keyOrTarget];
                    list && (list.isInvoking ? list.cancelAll() : (list.clear(), callbackListPool.free(list), 
                    delete this._callbackTable[keyOrTarget]));
                } else if (keyOrTarget) for (var key in this._callbackTable) {
                    var _list = this._callbackTable[key];
                    if (_list.isInvoking) for (var infos = _list.callbackInfos, i = 0; i < infos.length; ++i) {
                        var info = infos[i];
                        info && info.target === keyOrTarget && _list.cancel(i);
                    } else _list.removeByTarget(keyOrTarget);
                }
            }
        }, {
            key: "off",
            value: function off(key, callback, target) {
                var list = this._callbackTable[key];
                if (list) {
                    var infos = list.callbackInfos;
                    if (callback) for (var i = 0; i < infos.length; ++i) {
                        var info = infos[i];
                        if (info && info.callback === callback && info.target === target) {
                            list.isInvoking ? list.cancel(i) : (fastRemoveAt$1(infos, i), callbackInfoPool.free(info));
                            break;
                        }
                    } else this.removeAll(key);
                }
            }
        }, {
            key: "emit",
            value: function emit(key) {
                var list = this._callbackTable[key];
                if (list) {
                    var rootInvoker = !list.isInvoking;
                    list.isInvoking = !0;
                    for (var infos = list.callbackInfos, _len = arguments.length, args = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    for (var i = 0, len = infos.length; i < len; ++i) {
                        var info = infos[i];
                        if (info) {
                            var callback = info.callback, target = info.target;
                            info.once && this.off(key, callback, target), target ? callback.call.apply(callback, [ target ].concat(args)) : callback.apply(void 0, args);
                        }
                    }
                    rootInvoker && (list.isInvoking = !1, list.containCanceled && list.purgeCanceled());
                }
            }
        } ]), CallbacksInvoker;
    }();
    var _dec$1, _dec2, _class$1, _class2, _descriptor, _class3, _temp$1, fastRemove$1 = array.fastRemove, EventTarget = function(_CallbacksInvoker) {
        function EventTarget() {
            return _classCallCheck(this, EventTarget), _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).apply(this, arguments));
        }
        return _inherits(EventTarget, CallbacksInvoker), _createClass(EventTarget, [ {
            key: "on",
            value: function on(type, callback, target) {
                if (callback) {
                    if (!this.hasEventListener(type, callback, target)) {
                        _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target);
                        var targetImpl = target;
                        target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                    }
                    return callback;
                }
                cc.errorID(6800);
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                if (callback) {
                    _get(_getPrototypeOf(EventTarget.prototype), "off", this).call(this, type, callback, target);
                    var targetImpl = target;
                    target && (targetImpl.__eventTargets ? fastRemove$1(targetImpl.__eventTargets, this) : targetImpl.node && targetImpl.node.__eventTargets && fastRemove$1(targetImpl.node.__eventTargets, this));
                } else this.removeAll(type);
            }
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {
                this.removeAll(keyOrTarget);
            }
        }, {
            key: "once",
            value: function once(type, callback, target) {
                if (callback) {
                    if (!this.hasEventListener(type, callback, target)) {
                        _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target, !0);
                        var targetImpl = target;
                        target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                    }
                    return callback;
                }
                cc.errorID(6800);
            }
        } ]), EventTarget;
    }();
    function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function(baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
                "constructor" !== name && Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            });
        });
    }
    cc.EventTarget = EventTarget;
    var Asset = (_dec$1 = ccclass("cc.Asset"), _dec2 = property({
        visible: !1
    }), _dec$1((_temp$1 = _class3 = function(_RawAsset) {
        function Asset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Asset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Asset)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).loaded = !0, 
            _initializerDefineProperty(_this, "_native", _descriptor, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._callbackTable = createMap(!0), _this;
        }
        return _inherits(Asset, RawAsset), _createClass(Asset, null, [ {
            key: "deserialize",
            value: function deserialize(data) {
                return cc.deserialize(data);
            }
        } ]), _createClass(Asset, [ {
            key: "on",
            value: function on(type, callback, target) {}
        }, {
            key: "off",
            value: function off(type, callback, target) {}
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {}
        }, {
            key: "once",
            value: function once(type, callback, target) {}
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {}
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback, target) {
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {}
        }, {
            key: "emit",
            value: function emit(key) {}
        }, {
            key: "toString",
            value: function toString() {
                return this.nativeUrl;
            }
        }, {
            key: "_setRawAsset",
            value: function _setRawAsset(filename) {
                var inLibrary = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
                this._native = !1 !== inLibrary ? filename || void 0 : "/" + filename;
            }
        }, {
            key: "nativeUrl",
            get: function get$$1() {
                if (this._native) {
                    var name = this._native;
                    if (47 === name.charCodeAt(0)) return name.slice(1);
                    if (cc.AssetLibrary) {
                        var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, !0);
                        return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
                    }
                    cc.errorID(6400);
                }
                return "";
            }
        }, {
            key: "_nativeAsset",
            get: function get$$1() {
                return null;
            },
            set: function set(obj) {}
        } ]), Asset;
    }(), _class3.preventDeferredLoadDependents = !1, _class3.preventPreloadNativeObject = !1, 
    _descriptor = _applyDecoratedDescriptor((_class2 = _temp$1).prototype, "_native", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _applyDecoratedDescriptor(_class2.prototype, "nativeUrl", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2.prototype, "nativeUrl"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "_nativeAsset", [ property ], Object.getOwnPropertyDescriptor(_class2.prototype, "_nativeAsset"), _class2.prototype), 
    _class$1 = _class2)) || _class$1);
    function flattenCodeArray(array) {
        var strList = [];
        return function deepFlatten(strList, array) {
            var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var item = _ref;
                Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
            }
        }(strList, array), strList.join("");
    }
    applyMixins(Asset, [ CallbacksInvoker, EventTarget ]), Asset.prototype.createNode = null, 
    cc.Asset = Asset;
    var Destroyed$1 = CCObject.Flags.Destroyed, PersistentMask$1 = CCObject.Flags.PersistentMask, DEFAULT = DELIMETER + "default", IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE, DEFAULT_MODULE_CACHE = {
        "cc.Node": "cc.Node",
        "cc.Sprite": "cc.Sprite",
        "cc.Label": "cc.Label",
        "cc.Button": "cc.Button",
        "cc.Widget": "cc.Widget",
        "cc.Animation": "cc.Animation",
        "cc.ClickEvent": !1,
        "cc.PrefabInfo": !1
    }, escapeForJS$1 = CCClass.escapeForJS, Declaration = function() {
        function Declaration(varName, expression) {
            _classCallCheck(this, Declaration), this.varName = void 0, this.expression = void 0, 
            this.varName = varName, this.expression = expression;
        }
        return _createClass(Declaration, [ {
            key: "toString",
            value: function toString() {
                return "var " + this.varName + "=" + this.expression + ";";
            }
        } ]), Declaration;
    }();
    function mergeDeclaration(statement, expression) {
        return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
    }
    function writeAssignment(codeArray, statement, expression) {
        Array.isArray(expression) ? (expression[0] = mergeDeclaration(statement, expression[0]), 
        codeArray.push(expression)) : codeArray.push(mergeDeclaration(statement, expression) + ";");
    }
    var Assignments = function() {
        function Assignments(targetExpression) {
            _classCallCheck(this, Assignments), this._exps = void 0, this._targetExp = void 0, 
            this._exps = [], this._targetExp = targetExpression;
        }
        return _createClass(Assignments, [ {
            key: "append",
            value: function append(key, expression) {
                this._exps.push([ key, expression ]);
            }
        }, {
            key: "writeCode",
            value: function writeCode(codeArray) {
                var targetVar;
                if (1 < this._exps.length) codeArray.push("t=" + this._targetExp + ";"), targetVar = "t"; else {
                    if (1 !== this._exps.length) return;
                    targetVar = this._targetExp;
                }
                for (var i = 0; i < this._exps.length; i++) {
                    var pair = this._exps[i];
                    writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
                }
            }
        } ]), Assignments;
    }();
    function getPropAccessor(key) {
        return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
    }
    Assignments.pool = void 0, Assignments.pool = new Pool(function(obj) {
        obj._exps.length = 0, obj._targetExp = null;
    }, 1), Assignments.pool.get = function(targetExpression) {
        var cache = this._get() || new Assignments();
        return cache._targetExp = targetExpression, cache;
    };
    var _class$2, _class2$1, _descriptor$1, _descriptor2, _descriptor3, _class3$1, _temp$2, Parser = function() {
        function Parser(obj, parent) {
            var globalVariablesDeclaration;
            _classCallCheck(this, Parser), this.parent = void 0, this.objsToClear_iN$t = void 0, 
            this.codeArray = void 0, this.objs = void 0, this.funcs = void 0, this.funcModuleCache = void 0, 
            this.globalVariables = void 0, this.globalVariableId = void 0, this.localVariableId = void 0, 
            this.result = void 0, this.parent = parent, this.objsToClear_iN$t = [], this.codeArray = [], 
            this.objs = [], this.funcs = [], this.funcModuleCache = createMap(), mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE), 
            this.globalVariables = [], this.globalVariableId = 0, this.localVariableId = 0, 
            this.codeArray.push("var o,t;", "if(R){", "o=R;", "}else{", "o=R=new " + this.getFuncModule(obj.constructor, !0) + "();", "}"), 
            obj._iN$t = {
                globalVar: "R"
            }, this.objsToClear_iN$t.push(obj), this.enumerateObject(this.codeArray, obj), 0 < this.globalVariables.length && (globalVariablesDeclaration = "var " + this.globalVariables.join(",") + ";");
            var code = flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
            this.result = Function("O", "F", code)(this.objs, this.funcs);
            for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
            this.objsToClear_iN$t.length = 0;
        }
        return _createClass(Parser, [ {
            key: "getFuncModule",
            value: function getFuncModule(func, usedInNew) {
                var clsName = getClassName(func);
                if (clsName) {
                    var cache = this.funcModuleCache[clsName];
                    if (cache) return cache;
                    if (void 0 === cache) {
                        var clsNameIsModule = -1 !== clsName.indexOf(".");
                        if (clsNameIsModule) try {
                            if (clsNameIsModule = func === Function("return " + clsName)()) return this.funcModuleCache[clsName] = clsName;
                        } catch (e) {}
                    }
                }
                var index = this.funcs.indexOf(func);
                index < 0 && (index = this.funcs.length, this.funcs.push(func));
                var res = "F[" + index + "]";
                return usedInNew && (res = "(" + res + ")"), this.funcModuleCache[clsName] = res;
            }
        }, {
            key: "getObjRef",
            value: function getObjRef(obj) {
                var index = this.objs.indexOf(obj);
                return index < 0 && (index = this.objs.length, this.objs.push(obj)), "O[" + index + "]";
            }
        }, {
            key: "setValueType",
            value: function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                var assignments = Assignments.pool.get(targetExpression), fastDefinedProps = defaultValue.constructor.__props__;
                fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
                for (var i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i], prop = srcValue[propName];
                    if (defaultValue[propName] !== prop) {
                        var expression = this.enumerateField(srcValue, propName, prop);
                        assignments.append(propName, expression);
                    }
                }
                assignments.writeCode(codeArray), Assignments.pool.put(assignments);
            }
        }, {
            key: "enumerateCCClass",
            value: function enumerateCCClass(codeArray, obj, klass) {
                for (var props = klass.__values__, attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                    var key = props[p], val = obj[key], defaultValue = attrs[key + DEFAULT];
                    if (!equalsToDefault(defaultValue, val)) if ("object" === _typeof(val) && val instanceof cc.ValueType && (defaultValue = CCClass.getDefault(defaultValue)) && defaultValue.constructor === val.constructor) {
                        var targetExpression = "o" + getPropAccessor(key);
                        this.setValueType(codeArray, defaultValue, val, targetExpression);
                    } else this.setObjProp(codeArray, obj, key, val);
                }
            }
        }, {
            key: "instantiateArray",
            value: function instantiateArray(value$$1) {
                if (0 === value$$1.length) return "[]";
                var arrayVar = "a" + ++this.localVariableId, codeArray = [ new Declaration(arrayVar, "new Array(" + value$$1.length + ")") ];
                value$$1._iN$t = {
                    globalVar: "",
                    source: codeArray
                }, this.objsToClear_iN$t.push(value$$1);
                for (var i = 0; i < value$$1.length; ++i) {
                    writeAssignment(codeArray, arrayVar + "[" + i + "]=", this.enumerateField(value$$1, i, value$$1[i]));
                }
                return codeArray;
            }
        }, {
            key: "enumerateField",
            value: function enumerateField(obj, key, value$$1) {
                if ("object" === _typeof(value$$1) && value$$1) {
                    var _iN$t = value$$1._iN$t;
                    if (_iN$t) {
                        var globalVar = _iN$t.globalVar;
                        if (!globalVar) {
                            globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId, this.globalVariables.push(globalVar);
                            var line = _iN$t.source[0];
                            _iN$t.source[0] = mergeDeclaration(globalVar + "=", line);
                        }
                        return globalVar;
                    }
                    return Array.isArray(value$$1) ? this.instantiateArray(value$$1) : this.instantiateObj(value$$1);
                }
                return "function" == typeof value$$1 ? this.getFuncModule(value$$1) : "string" == typeof value$$1 ? escapeForJS$1(value$$1) : ("_objFlags" === key && obj instanceof CCObject && (value$$1 &= PersistentMask$1), 
                value$$1);
            }
        }, {
            key: "setObjProp",
            value: function setObjProp(codeArray, obj, key, value$$1) {
                writeAssignment(codeArray, "o" + getPropAccessor(key) + "=", this.enumerateField(obj, key, value$$1));
            }
        }, {
            key: "enumerateObject",
            value: function enumerateObject(codeArray, obj) {
                var klass = obj.constructor;
                if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
                    var value$$1 = obj[key];
                    "object" === _typeof(value$$1) && value$$1 && value$$1 === obj._iN$t || this.setObjProp(codeArray, obj, key, value$$1);
                }
            }
        }, {
            key: "instantiateObj",
            value: function instantiateObj(obj) {
                if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
                if (obj instanceof cc.Asset) return this.getObjRef(obj);
                if (obj._objFlags & Destroyed$1) return null;
                var createCode, ctor = obj.constructor;
                if (cc.Class._isCCClass(ctor)) {
                    if (this.parent) if (this.parent instanceof cc.Component) {
                        if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
                    } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                        if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
                    } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
                    createCode = new Declaration("o", "new " + this.getFuncModule(ctor, !0) + "()");
                } else if (ctor === Object) createCode = new Declaration("o", "{}"); else {
                    if (ctor) return this.getObjRef(obj);
                    createCode = new Declaration("o", "Object.create(null)");
                }
                var codeArray = [ createCode ];
                return obj._iN$t = {
                    globalVar: "",
                    source: codeArray
                }, this.objsToClear_iN$t.push(obj), this.enumerateObject(codeArray, obj), [ "(function(){", codeArray, "return o;})();" ];
            }
        } ]), Parser;
    }();
    function equalsToDefault(def, value$$1) {
        if ("function" == typeof def) try {
            def = def();
        } catch (e) {
            return !1;
        }
        if (def === value$$1) return !0;
        if (def && value$$1) {
            if (def instanceof cc.ValueType && def.equals(value$$1)) return !0;
            if (Array.isArray(def) && Array.isArray(value$$1) || def.constructor === Object && value$$1.constructor === Object) try {
                return Array.isArray(def) && Array.isArray(value$$1) && 0 === def.length && 0 === value$$1.length;
            } catch (e) {}
        }
        return !1;
    }
    function compile(node) {
        var root = node instanceof cc._BaseNode && node;
        return new Parser(node, root).result;
    }
    var _class$3, _class2$2, _class3$2, OptimizationPolicy = Enum({
        AUTO: 0,
        SINGLE_INSTANCE: 1,
        MULTI_INSTANCE: 2
    }), Prefab = ccclass("cc.Prefab")((_temp$2 = _class3$1 = function(_Asset) {
        function Prefab() {
            var _this;
            return _classCallCheck(this, Prefab), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this)), "data", _descriptor$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._createFunction = void 0, _this._instantiatedTimes = void 0, _this._createFunction = null, 
            _this._instantiatedTimes = 0, _this;
        }
        return _inherits(Prefab, Asset), _createClass(Prefab, [ {
            key: "createNode",
            value: function createNode(cb) {
                var node = cc.instantiate(this);
                node.name = this.name, cb(null, node);
            }
        }, {
            key: "compileCreateFunction",
            value: function compileCreateFunction() {
                this._createFunction = compile(this.data);
            }
        }, {
            key: "_doInstantiate",
            value: function _doInstantiate(rootToRedirect) {
                return this.data._prefab ? this.data._prefab._synced = !0 : cc.warnID(3700), this._createFunction || this.compileCreateFunction(), 
                this._createFunction(rootToRedirect);
            }
        }, {
            key: "_instantiate",
            value: function _instantiate() {
                var node;
                return this.optimizationPolicy !== OptimizationPolicy.SINGLE_INSTANCE && (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold) ? (node = this._doInstantiate(), 
                this.data._instantiate(node)) : (this.data._prefab._synced = !0, node = this.data._instantiate()), 
                ++this._instantiatedTimes, node;
            }
        } ]), Prefab;
    }(), _class3$1.OptimizationPolicy = OptimizationPolicy, _class3$1.OptimizationPolicyThreshold = 3, 
    _descriptor$1 = _applyDecoratedDescriptor((_class2$1 = _temp$2).prototype, "data", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2$1.prototype, "optimizationPolicy", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return OptimizationPolicy.AUTO;
        }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2$1.prototype, "asyncLoadAssets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$2 = _class2$1)) || _class$2;
    cc.Prefab = Prefab, obsolete(cc, "cc._Prefab", "Prefab");
    var Script = ccclass("cc.Script")(_class$3 = function(_Asset) {
        function Script() {
            return _classCallCheck(this, Script), _possibleConstructorReturn(this, _getPrototypeOf(Script).apply(this, arguments));
        }
        return _inherits(Script, Asset), Script;
    }()) || _class$3;
    cc._Script = Script;
    var JavaScript = ccclass("cc.JavaScript")(_class2$2 = function(_Script) {
        function JavaScript() {
            return _classCallCheck(this, JavaScript), _possibleConstructorReturn(this, _getPrototypeOf(JavaScript).apply(this, arguments));
        }
        return _inherits(JavaScript, Script), JavaScript;
    }()) || _class2$2;
    cc._JavaScript = JavaScript;
    var _class$4, _class2$3, _descriptor$2, _descriptor2$1, TypeScript = ccclass("cc.TypeScript")(_class3$2 = function(_Script2) {
        function TypeScript() {
            return _classCallCheck(this, TypeScript), _possibleConstructorReturn(this, _getPrototypeOf(TypeScript).apply(this, arguments));
        }
        return _inherits(TypeScript, Script), TypeScript;
    }()) || _class3$2;
    cc._TypeScript = TypeScript;
    var SceneAsset = ccclass("cc.SceneAsset")((_descriptor$2 = _applyDecoratedDescriptor((_class2$3 = function(_Asset) {
        function SceneAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SceneAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SceneAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "scene", _descriptor$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor2$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(SceneAsset, Asset), SceneAsset;
    }()).prototype, "scene", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "asyncLoadAssets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$4 = _class2$3)) || _class$4;
    cc.SceneAsset = SceneAsset;
    var ValueType = function() {
        function ValueType() {
            _classCallCheck(this, ValueType);
        }
        return _createClass(ValueType, [ {
            key: "clone",
            value: function clone() {
                return errorID(100, getClassName(this) + ".clone"), this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return !1;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio, out) {
                return 1 === ratio ? to.clone() : this.clone();
            }
        }, {
            key: "set",
            value: function set(other) {
                errorID(100, getClassName(this) + ".set");
            }
        }, {
            key: "toString",
            value: function toString() {
                return "" + {};
            }
        } ]), ValueType;
    }();
    setClassName("cc.ValueType", ValueType), cc.ValueType = ValueType;
    var Vec2 = function(_ValueType) {
        function Vec2(x, y) {
            var _this;
            return _classCallCheck(this, Vec2), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec2).call(this))).x = void 0, 
            _this.y = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y) : (_this.x = x || 0, 
            _this.y = y || 0), _this;
        }
        return _inherits(Vec2, ValueType), _createClass(Vec2, [ {
            key: "clone",
            value: function clone() {
                return new Vec2(this.x, this.y);
            }
        }, {
            key: "set",
            value: function set(other) {
                return this.x = other.x, this.y = other.y, this;
            }
        }, {
            key: "equals",
            value: function equals$$1(other) {
                return other && this.x === other.x && this.y === other.y;
            }
        }, {
            key: "fuzzyEquals",
            value: function fuzzyEquals(other, variance) {
                return this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ")");
            }
        }, {
            key: "lerp",
            value: function lerp$$1(to, ratio, out) {
                out = out || new Vec2();
                var x = this.x, y = this.y;
                return out.x = x + (to.x - x) * ratio, out.y = y + (to.y - y) * ratio, out;
            }
        }, {
            key: "clampf",
            value: function clampf(minInclusive, maxInclusive) {
                return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                this;
            }
        }, {
            key: "addSelf",
            value: function addSelf(other) {
                return this.x += other.x, this.y += other.y, this;
            }
        }, {
            key: "add",
            value: function add(other, out) {
                return (out = out || new Vec2()).x = this.x + other.x, out.y = this.y + other.y, 
                out;
            }
        }, {
            key: "subSelf",
            value: function subSelf(other) {
                return this.x -= other.x, this.y -= other.y, this;
            }
        }, {
            key: "sub",
            value: function sub(other, out) {
                return (out = out || new Vec2()).x = this.x - other.x, out.y = this.y - other.y, 
                out;
            }
        }, {
            key: "mulSelf",
            value: function mulSelf(scalar) {
                return this.x *= scalar, this.y *= scalar, this;
            }
        }, {
            key: "mul",
            value: function mul(scalar, out) {
                return (out = out || new Vec2()).x = this.x * scalar, out.y = this.y * scalar, out;
            }
        }, {
            key: "scaleSelf",
            value: function scaleSelf(other) {
                return this.x *= other.x, this.y *= other.y, this;
            }
        }, {
            key: "scale",
            value: function scale(other, out) {
                return (out = out || new Vec2()).x = this.x * other.x, out.y = this.y * other.y, 
                out;
            }
        }, {
            key: "divSelf",
            value: function divSelf(scalar) {
                return this.x /= scalar, this.y /= scalar, this;
            }
        }, {
            key: "div",
            value: function div(scalar, out) {
                return (out = out || new Vec2()).x = this.x / scalar, out.y = this.y / scalar, out;
            }
        }, {
            key: "negSelf",
            value: function negSelf() {
                return this.x = -this.x, this.y = -this.y, this;
            }
        }, {
            key: "neg",
            value: function neg(out) {
                return (out = out || new Vec2()).x = -this.x, out.y = -this.y, out;
            }
        }, {
            key: "dot",
            value: function dot(other) {
                return this.x * other.x + this.y * other.y;
            }
        }, {
            key: "cross",
            value: function cross(other) {
                return this.x * other.y - this.y * other.x;
            }
        }, {
            key: "mag",
            value: function mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
        }, {
            key: "magSqr",
            value: function magSqr() {
                return this.x * this.x + this.y * this.y;
            }
        }, {
            key: "normalizeSelf",
            value: function normalizeSelf() {
                var magSqr = this.x * this.x + this.y * this.y;
                if (1 === magSqr) return this;
                if (0 === magSqr) return this;
                var invsqrt = 1 / Math.sqrt(magSqr);
                return this.x *= invsqrt, this.y *= invsqrt, this;
            }
        }, {
            key: "normalize",
            value: function normalize(out) {
                return (out = out || new Vec2()).x = this.x, out.y = this.y, out.normalizeSelf(), 
                out;
            }
        }, {
            key: "angle",
            value: function angle(other) {
                var magSqr1 = this.magSqr(), magSqr2 = other.magSqr();
                if (0 === magSqr1 || 0 === magSqr2) return console.warn("Can't get angle between zero vector"), 
                0;
                var theta = this.dot(other) / Math.sqrt(magSqr1 * magSqr2);
                return theta = clamp(theta, -1, 1), Math.acos(theta);
            }
        }, {
            key: "signAngle",
            value: function signAngle(other) {
                var angle = this.angle(other);
                return this.cross(other) < 0 ? -angle : angle;
            }
        }, {
            key: "rotateSelf",
            value: function rotateSelf(radians) {
                var sin = Math.sin(radians), cos = Math.cos(radians), x = this.x;
                return this.x = cos * x - sin * this.y, this.y = sin * x + cos * this.y, this;
            }
        }, {
            key: "rotate",
            value: function rotate(radians, out) {
                return (out = out || new Vec2()).x = this.x, out.y = this.y, out.rotateSelf(radians);
            }
        }, {
            key: "project",
            value: function project(other) {
                return other.mul(this.dot(other) / other.dot(other));
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(matrix, out) {
                out = out || new Vec2(), vec2.transformMat4(out, this, matrix);
            }
        } ], [ {
            key: "ONE",
            get: function get() {
                return new Vec2(1, 1);
            }
        }, {
            key: "ZERO",
            get: function get() {
                return new Vec2(0, 0);
            }
        }, {
            key: "UP",
            get: function get() {
                return new Vec2(0, 1);
            }
        }, {
            key: "RIGHT",
            get: function get() {
                return new Vec2(1, 0);
            }
        } ]), Vec2;
    }();
    CCClass.fastDefine("cc.Vec2", Vec2, {
        x: 0,
        y: 0
    }), cc.Vec2 = Vec2, cc.v2 = function v2(x, y) {
        return new Vec2(x, y);
    };
    var Vec3 = function(_ValueType) {
        function Vec3(x, y, z) {
            var _this;
            return _classCallCheck(this, Vec3), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec3).call(this))).x = void 0, 
            _this.y = void 0, _this.z = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
            _this.y = x.y, _this.z = x.z) : (_this.x = x || 0, _this.y = y || 0, _this.z = z || 0), 
            _this;
        }
        return _inherits(Vec3, ValueType), _createClass(Vec3, [ {
            key: "clone",
            value: function clone() {
                return new Vec3(this.x, this.y, this.z);
            }
        }, {
            key: "set",
            value: function set(other) {
                return this.x = other.x, this.y = other.y, this.z = other.z, this;
            }
        }, {
            key: "equals",
            value: function equals$$1(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z;
            }
        }, {
            key: "fuzzyEquals",
            value: function fuzzyEquals(other, variance) {
                return this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance && this.z - variance <= other.z && other.z <= this.z + variance;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ")");
            }
        }, {
            key: "lerp",
            value: function lerp$$1(to, ratio, out) {
                return out = out || new Vec3(), vec3.lerp(out, this, to, ratio), out;
            }
        }, {
            key: "clampf",
            value: function clampf(minInclusive, maxInclusive) {
                return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this;
            }
        }, {
            key: "addSelf",
            value: function addSelf(other) {
                return this.x += other.x, this.y += other.y, this.z += other.z, this;
            }
        }, {
            key: "add",
            value: function add(other, out) {
                return (out = out || new Vec3()).x = this.x + other.x, out.y = this.y + other.y, 
                out.z = this.z + other.z, out;
            }
        }, {
            key: "subSelf",
            value: function subSelf(other) {
                return this.x -= other.x, this.y -= other.y, this.z -= other.z, this;
            }
        }, {
            key: "sub",
            value: function sub(other, out) {
                return (out = out || new Vec3()).x = this.x - other.x, out.y = this.y - other.y, 
                out.z = this.z - other.z, out;
            }
        }, {
            key: "mulSelf",
            value: function mulSelf(scalar) {
                return this.x *= scalar, this.y *= scalar, this.z *= scalar, this;
            }
        }, {
            key: "mul",
            value: function mul(scalar, out) {
                return (out = out || new Vec3()).x = this.x * scalar, out.y = this.y * scalar, out.z = this.z * scalar, 
                out;
            }
        }, {
            key: "scaleSelf",
            value: function scaleSelf(other) {
                return this.x *= other.x, this.y *= other.y, this.z *= other.z, this;
            }
        }, {
            key: "scale",
            value: function scale(other, out) {
                return (out = out || new Vec3()).x = this.x * other.x, out.y = this.y * other.y, 
                out.z = this.z * other.z, out;
            }
        }, {
            key: "divSelf",
            value: function divSelf(scalar) {
                return this.x /= scalar, this.y /= scalar, this.z /= scalar, this;
            }
        }, {
            key: "div",
            value: function div(scalar, out) {
                return (out = out || new Vec3()).x = this.x / scalar, out.y = this.y / scalar, out.z = this.z / scalar, 
                out;
            }
        }, {
            key: "negSelf",
            value: function negSelf() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
            }
        }, {
            key: "neg",
            value: function neg(out) {
                return (out = out || new Vec3()).x = -this.x, out.y = -this.y, out.z = -this.z, 
                out;
            }
        }, {
            key: "dot",
            value: function dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
            }
        }, {
            key: "cross",
            value: function cross(other, out) {
                return out = out || new Vec3(), vec3.cross(out, this, other), out;
            }
        }, {
            key: "mag",
            value: function mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
        }, {
            key: "magSqr",
            value: function magSqr() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            }
        }, {
            key: "normalizeSelf",
            value: function normalizeSelf() {
                return vec3.normalize(this, this), this;
            }
        }, {
            key: "normalize",
            value: function normalize(out) {
                return out = out || new Vec3(), vec3.normalize(out, this), out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(matrix, out) {
                return out = out || new Vec3(), vec3.transformMat4(out, this, matrix), out;
            }
        } ]), Vec3;
    }();
    function v3(x, y, z) {
        return new Vec3(x, y, z);
    }
    CCClass.fastDefine("cc.Vec3", Vec3, {
        x: 0,
        y: 0,
        z: 0
    }), cc.Vec3 = Vec3, cc.v3 = v3;
    var Vec4 = function(_ValueType) {
        function Vec4(x, y, z, w) {
            var _this;
            return _classCallCheck(this, Vec4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec4).call(this))).x = void 0, 
            _this.y = void 0, _this.z = void 0, _this.w = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
            _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, _this.y = y || 0, 
            _this.z = z || 0, _this.w = w || 0), _this;
        }
        return _inherits(Vec4, ValueType), _createClass(Vec4, [ {
            key: "clone",
            value: function clone() {
                return new Vec4(this.x, this.y, this.z, this.w);
            }
        }, {
            key: "set",
            value: function set(other) {
                return this.x = other.x, this.y = other.y, this.z = other.z, this.w = other.w, this;
            }
        }, {
            key: "equals",
            value: function equals$$1(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
            }
        }, {
            key: "fuzzyEquals",
            value: function fuzzyEquals(other, variance) {
                return this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance && this.z - variance <= other.z && other.z <= this.z + variance && this.w - variance <= other.w && other.w <= this.w + variance;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(to, ratio, out) {
                return out = out || new Vec4(), vec4.lerp(out, this, to, ratio), out;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ", ").concat(this.w.toFixed(2), ")");
            }
        }, {
            key: "clampf",
            value: function clampf(minInclusive, maxInclusive) {
                return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this.w = clamp(this.w, minInclusive.w, maxInclusive.w), 
                this;
            }
        }, {
            key: "addSelf",
            value: function addSelf(vector) {
                return this.x += vector.x, this.y += vector.y, this.z += vector.z, this.w += vector.w, 
                this;
            }
        }, {
            key: "add",
            value: function add(vector, out) {
                return (out = out || new Vec4()).x = this.x + vector.x, out.y = this.y + vector.y, 
                out.z = this.z + vector.z, out.w = this.w + vector.w, out;
            }
        }, {
            key: "subSelf",
            value: function subSelf(vector) {
                return this.x -= vector.x, this.y -= vector.y, this.z -= vector.z, this.w -= vector.w, 
                this;
            }
        }, {
            key: "sub",
            value: function sub(vector, out) {
                return (out = out || new Vec4()).x = this.x - vector.x, out.y = this.y - vector.y, 
                out.z = this.z - vector.z, out.w = this.w - vector.w, out;
            }
        }, {
            key: "mulSelf",
            value: function mulSelf(num) {
                return this.x *= num, this.y *= num, this.z *= num, this.w *= num, this;
            }
        }, {
            key: "mul",
            value: function mul(num, out) {
                return (out = out || new Vec4()).x = this.x * num, out.y = this.y * num, out.z = this.z * num, 
                out.w = this.w * num, out;
            }
        }, {
            key: "scaleSelf",
            value: function scaleSelf(vector) {
                return this.x *= vector.x, this.y *= vector.y, this.z *= vector.z, this.w *= vector.w, 
                this;
            }
        }, {
            key: "scale",
            value: function scale(vector, out) {
                return (out = out || new Vec4()).x = this.x * vector.x, out.y = this.y * vector.y, 
                out.z = this.z * vector.z, out.w = this.w * vector.w, out;
            }
        }, {
            key: "divSelf",
            value: function divSelf(num) {
                return this.x /= num, this.y /= num, this.z /= num, this.w /= num, this;
            }
        }, {
            key: "div",
            value: function div(num, out) {
                return (out = out || new Vec4()).x = this.x / num, out.y = this.y / num, out.z = this.z / num, 
                out.w = this.w / num, out;
            }
        }, {
            key: "negSelf",
            value: function negSelf() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
            }
        }, {
            key: "neg",
            value: function neg(out) {
                return (out = out || new Vec4()).x = -this.x, out.y = -this.y, out.z = -this.z, 
                out.w = -this.w, out;
            }
        }, {
            key: "dot",
            value: function dot(vector) {
                return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
            }
        }, {
            key: "cross",
            value: function cross(vector, out) {
                return out = out || new Vec4(), vec3.cross(out, this, vector), out;
            }
        }, {
            key: "mag",
            value: function mag() {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
            }
        }, {
            key: "magSqr",
            value: function magSqr() {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                return x * x + y * y + z * z + w * w;
            }
        }, {
            key: "normalizeSelf",
            value: function normalizeSelf() {
                return vec4.normalize(this, this), this;
            }
        }, {
            key: "normalize",
            value: function normalize(out) {
                return out = out || new Vec4(), vec4.normalize(out, this), out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(m, out) {
                return out = out || new Vec4(), vec4.transformMat4(out, this, m), out;
            }
        } ]), Vec4;
    }();
    CCClass.fastDefine("cc.Vec4", Vec4, {
        x: 0,
        y: 0,
        z: 0,
        w: 0
    }), cc.Vec4 = Vec4, cc.v4 = function v4(x, y, z, w) {
        return new Vec4(x, y, z, w);
    };
    var Quat = function(_ValueType) {
        function Quat(x, y, z, w) {
            var _this;
            return _classCallCheck(this, Quat), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Quat).call(this))).x = void 0, 
            _this.y = void 0, _this.z = void 0, _this.w = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
            _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, _this.y = y || 0, 
            _this.z = z || 0, _this.w = w || 1), _this;
        }
        return _inherits(Quat, ValueType), _createClass(Quat, [ {
            key: "clone",
            value: function clone() {
                return new Quat(this.x, this.y, this.z, this.w);
            }
        }, {
            key: "set",
            value: function set(other) {
                return this.x = other.x, this.y = other.y, this.z = other.z, this.w = other.w, this;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
            }
        }, {
            key: "getEulerAngles",
            value: function getEulerAngles(out) {
                return out = out || new Vec3(), quat.toEuler(out, this);
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio, out) {
                return out = out || new Quat(), quat.slerp(out, this, to, ratio), out;
            }
        } ]), Quat;
    }();
    CCClass.fastDefine("cc.Quat", Quat, {
        x: 0,
        y: 0,
        z: 0,
        w: 1
    }), cc.quat = function quat$1() {
        var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, z = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, w = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
        return new Quat(x, y, z, w);
    }, cc.Quat = Quat;
    var Mat4 = function(_ValueType) {
        function Mat4() {
            var _this, m00 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, m01 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, m02 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m03 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, m04 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, m05 = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, m06 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, m07 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, m08 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, m09 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, m10 = 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, m11 = 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, m12 = 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, m13 = 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, m14 = 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 0, m15 = 15 < arguments.length && void 0 !== arguments[15] ? arguments[15] : 1;
            return _classCallCheck(this, Mat4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mat4).call(this))).m00 = void 0, 
            _this.m01 = void 0, _this.m02 = void 0, _this.m03 = void 0, _this.m04 = void 0, 
            _this.m05 = void 0, _this.m06 = void 0, _this.m07 = void 0, _this.m08 = void 0, 
            _this.m09 = void 0, _this.m10 = void 0, _this.m11 = void 0, _this.m12 = void 0, 
            _this.m13 = void 0, _this.m14 = void 0, _this.m15 = void 0, "object" === _typeof(m00) ? (_this.m01 = m00.m01, 
            _this.m02 = m00.m02, _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, 
            _this.m06 = m00.m06, _this.m07 = m00.m07, _this.m08 = m00.m08, _this.m09 = m00.m09, 
            _this.m10 = m00.m10, _this.m11 = m00.m11, _this.m12 = m00.m12, _this.m13 = m00.m13, 
            _this.m14 = m00.m14, _this.m15 = m00.m15, _this.m00 = m00.m00) : (_this.m01 = m01, 
            _this.m02 = m02, _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, 
            _this.m07 = m07, _this.m08 = m08, _this.m09 = m09, _this.m10 = m10, _this.m11 = m11, 
            _this.m12 = m12, _this.m13 = m13, _this.m14 = m14, _this.m15 = m15, _this.m00 = m00), 
            _this;
        }
        return _inherits(Mat4, ValueType), _createClass(Mat4, [ {
            key: "clone",
            value: function clone() {
                var t = this;
                return new Mat4(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08, t.m09, t.m10, t.m11, t.m12, t.m13, t.m14, t.m15);
            }
        }, {
            key: "set",
            value: function set(other) {
                var t = this;
                return t.m00 = other.m00, t.m01 = other.m01, t.m02 = other.m02, t.m03 = other.m03, 
                t.m04 = other.m04, t.m05 = other.m05, t.m06 = other.m06, t.m07 = other.m07, t.m08 = other.m08, 
                t.m09 = other.m09, t.m10 = other.m10, t.m11 = other.m11, t.m12 = other.m12, t.m13 = other.m13, 
                t.m14 = other.m14, t.m15 = other.m15, this;
            }
        }, {
            key: "equals",
            value: function equals$$1(other) {
                return mat4.exactEquals(this, other);
            }
        }, {
            key: "fuzzyEquals",
            value: function fuzzyEquals(other) {
                return mat4.equals(this, other);
            }
        }, {
            key: "toString",
            value: function toString() {
                var t = this;
                return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ", " + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ", " + t.m06 + ", " + t.m07 + ",\n" + t.m08 + ", " + t.m09 + ", " + t.m10 + ", " + t.m11 + ",\n" + t.m12 + ", " + t.m13 + ", " + t.m14 + ", " + t.m15 + "\n]";
            }
        }, {
            key: "identity",
            value: function identity() {
                return mat4.identity(this);
            }
        }, {
            key: "transpose",
            value: function transpose(out) {
                return out = out || new cc.Mat4(), mat4.transpose(out, this);
            }
        }, {
            key: "invert",
            value: function invert(out) {
                return out = out || new cc.Mat4(), mat4.invert(out, this);
            }
        }, {
            key: "adjoint",
            value: function adjoint(out) {
                return out = out || new cc.Mat4(), mat4.adjoint(out, this);
            }
        }, {
            key: "determinant",
            value: function determinant() {
                return mat4.determinant(this);
            }
        }, {
            key: "add",
            value: function add(other, out) {
                return out = out || new cc.Mat4(), mat4.add(out, this, other);
            }
        }, {
            key: "sub",
            value: function sub(other, out) {
                return out = out || new cc.Mat4(), mat4.subtract(out, this, other);
            }
        }, {
            key: "mul",
            value: function mul(other, out) {
                return out = out || new cc.Mat4(), mat4.multiply(out, this, other);
            }
        }, {
            key: "mulScalar",
            value: function mulScalar(scalar, out) {
                return out = out || new cc.Mat4(), mat4.scale(out, this, scalar);
            }
        }, {
            key: "translate",
            value: function translate(v, out) {
                return out = out || new cc.Mat4(), mat4.translate(out, this, v);
            }
        }, {
            key: "scale",
            value: function scale(v, out) {
                return out = out || new cc.Mat4(), mat4.scale(out, this, v);
            }
        }, {
            key: "rotate",
            value: function rotate(rad, axis, out) {
                return out = out || new cc.Mat4(), mat4.rotate(out, this, rad, axis);
            }
        }, {
            key: "getTranslation",
            value: function getTranslation(out) {
                return out = out || new cc.Vec3(), mat4.getTranslation(out, this);
            }
        }, {
            key: "getScale",
            value: function getScale(out) {
                return out = out || new cc.Vec3(), mat4.getScaling(out, this);
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {
                return out = out || new Quat(), mat4.getRotation(out, this);
            }
        }, {
            key: "fromRTS",
            value: function fromRTS(q, v, s) {
                return mat4.fromRTS(this, q, v, s);
            }
        }, {
            key: "fromQuat",
            value: function fromQuat(quat$$1) {
                return mat4.fromQuat(this, quat$$1);
            }
        } ]), Mat4;
    }();
    CCClass.fastDefine("cc.Mat4", Mat4, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 0,
        m05: 1,
        m06: 0,
        m07: 0,
        m08: 0,
        m09: 0,
        m10: 1,
        m11: 0,
        m12: 0,
        m13: 0,
        m14: 0,
        m15: 1
    }), cc.Mat4 = Mat4, cc.mat4 = function mat4$1() {
        var m00 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, m01 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, m02 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, m03 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, m10 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, m11 = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, m12 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, m13 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, m20 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, m21 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, m22 = 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, m23 = 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, m30 = 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, m31 = 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, m32 = 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 0, m33 = 15 < arguments.length && void 0 !== arguments[15] ? arguments[15] : 1;
        return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    };
    var AffineTransform = function() {
        function AffineTransform() {
            var a = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, tx = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, ty = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
            _classCallCheck(this, AffineTransform), this.a = void 0, this.b = void 0, this.c = void 0, 
            this.d = void 0, this.tx = void 0, this.ty = void 0, this.a = a, this.b = b, this.c = c, 
            this.d = d, this.tx = tx, this.ty = ty;
        }
        return _createClass(AffineTransform, null, [ {
            key: "create",
            value: function create(a, b, c, d, tx, ty) {
                return new AffineTransform(a, b, c, d, tx, ty);
            }
        }, {
            key: "identity",
            value: function identity() {
                return new AffineTransform();
            }
        }, {
            key: "clone",
            value: function clone(affineTransform) {
                return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
            }
        }, {
            key: "concat",
            value: function concat(out, t1, t2) {
                var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
                return out.a = a * t2.a + b * t2.c, out.b = a * t2.b + b * t2.d, out.c = c * t2.a + d * t2.c, 
                out.d = c * t2.b + d * t2.d, out.tx = tx * t2.a + ty * t2.c + t2.tx, out.ty = tx * t2.b + ty * t2.d + t2.ty, 
                out;
            }
        }, {
            key: "invert",
            value: function invert(out, t) {
                var a = t.a, b = t.b, c = t.c, d = t.d, determinant = 1 / (a * d - b * c), tx = t.tx, ty = t.ty;
                return out.a = determinant * d, out.b = -determinant * b, out.c = -determinant * c, 
                out.d = determinant * a, out.tx = determinant * (c * ty - d * tx), out.ty = determinant * (b * tx - a * ty), 
                out;
            }
        }, {
            key: "fromMat4",
            value: function fromMat4(out, mat) {
                return out.a = mat.m00, out.b = mat.m01, out.c = mat.m04, out.d = mat.m05, out.tx = mat.m12, 
                out.ty = mat.m13, out;
            }
        }, {
            key: "transformVec2",
            value: function transformVec2(out, point, transOrY, t) {
                var x, y;
                return y = void 0 === t ? (t = transOrY, x = point.x, point.y) : (x = point, transOrY), 
                out.x = t.a * x + t.c * y + t.tx, out.y = t.b * x + t.d * y + t.ty, out;
            }
        }, {
            key: "transformSize",
            value: function transformSize(out, size, t) {
                return out.width = t.a * size.width + t.c * size.height, out.height = t.b * size.width + t.d * size.height, 
                out;
            }
        }, {
            key: "transformRect",
            value: function transformRect(out, rect, t) {
                var ol = rect.x, ob = rect.y, or = ol + rect.width, ot = ob + rect.height, lbx = t.a * ol + t.c * ob + t.tx, lby = t.b * ol + t.d * ob + t.ty, rbx = t.a * or + t.c * ob + t.tx, rby = t.b * or + t.d * ob + t.ty, ltx = t.a * ol + t.c * ot + t.tx, lty = t.b * ol + t.d * ot + t.ty, rtx = t.a * or + t.c * ot + t.tx, rty = t.b * or + t.d * ot + t.ty, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
                return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, 
                out;
            }
        }, {
            key: "transformObb",
            value: function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
                var x = rect.x, y = rect.y, width = rect.width, height = rect.height, tx = anAffineTransform.a * x + anAffineTransform.c * y + anAffineTransform.tx, ty = anAffineTransform.b * x + anAffineTransform.d * y + anAffineTransform.ty, xa = anAffineTransform.a * width, xb = anAffineTransform.b * width, yc = anAffineTransform.c * height, yd = anAffineTransform.d * height;
                out_tl.x = tx, out_tl.y = ty, out_tr.x = xa + tx, out_tr.y = xb + ty, out_bl.x = yc + tx, 
                out_bl.y = yd + ty, out_br.x = xa + yc + tx, out_br.y = xb + yd + ty;
            }
        } ]), AffineTransform;
    }();
    cc.AffineTransform = AffineTransform;
    var Size = function(_ValueType) {
        function Size(width, height) {
            var _this;
            return _classCallCheck(this, Size), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Size).call(this))).width = void 0, 
            _this.height = void 0, width && "object" === _typeof(width) ? (_this.height = width.height, 
            _this.width = width.width) : (_this.width = width || 0, _this.height = height || 0), 
            _this;
        }
        return _inherits(Size, ValueType), _createClass(Size, [ {
            key: "clone",
            value: function clone() {
                return new Size(this.width, this.height);
            }
        }, {
            key: "set",
            value: function set(other) {
                this.width = other.width, this.height = other.height;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return this.width === other.width && this.height === other.height;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio, out) {
                out = out || new Size();
                var width = this.width, height = this.height;
                return out.width = width + (to.width - width) * ratio, out.height = height + (to.height - height) * ratio, 
                out;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
            }
        } ], [ {
            key: "ZERO",
            get: function get() {
                return new Size(0, 0);
            }
        } ]), Size;
    }();
    CCClass.fastDefine("cc.Size", Size, {
        width: 0,
        height: 0
    }), cc.size = function size() {
        var width = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, height = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
        return new Size(width, height);
    }, cc.Size = Size;
    var Rect = function(_ValueType) {
        function Rect(x, y, width, height) {
            var _this;
            return _classCallCheck(this, Rect), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this))).x = void 0, 
            _this.y = void 0, _this.width = void 0, _this.height = void 0, x && "object" === _typeof(x) ? (_this.y = x.y, 
            _this.width = x.width, _this.height = x.height, _this.x = x.x) : (_this.x = x || 0, 
            _this.y = y || 0, _this.width = width || 0, _this.height = height || 0), _this;
        }
        return _inherits(Rect, ValueType), _createClass(Rect, [ {
            key: "xMin",
            get: function get() {
                return this.x;
            },
            set: function set(value) {
                this.width += this.x - value, this.x = value;
            }
        }, {
            key: "yMin",
            get: function get() {
                return this.y;
            },
            set: function set(value) {
                this.height += this.y - value, this.y = value;
            }
        }, {
            key: "xMax",
            get: function get() {
                return this.x + this.width;
            },
            set: function set(value) {
                this.width = value - this.x;
            }
        }, {
            key: "yMax",
            get: function get() {
                return this.y + this.height;
            },
            set: function set(value) {
                this.height = value - this.y;
            }
        }, {
            key: "center",
            get: function get() {
                return new Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
            },
            set: function set(value) {
                this.x = value.x - .5 * this.width, this.y = value.y - .5 * this.height;
            }
        }, {
            key: "origin",
            get: function get() {
                return new cc.Vec2(this.x, this.y);
            },
            set: function set(value) {
                this.x = value.x, this.y = value.y;
            }
        }, {
            key: "size",
            get: function get() {
                return new Size(this.width, this.height);
            },
            set: function set(value) {
                this.width = value.width, this.height = value.height;
            }
        } ], [ {
            key: "fromMinMax",
            value: function fromMinMax(v1, v2$$1) {
                var minX = Math.min(v1.x, v2$$1.x), minY = Math.min(v1.y, v2$$1.y);
                return new Rect(minX, minY, Math.max(v1.x, v2$$1.x) - minX, Math.max(v1.y, v2$$1.y) - minY);
            }
        } ]), _createClass(Rect, [ {
            key: "clone",
            value: function clone() {
                return new Rect(this.x, this.y, this.width, this.height);
            }
        }, {
            key: "set",
            value: function set(other) {
                this.x = other.x, this.y = other.y, this.width = other.width, this.height = other.height;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio, out) {
                out = out || new Rect();
                var x = this.x, y = this.y, width = this.width, height = this.height;
                return out.x = x + (to.x - x) * ratio, out.y = y + (to.y - y) * ratio, out.width = width + (to.width - width) * ratio, 
                out.height = height + (to.height - height) * ratio, out;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
            }
        }, {
            key: "intersects",
            value: function intersects(other) {
                var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = other.x + other.width, maxby = other.y + other.height;
                return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
            }
        }, {
            key: "intersection",
            value: function intersection(out, other) {
                var axMin = this.x, ayMin = this.y, axMax = this.x + this.width, ayMax = this.y + this.height, bxMin = other.x, byMin = other.y, bxMax = other.x + other.width, byMax = other.y + other.height;
                return out.x = Math.max(axMin, bxMin), out.y = Math.max(ayMin, byMin), out.width = Math.min(axMax, bxMax) - out.x, 
                out.height = Math.min(ayMax, byMax) - out.y, out;
            }
        }, {
            key: "contains",
            value: function contains(point) {
                return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
            }
        }, {
            key: "containsRect",
            value: function containsRect(other) {
                return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
            }
        }, {
            key: "union",
            value: function union(out, other) {
                var ax = this.x, ay = this.y, aw = this.width, ah = this.height, bx = other.x, by = other.y, bw = other.width, bh = other.height;
                return out.x = Math.min(ax, bx), out.y = Math.min(ay, by), out.width = Math.max(ax + aw, bx + bw) - out.x, 
                out.height = Math.max(ay + ah, by + bh) - out.y, out;
            }
        }, {
            key: "transformMat4",
            value: function transformMat4(out, mat) {
                var ol = this.x, ob = this.y, or = ol + this.width, ot = ob + this.height, lbx = mat.m00 * ol + mat.m04 * ob + mat.m12, lby = mat.m01 * ol + mat.m05 * ob + mat.m13, rbx = mat.m00 * or + mat.m04 * ob + mat.m12, rby = mat.m01 * or + mat.m05 * ob + mat.m13, ltx = mat.m00 * ol + mat.m04 * ot + mat.m12, lty = mat.m01 * ol + mat.m05 * ot + mat.m13, rtx = mat.m00 * or + mat.m04 * ot + mat.m12, rty = mat.m01 * or + mat.m05 * ot + mat.m13, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
                return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, 
                out;
            }
        } ]), Rect;
    }();
    function rect() {
        var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, width = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, height = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
        return new Rect(x, y, width, height);
    }
    CCClass.fastDefine("cc.Rect", Rect, {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }), cc.Rect = Rect, cc.rect = rect;
    var Color = function(_ValueType) {
        function Color(r, g, b, a) {
            var _this;
            return _classCallCheck(this, Color), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Color).call(this)))._val = void 0, 
            "object" === _typeof(r) && (g = r.g, b = r.b, a = r.a, r = r.r), r = r || 0, g = g || 0, 
            b = b || 0, a = "number" == typeof a ? a : 255, _this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r, 
            _this;
        }
        return _inherits(Color, ValueType), _createClass(Color, [ {
            key: "clone",
            value: function clone() {
                var ret = new Color();
                return ret._val = this._val, ret;
            }
        }, {
            key: "equals",
            value: function equals(other) {
                return other && this._val === other._val;
            }
        }, {
            key: "lerp",
            value: function lerp(to, ratio, out) {
                out = out || new Color();
                var r = this.r, g = this.g, b = this.b, a = this.a;
                return out.r = r + (to.r - r) * ratio, out.g = g + (to.g - g) * ratio, out.b = b + (to.b - b) * ratio, 
                out.a = a + (to.a - a) * ratio, out;
            }
        }, {
            key: "toString",
            value: function toString() {
                return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
            }
        }, {
            key: "toCSS",
            value: function toCSS(opt) {
                return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a * (1 / 255)).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
            }
        }, {
            key: "fromHEX",
            value: function fromHEX(hexString) {
                hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString;
                var r = parseInt(hexString.substr(0, 2), 16) || 0, g = parseInt(hexString.substr(2, 2), 16) || 0, b = parseInt(hexString.substr(4, 2), 16) || 0, a = parseInt(hexString.substr(6, 2), 16) || 255;
                return this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r, this;
            }
        }, {
            key: "toHEX",
            value: function toHEX(fmt) {
                var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ], i = -1;
                if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]); else if ("#rrggbbaa" === fmt) for (hex.push((0 | this.a).toString(16)), 
                i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
                return hex.join("");
            }
        }, {
            key: "toRGBValue",
            value: function toRGBValue() {
                return 16777215 & this._val;
            }
        }, {
            key: "fromHSV",
            value: function fromHSV(h, s, v) {
                var r = 0, g = 0, b = 0;
                if (0 === s) r = g = b = v; else if (0 === v) r = g = b = 0; else {
                    1 === h && (h = 0), h *= 6, s = s, v = v;
                    var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - s * f), t = v * (1 - s * (1 - f));
                    switch (i) {
                      case 0:
                        r = v, g = t, b = p;
                        break;

                      case 1:
                        r = q, g = v, b = p;
                        break;

                      case 2:
                        r = p, g = v, b = t;
                        break;

                      case 3:
                        r = p, g = q, b = v;
                        break;

                      case 4:
                        r = t, g = p, b = v;
                        break;

                      case 5:
                        r = v, g = p, b = q;
                    }
                }
                return r *= 255, g *= 255, b *= 255, this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + r, 
                this;
            }
        }, {
            key: "toHSV",
            value: function toHSV() {
                var r = this.r * (1 / 255), g = this.g * (1 / 255), b = this.b * (1 / 255), hsv = {
                    h: 0,
                    s: 0,
                    v: 0
                }, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = 0;
                return hsv.v = max, hsv.s = max ? (max - min) / max : 0, hsv.s ? (delta = max - min, 
                hsv.h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta, 
                hsv.h /= 6, hsv.h < 0 && (hsv.h += 1)) : hsv.h = 0, hsv;
            }
        }, {
            key: "set",
            value: function set(other) {
                other._val ? this._val = other._val : this._val = (other.a << 24 >>> 0) + (other.b << 16) + (other.g << 8) + other.r;
            }
        }, {
            key: "mulSelf",
            value: function mulSelf(other) {
                var r = (255 & this._val) * other.r >> 8, g = (65280 & this._val) * other.g >> 8, b = (16711680 & this._val) * other.b >> 8, a = ((4278190080 & this._val) >>> 8) * other.a;
                return this._val = 4278190080 & a | 16711680 & b | 65280 & g | 255 & r, this;
            }
        }, {
            key: "mul",
            value: function mul(other, out) {
                out = out || new Color();
                var r = (255 & this._val) * other.r >> 8, g = (65280 & this._val) * other.g >> 8, b = (16711680 & this._val) * other.b >> 8, a = ((4278190080 & this._val) >>> 8) * other.a;
                return out._val = 4278190080 & a | 16711680 & b | 65280 & g | 255 & r, out;
            }
        }, {
            key: "r",
            get: function get() {
                return 255 & this._val;
            },
            set: function set(red) {
                red = ~~cc.misc.clampf(red, 0, 255), this._val = (4294967040 & this._val | red) >>> 0;
            }
        }, {
            key: "g",
            get: function get() {
                return (65280 & this._val) >> 8;
            },
            set: function set(green) {
                green = ~~cc.misc.clampf(green, 0, 255), this._val = (4294902015 & this._val | green << 8) >>> 0;
            }
        }, {
            key: "b",
            get: function get() {
                return (16711680 & this._val) >> 16;
            },
            set: function set(blue) {
                blue = ~~cc.misc.clampf(blue, 0, 255), this._val = (4278255615 & this._val | blue << 16) >>> 0;
            }
        }, {
            key: "a",
            get: function get() {
                return (4278190080 & this._val) >>> 24;
            },
            set: function set(alpha) {
                alpha = ~~cc.misc.clampf(alpha, 0, 255), this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0;
            }
        }, {
            key: "x",
            get: function get() {
                return this.r * (1 / 255);
            },
            set: function set(value) {
                this.r = 255 * value;
            }
        }, {
            key: "y",
            get: function get() {
                return this.g * (1 / 255);
            },
            set: function set(value) {
                this.g = 255 * value;
            }
        }, {
            key: "z",
            get: function get() {
                return this.b * (1 / 255);
            },
            set: function set(value) {
                this.b = 255 * value;
            }
        }, {
            key: "w",
            get: function get() {
                return this.a * (1 / 255);
            },
            set: function set(value) {
                this.a = 255 * value;
            }
        } ], [ {
            key: "WHITE",
            get: function get() {
                return new Color(255, 255, 255, 255);
            }
        }, {
            key: "BLACK",
            get: function get() {
                return new Color(0, 0, 0, 255);
            }
        }, {
            key: "TRANSPARENT",
            get: function get() {
                return new Color(0, 0, 0, 0);
            }
        }, {
            key: "GRAY",
            get: function get() {
                return new Color(127.5, 127.5, 127.5, 255);
            }
        }, {
            key: "RED",
            get: function get() {
                return new Color(255, 0, 0, 255);
            }
        }, {
            key: "GREEN",
            get: function get() {
                return new Color(0, 255, 0, 255);
            }
        }, {
            key: "BLUE",
            get: function get() {
                return new Color(0, 0, 255, 255);
            }
        }, {
            key: "YELLOW",
            get: function get() {
                return new Color(255, 235, 4, 255);
            }
        }, {
            key: "ORANGE",
            get: function get() {
                return new Color(255, 127, 0, 255);
            }
        }, {
            key: "CYAN",
            get: function get() {
                return new Color(0, 255, 255, 255);
            }
        }, {
            key: "MAGENTA",
            get: function get() {
                return new Color(255, 0, 255, 255);
            }
        } ]), Color;
    }();
    CCClass.fastDefine("cc.Color", Color, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    }), cc.color = function color(r, g, b, a) {
        return "string" != typeof r ? "object" === _typeof(r) ? new Color(r.r, r.g, r.b, r.a) : new Color(r, g, b, a) : new Color().fromHEX(r);
    }, cc.Color = Color;
    var GFXObjectType, GFXStatus;
    !function(GFXObjectType) {
        GFXObjectType[GFXObjectType.UNKNOWN = 0] = "UNKNOWN", GFXObjectType[GFXObjectType.BUFFER = 1] = "BUFFER", 
        GFXObjectType[GFXObjectType.TEXTURE = 2] = "TEXTURE", GFXObjectType[GFXObjectType.TEXTURE_VIEW = 3] = "TEXTURE_VIEW", 
        GFXObjectType[GFXObjectType.RENDER_PASS = 4] = "RENDER_PASS", GFXObjectType[GFXObjectType.FRAMEBUFFER = 5] = "FRAMEBUFFER", 
        GFXObjectType[GFXObjectType.SAMPLER = 6] = "SAMPLER", GFXObjectType[GFXObjectType.SHADER = 7] = "SHADER", 
        GFXObjectType[GFXObjectType.PIPELINE_LAYOUT = 8] = "PIPELINE_LAYOUT", GFXObjectType[GFXObjectType.PIPELINE_STATE = 9] = "PIPELINE_STATE", 
        GFXObjectType[GFXObjectType.BINDING_LAYOUT = 10] = "BINDING_LAYOUT", GFXObjectType[GFXObjectType.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", 
        GFXObjectType[GFXObjectType.COMMAND_ALLOCATOR = 12] = "COMMAND_ALLOCATOR", GFXObjectType[GFXObjectType.COMMAND_BUFFER = 13] = "COMMAND_BUFFER", 
        GFXObjectType[GFXObjectType.QUEUE = 14] = "QUEUE", GFXObjectType[GFXObjectType.WINDOW = 15] = "WINDOW";
    }(GFXObjectType || (GFXObjectType = {})), function(GFXStatus) {
        GFXStatus[GFXStatus.UNREADY = 0] = "UNREADY", GFXStatus[GFXStatus.FAILED = 1] = "FAILED", 
        GFXStatus[GFXStatus.SUCCESS = 2] = "SUCCESS";
    }(GFXStatus || (GFXStatus = {}));
    var GFXAttributeName, GFXType, GFXFormat, GFXBufferUsageBit, GFXMemoryUsageBit, GFXBufferAccessBit, GFXPrimitiveMode, GFXPolygonMode, GFXShadeModel, GFXCullMode, GFXComparisonFunc, GFXStencilOp, GFXBlendOp, GFXBlendFactor, GFXColorMask, GFXFilter, GFXAddress, GFXTextureType, GFXTextureUsageBit, GFXSampleCount, GFXTextureFlagBit, GFXTextureViewType, GFXShaderType, GFXBindingType, GFXCommandBufferType, GFXLoadOp, GFXStoreOp, GFXTextureLayout, GFXPipelineBindPoint, GFXDynamicState, GFXStencilFace, GFXQueueType, GFXClearFlag, GFXObject = function() {
        function GFXObject(gfxType) {
            _classCallCheck(this, GFXObject), this._gfxType = GFXObjectType.UNKNOWN, this._status = GFXStatus.UNREADY, 
            this._gfxType = gfxType;
        }
        return _createClass(GFXObject, [ {
            key: "gfxType",
            get: function get() {
                return this._gfxType;
            }
        }, {
            key: "status",
            get: function get() {
                return this._status;
            }
        } ]), GFXObject;
    }();
    (GFXAttributeName = exports.GFXAttributeName || (exports.GFXAttributeName = {})).ATTR_POSITION = "a_position", 
    GFXAttributeName.ATTR_NORMAL = "a_normal", GFXAttributeName.ATTR_TANGENT = "a_tangent", 
    GFXAttributeName.ATTR_BITANGENT = "a_bitangent", GFXAttributeName.ATTR_WEIGHTS = "a_weights", 
    GFXAttributeName.ATTR_JOINTS = "a_joints", GFXAttributeName.ATTR_COLOR = "a_color", 
    GFXAttributeName.ATTR_COLOR1 = "a_color1", GFXAttributeName.ATTR_COLOR2 = "a_color2", 
    GFXAttributeName.ATTR_TEX_COORD = "a_texCoord", GFXAttributeName.ATTR_TEX_COORD1 = "a_texCoord1", 
    GFXAttributeName.ATTR_TEX_COORD2 = "a_texCoord2", GFXAttributeName.ATTR_TEX_COORD3 = "a_texCoord3", 
    GFXAttributeName.ATTR_TEX_COORD4 = "a_texCoord4", GFXAttributeName.ATTR_TEX_COORD5 = "a_texCoord5", 
    GFXAttributeName.ATTR_TEX_COORD6 = "a_texCoord6", GFXAttributeName.ATTR_TEX_COORD7 = "a_texCoord7", 
    GFXAttributeName.ATTR_TEX_COORD8 = "a_texCoord8", GFXAttributeName.ATTR_BATCH_ID = "a_batch_id", 
    GFXAttributeName.ATTR_BATCH_UV = "a_batch_uv", function(GFXType) {
        GFXType[GFXType.UNKNOWN = 0] = "UNKNOWN", GFXType[GFXType.BOOL = 1] = "BOOL", GFXType[GFXType.BOOL2 = 2] = "BOOL2", 
        GFXType[GFXType.BOOL3 = 3] = "BOOL3", GFXType[GFXType.BOOL4 = 4] = "BOOL4", GFXType[GFXType.INT = 5] = "INT", 
        GFXType[GFXType.INT2 = 6] = "INT2", GFXType[GFXType.INT3 = 7] = "INT3", GFXType[GFXType.INT4 = 8] = "INT4", 
        GFXType[GFXType.UINT = 9] = "UINT", GFXType[GFXType.UINT2 = 10] = "UINT2", GFXType[GFXType.UINT3 = 11] = "UINT3", 
        GFXType[GFXType.UINT4 = 12] = "UINT4", GFXType[GFXType.FLOAT = 13] = "FLOAT", GFXType[GFXType.FLOAT2 = 14] = "FLOAT2", 
        GFXType[GFXType.FLOAT3 = 15] = "FLOAT3", GFXType[GFXType.FLOAT4 = 16] = "FLOAT4", 
        GFXType[GFXType.MAT2 = 17] = "MAT2", GFXType[GFXType.MAT2X3 = 18] = "MAT2X3", GFXType[GFXType.MAT2X4 = 19] = "MAT2X4", 
        GFXType[GFXType.MAT3X2 = 20] = "MAT3X2", GFXType[GFXType.MAT3 = 21] = "MAT3", GFXType[GFXType.MAT3X4 = 22] = "MAT3X4", 
        GFXType[GFXType.MAT4X2 = 23] = "MAT4X2", GFXType[GFXType.MAT4X3 = 24] = "MAT4X3", 
        GFXType[GFXType.MAT4 = 25] = "MAT4", GFXType[GFXType.SAMPLER1D = 26] = "SAMPLER1D", 
        GFXType[GFXType.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", GFXType[GFXType.SAMPLER2D = 28] = "SAMPLER2D", 
        GFXType[GFXType.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", GFXType[GFXType.SAMPLER3D = 30] = "SAMPLER3D", 
        GFXType[GFXType.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", GFXType[GFXType.COUNT = 32] = "COUNT";
    }(GFXType || (GFXType = {})), (GFXFormat = exports.GFXFormat || (exports.GFXFormat = {}))[GFXFormat.UNKNOWN = 0] = "UNKNOWN", 
    GFXFormat[GFXFormat.A8 = 1] = "A8", GFXFormat[GFXFormat.L8 = 2] = "L8", GFXFormat[GFXFormat.LA8 = 3] = "LA8", 
    GFXFormat[GFXFormat.R8 = 4] = "R8", GFXFormat[GFXFormat.R8SN = 5] = "R8SN", GFXFormat[GFXFormat.R8UI = 6] = "R8UI", 
    GFXFormat[GFXFormat.R8I = 7] = "R8I", GFXFormat[GFXFormat.R16F = 8] = "R16F", GFXFormat[GFXFormat.R16UI = 9] = "R16UI", 
    GFXFormat[GFXFormat.R16I = 10] = "R16I", GFXFormat[GFXFormat.R32F = 11] = "R32F", 
    GFXFormat[GFXFormat.R32UI = 12] = "R32UI", GFXFormat[GFXFormat.R32I = 13] = "R32I", 
    GFXFormat[GFXFormat.RG8 = 14] = "RG8", GFXFormat[GFXFormat.RG8SN = 15] = "RG8SN", 
    GFXFormat[GFXFormat.RG8UI = 16] = "RG8UI", GFXFormat[GFXFormat.RG8I = 17] = "RG8I", 
    GFXFormat[GFXFormat.RG16F = 18] = "RG16F", GFXFormat[GFXFormat.RG16UI = 19] = "RG16UI", 
    GFXFormat[GFXFormat.RG16I = 20] = "RG16I", GFXFormat[GFXFormat.RG32F = 21] = "RG32F", 
    GFXFormat[GFXFormat.RG32UI = 22] = "RG32UI", GFXFormat[GFXFormat.RG32I = 23] = "RG32I", 
    GFXFormat[GFXFormat.RGB8 = 24] = "RGB8", GFXFormat[GFXFormat.SRGB8 = 25] = "SRGB8", 
    GFXFormat[GFXFormat.RGB8SN = 26] = "RGB8SN", GFXFormat[GFXFormat.RGB8UI = 27] = "RGB8UI", 
    GFXFormat[GFXFormat.RGB8I = 28] = "RGB8I", GFXFormat[GFXFormat.RGB16F = 29] = "RGB16F", 
    GFXFormat[GFXFormat.RGB16UI = 30] = "RGB16UI", GFXFormat[GFXFormat.RGB16I = 31] = "RGB16I", 
    GFXFormat[GFXFormat.RGB32F = 32] = "RGB32F", GFXFormat[GFXFormat.RGB32UI = 33] = "RGB32UI", 
    GFXFormat[GFXFormat.RGB32I = 34] = "RGB32I", GFXFormat[GFXFormat.RGBA8 = 35] = "RGBA8", 
    GFXFormat[GFXFormat.SRGB8_A8 = 36] = "SRGB8_A8", GFXFormat[GFXFormat.RGBA8SN = 37] = "RGBA8SN", 
    GFXFormat[GFXFormat.RGBA8UI = 38] = "RGBA8UI", GFXFormat[GFXFormat.RGBA8I = 39] = "RGBA8I", 
    GFXFormat[GFXFormat.RGBA16F = 40] = "RGBA16F", GFXFormat[GFXFormat.RGBA16UI = 41] = "RGBA16UI", 
    GFXFormat[GFXFormat.RGBA16I = 42] = "RGBA16I", GFXFormat[GFXFormat.RGBA32F = 43] = "RGBA32F", 
    GFXFormat[GFXFormat.RGBA32UI = 44] = "RGBA32UI", GFXFormat[GFXFormat.RGBA32I = 45] = "RGBA32I", 
    GFXFormat[GFXFormat.R5G6B5 = 46] = "R5G6B5", GFXFormat[GFXFormat.R11G11B10F = 47] = "R11G11B10F", 
    GFXFormat[GFXFormat.RGB5A1 = 48] = "RGB5A1", GFXFormat[GFXFormat.RGBA4 = 49] = "RGBA4", 
    GFXFormat[GFXFormat.RGB10A2 = 50] = "RGB10A2", GFXFormat[GFXFormat.RGB10A2UI = 51] = "RGB10A2UI", 
    GFXFormat[GFXFormat.RGB9E5 = 52] = "RGB9E5", GFXFormat[GFXFormat.D16 = 53] = "D16", 
    GFXFormat[GFXFormat.D16S8 = 54] = "D16S8", GFXFormat[GFXFormat.D24 = 55] = "D24", 
    GFXFormat[GFXFormat.D24S8 = 56] = "D24S8", GFXFormat[GFXFormat.D32F = 57] = "D32F", 
    GFXFormat[GFXFormat.D32F_S8 = 58] = "D32F_S8", GFXFormat[GFXFormat.BC1 = 59] = "BC1", 
    GFXFormat[GFXFormat.BC1_ALPHA = 60] = "BC1_ALPHA", GFXFormat[GFXFormat.BC1_SRGB = 61] = "BC1_SRGB", 
    GFXFormat[GFXFormat.BC1_SRGB_ALPHA = 62] = "BC1_SRGB_ALPHA", GFXFormat[GFXFormat.BC2 = 63] = "BC2", 
    GFXFormat[GFXFormat.BC2_SRGB = 64] = "BC2_SRGB", GFXFormat[GFXFormat.BC3 = 65] = "BC3", 
    GFXFormat[GFXFormat.BC3_SRGB = 66] = "BC3_SRGB", GFXFormat[GFXFormat.BC4 = 67] = "BC4", 
    GFXFormat[GFXFormat.BC4_SNORM = 68] = "BC4_SNORM", GFXFormat[GFXFormat.BC5 = 69] = "BC5", 
    GFXFormat[GFXFormat.BC5_SNORM = 70] = "BC5_SNORM", GFXFormat[GFXFormat.BC6H_UF16 = 71] = "BC6H_UF16", 
    GFXFormat[GFXFormat.BC6H_SF16 = 72] = "BC6H_SF16", GFXFormat[GFXFormat.BC7 = 73] = "BC7", 
    GFXFormat[GFXFormat.BC7_SRGB = 74] = "BC7_SRGB", GFXFormat[GFXFormat.ETC_RGB8 = 75] = "ETC_RGB8", 
    GFXFormat[GFXFormat.ETC2_RGB8 = 76] = "ETC2_RGB8", GFXFormat[GFXFormat.ETC2_SRGB8 = 77] = "ETC2_SRGB8", 
    GFXFormat[GFXFormat.ETC2_RGB8_A1 = 78] = "ETC2_RGB8_A1", GFXFormat[GFXFormat.ETC2_SRGB8_A1 = 79] = "ETC2_SRGB8_A1", 
    GFXFormat[GFXFormat.ETC2_RGBA8 = 80] = "ETC2_RGBA8", GFXFormat[GFXFormat.ETC2_SRGB8_A8 = 81] = "ETC2_SRGB8_A8", 
    GFXFormat[GFXFormat.EAC_R11 = 82] = "EAC_R11", GFXFormat[GFXFormat.EAC_R11SN = 83] = "EAC_R11SN", 
    GFXFormat[GFXFormat.EAC_RG11 = 84] = "EAC_RG11", GFXFormat[GFXFormat.EAC_RG11SN = 85] = "EAC_RG11SN", 
    GFXFormat[GFXFormat.PVRTC_RGB2 = 86] = "PVRTC_RGB2", GFXFormat[GFXFormat.PVRTC_RGBA2 = 87] = "PVRTC_RGBA2", 
    GFXFormat[GFXFormat.PVRTC_RGB4 = 88] = "PVRTC_RGB4", GFXFormat[GFXFormat.PVRTC_RGBA4 = 89] = "PVRTC_RGBA4", 
    GFXFormat[GFXFormat.PVRTC2_2BPP = 90] = "PVRTC2_2BPP", GFXFormat[GFXFormat.PVRTC2_4BPP = 91] = "PVRTC2_4BPP", 
    function(GFXBufferUsageBit) {
        GFXBufferUsageBit[GFXBufferUsageBit.NONE = 0] = "NONE", GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", 
        GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", GFXBufferUsageBit[GFXBufferUsageBit.INDEX = 4] = "INDEX", 
        GFXBufferUsageBit[GFXBufferUsageBit.VERTEX = 8] = "VERTEX", GFXBufferUsageBit[GFXBufferUsageBit.UNIFORM = 16] = "UNIFORM", 
        GFXBufferUsageBit[GFXBufferUsageBit.STORAGE = 32] = "STORAGE", GFXBufferUsageBit[GFXBufferUsageBit.INDIRECT = 64] = "INDIRECT";
    }(GFXBufferUsageBit || (GFXBufferUsageBit = {})), function(GFXMemoryUsageBit) {
        GFXMemoryUsageBit[GFXMemoryUsageBit.NONE = 0] = "NONE", GFXMemoryUsageBit[GFXMemoryUsageBit.DEVICE = 1] = "DEVICE", 
        GFXMemoryUsageBit[GFXMemoryUsageBit.HOST = 2] = "HOST";
    }(GFXMemoryUsageBit || (GFXMemoryUsageBit = {})), function(GFXBufferAccessBit) {
        GFXBufferAccessBit[GFXBufferAccessBit.NONE = 0] = "NONE", GFXBufferAccessBit[GFXBufferAccessBit.READ = 1] = "READ", 
        GFXBufferAccessBit[GFXBufferAccessBit.WRITE = 2] = "WRITE";
    }(GFXBufferAccessBit || (GFXBufferAccessBit = {})), (GFXPrimitiveMode = exports.GFXPrimitiveMode || (exports.GFXPrimitiveMode = {}))[GFXPrimitiveMode.POINT_LIST = 0] = "POINT_LIST", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST = 1] = "LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP = 2] = "LINE_STRIP", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_LOOP = 3] = "LINE_LOOP", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST", function(GFXPolygonMode) {
        GFXPolygonMode[GFXPolygonMode.FILL = 0] = "FILL", GFXPolygonMode[GFXPolygonMode.POINT = 1] = "POINT", 
        GFXPolygonMode[GFXPolygonMode.LINE = 2] = "LINE";
    }(GFXPolygonMode || (GFXPolygonMode = {})), function(GFXShadeModel) {
        GFXShadeModel[GFXShadeModel.GOURAND = 0] = "GOURAND", GFXShadeModel[GFXShadeModel.FLAT = 1] = "FLAT";
    }(GFXShadeModel || (GFXShadeModel = {})), function(GFXCullMode) {
        GFXCullMode[GFXCullMode.NONE = 0] = "NONE", GFXCullMode[GFXCullMode.FRONT = 1] = "FRONT", 
        GFXCullMode[GFXCullMode.BACK = 2] = "BACK";
    }(GFXCullMode || (GFXCullMode = {})), function(GFXComparisonFunc) {
        GFXComparisonFunc[GFXComparisonFunc.NEVER = 0] = "NEVER", GFXComparisonFunc[GFXComparisonFunc.LESS = 1] = "LESS", 
        GFXComparisonFunc[GFXComparisonFunc.EQUAL = 2] = "EQUAL", GFXComparisonFunc[GFXComparisonFunc.LESS_EQUAL = 3] = "LESS_EQUAL", 
        GFXComparisonFunc[GFXComparisonFunc.GREATER = 4] = "GREATER", GFXComparisonFunc[GFXComparisonFunc.NOT_EQUAL = 5] = "NOT_EQUAL", 
        GFXComparisonFunc[GFXComparisonFunc.GREATER_EQUAL = 6] = "GREATER_EQUAL", GFXComparisonFunc[GFXComparisonFunc.ALWAYS = 7] = "ALWAYS";
    }(GFXComparisonFunc || (GFXComparisonFunc = {})), function(GFXStencilOp) {
        GFXStencilOp[GFXStencilOp.ZERO = 0] = "ZERO", GFXStencilOp[GFXStencilOp.KEEP = 1] = "KEEP", 
        GFXStencilOp[GFXStencilOp.REPLACE = 2] = "REPLACE", GFXStencilOp[GFXStencilOp.INCR = 3] = "INCR", 
        GFXStencilOp[GFXStencilOp.DECR = 4] = "DECR", GFXStencilOp[GFXStencilOp.INVERT = 5] = "INVERT", 
        GFXStencilOp[GFXStencilOp.INCR_WRAP = 6] = "INCR_WRAP", GFXStencilOp[GFXStencilOp.DECR_WRAP = 7] = "DECR_WRAP";
    }(GFXStencilOp || (GFXStencilOp = {})), function(GFXBlendOp) {
        GFXBlendOp[GFXBlendOp.ADD = 0] = "ADD", GFXBlendOp[GFXBlendOp.SUB = 1] = "SUB", 
        GFXBlendOp[GFXBlendOp.REV_SUB = 2] = "REV_SUB", GFXBlendOp[GFXBlendOp.MIN = 3] = "MIN", 
        GFXBlendOp[GFXBlendOp.MAX = 4] = "MAX";
    }(GFXBlendOp || (GFXBlendOp = {})), function(GFXBlendFactor) {
        GFXBlendFactor[GFXBlendFactor.ZERO = 0] = "ZERO", GFXBlendFactor[GFXBlendFactor.ONE = 1] = "ONE", 
        GFXBlendFactor[GFXBlendFactor.SRC_ALPHA = 2] = "SRC_ALPHA", GFXBlendFactor[GFXBlendFactor.DST_ALPHA = 3] = "DST_ALPHA", 
        GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", 
        GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", 
        GFXBlendFactor[GFXBlendFactor.SRC_COLOR = 6] = "SRC_COLOR", GFXBlendFactor[GFXBlendFactor.DST_COLOR = 7] = "DST_COLOR", 
        GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", 
        GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", 
        GFXBlendFactor[GFXBlendFactor.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", GFXBlendFactor[GFXBlendFactor.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", 
        GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", 
        GFXBlendFactor[GFXBlendFactor.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA";
    }(GFXBlendFactor || (GFXBlendFactor = {})), function(GFXColorMask) {
        GFXColorMask[GFXColorMask.NONE = 0] = "NONE", GFXColorMask[GFXColorMask.R = 1] = "R", 
        GFXColorMask[GFXColorMask.G = 2] = "G", GFXColorMask[GFXColorMask.B = 4] = "B", 
        GFXColorMask[GFXColorMask.A = 8] = "A", GFXColorMask[GFXColorMask.ALL = 15] = "ALL";
    }(GFXColorMask || (GFXColorMask = {})), function(GFXFilter) {
        GFXFilter[GFXFilter.NONE = 0] = "NONE", GFXFilter[GFXFilter.POINT = 1] = "POINT", 
        GFXFilter[GFXFilter.LINEAR = 2] = "LINEAR", GFXFilter[GFXFilter.ANISOTROPIC = 3] = "ANISOTROPIC";
    }(GFXFilter || (GFXFilter = {})), function(GFXAddress) {
        GFXAddress[GFXAddress.WRAP = 0] = "WRAP", GFXAddress[GFXAddress.MIRROR = 1] = "MIRROR", 
        GFXAddress[GFXAddress.CLAMP = 2] = "CLAMP", GFXAddress[GFXAddress.BORDER = 3] = "BORDER";
    }(GFXAddress || (GFXAddress = {})), function(GFXTextureType) {
        GFXTextureType[GFXTextureType.TEX1D = 0] = "TEX1D", GFXTextureType[GFXTextureType.TEX2D = 1] = "TEX2D", 
        GFXTextureType[GFXTextureType.TEX3D = 2] = "TEX3D";
    }(GFXTextureType || (GFXTextureType = {})), function(GFXTextureUsageBit) {
        GFXTextureUsageBit[GFXTextureUsageBit.NONE = 0] = "NONE", GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", 
        GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", GFXTextureUsageBit[GFXTextureUsageBit.SAMPLED = 4] = "SAMPLED", 
        GFXTextureUsageBit[GFXTextureUsageBit.STORAGE = 8] = "STORAGE", GFXTextureUsageBit[GFXTextureUsageBit.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", 
        GFXTextureUsageBit[GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", 
        GFXTextureUsageBit[GFXTextureUsageBit.TRANSIENT_ATTACHMENT = 64] = "TRANSIENT_ATTACHMENT", 
        GFXTextureUsageBit[GFXTextureUsageBit.INPUT_ATTACHMENT = 128] = "INPUT_ATTACHMENT";
    }(GFXTextureUsageBit || (GFXTextureUsageBit = {})), function(GFXSampleCount) {
        GFXSampleCount[GFXSampleCount.X1 = 0] = "X1", GFXSampleCount[GFXSampleCount.X2 = 1] = "X2", 
        GFXSampleCount[GFXSampleCount.X4 = 2] = "X4", GFXSampleCount[GFXSampleCount.X8 = 3] = "X8", 
        GFXSampleCount[GFXSampleCount.X16 = 4] = "X16", GFXSampleCount[GFXSampleCount.X32 = 5] = "X32", 
        GFXSampleCount[GFXSampleCount.X64 = 6] = "X64";
    }(GFXSampleCount || (GFXSampleCount = {})), function(GFXTextureFlagBit) {
        GFXTextureFlagBit[GFXTextureFlagBit.NONE = 0] = "NONE", GFXTextureFlagBit[GFXTextureFlagBit.GEN_MIPMAP = 1] = "GEN_MIPMAP", 
        GFXTextureFlagBit[GFXTextureFlagBit.CUBEMAP = 2] = "CUBEMAP", GFXTextureFlagBit[GFXTextureFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER";
    }(GFXTextureFlagBit || (GFXTextureFlagBit = {})), function(GFXTextureViewType) {
        GFXTextureViewType[GFXTextureViewType.TV1D = 0] = "TV1D", GFXTextureViewType[GFXTextureViewType.TV2D = 1] = "TV2D", 
        GFXTextureViewType[GFXTextureViewType.TV3D = 2] = "TV3D", GFXTextureViewType[GFXTextureViewType.CUBE = 3] = "CUBE", 
        GFXTextureViewType[GFXTextureViewType.TV1D_ARRAY = 4] = "TV1D_ARRAY", GFXTextureViewType[GFXTextureViewType.TV2D_ARRAY = 5] = "TV2D_ARRAY";
    }(GFXTextureViewType || (GFXTextureViewType = {})), function(GFXShaderType) {
        GFXShaderType[GFXShaderType.VERTEX = 0] = "VERTEX", GFXShaderType[GFXShaderType.HULL = 1] = "HULL", 
        GFXShaderType[GFXShaderType.DOMAIN = 2] = "DOMAIN", GFXShaderType[GFXShaderType.GEOMETRY = 3] = "GEOMETRY", 
        GFXShaderType[GFXShaderType.FRAGMENT = 4] = "FRAGMENT", GFXShaderType[GFXShaderType.COMPUTE = 5] = "COMPUTE", 
        GFXShaderType[GFXShaderType.COUNT = 6] = "COUNT";
    }(GFXShaderType || (GFXShaderType = {})), function(GFXBindingType) {
        GFXBindingType[GFXBindingType.UNKNOWN = 0] = "UNKNOWN", GFXBindingType[GFXBindingType.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", 
        GFXBindingType[GFXBindingType.SAMPLER = 2] = "SAMPLER", GFXBindingType[GFXBindingType.STORAGE_BUFFER = 3] = "STORAGE_BUFFER";
    }(GFXBindingType || (GFXBindingType = {})), function(GFXCommandBufferType) {
        GFXCommandBufferType[GFXCommandBufferType.PRIMARY = 0] = "PRIMARY", GFXCommandBufferType[GFXCommandBufferType.SECONDARY = 1] = "SECONDARY";
    }(GFXCommandBufferType || (GFXCommandBufferType = {})), function(GFXLoadOp) {
        GFXLoadOp[GFXLoadOp.LOAD = 0] = "LOAD", GFXLoadOp[GFXLoadOp.CLEAR = 1] = "CLEAR", 
        GFXLoadOp[GFXLoadOp.DISCARD = 2] = "DISCARD";
    }(GFXLoadOp || (GFXLoadOp = {})), function(GFXStoreOp) {
        GFXStoreOp[GFXStoreOp.STORE = 0] = "STORE", GFXStoreOp[GFXStoreOp.DISCARD = 1] = "DISCARD";
    }(GFXStoreOp || (GFXStoreOp = {})), function(GFXTextureLayout) {
        GFXTextureLayout[GFXTextureLayout.UNDEFINED = 0] = "UNDEFINED", GFXTextureLayout[GFXTextureLayout.GENERAL = 1] = "GENERAL", 
        GFXTextureLayout[GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL = 2] = "COLOR_ATTACHMENT_OPTIMAL", 
        GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 
        GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_READONLY_OPTIMAL = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL", 
        GFXTextureLayout[GFXTextureLayout.SHADER_READONLY_OPTIMAL = 5] = "SHADER_READONLY_OPTIMAL", 
        GFXTextureLayout[GFXTextureLayout.TRANSFER_SRC_OPTIMAL = 6] = "TRANSFER_SRC_OPTIMAL", 
        GFXTextureLayout[GFXTextureLayout.TRANSFER_DST_OPTIMAL = 7] = "TRANSFER_DST_OPTIMAL", 
        GFXTextureLayout[GFXTextureLayout.PREINITIALIZED = 8] = "PREINITIALIZED", GFXTextureLayout[GFXTextureLayout.PRESENT_SRC = 9] = "PRESENT_SRC";
    }(GFXTextureLayout || (GFXTextureLayout = {})), function(GFXPipelineBindPoint) {
        GFXPipelineBindPoint[GFXPipelineBindPoint.GRAPHICS = 0] = "GRAPHICS", GFXPipelineBindPoint[GFXPipelineBindPoint.COMPUTE = 1] = "COMPUTE", 
        GFXPipelineBindPoint[GFXPipelineBindPoint.RAY_TRACING = 2] = "RAY_TRACING";
    }(GFXPipelineBindPoint || (GFXPipelineBindPoint = {})), function(GFXDynamicState) {
        GFXDynamicState[GFXDynamicState.VIEWPORT = 0] = "VIEWPORT", GFXDynamicState[GFXDynamicState.SCISSOR = 1] = "SCISSOR", 
        GFXDynamicState[GFXDynamicState.LINE_WIDTH = 2] = "LINE_WIDTH", GFXDynamicState[GFXDynamicState.DEPTH_BIAS = 3] = "DEPTH_BIAS", 
        GFXDynamicState[GFXDynamicState.BLEND_CONSTANTS = 4] = "BLEND_CONSTANTS", GFXDynamicState[GFXDynamicState.DEPTH_BOUNDS = 5] = "DEPTH_BOUNDS", 
        GFXDynamicState[GFXDynamicState.STENCIL_WRITE_MASK = 6] = "STENCIL_WRITE_MASK", 
        GFXDynamicState[GFXDynamicState.STENCIL_COMPARE_MASK = 7] = "STENCIL_COMPARE_MASK";
    }(GFXDynamicState || (GFXDynamicState = {})), function(GFXStencilFace) {
        GFXStencilFace[GFXStencilFace.FRONT = 0] = "FRONT", GFXStencilFace[GFXStencilFace.BACK = 1] = "BACK", 
        GFXStencilFace[GFXStencilFace.ALL = 2] = "ALL";
    }(GFXStencilFace || (GFXStencilFace = {})), function(GFXQueueType) {
        GFXQueueType[GFXQueueType.GRAPHICS = 0] = "GRAPHICS", GFXQueueType[GFXQueueType.COMPUTE = 1] = "COMPUTE", 
        GFXQueueType[GFXQueueType.TRANSFER = 2] = "TRANSFER";
    }(GFXQueueType || (GFXQueueType = {})), function(GFXClearFlag) {
        GFXClearFlag[GFXClearFlag.NONE = 0] = "NONE", GFXClearFlag[GFXClearFlag.COLOR = 1] = "COLOR", 
        GFXClearFlag[GFXClearFlag.DEPTH = 2] = "DEPTH", GFXClearFlag[GFXClearFlag.STENCIL = 4] = "STENCIL", 
        GFXClearFlag[GFXClearFlag.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", GFXClearFlag[GFXClearFlag.ALL = 7] = "ALL";
    }(GFXClearFlag || (GFXClearFlag = {}));
    var GFXFormatType, GFXTextureSubres = function GFXTextureSubres() {
        _classCallCheck(this, GFXTextureSubres), this.baseMipLevel = 0, this.levelCount = 1, 
        this.baseArrayLayer = 0, this.layerCount = 1;
    }, GFXBufferTextureCopy = function GFXBufferTextureCopy() {
        _classCallCheck(this, GFXBufferTextureCopy), this.buffOffset = 0, this.buffStride = 0, 
        this.buffTexHeight = 0, this.texOffset = {
            x: 0,
            y: 0,
            z: 0
        }, this.texExtent = {
            width: 0,
            height: 0,
            depth: 0
        }, this.texSubres = new GFXTextureSubres();
    };
    !function(GFXFormatType) {
        GFXFormatType[GFXFormatType.NONE = 0] = "NONE", GFXFormatType[GFXFormatType.UNORM = 1] = "UNORM", 
        GFXFormatType[GFXFormatType.SNORM = 2] = "SNORM", GFXFormatType[GFXFormatType.UINT = 3] = "UINT", 
        GFXFormatType[GFXFormatType.INT = 4] = "INT", GFXFormatType[GFXFormatType.UFLOAT = 5] = "UFLOAT", 
        GFXFormatType[GFXFormatType.FLOAT = 6] = "FLOAT";
    }(GFXFormatType || (GFXFormatType = {}));
    var GFXFormatInfos = [ {
        name: "UNKNOWN",
        size: 0,
        count: 0,
        type: GFXFormatType.NONE,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "A8",
        size: 1,
        count: 1,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "L8",
        size: 1,
        count: 1,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "LA8",
        size: 1,
        count: 2,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8",
        size: 1,
        count: 1,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8SN",
        size: 1,
        count: 1,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8UI",
        size: 1,
        count: 1,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R8I",
        size: 1,
        count: 1,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R16F",
        size: 2,
        count: 1,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R16UI",
        size: 2,
        count: 1,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R16I",
        size: 2,
        count: 1,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R32F",
        size: 4,
        count: 1,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R32UI",
        size: 4,
        count: 1,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R32I",
        size: 4,
        count: 1,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8",
        size: 2,
        count: 2,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8SN",
        size: 2,
        count: 2,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8UI",
        size: 2,
        count: 2,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG8I",
        size: 2,
        count: 2,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG16F",
        size: 4,
        count: 2,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG16UI",
        size: 4,
        count: 2,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG16I",
        size: 4,
        count: 2,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG32F",
        size: 8,
        count: 2,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG32UI",
        size: 8,
        count: 2,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RG32I",
        size: 8,
        count: 2,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8",
        size: 3,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "SRGB8",
        size: 3,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8SN",
        size: 3,
        count: 3,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8UI",
        size: 3,
        count: 3,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB8I",
        size: 3,
        count: 3,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB16F",
        size: 6,
        count: 3,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB16UI",
        size: 6,
        count: 3,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB16I",
        size: 6,
        count: 3,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB32F",
        size: 12,
        count: 3,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB32UI",
        size: 12,
        count: 3,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB32I",
        size: 12,
        count: 3,
        type: GFXFormatType.INT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8",
        size: 4,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "SRGB8_A8",
        size: 4,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8SN",
        size: 4,
        count: 4,
        type: GFXFormatType.SNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8UI",
        size: 4,
        count: 4,
        type: GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA8I",
        size: 4,
        count: 4,
        type: GFXFormatType.INT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA16F",
        size: 8,
        count: 4,
        type: GFXFormatType.FLOAT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA16UI",
        size: 8,
        count: 4,
        type: GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA16I",
        size: 8,
        count: 4,
        type: GFXFormatType.INT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA32F",
        size: 16,
        count: 4,
        type: GFXFormatType.FLOAT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA32UI",
        size: 16,
        count: 4,
        type: GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA32I",
        size: 16,
        count: 4,
        type: GFXFormatType.INT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R5G6B5",
        size: 2,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "R11G11B10F",
        size: 4,
        count: 3,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB5A1",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGBA4",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB10A2",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB10A2UI",
        size: 2,
        count: 4,
        type: GFXFormatType.UINT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "RGB9E5",
        size: 2,
        count: 4,
        type: GFXFormatType.FLOAT,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D16",
        size: 2,
        count: 1,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D16S8",
        size: 3,
        count: 2,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !0,
        isCompressed: !1
    }, {
        name: "D24",
        size: 3,
        count: 1,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D24S8",
        size: 4,
        count: 2,
        type: GFXFormatType.UINT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !0,
        isCompressed: !1
    }, {
        name: "D32F",
        size: 4,
        count: 1,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !1,
        isCompressed: !1
    }, {
        name: "D32FS8",
        size: 5,
        count: 2,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !0,
        hasStencil: !0,
        isCompressed: !1
    }, {
        name: "BC1",
        size: 1,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC1_ALPHA",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC1_SRGB",
        size: 1,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC1_SRGB_ALPHA",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC2",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC2_SRGB",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC3",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC3_SRGB",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC4",
        size: 1,
        count: 1,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC4_SNORM",
        size: 1,
        count: 1,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC5",
        size: 1,
        count: 2,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC5_SNORM",
        size: 1,
        count: 2,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC6H_UF16",
        size: 1,
        count: 3,
        type: GFXFormatType.UFLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC6H_SF16",
        size: 1,
        count: 3,
        type: GFXFormatType.FLOAT,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC7",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "BC7_SRGB",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC_RGB8",
        size: 1,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_RGB8",
        size: 1,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_SRGB8",
        size: 1,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_RGB8_A1",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_SRGB8_A1",
        size: 1,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_RGBA8",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "ETC2_SRGB8_A8",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_R11",
        size: 1,
        count: 1,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_R11SN",
        size: 1,
        count: 1,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_RG11",
        size: 2,
        count: 2,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "EAC_RG11SN",
        size: 2,
        count: 2,
        type: GFXFormatType.SNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGB2",
        size: 2,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGBA2",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGB4",
        size: 2,
        count: 3,
        type: GFXFormatType.UNORM,
        hasAlpha: !1,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC_RGBA4",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC2_2BPP",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    }, {
        name: "PVRTC2_4BPP",
        size: 2,
        count: 4,
        type: GFXFormatType.UNORM,
        hasAlpha: !0,
        hasDepth: !1,
        hasStencil: !1,
        isCompressed: !0
    } ];
    function GFXFormatSize(format, width, height, depth) {
        if (!GFXFormatInfos[format].isCompressed) return width * height * depth * GFXFormatInfos[format].size;
        switch (format) {
          case exports.GFXFormat.BC1:
          case exports.GFXFormat.BC1_ALPHA:
          case exports.GFXFormat.BC1_SRGB:
          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

          case exports.GFXFormat.BC2:
          case exports.GFXFormat.BC2_SRGB:
          case exports.GFXFormat.BC3:
          case exports.GFXFormat.BC3_SRGB:
          case exports.GFXFormat.BC4:
          case exports.GFXFormat.BC4_SNORM:
          case exports.GFXFormat.BC6H_SF16:
          case exports.GFXFormat.BC6H_UF16:
          case exports.GFXFormat.BC7:
          case exports.GFXFormat.BC7_SRGB:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

          case exports.GFXFormat.BC5:
          case exports.GFXFormat.BC5_SNORM:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

          case exports.GFXFormat.ETC_RGB8:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.ETC2_RGB8_A1:
          case exports.GFXFormat.ETC2_SRGB8_A1:
          case exports.GFXFormat.EAC_R11:
          case exports.GFXFormat.EAC_R11SN:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

          case exports.GFXFormat.EAC_RG11:
          case exports.GFXFormat.EAC_RG11SN:
            return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

          case exports.GFXFormat.PVRTC_RGB2:
          case exports.GFXFormat.PVRTC_RGBA2:
          case exports.GFXFormat.PVRTC2_2BPP:
            return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

          case exports.GFXFormat.PVRTC_RGB4:
          case exports.GFXFormat.PVRTC_RGBA4:
          case exports.GFXFormat.PVRTC2_4BPP:
            return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 2) * depth;

          default:
            return 0;
        }
    }
    function GFXFormatSurfaceSize(format, width, height, depth, mips) {
        for (var size = 0, i = 0; i < mips; ++i) size += GFXFormatSize(format, width, height, depth), 
        width = Math.max(width >> 1, 1), height = Math.max(height >> 1, 1), depth = Math.max(depth >> 1, 1);
        return size;
    }
    function GFXGetTypeSize(type) {
        switch (type) {
          case GFXType.BOOL:
          case GFXType.INT:
          case GFXType.UINT:
          case GFXType.FLOAT:
            return 4;

          case GFXType.BOOL2:
          case GFXType.INT2:
          case GFXType.UINT2:
          case GFXType.FLOAT2:
            return 8;

          case GFXType.BOOL3:
          case GFXType.INT3:
          case GFXType.UINT3:
          case GFXType.FLOAT3:
            return 12;

          case GFXType.BOOL4:
          case GFXType.INT4:
          case GFXType.UINT4:
          case GFXType.FLOAT4:
          case GFXType.MAT2:
            return 16;

          case GFXType.MAT2X3:
            return 24;

          case GFXType.MAT2X4:
            return 32;

          case GFXType.MAT3X2:
            return 24;

          case GFXType.MAT3:
            return 36;

          case GFXType.MAT3X4:
            return 48;

          case GFXType.MAT4X2:
          case GFXType.MAT4X2:
            return 32;

          case GFXType.MAT4:
            return 64;

          case GFXType.SAMPLER1D:
          case GFXType.SAMPLER1D_ARRAY:
          case GFXType.SAMPLER2D:
          case GFXType.SAMPLER2D_ARRAY:
          case GFXType.SAMPLER3D:
          case GFXType.SAMPLER_CUBE:
            return 4;

          default:
            return 0;
        }
    }
    var GFXAPI, GFXFeature, GFXDefines = Object.freeze({
        GFX_MAX_VERTEX_ATTRIBUTES: 16,
        GFX_MAX_TEXTURE_UNITS: 16,
        GFX_MAX_ATTACHMENTS: 4,
        GFX_MAX_BUFFER_BINDINGS: 24,
        get GFXObjectType() {
            return GFXObjectType;
        },
        get GFXStatus() {
            return GFXStatus;
        },
        GFXObject: GFXObject,
        get GFXAttributeName() {
            return exports.GFXAttributeName;
        },
        get GFXType() {
            return GFXType;
        },
        get GFXFormat() {
            return exports.GFXFormat;
        },
        get GFXBufferUsageBit() {
            return GFXBufferUsageBit;
        },
        get GFXMemoryUsageBit() {
            return GFXMemoryUsageBit;
        },
        get GFXBufferAccessBit() {
            return GFXBufferAccessBit;
        },
        get GFXPrimitiveMode() {
            return exports.GFXPrimitiveMode;
        },
        get GFXPolygonMode() {
            return GFXPolygonMode;
        },
        get GFXShadeModel() {
            return GFXShadeModel;
        },
        get GFXCullMode() {
            return GFXCullMode;
        },
        get GFXComparisonFunc() {
            return GFXComparisonFunc;
        },
        get GFXStencilOp() {
            return GFXStencilOp;
        },
        get GFXBlendOp() {
            return GFXBlendOp;
        },
        get GFXBlendFactor() {
            return GFXBlendFactor;
        },
        get GFXColorMask() {
            return GFXColorMask;
        },
        get GFXFilter() {
            return GFXFilter;
        },
        get GFXAddress() {
            return GFXAddress;
        },
        get GFXTextureType() {
            return GFXTextureType;
        },
        get GFXTextureUsageBit() {
            return GFXTextureUsageBit;
        },
        get GFXSampleCount() {
            return GFXSampleCount;
        },
        get GFXTextureFlagBit() {
            return GFXTextureFlagBit;
        },
        get GFXTextureViewType() {
            return GFXTextureViewType;
        },
        get GFXShaderType() {
            return GFXShaderType;
        },
        get GFXBindingType() {
            return GFXBindingType;
        },
        get GFXCommandBufferType() {
            return GFXCommandBufferType;
        },
        get GFXLoadOp() {
            return GFXLoadOp;
        },
        get GFXStoreOp() {
            return GFXStoreOp;
        },
        get GFXTextureLayout() {
            return GFXTextureLayout;
        },
        get GFXPipelineBindPoint() {
            return GFXPipelineBindPoint;
        },
        get GFXDynamicState() {
            return GFXDynamicState;
        },
        get GFXStencilFace() {
            return GFXStencilFace;
        },
        get GFXQueueType() {
            return GFXQueueType;
        },
        get GFXClearFlag() {
            return GFXClearFlag;
        },
        GFXTextureSubres: GFXTextureSubres,
        GFXTextureCopy: function GFXTextureCopy() {
            _classCallCheck(this, GFXTextureCopy), this.srcSubres = new GFXTextureSubres(), 
            this.srcOffset = {
                x: 0,
                y: 0,
                z: 0
            }, this.dstSubres = new GFXTextureSubres(), this.dstOffset = {
                x: 0,
                y: 0,
                z: 0
            }, this.extent = {
                width: 0,
                height: 0,
                depth: 0
            };
        },
        GFXBufferTextureCopy: GFXBufferTextureCopy,
        get GFXFormatType() {
            return GFXFormatType;
        },
        GFXFormatInfos: GFXFormatInfos,
        GFXFormatSize: GFXFormatSize,
        GFXFormatSurfaceSize: GFXFormatSurfaceSize,
        GFXGetTypeSize: GFXGetTypeSize
    });
    ccenum(exports.GFXFormat), function(GFXAPI) {
        GFXAPI[GFXAPI.UNKNOWN = 0] = "UNKNOWN", GFXAPI[GFXAPI.WEBGL = 1] = "WEBGL", GFXAPI[GFXAPI.WEBGL2 = 2] = "WEBGL2";
    }(GFXAPI || (GFXAPI = {})), function(GFXFeature) {
        GFXFeature[GFXFeature.COLOR_FLOAT = 0] = "COLOR_FLOAT", GFXFeature[GFXFeature.COLOR_HALF_FLOAT = 1] = "COLOR_HALF_FLOAT", 
        GFXFeature[GFXFeature.TEXTURE_FLOAT = 2] = "TEXTURE_FLOAT", GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT = 3] = "TEXTURE_HALF_FLOAT", 
        GFXFeature[GFXFeature.TEXTURE_FLOAT_LINEAR = 4] = "TEXTURE_FLOAT_LINEAR", GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR = 5] = "TEXTURE_HALF_FLOAT_LINEAR", 
        GFXFeature[GFXFeature.FORMAT_R11G11B10F = 6] = "FORMAT_R11G11B10F", GFXFeature[GFXFeature.FORMAT_D24S8 = 7] = "FORMAT_D24S8", 
        GFXFeature[GFXFeature.FORMAT_ETC1 = 8] = "FORMAT_ETC1", GFXFeature[GFXFeature.FORMAT_ETC2 = 9] = "FORMAT_ETC2", 
        GFXFeature[GFXFeature.FORMAT_DXT = 10] = "FORMAT_DXT", GFXFeature[GFXFeature.FORMAT_PVRTC = 11] = "FORMAT_PVRTC", 
        GFXFeature[GFXFeature.MSAA = 12] = "MSAA", GFXFeature[GFXFeature.COUNT = 13] = "COUNT";
    }(GFXFeature || (GFXFeature = {}));
    var PixelFormat, WrapMode, Filter, _dec$5, _dec2$2, _class$5, _class2$4, _class3$3, _temp$4, GFXDevice = function() {
        function GFXDevice() {
            _classCallCheck(this, GFXDevice), this._canvas = null, this._canvas2D = null, this._gfxAPI = GFXAPI.UNKNOWN, 
            this._deviceName = "", this._renderer = "", this._vendor = "", this._version = "", 
            this._features = new Array(GFXFeature.COUNT), this._queue = null, this._devicePixelRatio = 1, 
            this._width = 0, this._height = 0, this._nativeWidth = 0, this._nativeHeight = 0, 
            this._mainWindow = null, this._cmdAllocator = null, this._maxVertexAttributes = 0, 
            this._maxVertexUniformVectors = 0, this._maxFragmentUniformVectors = 0, this._maxTextureUnits = 0, 
            this._maxVertexTextureUnits = 0, this._maxUniformBufferBindings = 24, this._maxUniformBlockSize = 0, 
            this._depthBits = 0, this._stencilBits = 0, this._colorFmt = exports.GFXFormat.UNKNOWN, 
            this._depthStencilFmt = exports.GFXFormat.UNKNOWN, this._shaderIdGen = 0, this._macros = new Map(), 
            this._numDrawCalls = 0, this._numTris = 0;
        }
        return _createClass(GFXDevice, [ {
            key: "hasFeature",
            value: function hasFeature(feature) {
                return this._features[feature];
            }
        }, {
            key: "genShaderId",
            value: function genShaderId() {
                return this._shaderIdGen++;
            }
        }, {
            key: "defineMacro",
            value: function defineMacro(macro, value) {
                var val = void 0 !== value ? value : "";
                this._macros.set(macro, val);
            }
        }, {
            key: "canvas",
            get: function get() {
                return this._canvas;
            }
        }, {
            key: "canvas2D",
            get: function get() {
                return this._canvas2D;
            }
        }, {
            key: "gfxAPI",
            get: function get() {
                return this._gfxAPI;
            }
        }, {
            key: "queue",
            get: function get() {
                return this._queue;
            }
        }, {
            key: "devicePixelRatio",
            get: function get() {
                return this._devicePixelRatio;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "nativeWidth",
            get: function get() {
                return this._nativeWidth;
            }
        }, {
            key: "nativeHeight",
            get: function get() {
                return this._nativeHeight;
            }
        }, {
            key: "mainWindow",
            get: function get() {
                return this._mainWindow;
            }
        }, {
            key: "commandAllocator",
            get: function get() {
                return this._cmdAllocator;
            }
        }, {
            key: "renderer",
            get: function get() {
                return this._renderer;
            }
        }, {
            key: "vendor",
            get: function get() {
                return this._vendor;
            }
        }, {
            key: "maxVertexAttributes",
            get: function get() {
                return this._maxVertexAttributes;
            }
        }, {
            key: "maxVertexUniformVectors",
            get: function get() {
                return this._maxVertexUniformVectors;
            }
        }, {
            key: "maxFragmentUniformVectors",
            get: function get() {
                return this._maxFragmentUniformVectors;
            }
        }, {
            key: "maxTextureUnits",
            get: function get() {
                return this._maxTextureUnits;
            }
        }, {
            key: "maxVertexTextureUnits",
            get: function get() {
                return this._maxVertexTextureUnits;
            }
        }, {
            key: "maxUniformBufferBindings",
            get: function get() {
                return this._maxUniformBufferBindings;
            }
        }, {
            key: "maxUniformBlockSize",
            get: function get() {
                return this._maxUniformBlockSize;
            }
        }, {
            key: "depthBits",
            get: function get() {
                return this._depthBits;
            }
        }, {
            key: "stencilBits",
            get: function get() {
                return this._stencilBits;
            }
        }, {
            key: "colorFormat",
            get: function get() {
                return this._colorFmt;
            }
        }, {
            key: "depthStencilFormat",
            get: function get() {
                return this._depthStencilFmt;
            }
        }, {
            key: "macros",
            get: function get() {
                return this._macros;
            }
        }, {
            key: "numDrawCalls",
            get: function get() {
                return this._numDrawCalls;
            }
        }, {
            key: "numTris",
            get: function get() {
                return this._numTris;
            }
        } ]), GFXDevice;
    }();
    !function(PixelFormat) {
        PixelFormat[PixelFormat.RGB565 = exports.GFXFormat.R5G6B5] = "RGB565", PixelFormat[PixelFormat.RGB5A1 = exports.GFXFormat.RGB5A1] = "RGB5A1", 
        PixelFormat[PixelFormat.RGBA4444 = exports.GFXFormat.RGBA4] = "RGBA4444", PixelFormat[PixelFormat.RGB888 = exports.GFXFormat.RGB8] = "RGB888", 
        PixelFormat[PixelFormat.RGBA8888 = exports.GFXFormat.RGBA8] = "RGBA8888", PixelFormat[PixelFormat.RGBA32F = exports.GFXFormat.RGBA32F] = "RGBA32F", 
        PixelFormat[PixelFormat.A8 = exports.GFXFormat.A8] = "A8", PixelFormat[PixelFormat.I8 = exports.GFXFormat.L8] = "I8", 
        PixelFormat[PixelFormat.AI8 = exports.GFXFormat.LA8] = "AI8", PixelFormat[PixelFormat.RGB_PVRTC_2BPPV1 = exports.GFXFormat.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1", 
        PixelFormat[PixelFormat.RGBA_PVRTC_2BPPV1 = exports.GFXFormat.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1", 
        PixelFormat[PixelFormat.RGB_PVRTC_4BPPV1 = exports.GFXFormat.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1", 
        PixelFormat[PixelFormat.RGBA_PVRTC_4BPPV1 = exports.GFXFormat.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1", 
        PixelFormat[PixelFormat.RGB_ETC1 = exports.GFXFormat.ETC_RGB8] = "RGB_ETC1", PixelFormat[PixelFormat.RGB_ETC2 = exports.GFXFormat.ETC2_RGB8] = "RGB_ETC2", 
        PixelFormat[PixelFormat.RGBA_ETC2 = exports.GFXFormat.ETC2_RGBA8] = "RGBA_ETC2";
    }(PixelFormat || (PixelFormat = {})), function(WrapMode) {
        WrapMode[WrapMode.REPEAT = GFXAddress.WRAP] = "REPEAT", WrapMode[WrapMode.CLAMP_TO_EDGE = GFXAddress.CLAMP] = "CLAMP_TO_EDGE", 
        WrapMode[WrapMode.MIRRORED_REPEAT = GFXAddress.MIRROR] = "MIRRORED_REPEAT", WrapMode[WrapMode.CLAMP_TO_BORDER = GFXAddress.BORDER] = "CLAMP_TO_BORDER";
    }(WrapMode || (WrapMode = {})), function(Filter) {
        Filter[Filter.NONE = GFXFilter.NONE] = "NONE", Filter[Filter.LINEAR = GFXFilter.LINEAR] = "LINEAR", 
        Filter[Filter.NEAREST = GFXFilter.POINT] = "NEAREST";
    }(Filter || (Filter = {}));
    var SamplerInfoIndex, ImageAsset = (_dec$5 = ccclass("cc.ImageAsset"), _dec2$2 = property({
        override: !0
    }), _dec$5((_temp$4 = _class3$3 = function(_Asset) {
        function ImageAsset(nativeAsset) {
            var _this;
            return _classCallCheck(this, ImageAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ImageAsset).call(this)))._nativeData = void 0, 
            _this._url = void 0, _this._exportedExts = void 0, _this._format = PixelFormat.RGBA8888, 
            _this._width = 0, _this._height = 0, _this._url = "", _this.loaded = !1, _this._nativeData = {
                _data: null,
                width: 0,
                height: 0,
                format: 0,
                _compressed: !1
            }, void 0 !== nativeAsset && (_this._nativeAsset = nativeAsset), _this;
        }
        return _inherits(ImageAsset, Asset), _createClass(ImageAsset, [ {
            key: "_nativeAsset",
            get: function get() {
                return this._nativeData;
            },
            set: function set(value) {
                this.reset(value);
            }
        }, {
            key: "data",
            get: function get() {
                return "_data" in this._nativeData ? this._nativeData._data : this._nativeData;
            }
        }, {
            key: "width",
            get: function get() {
                return this._nativeData.width || this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._nativeData.height || this._height;
            }
        }, {
            key: "format",
            get: function get() {
                return this._format;
            }
        }, {
            key: "isCompressed",
            get: function get() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
            }
        }, {
            key: "url",
            get: function get() {
                return this._url;
            }
        } ]), _createClass(ImageAsset, [ {
            key: "reset",
            value: function reset(data) {
                var _this2 = this;
                data instanceof HTMLElement ? (this._nativeData = data).complete || data instanceof HTMLCanvasElement ? this._onDataComplete() : (this.loaded = !1, 
                data.addEventListener("load", function() {
                    _this2._onDataComplete();
                }), data.addEventListener("error", function(err) {
                    cc.warnID(3119, err.message);
                })) : (this._nativeData = data, this._nativeData.format = this._format, this._onDataComplete());
            }
        }, {
            key: "_serialize",
            value: function _serialize() {
                var targetExtensions = this._exportedExts;
                if (!targetExtensions && this._native && (targetExtensions = [ this._native ]), 
                !targetExtensions) return "";
                var extensionIndices = [], _iterator = targetExtensions, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var targetExtension = _ref, extensionFormat = targetExtension.split("@"), i = ImageAsset.extnames.indexOf(extensionFormat[0]), exportedExtensionID = i < 0 ? targetExtension : "".concat(i);
                    extensionFormat[1] && (exportedExtensionID += "@" + extensionFormat[1]), extensionIndices.push(exportedExtensionID);
                }
                return {
                    fmt: extensionIndices.join("_"),
                    w: this.width,
                    h: this.height
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(data, handle) {
                var fmtStr = "";
                fmtStr = "string" == typeof data ? data : (this._width = data.w, this._height = data.h, 
                data.fmt);
                var device = function _getGlobalDevice() {
                    return cc.director && cc.director.root ? cc.director.root.device : null;
                }(), extensionIDs = fmtStr.split("_"), preferedExtensionIndex = Number.MAX_VALUE, format = this._format, ext = "", SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS, _iterator2 = extensionIDs, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var extFormat = _ref2.split("@"), i = parseInt(extFormat[0], void 0), tmpExt = ImageAsset.extnames[i] || extFormat.join(), index = SupportTextureFormats.indexOf(tmpExt);
                    if (-1 !== index && index < preferedExtensionIndex) {
                        var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;
                        if (!(".pvr" !== tmpExt || device && device.hasFeature(GFXFeature.FORMAT_PVRTC))) continue;
                        if (!(fmt !== PixelFormat.RGB_ETC1 || device && device.hasFeature(GFXFeature.FORMAT_ETC1))) continue;
                        if (!(fmt !== PixelFormat.RGB_ETC2 && fmt !== PixelFormat.RGBA_ETC2 || device && device.hasFeature(GFXFeature.FORMAT_ETC2))) continue;
                        if (".webp" === tmpExt && !cc.sys.capabilities.webp) continue;
                        preferedExtensionIndex = index, ext = tmpExt, format = fmt;
                    }
                }
                ext && (this._setRawAsset(ext), this._format = format);
                var loadingItem = handle.customEnv, uuid = loadingItem && loadingItem.uuid;
                uuid && (this._uuid = uuid, this._url = this.nativeUrl);
            }
        }, {
            key: "_onDataComplete",
            value: function _onDataComplete() {
                this.loaded = !0, this.emit("load");
            }
        } ]), ImageAsset;
    }(), _class3$3.extnames = [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ], 
    _applyDecoratedDescriptor((_class2$4 = _temp$4).prototype, "_nativeAsset", [ _dec2$2 ], Object.getOwnPropertyDescriptor(_class2$4.prototype, "_nativeAsset"), _class2$4.prototype), 
    _class$5 = _class2$4)) || _class$5);
    cc.ImageAsset = ImageAsset, function(SamplerInfoIndex) {
        SamplerInfoIndex[SamplerInfoIndex.minFilter = 0] = "minFilter", SamplerInfoIndex[SamplerInfoIndex.magFilter = 1] = "magFilter", 
        SamplerInfoIndex[SamplerInfoIndex.mipFilter = 2] = "mipFilter", SamplerInfoIndex[SamplerInfoIndex.addressU = 3] = "addressU", 
        SamplerInfoIndex[SamplerInfoIndex.addressV = 4] = "addressV", SamplerInfoIndex[SamplerInfoIndex.addressW = 5] = "addressW", 
        SamplerInfoIndex[SamplerInfoIndex.maxAnisotropy = 6] = "maxAnisotropy", SamplerInfoIndex[SamplerInfoIndex.cmpFunc = 7] = "cmpFunc", 
        SamplerInfoIndex[SamplerInfoIndex.minLOD = 8] = "minLOD", SamplerInfoIndex[SamplerInfoIndex.maxLOD = 9] = "maxLOD", 
        SamplerInfoIndex[SamplerInfoIndex.mipLODBias = 10] = "mipLODBias", SamplerInfoIndex[SamplerInfoIndex.borderColor = 11] = "borderColor", 
        SamplerInfoIndex[SamplerInfoIndex.total = 15] = "total";
    }(SamplerInfoIndex || (SamplerInfoIndex = {}));
    var defaultInfo = [ GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.NONE, GFXAddress.WRAP, GFXAddress.WRAP, GFXAddress.WRAP, 16, GFXComparisonFunc.NEVER, 0, 0, 0, 0, 0, 0, 0 ], gfxInfo = {}, samplerLib = new (function() {
        function SamplerLib() {
            _classCallCheck(this, SamplerLib), this._cache = {};
        }
        return _createClass(SamplerLib, [ {
            key: "getSampler",
            value: function getSampler(device, info) {
                for (var hash = "", i = 0; i < defaultInfo.length; i++) hash += (info[i] || defaultInfo[i]) + ",";
                var cache = this._cache[hash];
                if (cache) return cache;
                if (gfxInfo.minFilter = info[SamplerInfoIndex.minFilter], gfxInfo.magFilter = info[SamplerInfoIndex.magFilter], 
                gfxInfo.mipFilter = info[SamplerInfoIndex.mipFilter], gfxInfo.addressU = info[SamplerInfoIndex.addressU], 
                gfxInfo.addressV = info[SamplerInfoIndex.addressV], gfxInfo.addressW = info[SamplerInfoIndex.addressW], 
                gfxInfo.maxAnisotropy = info[SamplerInfoIndex.maxAnisotropy], info.length > SamplerInfoIndex.cmpFunc && (gfxInfo.cmpFunc = info[SamplerInfoIndex.cmpFunc], 
                gfxInfo.minLOD = info[SamplerInfoIndex.minLOD], gfxInfo.maxLOD = info[SamplerInfoIndex.maxLOD], 
                gfxInfo.mipLODBias = info[SamplerInfoIndex.mipLODBias], info.length >= SamplerInfoIndex.total)) {
                    var ofs = SamplerInfoIndex.borderColor;
                    gfxInfo.borderColor = {
                        r: info[ofs],
                        g: info[ofs + 1],
                        b: info[ofs + 2],
                        a: info[ofs + 3]
                    };
                }
                return this._cache[hash] = device.createSampler(gfxInfo);
            }
        } ]), SamplerLib;
    }())(), url = {
        _rawAssets: "",
        normalize: function normalize(url) {
            return url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1))), 
            url;
        },
        raw: function raw(url) {
            if ((url = this.normalize(url)).startsWith("resources/")) {
                var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, null, !0);
                if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, !0) + cc.path.extname(url);
            } else cc.errorID(7002, url);
            return this._rawAssets + url;
        },
        _init: function _init(assets) {
            this._rawAssets = cc.path.stripSep(assets) + "/";
        }
    };
    cc.url = url;
    var _qid = 0 | 998 * Math.random(), _queues = createMap(!0), _pool = [], ItemState = {
        WORKING: 1,
        COMPLETE: 2,
        ERROR: 3
    }, _queueDeps = createMap(!0);
    function createItem(id, queueId) {
        var url = "object" === _typeof(id) ? id.url : id, result = {
            queueId: queueId,
            id: url,
            url: url,
            rawUrl: void 0,
            urlParam: function _parseUrlParam(url) {
                if (url) {
                    var split = url.split("?");
                    if (split && split[0] && split[1]) {
                        var urlParam = {};
                        return split[1].split("&").forEach(function(item) {
                            var itemSplit = item.split("=");
                            urlParam[itemSplit[0]] = itemSplit[1];
                        }), urlParam;
                    }
                }
            }(url),
            type: "",
            error: null,
            content: null,
            complete: !1,
            states: {},
            deps: null
        };
        if ("object" === _typeof(id) && (mixin(result, id), id.skips)) for (var i = 0; i < id.skips.length; i++) {
            var skip = id.skips[i];
            result.states[skip] = ItemState.COMPLETE;
        }
        return result.rawUrl = result.url, url && !result.type && (result.type = extname(url).toLowerCase().substr(1)), 
        result;
    }
    var checkedIds = [];
    function checkCircleReference(owner, item, recursiveCall) {
        if (!owner || !item) return !1;
        var result = !1;
        if (checkedIds.push(item.id), item.deps) {
            var i, subDep, deps = item.deps;
            for (i = 0; i < deps.length; i++) {
                if ((subDep = deps[i]).id === owner.id) {
                    result = !0;
                    break;
                }
                if (!(0 <= checkedIds.indexOf(subDep.id)) && (subDep.deps && checkCircleReference(owner, subDep, !0))) {
                    result = !0;
                    break;
                }
            }
        }
        return recursiveCall || (checkedIds.length = 0), result;
    }
    var LoadingItems = function(_CallbacksInvoker) {
        function LoadingItems(pipeline, urlList, onProgress, onComplete) {
            var _this;
            return _classCallCheck(this, LoadingItems), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingItems).call(this)))._id = ++_qid, 
            _queues[_this._id] = _assertThisInitialized(_assertThisInitialized(_this)), _this._pipeline = pipeline, 
            _this._errorUrls = [], _this._appending = !1, _this._ownerQueue = null, _this.onProgress = onProgress, 
            _this.onComplete = onComplete, _this.map = createMap(!0), _this.completed = {}, 
            _this.totalCount = 0, _this.completedCount = 0, _this._pipeline ? _this.active = !0 : _this.active = !1, 
            urlList && (0 < urlList.length ? _this.append(urlList) : _this.allComplete()), _this;
        }
        return _inherits(LoadingItems, CallbacksInvoker), _createClass(LoadingItems, [ {
            key: "append",
            value: function append(urlList, owner) {
                if (!this.active) return [];
                owner && !owner.deps && (owner.deps = []), this._appending = !0;
                var i, url, item, id, accepted = [];
                for (i = 0; i < urlList.length; ++i) if (!(url = urlList[i]).queueId || this.map[url.id]) {
                    if ("string" == typeof ((id = url).url || id)) {
                        var key = (item = createItem(url, this._id)).id;
                        this.map[key] || (this.map[key] = item, this.totalCount++, owner && owner.deps.push(item), 
                        LoadingItems.registerQueueDep(owner || this._id, key), accepted.push(item));
                    }
                } else {
                    if (this.map[url.id] = url, owner && owner.deps.push(url), url.complete || checkCircleReference(owner, url)) {
                        this.totalCount++, this.itemComplete(url.id);
                        continue;
                    }
                    var self = this, queue = _queues[url.queueId];
                    queue && (this.totalCount++, LoadingItems.registerQueueDep(owner || this._id, url.id), 
                    queue.addListener(url.id, function(item) {
                        self.itemComplete(item.id);
                    }));
                }
                return this._appending = !1, this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted), 
                accepted;
            }
        }, {
            key: "_childOnProgress",
            value: function _childOnProgress(item) {
                if (this.onProgress) {
                    var dep = _queueDeps[this._id];
                    this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                }
            }
        }, {
            key: "allComplete",
            value: function allComplete() {
                var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
                this.onComplete && this.onComplete(errors, this);
            }
        }, {
            key: "isCompleted",
            value: function isCompleted() {
                return this.completedCount >= this.totalCount;
            }
        }, {
            key: "isItemCompleted",
            value: function isItemCompleted(id) {
                return !!this.completed[id];
            }
        }, {
            key: "exists",
            value: function exists(id) {
                return !!this.map[id];
            }
        }, {
            key: "getContent",
            value: function getContent(id) {
                var item = this.map[id], ret = null;
                return item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content)), 
                ret;
            }
        }, {
            key: "getError",
            value: function getError(id) {
                var item = this.map[id], ret = null;
                return item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error)), 
                ret;
            }
        }, {
            key: "removeItem",
            value: function removeItem(url) {
                var item = this.map[url];
                item && this.completed[item.alias || url] && (delete this.completed[url], delete this.map[url], 
                item.alias && (delete this.completed[item.alias.id], delete this.map[item.alias.id]), 
                this.completedCount--, this.totalCount--);
            }
        }, {
            key: "itemComplete",
            value: function itemComplete(id) {
                var item = this.map[id];
                if (item) {
                    var errorListId = this._errorUrls.indexOf(id);
                    if (item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1), 
                    this.completed[id] = item, this.completedCount++, LoadingItems.finishDep(item.id), 
                    this.onProgress) {
                        var dep = _queueDeps[this._id];
                        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                    }
                    this.emit(id, item), this.removeAll(id), !this._appending && this.completedCount >= this.totalCount && this.allComplete();
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.active = !1, this._appending = !1, this._pipeline = null, this._ownerQueue = null, 
                this._errorUrls.length = 0, this.onProgress = null, this.onComplete = null, this.map = createMap(!0), 
                this.completed = {}, this.totalCount = 0, this.completedCount = 0, CallbacksInvoker.call(this), 
                _queues[this._id] = null, _queueDeps[this._id] && (_queueDeps[this._id].completed.length = 0, 
                _queueDeps[this._id].deps.length = 0), -1 === _pool.indexOf(this) && _pool.length < 10 && _pool.push(this);
            }
        } ], [ {
            key: "create",
            value: function create(pipeline, urlList, onProgress, onComplete) {
                void 0 === onProgress ? "function" == typeof urlList && (onComplete = urlList, urlList = onProgress = null) : void 0 === onComplete && ("function" == typeof urlList ? (onComplete = onProgress, 
                onProgress = urlList, urlList = null) : (onComplete = onProgress, onProgress = null));
                var queue = _pool.pop();
                return queue ? (queue._pipeline = pipeline, queue.onProgress = onProgress, queue.onComplete = onComplete, 
                (_queues[queue._id] = queue)._pipeline && (queue.active = !0), urlList && queue.append(urlList)) : queue = new LoadingItems(pipeline, urlList, onProgress, onComplete), 
                queue;
            }
        }, {
            key: "getQueue",
            value: function getQueue(item) {
                return item.queueId ? _queues[item.queueId] : null;
            }
        }, {
            key: "itemComplete",
            value: function itemComplete(item) {
                var queue = _queues[item.queueId];
                queue && queue.itemComplete(item.id);
            }
        }, {
            key: "initQueueDeps",
            value: function initQueueDeps(queue) {
                var dep = _queueDeps[queue._id];
                dep ? (dep.completed.length = 0, dep.deps.length = 0) : dep = _queueDeps[queue._id] = {
                    completed: [],
                    deps: []
                };
            }
        }, {
            key: "registerQueueDep",
            value: function registerQueueDep(owner, depId) {
                var queueId = owner.queueId || owner;
                if (!queueId) return !1;
                var queueDepList = _queueDeps[queueId];
                if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
                    var queue = _queueDeps[id];
                    -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
                }
            }
        }, {
            key: "finishDep",
            value: function finishDep(depId) {
                for (var id in _queueDeps) {
                    var queue = _queueDeps[id];
                    -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
                }
            }
        } ]), LoadingItems;
    }();
    LoadingItems.ItemState = new cc.Enum(ItemState);
    var proto = LoadingItems.prototype;
    proto.addListener = CallbacksInvoker.prototype.on, proto.hasListener = CallbacksInvoker.prototype.hasEventListener, 
    proto.removeListener = CallbacksInvoker.prototype.off, proto.removeAllListeners = CallbacksInvoker.prototype.removeAll;
    var ItemState$1 = (cc.LoadingItems = LoadingItems).ItemState;
    function flow(pipe, item) {
        var pipeId = pipe.id, itemState = item.states[pipeId], next = pipe.next, pipeline = pipe.pipeline;
        if (!item.error && itemState !== ItemState$1.WORKING && itemState !== ItemState$1.ERROR) if (itemState === ItemState$1.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
            item.states[pipeId] = ItemState$1.WORKING;
            var result = pipe.handle(item, function(err, result) {
                err ? (item.error = err, item.states[pipeId] = ItemState$1.ERROR, pipeline.flowOut(item)) : (result && (item.content = result), 
                item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
            });
            result instanceof Error ? (item.error = result, item.states[pipeId] = ItemState$1.ERROR, 
            pipeline.flowOut(item)) : void 0 !== result && (null !== result && (item.content = result), 
            item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
        }
    }
    var Pipeline = function() {
        function Pipeline(pipes) {
            _classCallCheck(this, Pipeline), this._pipes = pipes, this._cache = createMap(!0);
            for (var i = 0; i < pipes.length; ++i) {
                var pipe = pipes[i];
                pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null);
            }
        }
        return _createClass(Pipeline, [ {
            key: "insertPipe",
            value: function insertPipe(pipe, index) {
                if (!pipe.handle || !pipe.id || index > this._pipes.length) cc.warnID(4921); else if (0 < this._pipes.indexOf(pipe)) cc.warnID(4922); else {
                    var nextPipe = null;
                    index < (pipe.pipeline = this)._pipes.length && (nextPipe = this._pipes[index]);
                    var previousPipe = null;
                    0 < index && (previousPipe = this._pipes[index - 1]), previousPipe && (previousPipe.next = pipe), 
                    pipe.next = nextPipe, this._pipes.splice(index, 0, pipe);
                }
            }
        }, {
            key: "insertPipeAfter",
            value: function insertPipeAfter(refPipe, newPipe) {
                var index = this._pipes.indexOf(refPipe);
                index < 0 || this.insertPipe(newPipe, index + 1);
            }
        }, {
            key: "appendPipe",
            value: function appendPipe(pipe) {
                pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = null, 0 < this._pipes.length && (this._pipes[this._pipes.length - 1].next = pipe), 
                this._pipes.push(pipe));
            }
        }, {
            key: "flowIn",
            value: function flowIn(items) {
                var i, item, pipe = this._pipes[0];
                if (pipe) {
                    for (i = 0; i < items.length; i++) item = items[i], this._cache[item.id] = item;
                    for (i = 0; i < items.length; i++) flow(pipe, item = items[i]);
                } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
            }
        }, {
            key: "flowInDeps",
            value: function flowInDeps(owner, urlList, callback) {
                return LoadingItems.create(this, function(errors, items) {
                    callback(errors, items), items.destroy();
                }).append(urlList, owner);
            }
        }, {
            key: "flowOut",
            value: function flowOut(item) {
                item.error ? delete this._cache[item.id] : this._cache[item.id] || (this._cache[item.id] = item), 
                item.complete = !0, LoadingItems.itemComplete(item);
            }
        }, {
            key: "copyItemStates",
            value: function copyItemStates(srcItem, dstItems) {
                if (dstItems instanceof Array) for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states; else dstItems.states = srcItem.states;
            }
        }, {
            key: "getItem",
            value: function getItem(id) {
                var item = this._cache[id];
                return item && item.alias && (item = item.alias), item;
            }
        }, {
            key: "removeItem",
            value: function removeItem(id) {
                var removed = this._cache[id];
                removed && removed.complete && delete this._cache[id];
                return removed;
            }
        }, {
            key: "clear",
            value: function clear$$1() {
                for (var id in this._cache) {
                    var item = this._cache[id];
                    delete this._cache[id], item.complete || (item.error = new Error("Canceled manually"), 
                    this.flowOut(item));
                }
            }
        } ]), Pipeline;
    }();
    Pipeline.ItemState = ItemState$1, cc.Pipeline = Pipeline;
    var JsonUnpacker = function() {
        function JsonUnpacker() {
            _classCallCheck(this, JsonUnpacker), this.jsons = {};
        }
        return _createClass(JsonUnpacker, [ {
            key: "load",
            value: function load(indices, packedJson) {
                packedJson.length !== indices.length && cc.errorID(4915);
                for (var i = 0; i < indices.length; i++) {
                    var key = indices[i], json = packedJson[i];
                    this.jsons[key] = json;
                }
            }
        }, {
            key: "retrieve",
            value: function retrieve(key) {
                return this.jsons[key] || null;
            }
        } ]), JsonUnpacker;
    }(), TextureUnpacker = function() {
        function TextureUnpacker() {
            _classCallCheck(this, TextureUnpacker), this.contents = {};
        }
        return _createClass(TextureUnpacker, [ {
            key: "load",
            value: function load(indices, packedJson) {
                var datas = packedJson.data;
                datas.length !== indices.length && cc.errorID(4915);
                for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = {
                    base: datas[i][0],
                    mipmaps: datas[i][1]
                };
            }
        }, {
            key: "retrieve",
            value: function retrieve(key) {
                var content = this.contents[key];
                return content ? {
                    __type__: cc.js._getClassId(cc.Texture2D),
                    content: content
                } : null;
            }
        } ]), TextureUnpacker;
    }();
    var PackState = {
        Invalid: 0,
        Removed: 1,
        Downloading: 2,
        Loaded: 3
    };
    function UnpackerData() {
        this.unpacker = null, this.state = PackState.Invalid;
    }
    var uuidToPack = {}, packIndices = {}, globalUnpackers = {};
    function error$1(uuid, packUuid) {
        return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
    }
    function initPacks(packs) {
        for (var packUuid in packIndices = packs) for (var uuids = packs[packUuid], i = 0; i < uuids.length; i++) {
            var uuid = uuids[i], pushFront = 1 === uuids.length;
            pushToMap(uuidToPack, uuid, packUuid, pushFront);
        }
    }
    function _loadNewPack(uuid, packUuid, callback) {
        var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
        cc.loader.load({
            url: packUrl,
            ignoreMaxConcurrency: !0
        }, function(err, packJson) {
            if (err) return cc.errorID(4916, uuid), callback(err);
            var res = _doLoadNewPack(uuid, packUuid, packJson);
            res ? callback(null, res) : callback(error$1(uuid, packUuid));
        });
    }
    function _doPreload(packUuid, packJson) {
        var unpackerData = globalUnpackers[packUuid];
        unpackerData || ((unpackerData = globalUnpackers[packUuid] = new UnpackerData()).state = PackState.Downloading), 
        unpackerData.state !== PackState.Loaded && (unpackerData.unpacker = new JsonUnpacker(), 
        unpackerData.unpacker.load(packIndices[packUuid], packJson), unpackerData.state = PackState.Loaded);
    }
    function _doLoadNewPack(uuid, packUuid, packedJson) {
        var unpackerData = globalUnpackers[packUuid];
        return unpackerData.state !== PackState.Loaded && ("string" == typeof packedJson && (packedJson = JSON.parse(packedJson)), 
        Array.isArray(packedJson) ? unpackerData.unpacker = new JsonUnpacker() : packedJson.type === cc.js._getClassId(cc.Texture2D) && (unpackerData.unpacker = new TextureUnpacker()), 
        unpackerData.unpacker.load(packIndices[packUuid], packedJson), unpackerData.state = PackState.Loaded), 
        unpackerData.unpacker.retrieve(uuid);
    }
    function _selectLoadedPack(packUuids) {
        for (var existsPackState = PackState.Invalid, existsPackUuid = "", i = 0; i < packUuids.length; i++) {
            var packUuid = packUuids[i], unpackerData = globalUnpackers[packUuid];
            if (unpackerData) {
                var state = unpackerData.state;
                if (state === PackState.Loaded) return packUuid;
                existsPackState < state && (existsPackState = state, existsPackUuid = packUuid);
            }
        }
        return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
    }
    function load(item, callback) {
        var uuid = item.uuid, packUuid = uuidToPack[uuid];
        if (packUuid) {
            Array.isArray(packUuid) && (packUuid = _selectLoadedPack(packUuid));
            var unpackerData = globalUnpackers[packUuid];
            if (unpackerData && unpackerData.state === PackState.Loaded) {
                var json = unpackerData.unpacker.retrieve(uuid);
                return json || error$1(uuid, packUuid);
            }
            return unpackerData || (console.log("Create unpacker %s for %s", packUuid, uuid), 
            (unpackerData = globalUnpackers[packUuid] = new UnpackerData()).state = PackState.Downloading), 
            _loadNewPack(uuid, packUuid, callback), null;
        }
    }
    var PackDownloader = Object.freeze({
        initPacks: initPacks,
        _loadNewPack: _loadNewPack,
        _doPreload: _doPreload,
        _doLoadNewPack: _doLoadNewPack,
        _selectLoadedPack: _selectLoadedPack,
        load: load
    });
    function downloadBinary(item, callback) {
        var url = item.url, xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
        xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
            var arrayBuffer = xhr.response;
            arrayBuffer ? callback(null, arrayBuffer) : callback({
                status: xhr.status,
                errorMessage: errInfo + "(no response)"
            });
        }, xhr.onerror = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(error)"
            });
        }, xhr.ontimeout = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(time out)"
            });
        }, xhr.send(null);
    }
    var _noCacheRex = /\?/;
    function urlAppendTimestamp(url) {
        return cc.game.config.noCache && "string" == typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date() - 0) : url += "?_t=" + (new Date() - 0)), 
        url;
    }
    function downloadText(item, callback) {
        var url = item.url;
        url = urlAppendTimestamp(url);
        var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url;
        xhr.open("GET", url, !0), xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8"), 
        xhr.onload = function() {
            4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
                status: xhr.status,
                errorMessage: errInfo + "(wrong status)"
            }) : callback({
                status: xhr.status,
                errorMessage: errInfo + "(wrong readyState)"
            });
        }, xhr.onerror = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(error)"
            });
        }, xhr.ontimeout = function() {
            callback({
                status: xhr.status,
                errorMessage: errInfo + "(time out)"
            });
        }, xhr.send(null);
    }
    var buffer, sys = {};
    sys.LANGUAGE_ENGLISH = "en", sys.LANGUAGE_CHINESE = "zh", sys.LANGUAGE_FRENCH = "fr", 
    sys.LANGUAGE_ITALIAN = "it", sys.LANGUAGE_GERMAN = "de", sys.LANGUAGE_SPANISH = "es", 
    sys.LANGUAGE_DUTCH = "du", sys.LANGUAGE_RUSSIAN = "ru", sys.LANGUAGE_KOREAN = "ko", 
    sys.LANGUAGE_JAPANESE = "ja", sys.LANGUAGE_HUNGARIAN = "hu", sys.LANGUAGE_PORTUGUESE = "pt", 
    sys.LANGUAGE_ARABIC = "ar", sys.LANGUAGE_NORWEGIAN = "no", sys.LANGUAGE_POLISH = "pl", 
    sys.LANGUAGE_TURKISH = "tr", sys.LANGUAGE_UKRAINIAN = "uk", sys.LANGUAGE_ROMANIAN = "ro", 
    sys.LANGUAGE_BULGARIAN = "bg", sys.LANGUAGE_UNKNOWN = "unknown", sys.OS_IOS = "iOS", 
    sys.OS_ANDROID = "Android", sys.OS_WINDOWS = "Windows", sys.OS_MARMALADE = "Marmalade", 
    sys.OS_LINUX = "Linux", sys.OS_BADA = "Bada", sys.OS_BLACKBERRY = "Blackberry", 
    sys.OS_OSX = "OS X", sys.OS_WP8 = "WP8", sys.OS_WINRT = "WINRT", sys.OS_UNKNOWN = "Unknown", 
    sys.UNKNOWN = -1, sys.WIN32 = 0, sys.LINUX = 1, sys.MACOS = 2, sys.ANDROID = 3, 
    sys.IPHONE = 4, sys.IPAD = 5, sys.BLACKBERRY = 6, sys.NACL = 7, sys.EMSCRIPTEN = 8, 
    sys.TIZEN = 9, sys.WINRT = 10, sys.WP8 = 11, sys.MOBILE_BROWSER = 100, sys.DESKTOP_BROWSER = 101, 
    sys.EDITOR_PAGE = 102, sys.EDITOR_CORE = 103, sys.WECHAT_GAME = 104, sys.QQ_PLAY = 105, 
    sys.BROWSER_TYPE_WECHAT = "wechat", sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame", 
    sys.BROWSER_TYPE_WECHAT_GAME_SUB = "wechatgamesub", sys.BROWSER_TYPE_QQ_PLAY = "qqplay", 
    sys.BROWSER_TYPE_ANDROID = "androidbrowser", sys.BROWSER_TYPE_IE = "ie", sys.BROWSER_TYPE_QQ = "qqbrowser", 
    sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", sys.BROWSER_TYPE_UC = "ucbrowser", sys.BROWSER_TYPE_UCBS = "ucbs", 
    sys.BROWSER_TYPE_360 = "360browser", sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", 
    sys.BROWSER_TYPE_BAIDU = "baidubrowser", sys.BROWSER_TYPE_MAXTHON = "maxthon", sys.BROWSER_TYPE_OPERA = "opera", 
    sys.BROWSER_TYPE_OUPENG = "oupeng", sys.BROWSER_TYPE_MIUI = "miuibrowser", sys.BROWSER_TYPE_FIREFOX = "firefox", 
    sys.BROWSER_TYPE_SAFARI = "safari", sys.BROWSER_TYPE_CHROME = "chrome", sys.BROWSER_TYPE_LIEBAO = "liebao", 
    sys.BROWSER_TYPE_QZONE = "qzone", sys.BROWSER_TYPE_SOUGOU = "sogou", sys.BROWSER_TYPE_UNKNOWN = "unknown", 
    sys.isNative = !1, sys.isBrowser = "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "object" === ("undefined" == typeof document ? "undefined" : _typeof(document)) && !0, 
    sys.isLittleEndian = (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
    256 === new Int16Array(buffer)[0]);
    var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement, ua = nav.userAgent.toLowerCase();
    sys.isMobile = /mobile|android|iphone|ipad/.test(ua), sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
    var currLanguage = nav.language;
    currLanguage = (currLanguage = currLanguage || nav.browserLanguage) ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH, 
    sys.language = currLanguage;
    var isAndroid = !1, iOS = !1, osVersion = "", osMainVersion = 0, uaResult = /android (\d+(?:\.\d+)+)/i.exec(ua) || /android (\d+(?:\.\d+)+)/i.exec(nav.platform);
    uaResult && (isAndroid = !0, osVersion = uaResult[1] || "", osMainVersion = parseInt(osVersion) || 0), 
    (uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua)) ? (iOS = !0, osVersion = uaResult[2] || "", 
    osMainVersion = parseInt(osVersion) || 0) : /(iPhone|iPad|iPod)/.exec(nav.platform) && (iOS = !0, 
    osVersion = "", osMainVersion = 0);
    var osName = sys.OS_UNKNOWN;
    -1 !== nav.appVersion.indexOf("Win") ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : -1 !== nav.appVersion.indexOf("Mac") ? osName = sys.OS_OSX : -1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux") ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : -1 === nav.appVersion.indexOf("Linux") && -1 === ua.indexOf("ubuntu") || (osName = sys.OS_LINUX), 
    sys.os = osName, sys.osVersion = osVersion, sys.osMainVersion = osMainVersion, sys.browserType = sys.BROWSER_TYPE_UNKNOWN, 
    function() {
        var browserTypes = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i.exec(ua);
        browserTypes || (browserTypes = /qqbrowser|ucbrowser/i.exec(ua)), browserTypes || (browserTypes = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i.exec(ua));
        var browserType = browserTypes ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN;
        "micromessenger" === browserType ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid ? browserType = sys.BROWSER_TYPE_ANDROID : "qq" === browserType && ua.match(/android.*applewebkit/i) ? browserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr/" === browserType && (browserType = sys.BROWSER_TYPE_OPERA), 
        sys.browserType = browserType;
    }(), sys.browserVersion = "", (tmp = ua.match(/(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui)(mobile)?(browser)?\/?([\d.]+)/i)) || (tmp = ua.match(/(qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i)), 
    sys.browserVersion = tmp ? tmp[4] : "";
    var _w3 = window.innerWidth || document.documentElement.clientWidth, _h3 = window.innerHeight || document.documentElement.clientHeight, _ratio3 = window.devicePixelRatio || 1;
    sys.windowPixelResolution = {
        width: _ratio3 * _w3,
        height: _ratio3 * _h3
    }, sys._checkWebGLRenderMode = function() {
        if (cc.game.renderType !== cc.game.RENDER_TYPE_WEBGL) throw new Error("This feature supports WebGL render mode only.");
    };
    var _tmpCanvas1 = document.createElement("canvas");
    try {
        var localStorage = sys.localStorage = win.localStorage;
        localStorage.setItem("storage", ""), localStorage.removeItem("storage"), localStorage = null;
    } catch (e) {
        var warn$1 = function warn() {
            cc.warnID(5200);
        };
        sys.localStorage = {
            getItem: warn$1,
            setItem: warn$1,
            removeItem: warn$1,
            clear: warn$1
        };
    }
    var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp"), _supportCanvas = !!_tmpCanvas1.getContext("2d"), _supportWebGL = !1;
    if (sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME) _supportWebGL = !0; else if (win.WebGLRenderingContext && (function create3DContext(canvas, opt_attribs, opt_contextType) {
        if (!opt_contextType) return create3DContext(canvas, opt_attribs, "webgl") || create3DContext(canvas, opt_attribs, "experimental-webgl") || create3DContext(canvas, opt_attribs, "webkit-3d") || create3DContext(canvas, opt_attribs, "moz-webgl") || null;
        try {
            return canvas.getContext(opt_contextType, opt_attribs);
        } catch (e) {
            return null;
        }
    }(document.createElement("CANVAS")) && (_supportWebGL = !0), _supportWebGL && sys.os === sys.OS_ANDROID)) {
        var browserVer = parseFloat(sys.browserVersion);
        switch (sys.browserType) {
          case sys.BROWSER_TYPE_MOBILE_QQ:
          case sys.BROWSER_TYPE_BAIDU:
          case sys.BROWSER_TYPE_BAIDU_APP:
            _supportWebGL = 6.2 <= browserVer;
            break;

          case sys.BROWSER_TYPE_ANDROID:
            sys.osMainVersion && 5 <= sys.osMainVersion && (_supportWebGL = !0);
            break;

          case sys.BROWSER_TYPE_CHROME:
            _supportWebGL = 30 <= browserVer;
            break;

          case sys.BROWSER_TYPE_UC:
            _supportWebGL = 11 < browserVer;
            break;

          case sys.BROWSER_TYPE_360:
            _supportWebGL = !1;
        }
    }
    var __audioSupport, _capabilities = sys.capabilities = {
        canvas: _supportCanvas,
        opengl: _supportWebGL,
        webp: _supportWebp
    };
    (void 0 !== docEle.ontouchstart || void 0 !== doc.ontouchstart || nav.msPointerEnabled) && (_capabilities.touches = !0), 
    void 0 !== docEle.onmouseup && (_capabilities.mouse = !0), void 0 !== docEle.onkeyup && (_capabilities.keyboard = !0), 
    (win.DeviceMotionEvent || win.DeviceOrientationEvent) && (_capabilities.accelerometer = !0), 
    supportWebAudio = sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME && !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext), 
    __audioSupport = {
        ONLY_ONE: !1,
        WEB_AUDIO: supportWebAudio,
        DELAY_CREATE_CTX: !1
    }, sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata"), 
    sys.browserType === sys.BROWSER_TYPE_FIREFOX && (__audioSupport.DELAY_CREATE_CTX = !0, 
    __audioSupport.USE_LOADER_EVENT = "canplay"), sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = !0);
    try {
        __audioSupport.WEB_AUDIO && (__audioSupport._context = null, Object.defineProperty(__audioSupport, "context", {
            get: function get() {
                return this._context ? this._context : this._context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
            }
        }));
    } catch (error) {
        __audioSupport.WEB_AUDIO = !1, cc.logID(5201);
    }
    var audio, supportWebAudio, tmp, formatSupport = [];
    (audio = document.createElement("audio")).canPlayType && (audio.canPlayType('audio/ogg; codecs="vorbis"') && formatSupport.push(".ogg"), 
    audio.canPlayType("audio/mpeg") && formatSupport.push(".mp3"), audio.canPlayType('audio/wav; codecs="1"') && formatSupport.push(".wav"), 
    audio.canPlayType("audio/mp4") && formatSupport.push(".mp4"), audio.canPlayType("audio/x-m4a") && formatSupport.push(".m4a")), 
    __audioSupport.format = formatSupport, sys.__audioSupport = __audioSupport, sys.NetworkType = {
        NONE: 0,
        LAN: 1,
        WWAN: 2
    }, sys.getNetworkType = function() {
        return sys.NetworkType.LAN;
    }, sys.getBatteryLevel = function() {
        return 1;
    }, sys.garbageCollect = function() {}, sys.dumpRoot = function() {}, sys.restartVM = function() {}, 
    sys.cleanScript = function(jsfile) {}, sys.isObjectValid = function(obj) {
        return !!obj;
    }, sys.dump = function() {
        var str = "";
        str += "isMobile : " + this.isMobile + "\r\n", str += "language : " + this.language + "\r\n", 
        str += "browserType : " + this.browserType + "\r\n", str += "browserVersion : " + this.browserVersion + "\r\n", 
        str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", str += "os : " + this.os + "\r\n", 
        str += "osVersion : " + this.osVersion + "\r\n", str += "platform : " + this.platform + "\r\n", 
        str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n", 
        cc.log(str);
    }, sys.openURL = function(url) {
        window.open(url);
    }, sys.now = function() {
        return Date.now ? Date.now() : +new Date();
    }, cc.sys = sys;
    var PlayingState = {
        INITIALIZING: 0,
        PLAYING: 1,
        STOPPED: 2
    }, AudioPlayer = function() {
        function AudioPlayer(info) {
            _classCallCheck(this, AudioPlayer), this._state = PlayingState.STOPPED, this._duration = 0, 
            this._eventTarget = void 0, this._duration = info.duration, this._eventTarget = info.eventTarget;
        }
        return _createClass(AudioPlayer, [ {
            key: "getState",
            value: function getState() {
                return this._state;
            }
        }, {
            key: "destroy",
            value: function destroy() {}
        } ]), AudioPlayer;
    }(), AudioPlayerDOM = function(_AudioPlayer) {
        function AudioPlayerDOM(info) {
            var _this;
            return _classCallCheck(this, AudioPlayerDOM), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerDOM).call(this, info)))._volume = 1, 
            _this._loop = !1, _this._oneShoting = !1, _this._audio = void 0, _this._post_play = void 0, 
            _this._on_gesture = void 0, _this._alreadyDelayed = !1, _this._audio = info.clip, 
            _this._post_play = function() {
                _this._state = PlayingState.PLAYING, _this._eventTarget.emit("started");
            }, _this._on_gesture = function() {
                if (_this._audio) {
                    var promise = _this._audio.play();
                    promise ? promise.then(function() {
                        _this._alreadyDelayed ? _this._post_play() : (_this._audio.pause(), _this._audio.currentTime = 0), 
                        window.removeEventListener("touchend", _this._on_gesture), document.removeEventListener("mouseup", _this._on_gesture);
                    }) : console.warn("no promise returned from HTMLMediaElement.play()");
                }
            }, _this._audio.volume = _this._volume, _this._audio.loop = _this._loop, _this._audio.addEventListener("ended", function() {
                _this._oneShoting || (_this._state = PlayingState.STOPPED, _this._audio.currentTime = 0, 
                _this._eventTarget.emit("ended"));
            }), window.addEventListener("touchend", _this._on_gesture), document.addEventListener("mouseup", _this._on_gesture), 
            _this;
        }
        return _inherits(AudioPlayerDOM, AudioPlayer), _createClass(AudioPlayerDOM, [ {
            key: "play",
            value: function play() {
                var _this2 = this;
                if (this._audio && this._state !== PlayingState.PLAYING) {
                    var promise = this._audio.play();
                    promise ? promise.then(this._post_play).catch(function() {
                        _this2._alreadyDelayed = !0;
                    }) : console.warn("no promise returned from HTMLMediaElement.play()");
                }
            }
        }, {
            key: "pause",
            value: function pause() {
                this._audio && this._state === PlayingState.PLAYING && (this._audio.pause(), this._state = PlayingState.STOPPED, 
                this._oneShoting = !1);
            }
        }, {
            key: "stop",
            value: function stop() {
                this._audio && (this._audio.currentTime = 0, this._state === PlayingState.PLAYING && (this._audio.pause(), 
                this._state = PlayingState.STOPPED, this._oneShoting = !1));
            }
        }, {
            key: "playOneShot",
            value: function playOneShot() {
                var _this3 = this, volume = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, clip = this._audio;
                clip && (clip.currentTime = 0, clip.volume = volume, this._oneShoting || (clip.loop = !1, 
                this._oneShoting = !0, clip.play().then(function() {
                    clip.addEventListener("ended", function() {
                        clip.currentTime = 0, clip.volume = _this3._volume, clip.loop = _this3._loop, _this3._oneShoting = !1;
                    }, {
                        once: !0
                    });
                }).catch(function() {
                    _this3._oneShoting = !1;
                })));
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._audio && (this._audio.currentTime = val);
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._audio ? this._audio.currentTime : 0;
            }
        }, {
            key: "getDuration",
            value: function getDuration() {
                return this._audio ? isNaN(this._audio.duration) ? this._duration : this._audio.duration : this._duration;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._volume = val, this._audio && (this._audio.volume = val);
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._audio ? this._audio.volume : this._volume;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._loop = val, this._audio && (this._audio.loop = val);
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return this._loop;
            }
        } ]), AudioPlayerDOM;
    }(), audioSupport = sys.__audioSupport, AudioPlayerWeb = function(_AudioPlayer) {
        function AudioPlayerWeb(info) {
            var _this;
            return _classCallCheck(this, AudioPlayerWeb), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerWeb).call(this, info)))._startTime = 0, 
            _this._offset = 0, _this._volume = 1, _this._loop = !1, _this._currentTimer = 0, 
            _this._audio = void 0, _this._context = void 0, _this._sourceNode = void 0, _this._gainNode = void 0, 
            _this._on_ended = void 0, _this._do_play = void 0, _this._on_gesture = void 0, _this._alreadyDelayed = !1, 
            _this._audio = info.clip, _this._context = audioSupport.context, _this._sourceNode = _this._context.createBufferSource(), 
            _this._gainNode = _this._context.createGain(), _this._gainNode.connect(_this._context.destination), 
            _this._on_ended = function() {
                _this._offset = 0, _this._startTime = _this._context.currentTime, _this._sourceNode.loop || (_this._eventTarget.emit("ended"), 
                _this._state = PlayingState.STOPPED);
            }, _this._do_play = function() {
                _this._sourceNode = _this._context.createBufferSource(), _this._sourceNode.buffer = _this._audio, 
                _this._sourceNode.loop = _this._loop, _this._sourceNode.connect(_this._gainNode), 
                _this._sourceNode.start(0, _this._offset), _this._state = PlayingState.PLAYING, 
                _this._startTime = _this._context.currentTime, cc.director.once(cc.Director.EVENT_AFTER_UPDATE, function() {
                    _this._eventTarget.emit("started");
                }), clearInterval(_this._currentTimer), _this._currentTimer = window.setInterval(function() {
                    _this._on_ended(), clearInterval(_this._currentTimer), _this._sourceNode.loop && (_this._currentTimer = window.setInterval(_this._on_ended, 1e3 * _this._audio.duration));
                }, 1e3 * (_this._audio.duration - _this._offset));
            }, _this._on_gesture = function() {
                _this._context.resume().then(function() {
                    _this._alreadyDelayed && _this._do_play(), window.removeEventListener("touchend", _this._on_gesture), 
                    document.removeEventListener("mouseup", _this._on_gesture);
                });
            }, "running" === _this._context.state ? _possibleConstructorReturn(_this) : (window.addEventListener("touchend", _this._on_gesture), 
            document.addEventListener("mouseup", _this._on_gesture), _this);
        }
        return _inherits(AudioPlayerWeb, AudioPlayer), _createClass(AudioPlayerWeb, [ {
            key: "play",
            value: function play() {
                this._audio && this._state !== PlayingState.PLAYING && ("running" === this._context.state ? this._do_play() : this._alreadyDelayed = !0);
            }
        }, {
            key: "pause",
            value: function pause() {
                this._state === PlayingState.PLAYING && (this._sourceNode.stop(), this._offset += this._context.currentTime - this._startTime, 
                this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
            }
        }, {
            key: "stop",
            value: function stop() {
                this._offset = 0, this._state === PlayingState.PLAYING && (this._sourceNode.stop(), 
                this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
            }
        }, {
            key: "playOneShot",
            value: function playOneShot() {
                var volume = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
                if (this._audio) {
                    var gainNode = this._context.createGain();
                    gainNode.connect(this._context.destination), gainNode.gain.value = volume;
                    var sourceNode = this._context.createBufferSource();
                    sourceNode.buffer = this._audio, sourceNode.loop = !1, sourceNode.connect(gainNode), 
                    sourceNode.start();
                }
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._offset = val, this._state === PlayingState.PLAYING && (this._sourceNode.stop(), 
                this._do_play());
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._state !== PlayingState.PLAYING ? this._offset : this._context.currentTime - this._startTime + this._offset;
            }
        }, {
            key: "getDuration",
            value: function getDuration() {
                return this._audio ? this._audio.duration : 0;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._volume = val, !immediate && this._gainNode.gain.setTargetAtTime ? this._gainNode.gain.setTargetAtTime(val, this._context.currentTime, .01) : this._gainNode.gain.value = val;
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._volume;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._loop = val, this._sourceNode.loop = val;
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return this._loop;
            }
        } ]), AudioPlayerWeb;
    }(), Details = function() {
        function Details() {
            _classCallCheck(this, Details), this.assignAssetsBy = void 0, this.uuidList = void 0, 
            this.uuidObjList = void 0, this.uuidPropList = void 0, this._stillUseUrl = void 0, 
            this.uuidList = [], this.uuidObjList = [], this.uuidPropList = [], this._stillUseUrl = createMap(!0);
        }
        return _createClass(Details, [ {
            key: "reset",
            value: function reset() {
                this.uuidList.length = 0, this.uuidObjList.length = 0, this.uuidPropList.length = 0, 
                clear(this._stillUseUrl);
            }
        }, {
            key: "push",
            value: function push(obj, propName, uuid, _stillUseUrl) {
                _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = !0), this.uuidList.push(uuid), 
                this.uuidObjList.push(obj), this.uuidPropList.push(propName);
            }
        } ]), Details;
    }();
    function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue, stillUseUrl) {
        if (defaultValue instanceof cc.ValueType) {
            assumeHavePropIfIsValue || sources.push("if(prop){");
            var ctorCode = getClassName(defaultValue);
            sources.push("s._deserializeTypedObject(o".concat(accessorToSet, ",prop,").concat(ctorCode, ");")), 
            assumeHavePropIfIsValue || sources.push("}else o" + accessorToSet + "=null;");
        } else sources.push("if(prop){"), sources.push("s._deserializeObjField(o,prop," + propNameLiteralToSet + ",null," + !!stillUseUrl + ");"), 
        sources.push("}else o" + accessorToSet + "=null;");
    }
    Details.pool = void 0, Details.pool = new Pool(function(obj) {
        obj.reset();
    }, 10), Details.pool.get = function() {
        return this._get() || new Details();
    };
    var compileDeserialize = function(self, klass) {
        for (var TYPE = DELIMETER + "type", DEFAULT = DELIMETER + "default", SAVE_URL_AS_ASSET = DELIMETER + "saveUrlAsAsset", FORMERLY_SERIALIZED_AS = DELIMETER + "formerlySerializedAs", attrs = getClassAttrs(klass), props = klass.__values__, sources = [ "var prop;" ], fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass)), p = 0; p < props.length; p++) {
            var propName = props[p];
            0;
            var accessorToSet = void 0, propNameLiteralToSet = void 0, accessorToGet = accessorToSet = CCClass.IDENTIFIER_RE.test(propName) ? (propNameLiteralToSet = '"' + propName + '"', 
            "." + propName) : "[" + (propNameLiteralToSet = CCClass.escapeForJS(propName)) + "]";
            if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
                var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];
                accessorToGet = CCClass.IDENTIFIER_RE.test(propNameToRead) ? "." + propNameToRead : "[" + CCClass.escapeForJS(propNameToRead) + "]";
            }
            sources.push("prop=d" + accessorToGet + ";"), sources.push("if(typeof ".concat("prop", '!=="undefined"){'));
            var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET], defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
            if (fastMode) {
                var isPrimitiveType = void 0, userType = attrs[propName + TYPE];
                if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
                    var defaultType = _typeof(defaultValue);
                    isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
                }
                isPrimitiveType ? sources.push("o".concat(accessorToSet, "=prop;")) : compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, !0, stillUseUrl);
            } else sources.push("if(typeof ".concat("prop", '!=="object"){') + "o" + accessorToSet + "=prop;}else{"), 
            compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, !1, stillUseUrl), 
            sources.push("}");
            sources.push("}");
        }
        (cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component)) && sources.push("d._id&&(o._id=d._id);");
        return "_$erialized" === props[props.length - 1] && (sources.push("o._$erialized=JSON.parse(JSON.stringify(d));"), 
        sources.push("s._deserializePrimitiveObject(o._$erialized,d);")), Function("s", "o", "d", "k", "t", sources.join(""));
    };
    function _deserializeFireClass(self, obj, serialized, klass, target) {
        var deserialize;
        klass.hasOwnProperty("__deserialize__") ? deserialize = klass.__deserialize__ : (deserialize = compileDeserialize(self, klass), 
        value(klass, "__deserialize__", deserialize, !0)), deserialize(self, obj, serialized, klass, target);
    }
    var _Deserializer = function() {
        function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
            _classCallCheck(this, _Deserializer), this.result = void 0, this.customEnv = void 0, 
            this.deserializedList = void 0, this.deserializedData = void 0, this._classFinder = void 0, 
            this._target = void 0, this._ignoreEditorOnly = void 0, this._idList = void 0, this._idObjList = void 0, 
            this._idPropList = void 0, this.result = result, this.customEnv = customEnv, this.deserializedList = [], 
            this.deserializedData = null, this._classFinder = classFinder, this._idList = [], 
            this._idObjList = [], this._idPropList = [];
        }
        return _createClass(_Deserializer, [ {
            key: "deserialize",
            value: function deserialize(jsonObj) {
                if (Array.isArray(jsonObj)) {
                    var jsonArray = jsonObj, refCount = jsonArray.length;
                    this.deserializedList.length = refCount;
                    for (var i = 0; i < refCount; i++) {
                        if (jsonArray[i]) this.deserializedList[i] = this._deserializeObject(jsonArray[i], !1);
                    }
                    this.deserializedData = 0 < refCount ? this.deserializedList[0] : [];
                } else this.deserializedList.length = 1, this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, !1) : null, 
                this.deserializedList[0] = this.deserializedData;
                return function _dereference(self) {
                    var i, propName, id, deserializedList = self.deserializedList, idPropList = self._idPropList, idList = self._idList, idObjList = self._idObjList;
                    for (self._classFinder && self._classFinder.onDereferenced, i = 0; i < idList.length; i++) propName = idPropList[i], 
                    id = idList[i], idObjList[i][propName] = deserializedList[id];
                }(this), this.deserializedData;
            }
        }, {
            key: "_deserializeObject",
            value: function _deserializeObject(serialized, _stillUseUrl, target, owner, propName) {
                var prop, obj = null, klass = null, type = serialized.__type__;
                if (type) {
                    var deserializeByType = function deserializeByType() {
                        (obj = new klass())._deserialize ? obj._deserialize(serialized.content, self) : cc.Class._isCCClass(klass) ? _deserializeFireClass(self, obj, serialized, klass, target) : self._deserializeTypedObject(obj, serialized, klass);
                    };
                    if (!(klass = this._classFinder(type, serialized, owner, propName))) return this._classFinder === _getClassById && cc.deserialize.reportMissingClass(type), 
                    null;
                    var self = this;
                    deserializeByType();
                } else if (Array.isArray(serialized)) {
                    obj = new Array(serialized.length);
                    for (var i = 0; i < serialized.length; i++) "object" === _typeof(prop = serialized[i]) && prop ? this._deserializeObjField(obj, prop, "" + i, null, _stillUseUrl) : obj[i] = prop;
                } else obj = {}, this._deserializePrimitiveObject(obj, serialized);
                return obj;
            }
        }, {
            key: "_deserializeObjField",
            value: function _deserializeObjField(obj, jsonObj, propName, target, _stillUseUrl) {
                var id = jsonObj.__id__;
                if (void 0 === id) {
                    var uuid = jsonObj.__uuid__;
                    uuid ? this.result.push(obj, propName, uuid, _stillUseUrl) : obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
                } else {
                    var dObj = this.deserializedList[id];
                    dObj ? obj[propName] = dObj : (this._idList.push(id), this._idObjList.push(obj), 
                    this._idPropList.push(propName));
                }
            }
        }, {
            key: "_deserializePrimitiveObject",
            value: function _deserializePrimitiveObject(instance, serialized) {
                for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
                    var prop = serialized[propName];
                    "object" !== _typeof(prop) ? "__type__" !== propName && (instance[propName] = prop) : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null;
                }
            }
        }, {
            key: "_deserializeTypedObject",
            value: function _deserializeTypedObject(instance, serialized, klass) {
                var fastDefinedProps = klass.__props__;
                fastDefinedProps || (fastDefinedProps = Object.keys(instance));
                for (var i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i], prop = serialized[propName];
                    void 0 !== prop && serialized.hasOwnProperty(propName) && ("object" !== _typeof(prop) ? instance[propName] = prop : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null);
                }
            }
        } ]), _Deserializer;
    }();
    function deserialize(data, details, options) {
        var classFinder = (options = options || {}).classFinder || _getClassById, createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE, customEnv = options.customEnv, ignoreEditorOnly = options.ignoreEditorOnly;
        "string" == typeof data && (data = JSON.parse(data));
        var tempDetails = !details;
        details = details || Details.pool.get();
        var deserializer = _Deserializer.pool.get(details, !1, classFinder, customEnv, ignoreEditorOnly);
        cc.game._isCloning = !0;
        var res = deserializer.deserialize(data);
        return cc.game._isCloning = !1, _Deserializer.pool.put(deserializer), createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset), 
        tempDetails && Details.pool.put(details), res;
    }
    _Deserializer.pool = void 0, _Deserializer.pool = new Pool(function(obj) {
        obj.result = null, obj.customEnv = null, obj.deserializedList.length = 0, obj.deserializedData = null, 
        obj._classFinder = null, obj._idList.length = 0, obj._idObjList.length = 0, obj._idPropList.length = 0;
    }, 1), _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
        var cache = this._get();
        return cache ? (cache.result = result, cache.customEnv = customEnv, cache._classFinder = classFinder, 
        cache) : new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
    }, deserialize.Details = Details, deserialize.reportMissingClass = function(id) {
        cc.warnID(5302, id);
    }, cc.deserialize = deserialize;
    var _class$6, Destroyed$2 = CCObject.Flags.Destroyed, PersistentMask$2 = CCObject.Flags.PersistentMask, objsToClearTmpVar = [];
    function instantiate(original, internal_force) {
        if (!internal_force) {
            if ("object" !== _typeof(original) || Array.isArray(original)) return null;
            if (!original) return null;
            if (!cc.isValid(original)) return null;
            0;
        }
        var clone;
        if (original instanceof CCObject) {
            if (original._instantiate) return cc.game._isCloning = !0, clone = original._instantiate(), 
            cc.game._isCloning = !1, clone;
            if (original instanceof cc.Asset) return null;
        }
        return cc.game._isCloning = !0, clone = doInstantiate(original), cc.game._isCloning = !1, 
        clone;
    }
    function doInstantiate(obj, parent) {
        if (Array.isArray(obj)) return null;
        if (isDomNode(obj)) return null;
        var clone;
        if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
            clone = new obj.constructor();
        } else clone = Object.create(null);
        enumerateObject(obj, clone, parent);
        for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
        return objsToClearTmpVar.length = 0, clone;
    }
    function enumerateObject(obj, clone, parent) {
        obj._iN$t = clone, objsToClearTmpVar.push(obj);
        var klass = obj.constructor;
        if (cc.Class._isCCClass(klass)) !function enumerateCCClass(klass, obj, clone, parent) {
            for (var props = klass.__values__, p = 0; p < props.length; p++) {
                var key = props[p], value = obj[key];
                if ("object" === _typeof(value) && value) {
                    var initValue = clone[key];
                    initValue instanceof ValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
                } else clone[key] = value;
            }
        }(klass, obj, clone, parent); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
            var value = obj[key];
            if ("object" === _typeof(value) && value) {
                if (value === clone) continue;
                clone[key] = value._iN$t || instantiateObj(value, parent);
            } else clone[key] = value;
        }
        obj instanceof CCObject && (clone._objFlags &= PersistentMask$2);
    }
    function instantiateObj(obj, parent) {
        if (obj instanceof ValueType) return obj.clone();
        if (obj instanceof cc.Asset) return obj;
        var clone;
        if (Array.isArray(obj)) {
            var len = obj.length;
            clone = new Array(len), obj._iN$t = clone;
            for (var i = 0; i < len; ++i) {
                var value = obj[i];
                "object" === _typeof(value) && value ? clone[i] = value._iN$t || instantiateObj(value, parent) : clone[i] = value;
            }
            return objsToClearTmpVar.push(obj), clone;
        }
        if (obj._objFlags & Destroyed$2) return null;
        var ctor = obj.constructor;
        if (cc.Class._isCCClass(ctor)) {
            if (parent) if (parent instanceof cc.Component) {
                if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
            } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                if (!obj.isChildOf(parent)) return obj;
            } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
            clone = new ctor();
        } else if (ctor === Object) clone = {}; else {
            if (ctor) return obj;
            clone = Object.create(null);
        }
        return enumerateObject(obj, clone, parent), clone;
    }
    instantiate._clone = doInstantiate, cc.instantiate = instantiate, cc._decorator = _decorator;
    var _dec$7, _dec2$3, _class$7, _class2$5, _descriptor$3, _descriptor2$2, _class3$4, _temp$6, AudioPlayerWX = ccclass("cc.AudioPlayerWX")(_class$6 = function(_AudioPlayer) {
        function AudioPlayerWX(info) {
            var _this;
            return _classCallCheck(this, AudioPlayerWX), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerWX).call(this, info)))._volume = 1, 
            _this._loop = !1, _this._oneShoting = !1, _this._audio = void 0, _this._audio = info.clip, 
            _this._audio.obeyMuteSwitch = !1, _this._audio.onPlay(function() {
                _this._state = PlayingState.PLAYING, _this._eventTarget.emit("started");
            }), _this._audio.onPause(function() {
                _this._state = PlayingState.STOPPED, _this._oneShoting = !1;
            }), _this._audio.onStop(function() {
                _this._state = PlayingState.STOPPED, _this._oneShoting = !1;
            }), _this._audio.onEnded(function() {
                _this._state = PlayingState.STOPPED, _this._eventTarget.emit("ended"), _this._oneShoting && (_this._audio.volume = _this._volume, 
                _this._audio.loop = _this._loop, _this._oneShoting = !1);
            }), wx.onShow(function() {
                return _this._audio.play();
            }), wx.onAudioInterruptionEnd(function() {
                return _this._audio.play();
            }), _this;
        }
        return _inherits(AudioPlayerWX, AudioPlayer), _createClass(AudioPlayerWX, [ {
            key: "play",
            value: function play() {
                this._audio && this._state !== PlayingState.PLAYING && this._audio.play();
            }
        }, {
            key: "pause",
            value: function pause() {
                this._audio && this._state === PlayingState.PLAYING && this._audio.pause();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._audio && this._audio.stop();
            }
        }, {
            key: "playOneShot",
            value: function playOneShot() {
                var volume = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
                this._audio && (this._audio.volume = volume, this._oneShoting || (this._audio.loop = !1, 
                this._oneShoting = !0, this._audio.play()));
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._audio ? this._audio.currentTime : 0;
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._audio && this._audio.seek(val);
            }
        }, {
            key: "getDuration",
            value: function getDuration() {
                return this._audio ? this._audio.duration : 0;
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._audio ? this._audio.volume : this._volume;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._volume = val, this._audio && void 0 !== this._audio.volume && (this._audio.volume = val);
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return this._loop;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._loop = val, this._audio && (this._audio.loop = val);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return !!this._audio && (this._audio.destroy(), !0);
            }
        } ]), AudioPlayerWX;
    }()) || _class$6;
    cc.AudioPlayerWX = AudioPlayerWX;
    var AudioType = Enum({
        UNKNOWN_AUDIO: -1,
        WEB_AUDIO: 0,
        DOM_AUDIO: 1,
        WX_GAME_AUDIO: 2
    }), AudioClip = (_dec$7 = ccclass("cc.AudioClip"), _dec2$3 = property({
        type: AudioType
    }), _dec$7((_temp$6 = _class3$4 = function(_Asset) {
        function AudioClip() {
            var _this;
            return _classCallCheck(this, AudioClip), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioClip).call(this)), "_duration", _descriptor$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_loadMode", _descriptor2$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._audio = null, _this._player = null, _this.loaded = !1, _this;
        }
        return _inherits(AudioClip, Asset), _createClass(AudioClip, [ {
            key: "destroy",
            value: function destroy() {
                return this._player && this._player.destroy(), _get(_getPrototypeOf(AudioClip.prototype), "destroy", this).call(this);
            }
        }, {
            key: "play",
            value: function play() {
                this._player && this._player.play();
            }
        }, {
            key: "pause",
            value: function pause() {
                this._player && this._player.pause();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._player && this._player.stop();
            }
        }, {
            key: "playOneShot",
            value: function playOneShot(volume) {
                this._player && this._player.playOneShot(volume);
            }
        }, {
            key: "setCurrentTime",
            value: function setCurrentTime(val) {
                this._player && this._player.setCurrentTime(val);
            }
        }, {
            key: "getCurrentTime",
            value: function getCurrentTime() {
                return this._player ? this._player.getCurrentTime() : 0;
            }
        }, {
            key: "getDuration",
            value: function getDuration() {
                return this._player ? this._player.getDuration() : this._duration;
            }
        }, {
            key: "setVolume",
            value: function setVolume(val, immediate) {
                this._player && this._player.setVolume(val, immediate || !1);
            }
        }, {
            key: "getVolume",
            value: function getVolume() {
                return this._player ? this._player.getVolume() : 1;
            }
        }, {
            key: "setLoop",
            value: function setLoop(val) {
                this._player && this._player.setLoop(val);
            }
        }, {
            key: "getLoop",
            value: function getLoop() {
                return !!this._player && this._player.getLoop();
            }
        }, {
            key: "_nativeAsset",
            set: function set(clip) {
                var ctor;
                (this._audio = clip) ? (clip instanceof AudioBuffer ? (ctor = AudioPlayerWeb, this._loadMode = AudioType.WEB_AUDIO) : (ctor = AudioPlayerDOM, 
                this._loadMode = AudioType.DOM_AUDIO), this._player = new ctor({
                    clip: clip,
                    duration: this._duration,
                    eventTarget: this
                }), this.loaded = !0, this.emit("load")) : (this._player = null, this._loadMode = AudioType.UNKNOWN_AUDIO, 
                this._duration = 0, this.loaded = !1);
            },
            get: function get$$1() {
                return this._audio;
            }
        }, {
            key: "loadMode",
            get: function get$$1() {
                return this._loadMode;
            }
        }, {
            key: "state",
            get: function get$$1() {
                return this._player ? this._player.getState() : PlayingState.INITIALIZING;
            }
        } ]), AudioClip;
    }(), _class3$4.PlayingState = PlayingState, _class3$4.AudioType = AudioType, _class3$4.preventDeferredLoadDependents = !0, 
    _descriptor$3 = _applyDecoratedDescriptor((_class2$5 = _temp$6).prototype, "_duration", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_loadMode", [ _dec2$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return AudioType.UNKNOWN_AUDIO;
        }
    }), _class$7 = _class2$5)) || _class$7);
    cc.AudioClip = AudioClip;
    var __audioSupport$1 = sys.__audioSupport, formatSupport$1 = __audioSupport$1.format;
    function loadDomAudio(item, callback) {
        var dom = document.createElement("audio");
        dom.src = item.url;
        var clearEvent = function clearEvent() {
            clearTimeout(timer), dom.removeEventListener("canplaythrough", success, !1), dom.removeEventListener("error", failure, !1), 
            __audioSupport$1.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
        }, timer = setTimeout(function() {
            0 === dom.readyState ? failure() : success();
        }, 8e3), success = function success() {
            clearEvent(), callback(null, dom);
        }, failure = function failure() {
            clearEvent();
            var message = "load audio failure - " + item.url;
            cc.log(message), callback(message);
        };
        dom.addEventListener("canplaythrough", success, !1), dom.addEventListener("error", failure, !1), 
        __audioSupport$1.USE_LOADER_EVENT && dom.addEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
    }
    function loadWebAudio(item, callback) {
        var context = __audioSupport$1.context;
        context || callback(new Error(getError(4926)));
        var request = cc.loader.getXMLHttpRequest();
        request.open("GET", item.url, !0), request.responseType = "arraybuffer", request.onload = function() {
            context.decodeAudioData(request.response, function(buffer) {
                callback(null, buffer);
            }, function() {
                callback("decode error - " + item.id, null);
            });
        }, request.onerror = function() {
            callback("request error - " + item.id, null);
        }, request.send();
    }
    function downloadAudio(item, callback) {
        if (0 === formatSupport$1.length) return new Error(getError(4927));
        var loader;
        __audioSupport$1.WEB_AUDIO ? loader = item._owner instanceof AudioClip ? item._owner.loadMode === AudioType.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam.useDom ? loadDomAudio : loadWebAudio : loader = loadDomAudio;
        loader(item, callback);
    }
    function skip() {
        return null;
    }
    function downloadScript(item, callback, isAsync) {
        var url = item.url, d = document, s = document.createElement("script");
        function loadHandler() {
            s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), s.removeEventListener("error", errorHandler, !1), 
            callback(null, url);
        }
        function errorHandler() {
            s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), s.removeEventListener("error", errorHandler, !1), 
            callback(new Error(getError(4928, url)));
        }
        s.async = isAsync, s.src = urlAppendTimestamp(url), s.addEventListener("load", loadHandler, !1), 
        s.addEventListener("error", errorHandler, !1), d.body.appendChild(s);
    }
    function downloadImage(item, callback, isCrossOrigin, img) {
        void 0 === isCrossOrigin && (isCrossOrigin = !0);
        var url = urlAppendTimestamp(item.url);
        if (img = img || new Image(), isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null, 
        img.complete && 0 < img.naturalWidth && img.src === url) return img;
        var loadCallback = function loadCallback() {
            img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
            img.id = item.id, callback(null, img);
        }, errorCallback = function errorCallback() {
            img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
            "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, !1, img) : callback(new Error(getError(4930, url)));
        };
        img.addEventListener("load", loadCallback), img.addEventListener("error", errorCallback), 
        img.src = url;
    }
    var defaultMap = {
        js: downloadScript,
        png: downloadImage,
        jpg: downloadImage,
        bmp: downloadImage,
        jpeg: downloadImage,
        gif: downloadImage,
        ico: downloadImage,
        tiff: downloadImage,
        webp: function downloadWebp(item, callback, isCrossOrigin, img) {
            return cc.sys.capabilities.webp ? downloadImage(item, callback, isCrossOrigin, img) : new Error(getError(4929, item.url));
        },
        image: downloadImage,
        pvr: downloadBinary,
        pkm: downloadBinary,
        mp3: downloadAudio,
        ogg: downloadAudio,
        wav: downloadAudio,
        m4a: downloadAudio,
        txt: downloadText,
        xml: downloadText,
        vsh: downloadText,
        fsh: downloadText,
        atlas: downloadText,
        tmx: downloadText,
        tsx: downloadText,
        json: downloadText,
        ExportJson: downloadText,
        plist: downloadText,
        fnt: downloadText,
        font: skip,
        eot: skip,
        ttf: skip,
        woff: skip,
        svg: skip,
        ttc: skip,
        uuid: function downloadUuid(item, callback) {
            var result = load(item, callback);
            return void 0 === result ? this.extMap.json(item, callback) : result || void 0;
        },
        binary: downloadBinary,
        bin: downloadBinary,
        default: downloadText
    }, ID = "Downloader", Downloader = function() {
        function Downloader(extMap) {
            _classCallCheck(this, Downloader), this.id = ID, this.async = !0, this.pipeline = null, 
            this._curConcurrent = 0, this._loadQueue = [], this._subpackages = {}, this.extMap = mixin(extMap, defaultMap);
        }
        return _createClass(Downloader, [ {
            key: "addHandlers",
            value: function addHandlers(extMap) {
                mixin(this.extMap, extMap);
            }
        }, {
            key: "_handleLoadQueue",
            value: function _handleLoadQueue() {
                for (;this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT; ) {
                    var nextOne = this._loadQueue.shift();
                    if (!nextOne) break;
                    var syncRet = this.handle(nextOne.item, nextOne.callback);
                    void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
                }
            }
        }, {
            key: "handle",
            value: function handle(item, callback) {
                var self = this, downloadFunc = this.extMap[item.type] || this.extMap.default, syncRet = void 0;
                if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                    if (this._curConcurrent++, void 0 !== (syncRet = downloadFunc.call(this, item, function(err, result) {
                        self._curConcurrent = Math.max(0, self._curConcurrent - 1), self._handleLoadQueue(), 
                        callback && callback(err, result);
                    }))) return this._curConcurrent = Math.max(0, this._curConcurrent - 1), this._handleLoadQueue(), 
                    syncRet;
                } else if (item.ignoreMaxConcurrency) {
                    if (void 0 !== (syncRet = downloadFunc.call(this, item, callback))) return syncRet;
                } else this._loadQueue.push({
                    item: item,
                    callback: callback
                });
            }
        }, {
            key: "loadSubpackage",
            value: function loadSubpackage(name, completeCallback) {
                var pac = this._subpackages[name];
                pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
                    url: pac.path
                }, function(err) {
                    err || (pac.loaded = !0), completeCallback && completeCallback(err);
                }) : completeCallback && completeCallback(new Error("Can't find subpackage ".concat(name)));
            }
        } ]), Downloader;
    }();
    Downloader.ID = ID, Downloader.PackDownloader = PackDownloader, Pipeline.Downloader = Downloader;
    var SAXParser = function() {
        function SAXParser() {
            _classCallCheck(this, SAXParser), window.DOMParser ? (this._isSupportDOMParser = !0, 
            this._parser = new DOMParser()) : (this._isSupportDOMParser = !1, this._parser = null);
        }
        return _createClass(SAXParser, [ {
            key: "parse",
            value: function parse(xmlTxt) {
                return this._parseXML(xmlTxt);
            }
        }, {
            key: "_parseXML",
            value: function _parseXML(textxml) {
                var xmlDoc;
                return this._isSupportDOMParser ? xmlDoc = this._parser.parseFromString(textxml, "text/xml") : ((xmlDoc = new ActiveXObject("Microsoft.XMLDOM")).async = "false", 
                xmlDoc.loadXML(textxml)), xmlDoc;
            }
        } ]), SAXParser;
    }(), plistParser = new (function(_SAXParser) {
        function PlistParser() {
            return _classCallCheck(this, PlistParser), _possibleConstructorReturn(this, _getPrototypeOf(PlistParser).apply(this, arguments));
        }
        return _inherits(PlistParser, SAXParser), _createClass(PlistParser, [ {
            key: "parse",
            value: function parse(xmlTxt) {
                var xmlDoc = this._parseXML(xmlTxt), plist = xmlDoc.documentElement;
                if ("plist" !== plist.tagName) return cc.warnID(5100), {};
                for (var node = null, i = 0, len = plist.childNodes.length; i < len && 1 !== (node = plist.childNodes[i]).nodeType; i++) ;
                return xmlDoc = null, this._parseNode(node);
            }
        }, {
            key: "_parseNode",
            value: function _parseNode(node) {
                var data = null, tagName = node.tagName;
                if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
                    data = "";
                    for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
                } else "false" === tagName ? data = !1 : "true" === tagName ? data = !0 : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
                return data;
            }
        }, {
            key: "_parseArray",
            value: function _parseArray(node) {
                for (var data = [], i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    1 === child.nodeType && data.push(this._parseNode(child));
                }
                return data;
            }
        }, {
            key: "_parseDict",
            value: function _parseDict(node) {
                for (var data = {}, key = null, i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    1 === child.nodeType && ("key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child));
                }
                return data;
            }
        } ]), PlistParser;
    }())();
    function isSceneObj(json) {
        return json && (json[0] && "cc.Scene" === json[0].__type__ || json[1] && "cc.Scene" === json[1].__type__ || json[0] && "cc.Prefab" === json[0].__type__);
    }
    function loadUuid(item, callback) {
        var json, classFinder;
        if ("string" == typeof item.content) try {
            json = JSON.parse(item.content);
        } catch (e) {
            return new Error(getError(4923, item.id, e.stack));
        } else {
            if ("object" !== _typeof(item.content)) return new Error(getError(4924));
            json = item.content;
        }
        if (null == json) return new Error(getError(4923, item.id));
        var isScene = isSceneObj(json);
        classFinder = isScene ? cc._MissingScript.safeFindClass : function classFinder(id) {
            var cls = _getClassById(id);
            return cls || (cc.warnID(4903, id), Object);
        };
        var asset, tdInfo = cc.deserialize.Details.pool.get();
        try {
            asset = cc.deserialize(json, tdInfo, {
                classFinder: classFinder,
                target: item.existingAsset,
                customEnv: item
            });
        } catch (e) {
            return cc.deserialize.Details.pool.put(tdInfo), console.error(e), new Error("Failed to load asset ".concat(item.id, ", exception occurs during deserialization: ").concat(e.stack, "."));
        }
        asset._uuid = item.uuid;
        var deferredLoad = function canDeferredLoad(asset, item, isScene) {
            var res = item.deferredLoadRaw;
            return res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = !1) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets), 
            res;
        }(asset, item, isScene), depends = function parseDepends(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
            var depends, i, dependUuid, uuidList = tdInfo.uuidList, objList = tdInfo.uuidObjList, propList = tdInfo.uuidPropList, stillUseUrl = tdInfo._stillUseUrl, dependKeys = item.dependKeys = [];
            if (deferredLoadRawAssetsInRuntime) for (depends = [], i = 0; i < uuidList.length; i++) {
                dependUuid = uuidList[i];
                var obj = objList[i], prop = propList[i], info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
                if (info.raw) {
                    var url = info.url;
                    obj[prop] = url, dependKeys.push(url);
                } else depends.push({
                    type: "uuid",
                    uuid: dependUuid,
                    deferredLoadRaw: !0,
                    _owner: obj,
                    _ownerProp: prop,
                    _stillUseUrl: stillUseUrl[i]
                });
            } else {
                for (depends = new Array(uuidList.length), i = 0; i < uuidList.length; i++) dependUuid = uuidList[i], 
                depends[i] = {
                    type: "uuid",
                    uuid: dependUuid,
                    _owner: objList[i],
                    _ownerProp: propList[i],
                    _stillUseUrl: stillUseUrl[i]
                };
                asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
                    url: asset.nativeUrl,
                    _owner: asset,
                    _ownerProp: "_nativeAsset"
                });
            }
            return depends;
        }(item, asset, tdInfo, deferredLoad);
        cc.deserialize.Details.pool.put(tdInfo);
        var wrappedCallback = function wrappedCallback(err, asset) {
            if (!err && asset.onLoaded) try {
                asset.onLoaded();
            } catch (error$$1) {
                err = error$$1;
            }
            callback(err, asset);
        };
        if (0 === depends.length) return wrappedCallback(null, asset);
        !function loadDepends(pipeline, item, asset, depends, callback) {
            item.content = asset;
            var dependKeys = item.dependKeys;
            pipeline.flowInDeps(item, depends, function(errors, items) {
                var item, itemsMap = items.map;
                for (var src in itemsMap) (item = itemsMap[src]).uuid && item.content && (item.content._uuid = item.uuid);
                for (var i = 0; i < depends.length; i++) {
                    var loadCallback = function loadCallback(item) {
                        var value$$1 = item.content;
                        this._stillUseUrl && (value$$1 = value$$1 ? value$$1.nativeUrl : item.rawUrl), this._owner[this._ownerProp] = value$$1, 
                        item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
                    }, dep = depends[i], dependSrc = dep.uuid, dependUrl = dep.url;
                    if (dep._owner, dep._ownerProp, item = itemsMap[dependUrl]) {
                        var loadCallbackCtx = dep;
                        if (item.complete || item.content) item.error ? cc._throw(item.error) : loadCallback.call(loadCallbackCtx, item); else {
                            var queue = LoadingItems.getQueue(item), list = queue._callbackTable[dependSrc];
                            list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
                        }
                    }
                }
                callback(errors, asset);
            });
        }(this.pipeline, item, asset, depends, wrappedCallback);
    }
    loadUuid.isSceneObj = isSceneObj;
    var WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/, SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/, LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+|\S)$/, LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+$/, FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]/;
    function isUnicodeCJK(ch) {
        return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(ch) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(ch) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(ch);
    }
    function isUnicodeSpace(ch) {
        var chCode = ch.charCodeAt(0);
        return 9 <= chCode && chCode <= 13 || 32 === chCode || 133 === chCode || 160 === chCode || 5760 === chCode || 8192 <= chCode && chCode <= 8202 || 8232 === chCode || 8233 === chCode || 8239 === chCode || 8287 === chCode || 12288 === chCode;
    }
    function safeMeasureText(ctx, string) {
        var metric = ctx.measureText(string);
        return metric && metric.width || 0;
    }
    function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];
        if (0 === stringToken.length || maxWidth < 0) return wrappedWords.push(""), wrappedWords;
        for (var text = stringToken; maxWidth < allWidth && 1 < text.length; ) {
            for (var fuzzyLen = text.length * (maxWidth / allWidth) | 0, tmpText = text.substr(fuzzyLen), width = allWidth - measureText(tmpText), sLine = tmpText, pushNum = 0, checkWhile = 0; maxWidth < width && checkWhile++ < 10; ) fuzzyLen *= maxWidth / width, 
            fuzzyLen |= 0, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
            for (checkWhile = 0; width <= maxWidth && checkWhile++ < 10; ) {
                if (tmpText) {
                    var exec = WORD_REG.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1, sLine = tmpText;
                }
                fuzzyLen += pushNum, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
            }
            0 === (fuzzyLen -= pushNum) && (fuzzyLen = 1, sLine = sLine.substr(1));
            var sText = text.substr(0, fuzzyLen), result = void 0;
            SYMBOL_REG.test(sLine || tmpText) && (0 === (fuzzyLen -= (result = LAST_WORD_REG.exec(sText)) ? result[0].length : 0) && (fuzzyLen = 1), 
            sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), FIRST_ENGLISH_REG.test(sLine) && (result = LAST_ENGLISH_REG.exec(sText)) && sText !== result[0] && (fuzzyLen -= result[0].length, 
            sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), 0 === wrappedWords.length ? wrappedWords.push(sText) : 0 < (sText = sText.trim()).length && wrappedWords.push(sText), 
            allWidth = measureText(text = sLine || tmpText);
        }
        return 0 === wrappedWords.length ? wrappedWords.push(text) : 0 < (text = text.trim()).length && wrappedWords.push(text), 
        wrappedWords;
    }
    var _canvasContext = null, _testString = "BES bswy:->@", _fontFaces = {}, _intervalId = -1, _loadingFonts = [], _timeout = 6e4;
    function _checkFontLoaded() {
        for (var allFontsLoaded = !0, now = Date.now(), i = _loadingFonts.length - 1; 0 <= i; i--) {
            var fontLoadHandle = _loadingFonts[i], fontFamily = fontLoadHandle.fontFamilyName;
            if (now - fontLoadHandle.startTime > _timeout) cc.warnID(4933, fontFamily), fontLoadHandle.callback(null, fontFamily), 
            _loadingFonts.splice(i, 1); else {
                var oldWidth = fontLoadHandle.refWidth;
                _canvasContext.font = "40px " + fontFamily, oldWidth !== safeMeasureText(_canvasContext, _testString) ? (_loadingFonts.splice(i, 1), 
                fontLoadHandle.callback(null, fontFamily)) : allFontsLoaded = !1;
            }
        }
        allFontsLoaded && (clearInterval(_intervalId), _intervalId = -1);
    }
    function loadFont(item, callback) {
        var url = item.url, fontFamilyName = function _getFontFamily(fontHandle) {
            var ttfIndex = fontHandle.lastIndexOf(".ttf");
            if (-1 === ttfIndex) return fontHandle;
            var fontFamilyName, slashPos = fontHandle.lastIndexOf("/");
            fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
            -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
            return fontFamilyName;
        }(url);
        if (_fontFaces[fontFamilyName]) return fontFamilyName;
        if (!_canvasContext) {
            var labelCanvas = document.createElement("canvas");
            labelCanvas.width = 100, labelCanvas.height = 100, _canvasContext = labelCanvas.getContext("2d");
        }
        var fontDesc = "40px " + fontFamilyName;
        _canvasContext.font = fontDesc;
        var refWidth = safeMeasureText(_canvasContext, _testString), fontStyle = document.createElement("style");
        fontStyle.type = "text/css";
        var fontStr = "";
        isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:", 
        fontStr += "url('" + url + "');", fontStyle.textContent = fontStr + "}", document.body.appendChild(fontStyle);
        var preloadDiv = document.createElement("div"), divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName, preloadDiv.innerHTML = ".", divStyle.position = "absolute", 
        divStyle.left = "-100px", divStyle.top = "-100px", document.body.appendChild(preloadDiv);
        var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            callback: callback,
            startTime: Date.now()
        };
        _loadingFonts.push(fontLoadHandle), _fontFaces[fontFamilyName] = fontStyle, -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
    }
    function loadJSON(item) {
        if ("string" != typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
        try {
            return JSON.parse(item.content);
        } catch (e) {
            return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
        }
    }
    function loadImage(item) {
        if (item._owner instanceof cc.Asset) return null;
        var image = item.content;
        if (!(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
        var rawUrl = item.rawUrl, imageAsset = item.imageAsset || new ImageAsset();
        return imageAsset._uuid = item.uuid, imageAsset.url = rawUrl, imageAsset._setRawAsset(rawUrl, !1), 
        imageAsset._nativeAsset = image, imageAsset;
    }
    function loadAudioAsAsset(item, callback) {
        if (item._owner instanceof cc.Asset) return null;
        var audioClip = new cc.AudioClip();
        return audioClip._setRawAsset(item.rawUrl, !1), audioClip._nativeAsset = item.content, 
        audioClip;
    }
    function loadBinary(item) {
        return item.load ? item.load(item.content) : item.content;
    }
    function readBEUint16(header, offset) {
        return header[offset] << 8 | header[offset + 1];
    }
    var defaultMap$1 = {
        png: loadImage,
        jpg: loadImage,
        bmp: loadImage,
        jpeg: loadImage,
        gif: loadImage,
        ico: loadImage,
        tiff: loadImage,
        webp: loadImage,
        image: loadImage,
        pvr: function loadPVRTex(item) {
            var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Int32Array(buffer, 0, 13);
            if (55727696 === header[0]) {
                var _width = header[7], _height = header[6], dataOffset = header[12] + 52;
                return buffer = buffer.slice(dataOffset, buffer.byteLength), {
                    _data: new Uint8Array(buffer),
                    _compressed: !0,
                    width: _width,
                    height: _height
                };
            }
            if (559044176 !== header[11]) return new Error("Invalid magic number in PVR header");
            var headerLength = header[0], height = header[1], width = header[2];
            return buffer = buffer.slice(headerLength, buffer.byteLength), {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: width,
                height: height
            };
        },
        pkm: function loadPKMTex(item) {
            var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Uint8Array(buffer), format = readBEUint16(header, 6);
            if (0 !== format && 1 !== format && 3 !== format) return new Error("Invalid magic number in ETC header");
            var width = readBEUint16(header, 12), height = readBEUint16(header, 14);
            return readBEUint16(header, 8), readBEUint16(header, 10), buffer = buffer.slice(16, buffer.byteLength), 
            {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: width,
                height: height
            };
        },
        mp3: loadAudioAsAsset,
        ogg: loadAudioAsAsset,
        wav: loadAudioAsAsset,
        m4a: loadAudioAsAsset,
        json: loadJSON,
        ExportJson: loadJSON,
        plist: function loadPlist(item) {
            if ("string" != typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
            var result = plistParser.parse(item.content);
            return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
        },
        uuid: loadUuid,
        prefab: loadUuid,
        fire: loadUuid,
        scene: loadUuid,
        binary: loadBinary,
        bin: loadBinary,
        font: loadFont,
        eot: loadFont,
        ttf: loadFont,
        woff: loadFont,
        svg: loadFont,
        ttc: loadFont,
        default: function loadNothing() {
            return null;
        }
    }, Loader = function() {
        function Loader(extMap) {
            _classCallCheck(this, Loader), this.id = "Loader", this.async = !0, this.pipeline = null, 
            this.extMap = mixin(extMap, defaultMap$1);
        }
        return _createClass(Loader, [ {
            key: "addHandlers",
            value: function addHandlers(extMap) {
                this.extMap = mixin(this.extMap, extMap);
            }
        }, {
            key: "handle",
            value: function handle(item, callback) {
                return (this.extMap[item.type] || this.extMap.default).call(this, item, callback);
            }
        } ]), Loader;
    }();
    Loader.ID = "Loader", Pipeline.Loader = Loader;
    var reusedArray = [], AssetLoader = function() {
        function AssetLoader(extMap) {
            _classCallCheck(this, AssetLoader), this.id = "AssetLoader", this.async = !0, this.pipeline = null;
        }
        return _createClass(AssetLoader, [ {
            key: "handle",
            value: function handle(item, callback) {
                var uuid = item.uuid;
                if (!uuid) return item.content || null;
                cc.AssetLibrary.queryAssetInfo(uuid, function(error$$1, url, isRawAsset) {
                    if (error$$1) callback(error$$1); else if (item.url = item.rawUrl = url, item.isRawAsset = isRawAsset) {
                        var ext = extname(url).toLowerCase();
                        if (!ext) return void callback(new Error(getError(4931, uuid)));
                        ext = ext.substr(1);
                        var queue = LoadingItems.getQueue(item);
                        reusedArray[0] = {
                            queueId: item.queueId,
                            id: url,
                            url: url,
                            type: ext,
                            error: null,
                            alias: item,
                            complete: !0
                        }, queue.append(reusedArray), item.type = ext, callback(null, item.content);
                    } else item.type = "uuid", callback(null, item.content);
                });
            }
        } ]), AssetLoader;
    }();
    function Entry(uuid, type) {
        this.uuid = uuid, this.type = type;
    }
    function isMatchByWord(path, test) {
        return !(path.length > test.length) || 47 === path.charCodeAt(test.length);
    }
    AssetLoader.ID = "AssetLoader", Pipeline.AssetLoader = AssetLoader;
    var AssetTable = function() {
        function AssetTable() {
            _classCallCheck(this, AssetTable), this._pathToUuid = createMap(!0);
        }
        return _createClass(AssetTable, [ {
            key: "getUuid",
            value: function getUuid(path, type) {
                path = cc.url.normalize(path);
                var item = this._pathToUuid[path];
                if (item) if (Array.isArray(item)) {
                    if (!type) return item[0].uuid;
                    for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        if (isChildClassOf(entry.type, type)) return entry.uuid;
                    }
                } else {
                    if (!type || isChildClassOf(item.type, type)) return item.uuid;
                }
                return "";
            }
        }, {
            key: "getUuidArray",
            value: function getUuidArray(path, type, out_urls) {
                "/" === (path = cc.url.normalize(path))[path.length - 1] && (path = path.slice(0, -1));
                var path2uuid = this._pathToUuid, uuids = [];
                for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                    var item = path2uuid[p];
                    if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        (!type || isChildClassOf(entry.type, type)) && (uuids.push(entry.uuid), out_urls && out_urls.push(p));
                    } else (!type || isChildClassOf(item.type, type)) && (uuids.push(item.uuid), out_urls && out_urls.push(p));
                }
                return uuids;
            }
        }, {
            key: "add",
            value: function add(path, uuid, type, isMainAsset) {
                isMainAsset && (path = path.substring(0, path.length - cc.path.extname(path).length));
                var newEntry = new Entry(uuid, type);
                pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
            }
        }, {
            key: "_getInfo_DEBUG",
            value: function _getInfo_DEBUG(uuid, out_info) {
                for (var path2uuid = this._pathToUuid, paths = Object.keys(path2uuid), p = 0; p < paths.length; ++p) {
                    var path = paths[p], item = path2uuid[path];
                    if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        if (entry.uuid === uuid) return out_info.path = path, out_info.type = entry.type, 
                        !0;
                    } else if (item.uuid === uuid) return out_info.path = path, out_info.type = item.type, 
                    !0;
                }
                return !1;
            }
        }, {
            key: "reset",
            value: function reset() {
                this._pathToUuid = createMap(!0);
            }
        } ]), AssetTable;
    }();
    function parseDepends$1(key, parsed) {
        var item = cc.loader.getItem(key);
        if (item) {
            var depends = item.dependKeys;
            if (depends) for (var i = 0; i < depends.length; i++) {
                var depend = depends[i];
                parsed[depend] || (parsed[depend] = !0, parseDepends$1(depend, parsed));
            }
        }
    }
    function visitAsset(asset, excludeMap) {
        if (asset._uuid) {
            var key = cc.loader._getReferenceKey(asset);
            excludeMap[key] || (excludeMap[key] = !0, parseDepends$1(key, excludeMap));
        }
    }
    function visitComponent(comp, excludeMap) {
        for (var props = Object.getOwnPropertyNames(comp), i = 0; i < props.length; i++) {
            var value$$1 = comp[props[i]];
            if ("object" === _typeof(value$$1) && value$$1) if (Array.isArray(value$$1)) for (var j = 0; j < value$$1.length; j++) {
                var val = value$$1[j];
                val instanceof cc.RawAsset && visitAsset(val, excludeMap);
            } else if (value$$1.constructor && value$$1.constructor !== Object) value$$1 instanceof cc.RawAsset && visitAsset(value$$1, excludeMap); else for (var keys = Object.getOwnPropertyNames(value$$1), _j = 0; _j < keys.length; _j++) {
                var _val = value$$1[keys[_j]];
                _val instanceof cc.RawAsset && visitAsset(_val, excludeMap);
            }
        }
    }
    function visitNode(node, excludeMap) {
        for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
        for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
    }
    function getDependsRecursively(key) {
        var depends = {};
        return parseDepends$1(key, depends), Object.keys(depends);
    }
    var assetTables = Object.create(null);
    function getXMLHttpRequest() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    }
    assetTables.assets = new AssetTable(), assetTables.internal = new AssetTable();
    var _info = {
        url: null,
        raw: !1
    };
    function getResWithUrl(res) {
        var id, result, isUuid;
        if ("object" === _typeof(res)) {
            if ((result = res).url) return result;
            id = res.uuid;
        } else result = {}, id = res;
        return isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id), 
        cc.AssetLibrary._getAssetInfoInRuntime(id, _info), result.url = isUuid ? _info.url : id, 
        _info.url && "uuid" === result.type && _info.raw ? (result.type = null, result.isRawAsset = !0) : isUuid || (result.isRawAsset = !0), 
        result;
    }
    var _sharedResources = [], _sharedList = [], CCLoader = function(_Pipeline) {
        function CCLoader() {
            var _this;
            _classCallCheck(this, CCLoader);
            var assetLoader = new AssetLoader(), downloader = new Downloader(), loader = new Loader();
            return (_this = _possibleConstructorReturn(this, _getPrototypeOf(CCLoader).call(this, [ assetLoader, downloader, loader ]))).getXMLHttpRequest = void 0, 
            _this.assetLoader = void 0, _this.md5Pipe = void 0, _this.downloader = void 0, _this.loader = void 0, 
            _this.onProgress = void 0, _this._assetTables = void 0, _this._autoReleaseSetting = void 0, 
            _this._releasedAssetChecker_DEBUG = void 0, _this.getXMLHttpRequest = getXMLHttpRequest, 
            _this.assetLoader = assetLoader, _this.md5Pipe = null, _this.downloader = downloader, 
            _this.loader = loader, _this.onProgress = null, _this._assetTables = assetTables, 
            _this._autoReleaseSetting = createMap(!0), _this;
        }
        return _inherits(CCLoader, Pipeline), _createClass(CCLoader, [ {
            key: "init",
            value: function init(director) {}
        }, {
            key: "addDownloadHandlers",
            value: function addDownloadHandlers(extMap) {
                this.downloader.addHandlers(extMap);
            }
        }, {
            key: "addLoadHandlers",
            value: function addLoadHandlers(extMap) {
                this.loader.addHandlers(extMap);
            }
        }, {
            key: "load",
            value: function load(resources, progressCallback, completeCallback) {
                void 0 === completeCallback && (completeCallback = progressCallback, progressCallback = this.onProgress || null);
                var res, self = this, singleRes = !1;
                resources instanceof Array || (resources = resources ? (singleRes = !0, [ resources ]) : []);
                for (var i = _sharedResources.length = 0; i < resources.length; ++i) {
                    var resource = resources[i];
                    if (resource && resource.id && (cc.warnID(4920, resource.id), resource.uuid || resource.url || (resource.url = resource.id)), 
                    (res = getResWithUrl(resource)).url || res.uuid) {
                        var item = this._cache[res.url];
                        _sharedResources.push(item || res);
                    }
                }
                var queue = LoadingItems.create(this, progressCallback, function(errors, items) {
                    callInNextTick(function() {
                        if (completeCallback) {
                            if (singleRes) {
                                var id = res.url;
                                completeCallback.call(self, items.getError(id), items.getContent(id));
                            } else completeCallback.call(self, errors, items);
                            completeCallback = null;
                        }
                        items.destroy();
                    });
                });
                LoadingItems.initQueueDeps(queue), queue.append(_sharedResources), _sharedResources.length = 0;
            }
        }, {
            key: "flowInDeps",
            value: function flowInDeps(owner, urlList, callback) {
                for (var i = _sharedList.length = 0; i < urlList.length; ++i) {
                    var res = getResWithUrl(urlList[i]);
                    if (res.url || res.uuid) {
                        var item = this._cache[res.url];
                        item ? _sharedList.push(item) : _sharedList.push(res);
                    }
                }
                var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
                    queue._ownerQueue && queue._ownerQueue.onProgress && queue._ownerQueue._childOnProgress(item);
                } : null, function(errors, items) {
                    callback(errors, items), owner && owner.deps && (owner.deps.length = 0), items.destroy();
                });
                if (owner) {
                    var ownerQueue = LoadingItems.getQueue(owner);
                    queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
                }
                var accepted = queue.append(_sharedList, owner);
                return _sharedList.length = 0, accepted;
            }
        }, {
            key: "loadRes",
            value: function loadRes(url, type, mount, progressCallback, completeCallback) {
                5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                mount = "assets");
                var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                var self = this, uuid = self._getResUuid(url, type, mount, !0);
                uuid ? this.load({
                    type: "uuid",
                    uuid: uuid
                }, progressCallback, function(err, asset) {
                    asset && self.setAutoReleaseRecursively(uuid, !1), completeCallback && completeCallback(err, asset);
                }) : self._urlNotFound(url, type, completeCallback);
            }
        }, {
            key: "loadResDir",
            value: function loadResDir(url, type, mount, progressCallback, completeCallback) {
                if (5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                mount = "assets"), assetTables[mount]) {
                    var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                    type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                    var urls = [], uuids = assetTables[mount].getUuidArray(url, type, urls);
                    this._loadResUuids(uuids, progressCallback, function(errors, assetRes, urlRes) {
                        for (var assetResLength = assetRes.length, i = 0; i < assetResLength; ++i) if (assetRes[i] instanceof cc.SpriteAtlas) {
                            var spriteFrames = assetRes[i].getSpriteFrames();
                            for (var k in spriteFrames) {
                                var sf = spriteFrames[k];
                                assetRes.push(sf), urlRes && urlRes.push("".concat(urlRes[i], "/").concat(sf.name));
                            }
                        }
                        completeCallback && completeCallback(errors, assetRes, urlRes);
                    }, urls);
                }
            }
        }, {
            key: "loadResArray",
            value: function loadResArray(urls, type, mount, progressCallback, completeCallback) {
                5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
                mount = "assets");
                var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                for (var uuids = [], i = 0; i < urls.length; i++) {
                    var url = urls[i], uuid = this._getResUuid(url, type, mount, !0);
                    if (!uuid) return void this._urlNotFound(url, type, completeCallback);
                    uuids.push(uuid);
                }
                this._loadResUuids(uuids, progressCallback, completeCallback);
            }
        }, {
            key: "getRes",
            value: function getRes(url, type) {
                var item = this._cache[url];
                if (!item) {
                    var uuid = this._getResUuid(url, type, null, !0);
                    if (!uuid) return null;
                    var ref = this._getReferenceKey(uuid);
                    item = this._cache[ref];
                }
                return item && item.alias && (item = item.alias), item && item.complete ? item.content : null;
            }
        }, {
            key: "getResCount",
            value: function getResCount() {
                return Object.keys(this._cache).length;
            }
        }, {
            key: "getDependsRecursively",
            value: function getDependsRecursively$$1(owner) {
                if (owner) {
                    var key = this._getReferenceKey(owner), assets = getDependsRecursively(key);
                    return assets.push(key), assets;
                }
                return [];
            }
        }, {
            key: "release",
            value: function release(asset) {
                if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
                    var key = asset[i];
                    this.release(key);
                } else if (asset) {
                    var id = this._getReferenceKey(asset), item = this.getItem(id);
                    if (item) {
                        this.removeItem(id);
                        if ((asset = item.content) instanceof cc.Asset) {
                            var nativeUrl = asset.nativeUrl;
                            nativeUrl && this.release(nativeUrl), asset.destroy();
                        }
                        0;
                    }
                }
            }
        }, {
            key: "releaseAsset",
            value: function releaseAsset(asset) {
                var uuid = asset._uuid;
                uuid && this.release(uuid);
            }
        }, {
            key: "releaseRes",
            value: function releaseRes(url, type, mount) {
                var uuid = this._getResUuid(url, type, mount, !0);
                uuid ? this.release(uuid) : cc.errorID(4914, url);
            }
        }, {
            key: "releaseResDir",
            value: function releaseResDir(url, type, mount) {
                if (assetTables[mount = mount || "assets"]) for (var uuids = assetTables[mount].getUuidArray(url, type), i = 0; i < uuids.length; i++) {
                    var uuid = uuids[i];
                    this.release(uuid);
                }
            }
        }, {
            key: "releaseAll",
            value: function releaseAll() {
                for (var id in this._cache) this.release(id);
            }
        }, {
            key: "removeItem",
            value: function removeItem(key) {
                var removed = Pipeline.prototype.removeItem.call(this, key);
                return delete this._autoReleaseSetting[key], removed;
            }
        }, {
            key: "setAutoRelease",
            value: function setAutoRelease(assetOrUrlOrUuid, autoRelease$$1) {
                var key = this._getReferenceKey(assetOrUrlOrUuid);
                key && (this._autoReleaseSetting[key] = !!autoRelease$$1);
            }
        }, {
            key: "setAutoReleaseRecursively",
            value: function setAutoReleaseRecursively(assetOrUrlOrUuid, autoRelease$$1) {
                autoRelease$$1 = !!autoRelease$$1;
                var key = this._getReferenceKey(assetOrUrlOrUuid);
                if (key) {
                    this._autoReleaseSetting[key] = autoRelease$$1;
                    for (var depends = getDependsRecursively(key), i = 0; i < depends.length; i++) {
                        var depend = depends[i];
                        this._autoReleaseSetting[depend] = autoRelease$$1;
                    }
                } else 0;
            }
        }, {
            key: "isAutoRelease",
            value: function isAutoRelease(assetOrUrl) {
                var key = this._getReferenceKey(assetOrUrl);
                return !!key && !!this._autoReleaseSetting[key];
            }
        }, {
            key: "_getResUuid",
            value: function _getResUuid(url, type, mount, quiet) {
                var assetTable = assetTables[mount = mount || "assets"];
                if (!url || !assetTable) return null;
                var index = url.indexOf("?");
                -1 !== index && (url = url.substr(0, index));
                var uuid = assetTable.getUuid(url, type);
                if (!uuid) {
                    var extname = cc.path.extname(url);
                    extname && (url = url.slice(0, -extname.length), (uuid = assetTable.getUuid(url, type)) && !quiet && cc.warnID(4901, url, extname));
                }
                return uuid;
            }
        }, {
            key: "_getReferenceKey",
            value: function _getReferenceKey(assetOrUrlOrUuid) {
                var key;
                return "object" === _typeof(assetOrUrlOrUuid) ? key = assetOrUrlOrUuid._uuid || null : "string" == typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, null, !0) || assetOrUrlOrUuid), 
                key ? (cc.AssetLibrary._getAssetInfoInRuntime(key, _info), this._cache[_info.url] ? _info.url : key) : (cc.warnID(4800, assetOrUrlOrUuid), 
                key);
            }
        }, {
            key: "_urlNotFound",
            value: function _urlNotFound(url, type, completeCallback) {
                callInNextTick(function() {
                    url = cc.url.normalize(url);
                    var info = "".concat(type ? getClassName(type) : "Asset", ' in "resources/').concat(url, '" does not exist.');
                    completeCallback && completeCallback(new Error(info), []);
                });
            }
        }, {
            key: "_parseLoadResArgs",
            value: function _parseLoadResArgs(type, onProgress, onComplete) {
                if (void 0 === onComplete) {
                    var isValidType = isChildClassOf(type, cc.RawAsset);
                    onProgress ? (onComplete = onProgress, isValidType && (onProgress = this.onProgress || null)) : void 0 !== onProgress || isValidType || (onComplete = type, 
                    onProgress = this.onProgress || null, type = null), void 0 === onProgress || isValidType || (onProgress = type, 
                    type = null);
                }
                return {
                    type: type,
                    onProgress: onProgress,
                    onComplete: onComplete
                };
            }
        }, {
            key: "_loadResUuids",
            value: function _loadResUuids(uuids, progressCallback, completeCallback, urls) {
                if (0 < uuids.length) {
                    var self = this, res = uuids.map(function(uuid) {
                        return {
                            type: "uuid",
                            uuid: uuid
                        };
                    });
                    this.load(res, progressCallback, function(errors, items) {
                        if (completeCallback) {
                            for (var assetRes = [], urlRes = urls && [], i = 0; i < res.length; ++i) {
                                var uuid = res[i].uuid, id = self._getReferenceKey(uuid), item = items.getContent(id);
                                item && (self.setAutoReleaseRecursively(uuid, !1), assetRes.push(item), urlRes && urlRes.push(urls[i]));
                            }
                            urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
                        }
                    });
                } else completeCallback && callInNextTick(function() {
                    urls ? completeCallback(null, [], []) : completeCallback(null, []);
                });
            }
        } ]), CCLoader;
    }(), loader = cc.loader = new CCLoader();
    function postLoadImage(imageAsset, callback) {
        imageAsset.loaded ? callback && callback() : imageAsset.nativeUrl ? loader.load({
            url: imageAsset.nativeUrl,
            skips: imageAsset.isCompressed ? void 0 : [ "Loader" ]
        }, function(err, image) {
            image && (imageAsset.loaded || (imageAsset._nativeAsset = image)), callback && callback(err);
        }) : callback && callback();
    }
    var _class$8, _class2$6, _descriptor$4, _descriptor2$3, _descriptor3$1, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _class3$5, _temp$7, _dec$9, _dec2$4, _class$9, _class2$7, _descriptor$5, textureUtil = Object.freeze({
        loadImage: function loadImage$1(url$$1, callback, target) {
            assertID(!!url$$1, 3103);
            var imageAsset = loader.getRes(url$$1);
            return imageAsset ? imageAsset.loaded ? callback && callback.call(target, null, imageAsset) : imageAsset.once("load", function() {
                callback && callback.call(target, null, imageAsset);
            }, target) : (imageAsset = new ImageAsset(), loader.load({
                url: url$$1,
                imageAsset: imageAsset
            }, function(err, asset) {
                if (err) return callback && callback.call(target, err || new Error("Unknown error")), 
                imageAsset;
                callback && callback.call(target, null, asset);
            })), imageAsset;
        },
        cacheImage: function cacheImage(url$$1, image) {
            if (url$$1 && image) {
                var imageAsset = new ImageAsset(image), item = {
                    id: url$$1,
                    url: url$$1,
                    error: null,
                    content: imageAsset,
                    complete: !1
                };
                return loader.flowOut(item), imageAsset;
            }
        },
        postLoadImage: postLoadImage
    }), idGenerator = new IDGenerator("Tex"), _regions = [ {
        buffOffset: 0,
        buffStride: 0,
        buffTexHeight: 0,
        texOffset: {
            x: 0,
            y: 0,
            z: 0
        },
        texExtent: {
            width: 1,
            height: 1,
            depth: 1
        },
        texSubres: {
            baseMipLevel: 1,
            levelCount: 1,
            baseArrayLayer: 0,
            layerCount: 1
        }
    } ], TextureBase = ccclass("cc.TextureBase")((_temp$7 = _class3$5 = function(_Asset) {
        function TextureBase() {
            var _this, flipY = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return _classCallCheck(this, TextureBase), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureBase).call(this)), "_format", _descriptor$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_premultiplyAlpha", _descriptor2$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_flipY", _descriptor3$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_minFilter", _descriptor4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_magFilter", _descriptor5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_mipFilter", _descriptor6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_wrapS", _descriptor7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_wrapT", _descriptor8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_wrapR", _descriptor9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_anisotropy", _descriptor10, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._texture = null, _this._textureView = null, _this._potientialWidth = 0, _this._potientialHeight = 0, 
            _this._mipmapLevel = 1, _this._id = void 0, _this._samplerInfo = [], _this._flipY = flipY, 
            _this._id = idGenerator.getNewId(), _this.loaded = !1, _this;
        }
        return _inherits(TextureBase, Asset), _createClass(TextureBase, [ {
            key: "width",
            get: function get$$1() {
                return this._texture ? this._texture.width : 0;
            }
        }, {
            key: "height",
            get: function get$$1() {
                return this._texture ? this._texture.height : 0;
            }
        }, {
            key: "isCompressed",
            get: function get$$1() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
            }
        } ]), _createClass(TextureBase, [ {
            key: "create",
            value: function create(width, height) {
                var format = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888, mipmapLevel = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
                this._potientialWidth = width, this._potientialHeight = height, this._format = format, 
                this._mipmapLevel = mipmapLevel, this._recreateTexture();
            }
        }, {
            key: "getImpl",
            value: function getImpl() {
                return this._texture;
            }
        }, {
            key: "getId",
            value: function getId() {
                return this._id;
            }
        }, {
            key: "getPixelFormat",
            value: function getPixelFormat() {
                return this._format;
            }
        }, {
            key: "hasPremultipliedAlpha",
            value: function hasPremultipliedAlpha() {
                return this._premultiplyAlpha || !1;
            }
        }, {
            key: "getAnisotropy",
            value: function getAnisotropy() {
                return this._anisotropy;
            }
        }, {
            key: "setWrapMode",
            value: function setWrapMode(wrapS, wrapT, wrapR) {
                this._wrapS = wrapS, this._samplerInfo[SamplerInfoIndex.addressU] = wrapS, this._wrapT = wrapT, 
                this._samplerInfo[SamplerInfoIndex.addressV] = wrapT, void 0 !== wrapR && (this._wrapR = wrapR, 
                this._samplerInfo[SamplerInfoIndex.addressW] = wrapR);
            }
        }, {
            key: "setFilters",
            value: function setFilters(minFilter, magFilter) {
                this._minFilter = minFilter, this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter, 
                this._magFilter = magFilter, this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter;
            }
        }, {
            key: "setMipFilter",
            value: function setMipFilter(mipFilter) {
                this._mipFilter = mipFilter, this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter, 
                this._samplerInfo[SamplerInfoIndex.maxLOD] = mipFilter === Filter.NONE ? 0 : 1e3;
            }
        }, {
            key: "setFlipY",
            value: function setFlipY(flipY) {
                this._flipY = flipY;
            }
        }, {
            key: "setPremultiplyAlpha",
            value: function setPremultiplyAlpha(premultiply) {
                this._premultiplyAlpha = premultiply;
            }
        }, {
            key: "setAnisotropy",
            value: function setAnisotropy(anisotropy) {
                this._anisotropy = anisotropy, this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._destroyTexture(), _get(_getPrototypeOf(TextureBase.prototype), "destroy", this).call(this);
            }
        }, {
            key: "getGFXTexture",
            value: function getGFXTexture() {
                return this._texture;
            }
        }, {
            key: "getGFXTextureView",
            value: function getGFXTextureView() {
                return this._textureView;
            }
        }, {
            key: "getGFXSamplerInfo",
            value: function getGFXSamplerInfo() {
                return this._samplerInfo;
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0) + "," + this._mipFilter + "," + this._anisotropy + "," + (this._flipY ? 1 : 0);
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializedData, handle) {
                var fields = serializedData.split(",");
                fields.unshift(""), 6 <= fields.length && (this.setFilters(parseInt(fields[1]), parseInt(fields[2])), 
                this.setWrapMode(parseInt(fields[3]), parseInt(fields[4])), this._premultiplyAlpha = 49 === fields[5].charCodeAt(0)), 
                8 <= fields.length && (this.setMipFilter(parseInt(fields[6])), this.setAnisotropy(parseInt(fields[7]))), 
                9 <= fields.length && (this._flipY = 49 === fields[8].charCodeAt(0));
            }
        }, {
            key: "updateImage",
            value: function updateImage() {
                this.updateMipmaps(0);
            }
        }, {
            key: "updateMipmaps",
            value: function updateMipmaps() {}
        }, {
            key: "uploadData",
            value: function uploadData(source) {
                var level = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, arrayIndex = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                if (this._texture && !(this._texture.mipLevel <= level)) {
                    var gfxDevice = this._getGlobalDevice();
                    if (gfxDevice) {
                        var region = _regions[0];
                        region.texExtent.width = this._texture.width >> level, region.texExtent.height = this._texture.height >> level, 
                        region.texSubres.baseMipLevel = level, region.texSubres.baseArrayLayer = arrayIndex, 
                        source instanceof ArrayBuffer ? gfxDevice.copyBuffersToTexture([ source ], this._texture, _regions) : gfxDevice.copyTexImagesToTexture([ source ], this._texture, _regions);
                    }
                }
            }
        }, {
            key: "_getGlobalDevice",
            value: function _getGlobalDevice() {
                return cc.director.root && cc.director.root.device;
            }
        }, {
            key: "_assignImage",
            value: function _assignImage(image, level, arrayIndex) {
                var _this2 = this, upload = function upload() {
                    var source, data = image.data;
                    data && (source = ArrayBuffer.isView(data) ? data.buffer : data, _this2.uploadData(source, level, arrayIndex));
                };
                if (image.loaded) upload(); else {
                    if (image.once("load", function() {
                        upload();
                    }), !this.isCompressed) {
                        var defaultImg = cc.builtinResMgr.get("black-texture").image;
                        this.uploadData(defaultImg.data, level, arrayIndex);
                    }
                    postLoadImage(image);
                }
            }
        }, {
            key: "_getTextureCreateInfo",
            value: function _getTextureCreateInfo() {
                return {
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED | GFXTextureUsageBit.TRANSFER_DST,
                    format: this._format,
                    width: this._potientialWidth,
                    height: this._potientialHeight,
                    mipLevel: this._mipmapLevel,
                    flags: this._mipFilter !== Filter.NONE ? GFXTextureFlagBit.GEN_MIPMAP : GFXTextureFlagBit.NONE
                };
            }
        }, {
            key: "_getTextureViewCreateInfo",
            value: function _getTextureViewCreateInfo() {
                return {
                    texture: this._texture,
                    type: GFXTextureViewType.TV2D,
                    format: this._format
                };
            }
        }, {
            key: "_recreateTexture",
            value: function _recreateTexture() {
                this._destroyTexture();
                var gfxDevice = this._getGlobalDevice();
                gfxDevice && (this._texture = gfxDevice.createTexture(this._getTextureCreateInfo()), 
                this._textureView = gfxDevice.createTextureView(this._getTextureViewCreateInfo()));
            }
        }, {
            key: "_destroyTexture",
            value: function _destroyTexture() {
                this._textureView && (this._textureView.destroy(), this._textureView = null), this._texture && (this._texture.destroy(), 
                this._texture = null);
            }
        } ]), TextureBase;
    }(), _class3$5.PixelFormat = PixelFormat, _class3$5.WrapMode = WrapMode, _class3$5.Filter = Filter, 
    _descriptor$4 = _applyDecoratedDescriptor((_class2$6 = _temp$7).prototype, "_format", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PixelFormat.RGBA8888;
        }
    }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "_premultiplyAlpha", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$6.prototype, "_flipY", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2$6.prototype, "_minFilter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Filter.LINEAR;
        }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2$6.prototype, "_magFilter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Filter.LINEAR;
        }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2$6.prototype, "_mipFilter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Filter.NONE;
        }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2$6.prototype, "_wrapS", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode.REPEAT;
        }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2$6.prototype, "_wrapT", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode.REPEAT;
        }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2$6.prototype, "_wrapR", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode.REPEAT;
        }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2$6.prototype, "_anisotropy", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 16;
        }
    }), _class$8 = _class2$6)) || _class$8;
    cc.TextureBase = TextureBase;
    var _class$a, Texture2D = (_dec$9 = ccclass("cc.Texture2D"), _dec2$4 = property([ ImageAsset ]), 
    _dec$9((_descriptor$5 = _applyDecoratedDescriptor((_class2$7 = function(_TextureBase) {
        function Texture2D() {
            var _this;
            return _classCallCheck(this, Texture2D), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Texture2D).call(this, !0)), "_mipmaps", _descriptor$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(Texture2D, TextureBase), _createClass(Texture2D, [ {
            key: "mipmaps",
            get: function get$$1() {
                return this._mipmaps;
            },
            set: function set(value) {
                var _this2 = this;
                if (this._mipmaps = value, 0 < this._mipmaps.length) {
                    var imageAsset = this._mipmaps[0];
                    this.create(imageAsset.width, imageAsset.height, imageAsset.format, this._mipmaps.length), 
                    this._mipmaps.forEach(function(mipmap, level) {
                        _this2._assignImage(mipmap, level);
                    });
                } else this.create(0, 0, void 0, this._mipmaps.length);
            }
        }, {
            key: "image",
            get: function get$$1() {
                return 0 === this._mipmaps.length ? null : this._mipmaps[0];
            },
            set: function set(value) {
                this.mipmaps = value ? [ value ] : [];
            }
        } ]), _createClass(Texture2D, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.initialize(), this.loaded = !0, this.emit("load");
            }
        }, {
            key: "toString",
            value: function toString() {
                return 0 !== this._mipmaps.length ? this._mipmaps[0].url : "";
            }
        }, {
            key: "updateMipmaps",
            value: function updateMipmaps() {
                var firstLevel = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, count = 1 < arguments.length ? arguments[1] : void 0;
                if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), i = 0; i < nUpdate; ++i) {
                    var level = firstLevel + i;
                    this._assignImage(this._mipmaps[level], level);
                }
            }
        }, {
            key: "getHtmlElementObj",
            value: function getHtmlElementObj() {
                return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._mipmaps = [], _get(_getPrototypeOf(Texture2D.prototype), "destroy", this).call(this);
            }
        }, {
            key: "description",
            value: function description() {
                var url = this._mipmaps[0] ? this._mipmaps[0].url : "";
                return "<cc.Texture2D | Name = ".concat(url, " | Dimension = ").concat(this.width, " x ").concat(this.height, ">");
            }
        }, {
            key: "releaseTexture",
            value: function releaseTexture() {
                this.mipmaps = [];
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return {
                    base: _get(_getPrototypeOf(Texture2D.prototype), "_serialize", this).call(this, exporting),
                    mipmaps: this._mipmaps.map(function(mipmap) {
                        return exporting ? Editor.Utils.UuidUtils.compressUuid(mipmap._uuid, !0) : mipmap._uuid;
                    })
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializedData, handle) {
                var data = serializedData;
                _get(_getPrototypeOf(Texture2D.prototype), "_deserialize", this).call(this, data.base, handle), 
                this._mipmaps = new Array(data.mipmaps.length);
                for (var i = 0; i < data.mipmaps.length; ++i) {
                    this._mipmaps[i] = new ImageAsset();
                    var mipmapUUID = data.mipmaps[i];
                    handle.result.push(this._mipmaps, "".concat(i), mipmapUUID);
                }
            }
        }, {
            key: "initialize",
            value: function initialize() {
                this.mipmaps = this._mipmaps;
            }
        } ]), Texture2D;
    }()).prototype, "_mipmaps", [ _dec2$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$9 = _class2$7)) || _class$9);
    cc.Texture2D = Texture2D;
    var _class$b, _class2$8, _descriptor$6, temp_uvs = [ {
        u: 0,
        v: 0
    }, {
        u: 0,
        v: 0
    }, {
        u: 0,
        v: 0
    }, {
        u: 0,
        v: 0
    } ], SpriteFrame = ccclass("cc.SpriteFrame")(_class$a = function(_Texture2D) {
        function SpriteFrame() {
            var _this;
            return _classCallCheck(this, SpriteFrame), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpriteFrame).call(this))).vertices = null, 
            _this.uv = [], _this.uvSliced = [], _this._rect = new Rect(), _this._offset = new Vec2(), 
            _this._originalSize = new Size(), _this._rotated = !1, _this._capInsets = [ 0, 0, 0, 0 ], 
            _this._original = null, _this._atlasUuid = "", _this;
        }
        return _inherits(SpriteFrame, Texture2D), _createClass(SpriteFrame, [ {
            key: "insetTop",
            get: function get$$1() {
                return this._capInsets[1];
            },
            set: function set(value) {
                this._capInsets[1] = value, this.image && this._calculateSlicedUV();
            }
        }, {
            key: "insetBottom",
            get: function get$$1() {
                return this._capInsets[3];
            },
            set: function set(value) {
                this._capInsets[3] = value, this.image && this._calculateSlicedUV();
            }
        }, {
            key: "insetLeft",
            get: function get$$1() {
                return this._capInsets[0];
            },
            set: function set(value) {
                this._capInsets[0] = value, this.image && this._calculateSlicedUV();
            }
        }, {
            key: "insetRight",
            get: function get$$1() {
                return this._capInsets[2];
            },
            set: function set(value) {
                this._capInsets[2] = value, this.image && this._calculateSlicedUV();
            }
        }, {
            key: "atlasUuid",
            get: function get$$1() {
                return this._atlasUuid;
            },
            set: function set(value) {
                this._atlasUuid = value;
            }
        }, {
            key: "original",
            get: function get$$1() {
                return this._original;
            }
        } ]), _createClass(SpriteFrame, [ {
            key: "textureLoaded",
            value: function textureLoaded() {
                return this.loaded;
            }
        }, {
            key: "isRotated",
            value: function isRotated() {
                return this._rotated;
            }
        }, {
            key: "setRotated",
            value: function setRotated(rotated) {
                this._rotated = rotated;
            }
        }, {
            key: "getRect",
            value: function getRect(out) {
                return out ? (out.set(this._rect), out) : this._rect.clone();
            }
        }, {
            key: "setRect",
            value: function setRect(rect) {
                this._rect = rect;
            }
        }, {
            key: "getOriginalSize",
            value: function getOriginalSize(out) {
                return out ? (out.set(this._originalSize), out) : this._originalSize.clone();
            }
        }, {
            key: "setOriginalSize",
            value: function setOriginalSize(size) {
                this._originalSize.set(size);
            }
        }, {
            key: "_setBorder",
            value: function _setBorder(l, b, r, t) {
                this._capInsets[0] = l, this._capInsets[3] = b, this._capInsets[2] = r, this._capInsets[1] = t;
            }
        }, {
            key: "getOffset",
            value: function getOffset(out) {
                return out ? (out.set(this._offset), out) : this._offset.clone();
            }
        }, {
            key: "setOffset",
            value: function setOffset(offsets) {
                vec2.set(this._offset, offsets.x, offsets.y);
            }
        }, {
            key: "clone",
            value: function clone() {
                var cloneSprite = new SpriteFrame();
                cloneSprite.name = this.name, cloneSprite.atlasUuid = this.atlasUuid, cloneSprite.setOriginalSize(this._originalSize), 
                cloneSprite.setRect(this._rect);
                var cap = this._capInsets;
                return cloneSprite._setBorder(cap[0], cap[3], cap[2], cap[1]), cloneSprite.setOffset(this._offset), 
                cloneSprite._mipmaps = this._mipmaps, cloneSprite.onLoaded(), cloneSprite;
            }
        }, {
            key: "checkRect",
            value: function checkRect(texture) {
                var rect = this._rect, maxX = rect.x, maxY = rect.y;
                this._rotated ? (maxX += rect.height, maxY += rect.width) : (maxX += rect.width, 
                maxY += rect.height), maxX > texture.width && cc.errorID(3300, texture.url + "/" + this.name, maxX, texture.width), 
                maxY > texture.height && cc.errorID(3400, texture.url + "/" + this.name, maxY, texture.height);
            }
        }, {
            key: "_calculateSlicedUV",
            value: function _calculateSlicedUV() {
                var rect = this._rect, atlasWidth = this.image.width, atlasHeight = this.image.height, leftWidth = this._capInsets[0], rightWidth = this._capInsets[2], centerWidth = rect.width - leftWidth - rightWidth, topHeight = this._capInsets[1], bottomHeight = this._capInsets[3], centerHeight = rect.height - topHeight - bottomHeight, uvSliced = this.uvSliced;
                if (uvSliced.length = 0, this._rotated) {
                    temp_uvs[0].u = rect.x / atlasWidth, temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth, 
                    temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth, temp_uvs[3].u = (rect.x + rect.height) / atlasWidth, 
                    temp_uvs[3].v = rect.y / atlasHeight, temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight, 
                    temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight, temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
                    for (var row = 0; row < 4; ++row) for (var rowD = temp_uvs[row], col = 0; col < 4; ++col) {
                        var colD = temp_uvs[3 - col];
                        uvSliced.push({
                            u: rowD.u,
                            v: colD.v
                        });
                    }
                } else {
                    temp_uvs[0].u = rect.x / atlasWidth, temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth, 
                    temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth, temp_uvs[3].u = (rect.x + rect.width) / atlasWidth, 
                    temp_uvs[3].v = rect.y / atlasHeight, temp_uvs[2].v = (rect.y + topHeight) / atlasHeight, 
                    temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight, temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
                    for (var _row = 0; _row < 4; ++_row) for (var _rowD = temp_uvs[_row], _col = 0; _col < 4; ++_col) {
                        var _colD = temp_uvs[_col];
                        uvSliced.push({
                            u: _colD.u,
                            v: _rowD.v
                        });
                    }
                }
            }
        }, {
            key: "_calculateUV",
            value: function _calculateUV() {
                var rect = this._rect, texture = this.image, uv = this.uv, texw = texture.width, texh = texture.height;
                if (this._rotated) {
                    var l = 0 === texw ? 0 : rect.x / texw, r = 0 === texw ? 0 : (rect.x + rect.height) / texw, b = 0 === texh ? 0 : (rect.y + rect.width) / texh, t = 0 === texh ? 0 : rect.y / texh;
                    uv[0] = l, uv[1] = t, uv[2] = l, uv[3] = b, uv[4] = r, uv[5] = t, uv[6] = r, uv[7] = b;
                } else {
                    var _l = 0 === texw ? 0 : rect.x / texw, _r = 0 === texw ? 0 : (rect.x + rect.width) / texw, _b = 0 === texh ? 0 : (rect.y + rect.height) / texh, _t = 0 === texh ? 0 : rect.y / texh;
                    uv[0] = _l, uv[1] = _b, uv[2] = _r, uv[3] = _b, uv[4] = _l, uv[5] = _t, uv[6] = _r, 
                    uv[7] = _t;
                }
                var vertices = this.vertices;
                if (vertices) {
                    vertices.nu.length = 0;
                    for (var i = vertices.nv.length = 0; i < vertices.u.length; i++) vertices.nu[i] = vertices.u[i] / texw, 
                    vertices.nv[i] = vertices.v[i] / texh;
                }
                this._calculateSlicedUV();
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                var vertices, rect = this._rect, offset = this._offset, size = this._originalSize, uuid = this._uuid;
                return uuid && exporting && (uuid = Editor.Utils.UuidUtils.compressUuid(uuid, !0)), 
                this.vertices && (vertices = {
                    triangles: this.vertices.triangles,
                    x: this.vertices.x,
                    y: this.vertices.y,
                    u: this.vertices.u,
                    v: this.vertices.v
                }), {
                    base: _get(_getPrototypeOf(SpriteFrame.prototype), "_serialize", this).call(this, exporting),
                    name: this._name,
                    texture: uuid || void 0,
                    atlas: exporting ? void 0 : this._atlasUuid,
                    rect: rect ? [ rect.x, rect.y, rect.width, rect.height ] : void 0,
                    offset: offset ? [ offset.x, offset.y ] : void 0,
                    originalSize: size ? [ size.width, size.height ] : void 0,
                    rotated: this._rotated ? this._rotated : void 0,
                    capInsets: this._capInsets,
                    vertices: vertices
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializeData, handle) {
                var data = serializeData;
                _get(_getPrototypeOf(SpriteFrame.prototype), "_deserialize", this).call(this, data.base, handle);
                var rect = data.rect;
                rect && this.setRect(new Rect(rect[0], rect[1], rect[2], rect[3])), data.offset && this.setOffset(new Vec2(data.offset[0], data.offset[1])), 
                data.originalSize && this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1])), 
                this._rotated = !!data.rotated, this._name = data.name;
                var capInsets = data.capInsets;
                capInsets && (this._capInsets[0] = capInsets[0], this._capInsets[1] = capInsets[1], 
                this._capInsets[2] = capInsets[2], this._capInsets[3] = capInsets[3]), this.vertices = data.vertices, 
                this.vertices && (this.vertices.nu = [], this.vertices.nv = []);
            }
        }, {
            key: "initialize",
            value: function initialize() {
                _get(_getPrototypeOf(SpriteFrame.prototype), "initialize", this).call(this);
                var w = this.width, h = this.height;
                this._rect ? this.checkRect(this.image) : this.setRect(new Rect(0, 0, w, h)), this._originalSize || this.setOriginalSize(new Size(w, h)), 
                this._offset || this.setOffset(new Vec2(0, 0)), this._calculateUV();
            }
        } ]), SpriteFrame;
    }()) || _class$a;
    cc.SpriteFrame = SpriteFrame;
    var _class$c, _class2$9, _descriptor$7, SpriteAtlas = ccclass("cc.SpriteAtlas")((_descriptor$6 = _applyDecoratedDescriptor((_class2$8 = function(_Asset) {
        function SpriteAtlas() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SpriteAtlas);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteAtlas)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spriteFrames", _descriptor$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(SpriteAtlas, Asset), _createClass(SpriteAtlas, [ {
            key: "getTexture",
            value: function getTexture() {
                var keys = Object.keys(this.spriteFrames);
                if (0 < keys.length) {
                    var spriteFrame = this.spriteFrames[keys[0]];
                    return spriteFrame ? spriteFrame.image : null;
                }
                return null;
            }
        }, {
            key: "getSpriteFrame",
            value: function getSpriteFrame(key) {
                var sf = this.spriteFrames[key];
                return sf ? (sf.name || (sf.name = key), sf) : null;
            }
        }, {
            key: "getSpriteFrames",
            value: function getSpriteFrames() {
                for (var frames = [], spriteFrames = this.spriteFrames, _arr = Object.keys(spriteFrames), _i = 0; _i < _arr.length; _i++) {
                    var _key2 = _arr[_i];
                    frames.push(spriteFrames[_key2]);
                }
                return frames;
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                for (var frames = [], _arr2 = Object.keys(this.spriteFrames), _i2 = 0; _i2 < _arr2.length; _i2++) {
                    var _key3 = _arr2[_i2], spriteFrame = this.spriteFrames[_key3], id = spriteFrame ? spriteFrame._uuid : "", strs = id.split("@"), uuid = strs[0], _name = strs[1];
                    id && exporting && (id = Editor.Utils.UuidUtils.compressUuid(uuid, !0), _name && (id += "@".concat(_name))), 
                    frames.push(_name), frames.push(id);
                }
                return {
                    name: this._name,
                    spriteFrames: frames
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializeData, handle) {
                var data = serializeData;
                this._name = data.name;
                var frames = data.spriteFrames;
                this.spriteFrames = createMap();
                for (var i = 0; i < frames.length; i += 2) handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
            }
        } ]), SpriteAtlas;
    }()).prototype, "spriteFrames", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return createMap();
        }
    }), _class$b = _class2$8)) || _class$b;
    cc.SpriteAtlas = SpriteAtlas;
    var _class$d, _class2$a, _descriptor$8, TextAsset = ccclass("cc.TextAsset")((_descriptor$7 = _applyDecoratedDescriptor((_class2$9 = function(_Asset) {
        function TextAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, TextAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "text", _descriptor$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(TextAsset, Asset), _createClass(TextAsset, [ {
            key: "toString",
            value: function toString() {
                return this.text;
            }
        } ]), TextAsset;
    }()).prototype, "text", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$c = _class2$9)) || _class$c;
    cc.TextAsset = TextAsset;
    var JsonAsset = ccclass("cc.JsonAsset")((_descriptor$8 = _applyDecoratedDescriptor((_class2$a = function(_Asset) {
        function JsonAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, JsonAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(JsonAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "json", _descriptor$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(JsonAsset, Asset), JsonAsset;
    }()).prototype, "json", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$d = _class2$a)) || _class$d;
    cc.JsonAsset = JsonAsset;
    var HexChars = "0123456789abcdef".split(""), _t = [ "", "", "", "" ], UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t), Indices = UuidTemplate.map(function(x, i) {
        return "-" === x ? NaN : i;
    }).filter(isFinite);
    function decodeUuid(base64) {
        var uuid = base64.split("@")[0];
        if (22 !== uuid.length) return base64;
        UuidTemplate[0] = base64[0], UuidTemplate[1] = base64[1];
        for (var i = 2, j = 2; i < 22; i += 2) {
            var lhs = BASE64_VALUES[base64.charCodeAt(i)], rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
            UuidTemplate[Indices[j++]] = HexChars[lhs >> 2], UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4], 
            UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
        }
        return base64.replace(uuid, UuidTemplate.join(""));
    }
    var ExtnameRegex = /(\.[^.\n\\/]*)$/, UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-]{8,})/;
    var MD5Pipe = function() {
        function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
            _classCallCheck(this, MD5Pipe), this.id = "MD5Pipe", this.async = !1, this.pipeline = null, 
            this.md5AssetsMap = md5AssetsMap, this.md5NativeAssetsMap = md5NativeAssetsMap, 
            this.libraryBase = libraryBase;
        }
        return _createClass(MD5Pipe, [ {
            key: "handle",
            value: function handle(item) {
                var hashPatchInFolder = !1;
                return "ttf" === item.type && (hashPatchInFolder = !0), item.url = this.transformURL(item.url, hashPatchInFolder), 
                item;
            }
        }, {
            key: "transformURL",
            value: function transformURL(url, hashPatchInFolder) {
                var uuid = function getUuidFromURL(url) {
                    var matches = url.match(UuidRegex);
                    return matches ? matches[1] : "";
                }(url);
                if (uuid) {
                    var hashValue = (!url.startsWith(this.libraryBase) ? this.md5NativeAssetsMap : this.md5AssetsMap)[uuid];
                    if (hashValue) if (hashPatchInFolder) {
                        var dirname = cc.path.dirname(url), basename = cc.path.basename(url);
                        url = "".concat(dirname, ".").concat(hashValue, "/").concat(basename);
                    } else {
                        var matched = !1;
                        url = url.replace(ExtnameRegex, function(match, p1) {
                            return matched = !0, "." + hashValue + p1;
                        }), matched || (url = url + "." + hashValue);
                    }
                }
                return url;
            }
        } ]), MD5Pipe;
    }();
    MD5Pipe.ID = "MD5Pipe", Pipeline.MD5Pipe = MD5Pipe;
    var _libraryBase = "", _rawAssetsBase = "", _uuidToRawAsset = createMap(!0);
    function RawAssetEntry(url, type) {
        this.url = url, this.type = type;
    }
    var _class$e, AssetLibrary = {
        _uuidToAsset: {},
        loadAsset: function loadAsset(uuid, callback, options) {
            if ("string" != typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
            var item = {
                uuid: uuid,
                type: "uuid"
            };
            options && options.existingAsset && (item.existingAsset = options.existingAsset), 
            cc.loader.load(item, function(error, asset) {
                if (error || !asset) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error ? error.message : "Unknown error")); else if (asset.constructor === cc.SceneAsset) {
                    var key = cc.loader._getReferenceKey(uuid);
                    asset.scene.dependAssets = getDependsRecursively(key);
                }
                callback && callback(error, asset);
            });
        },
        getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
            return uuid = decodeUuid(uuid), (inRawAssetsDir ? _rawAssetsBase + "assets/" : _libraryBase) + uuid.slice(0, 2) + "/" + uuid;
        },
        _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
            0;
        },
        _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
            result = result || {
                url: null,
                raw: !1
            };
            var info = _uuidToRawAsset[uuid];
            return info && !isChildClassOf(info.type, cc.Asset) ? (result.url = _rawAssetsBase + info.url, 
            result.raw = !0) : (result.url = this.getLibUrlNoExt(uuid) + ".json", result.raw = !1), 
            result;
        },
        _uuidInSettings: function _uuidInSettings(uuid) {
            return uuid in _uuidToRawAsset;
        },
        queryAssetInfo: function queryAssetInfo(uuid, callback) {
            var info = this._getAssetInfoInRuntime(uuid);
            callback(null, info.url, info.raw);
        },
        parseUuidInEditor: function parseUuidInEditor(url) {},
        loadJson: function loadJson(json, callback) {
            var randomUuid = "" + (new Date().getTime() + Math.random()), item = {
                uuid: randomUuid,
                type: "uuid",
                content: json,
                skips: [ cc.loader.assetLoader.id, cc.loader.downloader.id ]
            };
            cc.loader.load(item, function(error, asset) {
                if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
                    if (asset.constructor === cc.SceneAsset) {
                        var key = cc.loader._getReferenceKey(randomUuid);
                        asset.scene.dependAssets = getDependsRecursively(key);
                    }
                    if (function isScene(asset) {
                        return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
                    }(asset)) {
                        var id = cc.loader._getReferenceKey(randomUuid);
                        cc.loader.removeItem(id);
                    }
                }
                asset._uuid = "", callback && callback(error, asset);
            });
        },
        getAssetByUuid: function getAssetByUuid(uuid) {
            return AssetLibrary._uuidToAsset[uuid] || null;
        },
        init: function init(options) {
            var libraryPath = options.libraryPath;
            libraryPath = libraryPath.replace(/\\/g, "/"), _libraryBase = cc.path.stripSep(libraryPath) + "/", 
            _rawAssetsBase = options.rawAssetsBase;
            var md5AssetsMap = options.md5AssetsMap;
            if (md5AssetsMap && md5AssetsMap.import) {
                var i = 0, md5ImportMap = createMap(!0), md5Entries = md5AssetsMap.import;
                for (i = 0; i < md5Entries.length; i += 2) md5ImportMap[decodeUuid(md5Entries[i])] = md5Entries[i + 1];
                var md5RawAssetsMap = createMap(!0);
                for (md5Entries = md5AssetsMap["raw-assets"], i = 0; i < md5Entries.length; i += 2) md5RawAssetsMap[decodeUuid(md5Entries[i])] = md5Entries[i + 1];
                var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
                cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe), cc.loader.md5Pipe = md5Pipe;
            }
            var assetTables = loader._assetTables;
            for (var mount in assetTables) assetTables[mount].reset();
            var rawAssets = options.rawAssets;
            if (rawAssets) for (var mountPoint in rawAssets) {
                var assets = rawAssets[mountPoint];
                for (var _uuid in assets) {
                    var info = assets[_uuid], url = info[0], typeId = info[1], type = _getClassById(typeId);
                    if (type) {
                        _uuidToRawAsset[_uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
                        var isSubAsset = 1 === info[2];
                        assetTables[mountPoint] || (assetTables[mountPoint] = new AssetTable()), assetTables[mountPoint].add(url, _uuid, type, !isSubAsset);
                    } else cc.error("Cannot get", typeId);
                }
            }
            options.packedAssets && initPacks(options.packedAssets), cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
        }
    };
    cc.AssetLibrary = AssetLibrary;
    var _dec$f, _dec2$5, _class$f, _class2$b, _descriptor$9, Font = ccclass("cc.Font")(_class$e = function(_Asset) {
        function Font() {
            return _classCallCheck(this, Font), _possibleConstructorReturn(this, _getPrototypeOf(Font).apply(this, arguments));
        }
        return _inherits(Font, Asset), Font;
    }()) || _class$e;
    cc.Font = Font;
    var _dec$g, _dec2$6, _class$g, _class2$c, _descriptor$a, _descriptor2$4, _descriptor3$2, _descriptor4$1, TTFFont = (_dec$f = ccclass("cc.TTFFont"), 
    _dec2$5 = property({
        type: cc.String,
        override: !0
    }), _dec$f((_descriptor$9 = _applyDecoratedDescriptor((_class2$b = function(_Font) {
        function TTFFont() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, TTFFont);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TTFFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_fontFamily", _descriptor$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(TTFFont, Font), _createClass(TTFFont, [ {
            key: "_nativeAsset",
            get: function get() {
                return this._fontFamily;
            },
            set: function set(value) {
                this._fontFamily = value || "Arial";
            }
        } ]), TTFFont;
    }()).prototype, "_fontFamily", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$b.prototype, "_nativeAsset", [ _dec2$5 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "_nativeAsset"), _class2$b.prototype), 
    _class$f = _class2$b)) || _class$f);
    cc.TTFFont = TTFFont;
    var _class$h, BitmapFont = (_dec$g = ccclass("cc.BitmapFont"), _dec2$6 = property({
        type: SpriteFrame
    }), _dec$g((_descriptor$a = _applyDecoratedDescriptor((_class2$c = function(_Font) {
        function BitmapFont() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, BitmapFont);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BitmapFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "fntDataStr", _descriptor$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "spriteFrame", _descriptor2$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "fontSize", _descriptor3$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "fntConfig", _descriptor4$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(BitmapFont, Font), BitmapFont;
    }()).prototype, "fntDataStr", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$c.prototype, "spriteFrame", [ _dec2$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$c.prototype, "fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$c.prototype, "fntConfig", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$g = _class2$c)) || _class$g);
    cc.BitmapFont = BitmapFont;
    var LabelAtlas = ccclass("cc.LabelAtlas")(_class$h = function(_BitmapFont) {
        function LabelAtlas() {
            return _classCallCheck(this, LabelAtlas), _possibleConstructorReturn(this, _getPrototypeOf(LabelAtlas).apply(this, arguments));
        }
        return _inherits(LabelAtlas, BitmapFont), LabelAtlas;
    }()) || _class$h;
    cc.LabelAtlas = LabelAtlas;
    var Event = function() {
        function Event(type, bubbles) {
            _classCallCheck(this, Event), this.type = void 0, this.bubbles = void 0, this.target = null, 
            this.currentTarget = null, this.eventPhase = 0, this.propagationStopped = !1, this.propagationImmediateStopped = !1, 
            this.type = type, this.bubbles = !!bubbles;
        }
        return _createClass(Event, [ {
            key: "unuse",
            value: function unuse() {
                this.type = Event.NO_TYPE, this.target = null, this.currentTarget = null, this.eventPhase = Event.NONE, 
                this.propagationStopped = !1, this.propagationImmediateStopped = !1;
            }
        }, {
            key: "reuse",
            value: function reuse(type, bubbles) {
                this.type = type, this.bubbles = bubbles || !1;
            }
        }, {
            key: "isStopped",
            value: function isStopped() {
                return this.propagationStopped || this.propagationImmediateStopped;
            }
        }, {
            key: "getCurrentTarget",
            value: function getCurrentTarget() {
                return this.currentTarget;
            }
        }, {
            key: "getType",
            value: function getType() {
                return this.type;
            }
        } ]), Event;
    }();
    Event.NO_TYPE = "no_type", Event.TOUCH = "touch", Event.MOUSE = "mouse", Event.KEYBOARD = "keyboard", 
    Event.ACCELERATION = "acceleration", Event.NONE = 0, Event.CAPTURING_PHASE = 1, 
    Event.AT_TARGET = 2, Event.BUBBLING_PHASE = 3, cc.Event = Event;
    var EventMouse = function(_Event) {
        function EventMouse(eventType, bubbles) {
            var _this;
            return _classCallCheck(this, EventMouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(EventMouse).call(this, Event.MOUSE, bubbles))).movementX = 0, 
            _this.movementY = 0, _this._eventType = void 0, _this._button = 0, _this._x = 0, 
            _this._y = 0, _this._prevX = 0, _this._prevY = 0, _this._scrollX = 0, _this._scrollY = 0, 
            _this._eventType = eventType, _this;
        }
        return _inherits(EventMouse, Event), _createClass(EventMouse, [ {
            key: "setScrollData",
            value: function setScrollData(scrollX, scrollY) {
                this._scrollX = scrollX, this._scrollY = scrollY;
            }
        }, {
            key: "getScrollX",
            value: function getScrollX() {
                return this._scrollX;
            }
        }, {
            key: "getScrollY",
            value: function getScrollY() {
                return this._scrollY;
            }
        }, {
            key: "setLocation",
            value: function setLocation(x, y) {
                this._x = x, this._y = y;
            }
        }, {
            key: "getLocation",
            value: function getLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._x, this._y), out;
            }
        }, {
            key: "getLocationInView",
            value: function getLocationInView(out) {
                return out || (out = new Vec2()), vec2.set(out, this._x, cc.view._designResolutionSize.height - this._y), 
                out;
            }
        }, {
            key: "getUILocation",
            value: function getUILocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._x, this._y), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "_setPrevCursor",
            value: function _setPrevCursor(x, y) {
                this._prevX = x, this._prevY = y;
            }
        }, {
            key: "getPreviousLocation",
            value: function getPreviousLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._prevX, this._prevY), out;
            }
        }, {
            key: "getUIPreviousLocation",
            value: function getUIPreviousLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._prevX, this._prevY), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "getDelta",
            value: function getDelta(out) {
                return out || (out = new Vec2()), vec2.set(out, this._x - this._prevX, this._y - this._prevY), 
                out;
            }
        }, {
            key: "getDeltaX",
            value: function getDeltaX() {
                return this._x - this._prevX;
            }
        }, {
            key: "getDeltaY",
            value: function getDeltaY() {
                return this._y - this._prevY;
            }
        }, {
            key: "getUIDelta",
            value: function getUIDelta(out) {
                return out || (out = new Vec2()), vec2.set(out, (this._x - this._prevX) / cc.view.getScaleX(), (this._y - this._prevY) / cc.view.getScaleY()), 
                out;
            }
        }, {
            key: "getUIDeltaX",
            value: function getUIDeltaX() {
                return (this._x - this._prevX) / cc.view.getScaleX();
            }
        }, {
            key: "getUIDeltaY",
            value: function getUIDeltaY() {
                return (this._y - this._prevY) / cc.view.getScaleY();
            }
        }, {
            key: "setButton",
            value: function setButton(button) {
                this._button = button;
            }
        }, {
            key: "getButton",
            value: function getButton() {
                return this._button;
            }
        }, {
            key: "getLocationX",
            value: function getLocationX() {
                return this._x;
            }
        }, {
            key: "getLocationY",
            value: function getLocationY() {
                return this._y;
            }
        }, {
            key: "getUILocationX",
            value: function getUILocationX() {
                var viewport = cc.view.getViewportRect();
                return (this._x - viewport.x) / cc.view.getScaleX();
            }
        }, {
            key: "getUILocationY",
            value: function getUILocationY() {
                var viewport = cc.view.getViewportRect();
                return (this._y - viewport.y) / cc.view.getScaleY();
            }
        } ]), EventMouse;
    }();
    EventMouse.NONE = 0, EventMouse.DOWN = 1, EventMouse.UP = 2, EventMouse.MOVE = 3, 
    EventMouse.SCROLL = 4, EventMouse.BUTTON_LEFT = 0, EventMouse.BUTTON_RIGHT = 2, 
    EventMouse.BUTTON_MIDDLE = 1, EventMouse.BUTTON_4 = 3, EventMouse.BUTTON_5 = 4, 
    EventMouse.BUTTON_6 = 5, EventMouse.BUTTON_7 = 6, EventMouse.BUTTON_8 = 7;
    var EventTouch = function(_Event2) {
        function EventTouch(touches, bubbles) {
            var _this2;
            return _classCallCheck(this, EventTouch), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(EventTouch).call(this, Event.TOUCH, bubbles))).touch = null, 
            _this2.currentTouch = null, _this2._eventCode = 0, _this2.simulate = !1, _this2._touches = void 0, 
            _this2._eventCode = 0, _this2._touches = touches || [], _this2;
        }
        return _inherits(EventTouch, Event), _createClass(EventTouch, [ {
            key: "getEventCode",
            value: function getEventCode() {
                return this._eventCode;
            }
        }, {
            key: "getTouches",
            value: function getTouches() {
                return this._touches;
            }
        }, {
            key: "_setEventCode",
            value: function _setEventCode(eventCode) {
                this._eventCode = eventCode;
            }
        }, {
            key: "_setTouches",
            value: function _setTouches(touches) {
                this._touches = touches;
            }
        }, {
            key: "setLocation",
            value: function setLocation(x, y) {
                this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
            }
        }, {
            key: "getLocation",
            value: function getLocation(out) {
                return this.touch ? this.touch.getLocation(out) : new Vec2();
            }
        }, {
            key: "getLocationInView",
            value: function getLocationInView(out) {
                return this.touch ? this.touch.getLocationInView(out) : new Vec2();
            }
        }, {
            key: "getPreviousLocation",
            value: function getPreviousLocation(out) {
                return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
            }
        }, {
            key: "getStartLocation",
            value: function getStartLocation(out) {
                return this.touch ? this.touch.getStartLocation(out) : new Vec2();
            }
        }, {
            key: "getID",
            value: function getID() {
                return this.touch ? this.touch.getID() : null;
            }
        }, {
            key: "getDelta",
            value: function getDelta(out) {
                return this.touch ? this.touch.getDelta(out) : new Vec2();
            }
        }, {
            key: "getDeltaX",
            value: function getDeltaX(out) {
                return this.touch ? this.touch.getDelta(out).x : 0;
            }
        }, {
            key: "getDeltaY",
            value: function getDeltaY(out) {
                return this.touch ? this.touch.getDelta(out).y : 0;
            }
        }, {
            key: "getLocationX",
            value: function getLocationX() {
                return this.touch ? this.touch.getLocationX() : 0;
            }
        }, {
            key: "getLocationY",
            value: function getLocationY() {
                return this.touch ? this.touch.getLocationY() : 0;
            }
        } ]), EventTouch;
    }();
    EventTouch.MAX_TOUCHES = 5, EventTouch.BEGAN = 0, EventTouch.MOVED = 1, EventTouch.ENDED = 2, 
    EventTouch.CANCELLED = 3;
    var EventAcceleration = function(_Event3) {
        function EventAcceleration(acc, bubbles) {
            var _this3;
            return _classCallCheck(this, EventAcceleration), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(EventAcceleration).call(this, Event.ACCELERATION, bubbles))).acc = void 0, 
            _this3.acc = acc, _this3;
        }
        return _inherits(EventAcceleration, Event), EventAcceleration;
    }(), EventKeyboard = function(_Event4) {
        function EventKeyboard(keyCode, isPressed, bubbles) {
            var _this4;
            return _classCallCheck(this, EventKeyboard), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(EventKeyboard).call(this, Event.KEYBOARD, bubbles))).keyCode = void 0, 
            _this4.rawEvent = void 0, _this4.isPressed = void 0, "number" == typeof keyCode ? _this4.keyCode = keyCode : (_this4.keyCode = keyCode.keyCode, 
            _this4.rawEvent = keyCode), _this4.isPressed = isPressed, _this4;
        }
        return _inherits(EventKeyboard, Event), EventKeyboard;
    }();
    Event.EventMouse = EventMouse, Event.EventTouch = EventTouch, Event.EventAcceleration = EventAcceleration, 
    Event.EventKeyboard = EventKeyboard;
    var EventListener = function() {
        function EventListener(type, listenerID, callback) {
            _classCallCheck(this, EventListener), this.owner = null, this.mask = null, this._previousIn = !1, 
            this._target = null, this._onEvent = void 0, this._type = void 0, this._listenerID = void 0, 
            this._registered = !1, this._fixedPriority = 0, this._node = null, this._paused = !0, 
            this._isEnabled = !0, this._onEvent = callback, this._type = type || 0, this._listenerID = listenerID || "";
        }
        return _createClass(EventListener, [ {
            key: "onEvent",
            get: function get() {
                return this._onEvent;
            }
        } ], [ {
            key: "create",
            value: function create(argObj) {
                cc.assertID(argObj && argObj.event, 1900);
                var listenerType = argObj.event;
                delete argObj.event;
                var listener = null;
                if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? listener = new TouchOneByOne() : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? listener = new TouchAllAtOnce() : listenerType === cc.EventListener.MOUSE ? listener = new Mouse() : listenerType === cc.EventListener.KEYBOARD ? listener = new Keyboard() : listenerType === cc.EventListener.ACCELERATION && (listener = new Acceleration(argObj.callback), 
                delete argObj.callback), listener) for (var _arr = Object.keys(argObj), _i = 0; _i < _arr.length; _i++) {
                    var key = _arr[_i];
                    listener[key] = argObj[key];
                }
                return listener;
            }
        } ]), _createClass(EventListener, [ {
            key: "_setPaused",
            value: function _setPaused(paused) {
                this._paused = paused;
            }
        }, {
            key: "_isPaused",
            value: function _isPaused() {
                return this._paused;
            }
        }, {
            key: "_setRegistered",
            value: function _setRegistered(registered) {
                this._registered = registered;
            }
        }, {
            key: "_isRegistered",
            value: function _isRegistered() {
                return this._registered;
            }
        }, {
            key: "_getType",
            value: function _getType() {
                return this._type;
            }
        }, {
            key: "_getListenerID",
            value: function _getListenerID() {
                return this._listenerID;
            }
        }, {
            key: "_setFixedPriority",
            value: function _setFixedPriority(fixedPriority) {
                this._fixedPriority = fixedPriority;
            }
        }, {
            key: "_getFixedPriority",
            value: function _getFixedPriority() {
                return this._fixedPriority;
            }
        }, {
            key: "_setSceneGraphPriority",
            value: function _setSceneGraphPriority(node) {
                this._target = node, this._node = node;
            }
        }, {
            key: "_getSceneGraphPriority",
            value: function _getSceneGraphPriority() {
                return this._node;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return null !== this._onEvent;
            }
        }, {
            key: "clone",
            value: function clone() {
                return null;
            }
        }, {
            key: "setEnabled",
            value: function setEnabled(enabled) {
                this._isEnabled = enabled;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled() {
                return this._isEnabled;
            }
        } ]), EventListener;
    }();
    EventListener.UNKNOWN = 0, EventListener.TOUCH_ONE_BY_ONE = 1, EventListener.TOUCH_ALL_AT_ONCE = 2, 
    EventListener.KEYBOARD = 3, EventListener.MOUSE = 4, EventListener.ACCELERATION = 6, 
    EventListener.CUSTOM = 8, EventListener.ListenerID = {
        MOUSE: "__cc_mouse",
        TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
        TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
        KEYBOARD: "__cc_keyboard",
        ACCELERATION: "__cc_acceleration"
    };
    var ListenerID = EventListener.ListenerID, Mouse = function(_EventListener) {
        function Mouse() {
            var _this;
            return _classCallCheck(this, Mouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mouse).call(this, EventListener.MOUSE, ListenerID.MOUSE, null))).onMouseDown = null, 
            _this.onMouseUp = null, _this.onMouseMove = null, _this.onMouseScroll = null, _this._onEvent = function(event) {
                return _this._callback(event);
            }, _this;
        }
        return _inherits(Mouse, EventListener), _createClass(Mouse, [ {
            key: "_callback",
            value: function _callback(event) {
                var eventType = cc.Event.EventMouse;
                switch (event._eventType) {
                  case eventType.DOWN:
                    this.onMouseDown && this.onMouseDown(event);
                    break;

                  case eventType.UP:
                    this.onMouseUp && this.onMouseUp(event);
                    break;

                  case eventType.MOVE:
                    this.onMouseMove && this.onMouseMove(event);
                    break;

                  case eventType.SCROLL:
                    this.onMouseScroll && this.onMouseScroll(event);
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var eventListener = new Mouse();
                return eventListener.onMouseDown = this.onMouseDown, eventListener.onMouseUp = this.onMouseUp, 
                eventListener.onMouseMove = this.onMouseMove, eventListener.onMouseScroll = this.onMouseScroll, 
                eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return !0;
            }
        } ]), Mouse;
    }(), TouchOneByOne = function(_EventListener2) {
        function TouchOneByOne() {
            var _this2;
            return _classCallCheck(this, TouchOneByOne), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(TouchOneByOne).call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null))).swallowTouches = !1, 
            _this2.onTouchBegan = null, _this2.onTouchMoved = null, _this2.onTouchEnded = null, 
            _this2.onTouchCancelled = null, _this2._claimedTouches = [], _this2;
        }
        return _inherits(TouchOneByOne, EventListener), _createClass(TouchOneByOne, [ {
            key: "setSwallowTouches",
            value: function setSwallowTouches(needSwallow) {
                this.swallowTouches = needSwallow;
            }
        }, {
            key: "isSwallowTouches",
            value: function isSwallowTouches() {
                return this.swallowTouches;
            }
        }, {
            key: "clone",
            value: function clone() {
                var eventListener = new TouchOneByOne();
                return eventListener.onTouchBegan = this.onTouchBegan, eventListener.onTouchMoved = this.onTouchMoved, 
                eventListener.onTouchEnded = this.onTouchEnded, eventListener.onTouchCancelled = this.onTouchCancelled, 
                eventListener.swallowTouches = this.swallowTouches, eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return !!this.onTouchBegan || (cc.logID(1801), !1);
            }
        } ]), TouchOneByOne;
    }(), TouchAllAtOnce = function(_EventListener3) {
        function TouchAllAtOnce() {
            var _this3;
            return _classCallCheck(this, TouchAllAtOnce), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(TouchAllAtOnce).call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null))).onTouchesBegan = null, 
            _this3.onTouchesMoved = null, _this3.onTouchesEnded = null, _this3.onTouchesCancelled = null, 
            _this3;
        }
        return _inherits(TouchAllAtOnce, EventListener), _createClass(TouchAllAtOnce, [ {
            key: "clone",
            value: function clone() {
                var eventListener = new TouchAllAtOnce();
                return eventListener.onTouchesBegan = this.onTouchesBegan, eventListener.onTouchesMoved = this.onTouchesMoved, 
                eventListener.onTouchesEnded = this.onTouchesEnded, eventListener.onTouchesCancelled = this.onTouchesCancelled, 
                eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (cc.logID(1802), 
                !1);
            }
        } ]), TouchAllAtOnce;
    }(), Acceleration = function(_EventListener4) {
        function Acceleration(callback) {
            var _this4;
            return _classCallCheck(this, Acceleration), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(Acceleration).call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null)))._onAccelerationEvent = null, 
            _this4._onEvent = function(event) {
                return _this4._callback(event);
            }, _this4._onAccelerationEvent = callback, _this4;
        }
        return _inherits(Acceleration, EventListener), _createClass(Acceleration, [ {
            key: "_callback",
            value: function _callback(event) {
                this._onAccelerationEvent && this._onAccelerationEvent(event.acc, event);
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return cc.assertID(this._onAccelerationEvent, 1803), !0;
            }
        }, {
            key: "clone",
            value: function clone() {
                return new Acceleration(this._onAccelerationEvent);
            }
        } ]), Acceleration;
    }(), Keyboard = function(_EventListener5) {
        function Keyboard() {
            var _this5;
            return _classCallCheck(this, Keyboard), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Keyboard).call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null))).onKeyPressed = null, 
            _this5.onKeyReleased = null, _this5._onEvent = function(event) {
                return _this5._callback(event);
            }, _this5;
        }
        return _inherits(Keyboard, EventListener), _createClass(Keyboard, [ {
            key: "_callback",
            value: function _callback(event) {
                event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
            }
        }, {
            key: "clone",
            value: function clone() {
                var eventListener = new Keyboard();
                return eventListener.onKeyPressed = this.onKeyPressed, eventListener.onKeyReleased = this.onKeyReleased, 
                eventListener;
            }
        }, {
            key: "checkAvailable",
            value: function checkAvailable() {
                return null !== this.onKeyPressed || null !== this.onKeyReleased || (cc.logID(1800), 
                !1);
            }
        } ]), Keyboard;
    }(), ListenerID$1 = (cc.EventListener = EventListener).ListenerID, _EventListenerVector = function() {
        function _EventListenerVector() {
            _classCallCheck(this, _EventListenerVector), this.gt0Index = 0, this._fixedListeners = [], 
            this._sceneGraphListeners = [];
        }
        return _createClass(_EventListenerVector, [ {
            key: "size",
            value: function size() {
                return this._fixedListeners.length + this._sceneGraphListeners.length;
            }
        }, {
            key: "empty",
            value: function empty() {
                return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
            }
        }, {
            key: "push",
            value: function push(listener) {
                0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
            }
        }, {
            key: "clearSceneGraphListeners",
            value: function clearSceneGraphListeners() {
                this._sceneGraphListeners.length = 0;
            }
        }, {
            key: "clearFixedListeners",
            value: function clearFixedListeners() {
                this._fixedListeners.length = 0;
            }
        }, {
            key: "clear",
            value: function clear$$1() {
                this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0;
            }
        }, {
            key: "getFixedPriorityListeners",
            value: function getFixedPriorityListeners() {
                return this._fixedListeners;
            }
        }, {
            key: "getSceneGraphPriorityListeners",
            value: function getSceneGraphPriorityListeners() {
                return this._sceneGraphListeners;
            }
        } ]), _EventListenerVector;
    }();
    var eventManager = new (function() {
        function EventManager() {
            _classCallCheck(this, EventManager), this._listenersMap = {}, this._priorityDirtyFlagMap = {}, 
            this._nodeListenersMap = {}, this._nodePriorityMap = createMap(!0), this._globalZOrderNodeMap = [], 
            this._toAddedListeners = [], this._toRemovedListeners = [], this._dirtyNodes = [], 
            this._inDispatch = 0, this._isEnabled = !1, this._nodePriorityIndex = 0, this._internalCustomListenerIDs = [];
        }
        return _createClass(EventManager, [ {
            key: "pauseTarget",
            value: function pauseTarget(node) {
                var recursive = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                if (node instanceof cc._BaseNode) {
                    var listeners = this._nodeListenersMap[node.uuid];
                    if (listeners) {
                        var _iterator = listeners, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            _ref._setPaused(!0);
                        }
                    }
                    if (!0 === recursive) {
                        var locChildren = node.children;
                        if (locChildren) {
                            var _iterator2 = locChildren, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref2;
                                if (_isArray2) {
                                    if (_i2 >= _iterator2.length) break;
                                    _ref2 = _iterator2[_i2++];
                                } else {
                                    if ((_i2 = _iterator2.next()).done) break;
                                    _ref2 = _i2.value;
                                }
                                var locChild = _ref2;
                                this.pauseTarget(locChild, !0);
                            }
                        }
                    }
                } else cc.warnID(3506);
            }
        }, {
            key: "resumeTarget",
            value: function resumeTarget(node) {
                var recursive = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                if (node instanceof cc._BaseNode) {
                    var listeners = this._nodeListenersMap[node.uuid];
                    if (listeners) {
                        var _iterator3 = listeners, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            _ref3._setPaused(!1);
                        }
                    }
                    if (this._setDirtyForNode(node), !0 === recursive && 0 < node.children.length) {
                        var locChildren = node.children;
                        if (locChildren) {
                            var _iterator4 = locChildren, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                var _ref4;
                                if (_isArray4) {
                                    if (_i4 >= _iterator4.length) break;
                                    _ref4 = _iterator4[_i4++];
                                } else {
                                    if ((_i4 = _iterator4.next()).done) break;
                                    _ref4 = _i4.value;
                                }
                                var locChild = _ref4;
                                this.resumeTarget(locChild, !0);
                            }
                        }
                    }
                } else cc.warnID(3506);
            }
        }, {
            key: "frameUpdateListeners",
            value: function frameUpdateListeners() {
                var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
                for (var selKey in locListenersMap) locListenersMap[selKey].empty() && (delete locPriorityDirtyFlagMap[selKey], 
                delete locListenersMap[selKey]);
                var locToAddedListeners = this._toAddedListeners;
                if (0 !== locToAddedListeners.length) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                    locToAddedListeners.length = 0;
                }
                0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(listenerID) {
                return !!this._getListeners(listenerID);
            }
        }, {
            key: "addListener",
            value: function addListener(listener, nodeOrPriority) {
                if (cc.assertID(listener && nodeOrPriority, 3503), cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode) {
                    if (listener instanceof cc.EventListener) {
                        if (listener._isRegistered()) return void cc.logID(3505);
                    } else cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504), listener = cc.EventListener.create(listener);
                    if (listener.checkAvailable()) {
                        if (cc.js.isNumber(nodeOrPriority)) {
                            if (0 === nodeOrPriority) return void cc.logID(3500);
                            listener._setSceneGraphPriority(null), listener._setFixedPriority(nodeOrPriority), 
                            listener._setRegistered(!0), listener._setPaused(!1), this._addListener(listener);
                        } else listener._setSceneGraphPriority(nodeOrPriority), listener._setFixedPriority(0), 
                        listener._setRegistered(!0), this._addListener(listener);
                        return listener;
                    }
                } else cc.warnID(3506);
            }
        }, {
            key: "addCustomListener",
            value: function addCustomListener(eventName, callback) {
                var listener = EventListener.create({
                    event: cc.EventListener.CUSTOM,
                    eventName: eventName,
                    callback: callback
                });
                return this.addListener(listener, 1), listener;
            }
        }, {
            key: "removeListener",
            value: function removeListener(listener) {
                if (null != listener) {
                    for (var isFound = !1, locListener = this._listenersMap, _arr = Object.keys(locListener), _i5 = 0; _i5 < _arr.length; _i5++) {
                        var selKey = _arr[_i5], listeners = locListener[selKey], fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                        if ((isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener)) ? this._setDirty(listener._getListenerID(), 2) : (isFound = this._removeListenerInVector(fixedPriorityListeners, listener)) && this._setDirty(listener._getListenerID(), 1), 
                        listeners.empty() && (delete this._priorityDirtyFlagMap[listener._getListenerID()], 
                        delete locListener[selKey]), isFound) break;
                    }
                    if (!isFound) for (var locToAddedListeners = this._toAddedListeners, i = 0, len = locToAddedListeners.length; i < len; i++) {
                        var selListener = locToAddedListeners[i];
                        if (selListener === listener) {
                            cc.js.array.remove(locToAddedListeners, selListener), selListener._setRegistered(!1);
                            break;
                        }
                    }
                }
            }
        }, {
            key: "removeListeners",
            value: function removeListeners(listenerType) {
                var recursive = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                if (cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode) if (void 0 !== listenerType._id) {
                    delete this._nodePriorityMap[listenerType._id], cc.js.array.remove(this._dirtyNodes, listenerType);
                    var listeners = this._nodeListenersMap[listenerType._id];
                    if (listeners) {
                        var _iterator5 = cc.js.array.copy(listeners), _isArray5 = Array.isArray(_iterator5), _i6 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i6 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i6++];
                            } else {
                                if ((_i6 = _iterator5.next()).done) break;
                                _ref5 = _i6.value;
                            }
                            var listenerCopy = _ref5;
                            this.removeListener(listenerCopy);
                        }
                        delete this._nodeListenersMap[listenerType._id];
                    }
                    for (var locToAddedListeners = this._toAddedListeners, i = 0; i < locToAddedListeners.length; ) {
                        var listener = locToAddedListeners[i];
                        listener._getSceneGraphPriority() === listenerType ? (listener._setSceneGraphPriority(null), 
                        listener._setRegistered(!1), locToAddedListeners.splice(i, 1)) : ++i;
                    }
                    if (!0 === recursive) {
                        var _iterator6 = listenerType.getChildren(), _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i7 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i7++];
                            } else {
                                if ((_i7 = _iterator6.next()).done) break;
                                _ref6 = _i7.value;
                            }
                            var locChild = _ref6;
                            this.removeListeners(locChild, !0);
                        }
                    }
                } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? this._removeListenersForListenerID(ListenerID$1.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(ListenerID$1.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(ListenerID$1.KEYBOARD) : cc.logID(3501); else cc.warnID(3506);
            }
        }, {
            key: "removeCustomListeners",
            value: function removeCustomListeners(customEventName) {
                this._removeListenersForListenerID(customEventName);
            }
        }, {
            key: "removeAllListeners",
            value: function removeAllListeners() {
                var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
                for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
            }
        }, {
            key: "setPriority",
            value: function setPriority(listener, fixedPriority) {
                if (null != listener) for (var locListeners = this._listenersMap, _arr2 = Object.keys(locListeners), _i8 = 0; _i8 < _arr2.length; _i8++) {
                    var fixedPriorityListeners = locListeners[_arr2[_i8]].getFixedPriorityListeners();
                    if (fixedPriorityListeners) if (-1 !== fixedPriorityListeners.indexOf(listener)) return null != listener._getSceneGraphPriority() && cc.logID(3502), 
                    void (listener._getFixedPriority() !== fixedPriority && (listener._setFixedPriority(fixedPriority), 
                    this._setDirty(listener._getListenerID(), 1)));
                }
            }
        }, {
            key: "setEnabled",
            value: function setEnabled(enabled) {
                this._isEnabled = enabled;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled() {
                return this._isEnabled;
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                if (this._isEnabled) if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, 
                event && event.getType) {
                    if (event.getType().startsWith(cc.Event.TOUCH)) return this._dispatchTouchEvent(event), 
                    void this._inDispatch--;
                    var listenerID = function __getListenerID(event) {
                        var eventType = Event, type = event.type;
                        return type === eventType.ACCELERATION ? ListenerID$1.ACCELERATION : type === eventType.KEYBOARD ? ListenerID$1.KEYBOARD : type.startsWith(eventType.MOUSE) ? ListenerID$1.MOUSE : (type.startsWith(eventType.TOUCH) && cc.logID(2e3), 
                        "");
                    }(event);
                    this._sortEventListeners(listenerID);
                    var selListeners = this._listenersMap[listenerID];
                    null != selListeners && (this._dispatchEventToListeners(selListeners, this._onListenerCallback, event), 
                    this._onUpdateListeners(selListeners)), this._inDispatch--;
                } else cc.errorID(3511);
            }
        }, {
            key: "_onListenerCallback",
            value: function _onListenerCallback(listener, event) {
                event.currentTarget = listener._target;
                var onEvent = listener.onEvent;
                return onEvent && onEvent(event), event.isStopped();
            }
        }, {
            key: "dispatchCustomEvent",
            value: function dispatchCustomEvent(eventName, optionalUserData) {
                var ev = new cc.Event.EventCustom(eventName);
                ev.setUserData(optionalUserData), this.dispatchEvent(ev);
            }
        }, {
            key: "_setDirtyForNode",
            value: function _setDirtyForNode(node) {
                if (void 0 !== this._nodeListenersMap[node.uuid] && this._dirtyNodes.push(node), 
                0 < node.children.length) for (var _children = node.children, i = 0, len = _children ? _children.length : 0; i < len; i++) this._setDirtyForNode(_children[i]);
            }
        }, {
            key: "_addListener",
            value: function _addListener(listener) {
                0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
            }
        }, {
            key: "_forceAddEventListener",
            value: function _forceAddEventListener(listener) {
                var listenerID = listener._getListenerID(), listeners = this._listenersMap[listenerID];
                if (listeners || (listeners = new _EventListenerVector(), this._listenersMap[listenerID] = listeners), 
                listeners.push(listener), 0 === listener._getFixedPriority()) {
                    this._setDirty(listenerID, 2);
                    var node = listener._getSceneGraphPriority();
                    null === node && cc.logID(3507), this._associateNodeAndEventListener(node, listener), 
                    node.activeInHierarchy && this.resumeTarget(node);
                } else this._setDirty(listenerID, 1);
            }
        }, {
            key: "_getListeners",
            value: function _getListeners(listenerID) {
                return this._listenersMap[listenerID];
            }
        }, {
            key: "_updateDirtyFlagForSceneGraph",
            value: function _updateDirtyFlagForSceneGraph() {
                if (0 !== this._dirtyNodes.length) {
                    for (var locDirtyNodes = this._dirtyNodes, locNodeListenersMap = this._nodeListenersMap, i = 0, len = locDirtyNodes.length; i < len; i++) {
                        var selListeners = locNodeListenersMap[locDirtyNodes[i]._id];
                        if (selListeners) for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
                            var selListener = selListeners[j];
                            selListener && this._setDirty(selListener._getListenerID(), 2);
                        }
                    }
                    this._dirtyNodes.length = 0;
                }
            }
        }, {
            key: "_removeAllListenersInVector",
            value: function _removeAllListenersInVector(listenerVector) {
                if (listenerVector) for (var selListener, i = 0; i < listenerVector.length; ) (selListener = listenerVector[i])._setRegistered(!1), 
                null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.remove(listenerVector, selListener) : ++i;
            }
        }, {
            key: "_removeListenersForListenerID",
            value: function _removeListenersForListenerID(listenerID) {
                var listeners = this._listenersMap[listenerID];
                if (listeners) {
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    this._removeAllListenersInVector(sceneGraphPriorityListeners), this._removeAllListenersInVector(fixedPriorityListeners), 
                    delete this._priorityDirtyFlagMap[listenerID], this._inDispatch || (listeners.clear(), 
                    delete this._listenersMap[listenerID]);
                }
                for (var locToAddedListeners = this._toAddedListeners, i = 0; i < locToAddedListeners.length; ) {
                    var listener = locToAddedListeners[i];
                    listener && listener._getListenerID() === listenerID ? cc.js.array.remove(locToAddedListeners, listener) : ++i;
                }
            }
        }, {
            key: "_sortEventListeners",
            value: function _sortEventListeners(listenerID) {
                var dirtyFlag = 0, locFlagMap = this._priorityDirtyFlagMap;
                if (locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]), 0 !== dirtyFlag && (locFlagMap[listenerID] = 0, 
                1 & dirtyFlag && this._sortListenersOfFixedPriority(listenerID), 2 & dirtyFlag)) {
                    var rootEntity = cc.director.getScene();
                    rootEntity && this._sortListenersOfSceneGraphPriority(listenerID, rootEntity);
                }
            }
        }, {
            key: "_sortListenersOfSceneGraphPriority",
            value: function _sortListenersOfSceneGraphPriority(listenerID, rootNode) {
                var listeners = this._getListeners(listenerID);
                if (listeners) {
                    var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                    sceneGraphListener && 0 !== sceneGraphListener.length && (this._nodePriorityIndex = 0, 
                    this._nodePriorityMap = createMap(!0), this._visitTarget(rootNode, !0), listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes));
                }
            }
        }, {
            key: "_sortEventListenersOfSceneGraphPriorityDes",
            value: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
                var locNodePriorityMap = eventManager._nodePriorityMap, node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
                return l2 && node2 && locNodePriorityMap[node2._id] ? l1 && node1 && locNodePriorityMap[node1._id] ? locNodePriorityMap[node2._id] - locNodePriorityMap[node1._id] : 1 : -1;
            }
        }, {
            key: "_sortListenersOfFixedPriority",
            value: function _sortListenersOfFixedPriority(listenerID) {
                var listeners = this._listenersMap[listenerID];
                if (listeners) {
                    var fixedListeners = listeners.getFixedPriorityListeners();
                    if (fixedListeners && 0 !== fixedListeners.length) {
                        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                        for (var index = 0, len = fixedListeners.length; index < len && !(0 <= fixedListeners[index]._getFixedPriority()); ) ++index;
                        listeners.gt0Index = index;
                    }
                }
            }
        }, {
            key: "_sortListenersOfFixedPriorityAsc",
            value: function _sortListenersOfFixedPriorityAsc(l1, l2) {
                return l1._getFixedPriority() - l2._getFixedPriority();
            }
        }, {
            key: "_onUpdateListeners",
            value: function _onUpdateListeners(listeners) {
                var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), toRemovedListeners = this._toRemovedListeners;
                if (sceneGraphPriorityListeners) for (var i = 0; i < sceneGraphPriorityListeners.length; ) {
                    var selListener = sceneGraphPriorityListeners[i];
                    if (selListener._isRegistered()) ++i; else {
                        cc.js.array.remove(sceneGraphPriorityListeners, selListener);
                        var idx = toRemovedListeners.indexOf(selListener);
                        -1 !== idx && toRemovedListeners.splice(idx, 1);
                    }
                }
                if (fixedPriorityListeners) for (var _i9 = 0; _i9 < fixedPriorityListeners.length; ) {
                    var _selListener = fixedPriorityListeners[_i9];
                    if (_selListener._isRegistered()) ++_i9; else {
                        cc.js.array.remove(fixedPriorityListeners, _selListener);
                        var _idx = toRemovedListeners.indexOf(_selListener);
                        -1 !== _idx && toRemovedListeners.splice(_idx, 1);
                    }
                }
                sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners(), 
                fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
            }
        }, {
            key: "_updateTouchListeners",
            value: function _updateTouchListeners(event) {
                var locInDispatch = this._inDispatch;
                if (cc.assertID(0 < locInDispatch, 3508), !(1 < locInDispatch)) {
                    var listeners;
                    (listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE]) && this._onUpdateListeners(listeners), 
                    (listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE]) && this._onUpdateListeners(listeners), 
                    cc.assertID(1 === locInDispatch, 3509);
                    var locToAddedListeners = this._toAddedListeners;
                    if (0 !== locToAddedListeners.length) {
                        for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                        this._toAddedListeners.length = 0;
                    }
                    0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
                }
            }
        }, {
            key: "_cleanToRemovedListeners",
            value: function _cleanToRemovedListeners() {
                var toRemovedListeners = this._toRemovedListeners, _iterator7 = toRemovedListeners, _isArray7 = Array.isArray(_iterator7), _i10 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i10 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i10++];
                    } else {
                        if ((_i10 = _iterator7.next()).done) break;
                        _ref7 = _i10.value;
                    }
                    var selListener = _ref7, listeners = this._listenersMap[selListener._getListenerID()];
                    if (listeners) {
                        var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                        if (sceneGraphPriorityListeners) {
                            var idx = sceneGraphPriorityListeners.indexOf(selListener);
                            -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
                        }
                        if (fixedPriorityListeners) {
                            var _idx2 = fixedPriorityListeners.indexOf(selListener);
                            -1 !== _idx2 && fixedPriorityListeners.splice(_idx2, 1);
                        }
                    }
                }
                toRemovedListeners.length = 0;
            }
        }, {
            key: "_onTouchEventCallback",
            value: function _onTouchEventCallback(listener, argsObj) {
                if (!listener._isRegistered()) return !1;
                var event = argsObj.event, selTouch = event.currentTouch;
                event.currentTarget = listener._getSceneGraphPriority();
                var removedIdx, isClaimed = !1, getCode = event.getEventCode();
                return getCode === EventTouch.BEGAN ? listener.onTouchBegan && (isClaimed = listener.onTouchBegan(selTouch, event)) && listener._isRegistered() && listener._claimedTouches.push(selTouch) : 0 < listener._claimedTouches.length && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch)) && (isClaimed = !0, 
                getCode === EventTouch.MOVED && listener.onTouchMoved ? listener.onTouchMoved(selTouch, event) : getCode === EventTouch.ENDED ? (listener.onTouchEnded && listener.onTouchEnded(selTouch, event), 
                listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1)) : getCode === EventTouch.CANCELLED && (listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event), 
                listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1))), event.isStopped() ? (eventManager._updateTouchListeners(event), 
                !0) : !!(isClaimed && listener._isRegistered() && listener.swallowTouches) && (argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1), 
                !0);
            }
        }, {
            key: "_dispatchTouchEvent",
            value: function _dispatchTouchEvent(event) {
                this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE), this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
                var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE), allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
                if (null !== oneByOneListeners || null !== allAtOnceListeners) {
                    var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches), oneByOneArgsObj = {
                        event: event,
                        needsMutableSet: oneByOneListeners && allAtOnceListeners,
                        touches: mutableTouches,
                        selTouch: null
                    };
                    if (oneByOneListeners) {
                        var _iterator8 = originalTouches, _isArray8 = Array.isArray(_iterator8), _i11 = 0;
                        for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                            var _ref8;
                            if (_isArray8) {
                                if (_i11 >= _iterator8.length) break;
                                _ref8 = _iterator8[_i11++];
                            } else {
                                if ((_i11 = _iterator8.next()).done) break;
                                _ref8 = _i11.value;
                            }
                            var originalTouch = _ref8;
                            event.currentTouch = originalTouch, event.propagationStopped = event.propagationImmediateStopped = !1, 
                            this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                        }
                    }
                    allAtOnceListeners && 0 < mutableTouches.length && (this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                        event: event,
                        touches: mutableTouches
                    }), event.isStopped()) || this._updateTouchListeners(event);
                }
            }
        }, {
            key: "_onTouchesEventCallback",
            value: function _onTouchesEventCallback(listener, callbackParams) {
                if (!listener._isRegistered()) return !1;
                var event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
                return event.currentTarget = listener._getSceneGraphPriority(), getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event), 
                !!event.isStopped() && (eventManager._updateTouchListeners(event), !0);
            }
        }, {
            key: "_associateNodeAndEventListener",
            value: function _associateNodeAndEventListener(node, listener) {
                var listeners = this._nodeListenersMap[node.uuid];
                listeners || (listeners = [], this._nodeListenersMap[node.uuid] = listeners), listeners.push(listener);
            }
        }, {
            key: "_dissociateNodeAndEventListener",
            value: function _dissociateNodeAndEventListener(node, listener) {
                var listeners = this._nodeListenersMap[node.uuid];
                listeners && (cc.js.array.remove(listeners, listener), 0 === listeners.length && delete this._nodeListenersMap[node.uuid]);
            }
        }, {
            key: "_dispatchEventToListeners",
            value: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
                var shouldStopPropagation = !1, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), i = 0;
                if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
                    var selListener = fixedPriorityListeners[i];
                    if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                        shouldStopPropagation = !0;
                        break;
                    }
                }
                if (sceneGraphPriorityListeners && !shouldStopPropagation) {
                    var _iterator9 = sceneGraphPriorityListeners, _isArray9 = Array.isArray(_iterator9), _i12 = 0;
                    for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray9) {
                            if (_i12 >= _iterator9.length) break;
                            _ref9 = _iterator9[_i12++];
                        } else {
                            if ((_i12 = _iterator9.next()).done) break;
                            _ref9 = _i12.value;
                        }
                        var _selListener2 = _ref9;
                        if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
                            shouldStopPropagation = !0;
                            break;
                        }
                    }
                }
                if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
                    var _selListener3 = fixedPriorityListeners[i];
                    if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
                        shouldStopPropagation = !0;
                        break;
                    }
                }
            }
        }, {
            key: "_setDirty",
            value: function _setDirty(listenerID, flag) {
                var locDirtyFlagMap = this._priorityDirtyFlagMap;
                null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
            }
        }, {
            key: "_visitTarget",
            value: function _visitTarget(node, isRootNode) {
                node._reorderChildDirty && node.sortAllChildren();
                var child, children = node.children, i = 0, childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
                if (0 < childrenCount) for (void 0 !== locNodeListenersMap[node._id] && (locGlobalZOrderNodeMap || (locGlobalZOrderNodeMap = []), 
                locGlobalZOrderNodeMap.push(node._id)); i < childrenCount; i++) (child = children[i]) && this._visitTarget(child, !1); else void 0 !== locNodeListenersMap[node._id] && (locGlobalZOrderNodeMap || (locGlobalZOrderNodeMap = []), 
                locGlobalZOrderNodeMap.push(node._id));
                if (isRootNode) {
                    var locNodePriorityMap = this._nodePriorityMap, _iterator10 = locGlobalZOrderNodeMap, _isArray10 = Array.isArray(_iterator10), _i13 = 0;
                    for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                        var _ref10;
                        if (_isArray10) {
                            if (_i13 >= _iterator10.length) break;
                            _ref10 = _iterator10[_i13++];
                        } else {
                            if ((_i13 = _iterator10.next()).done) break;
                            _ref10 = _i13.value;
                        }
                        locNodePriorityMap[_ref10] = ++this._nodePriorityIndex;
                    }
                    this._globalZOrderNodeMap.length = 0;
                }
            }
        }, {
            key: "_sortNumberAsc",
            value: function _sortNumberAsc(a, b) {
                return a - b;
            }
        }, {
            key: "_removeListenerInCallback",
            value: function _removeListenerInCallback(listeners, callback) {
                if (null == listeners) return !1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var selListener = listeners[i];
                    if (selListener._onCustomEvent === callback || selListener.onEvent === callback) return selListener._setRegistered(!1), 
                    null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                    selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener), 
                    !0;
                }
                return !1;
            }
        }, {
            key: "_removeListenerInVector",
            value: function _removeListenerInVector(listeners, listener) {
                if (null == listeners) return !1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var selListener = listeners[i];
                    if (selListener === listener) return selListener._setRegistered(!1), null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                    selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener), 
                    !0;
                }
                return !1;
            }
        } ]), EventManager;
    }())();
    cc.eventManager = eventManager;
    var macro = {
        SUPPORT_TEXTURE_FORMATS: [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ],
        KEY: {
            none: 0,
            back: 6,
            menu: 18,
            backspace: 8,
            tab: 9,
            enter: 13,
            shift: 16,
            ctrl: 17,
            alt: 18,
            pause: 19,
            capslock: 20,
            escape: 27,
            space: 32,
            pageup: 33,
            pagedown: 34,
            end: 35,
            home: 36,
            left: 37,
            up: 38,
            right: 39,
            down: 40,
            select: 41,
            insert: 45,
            Delete: 46,
            0: 48,
            1: 49,
            2: 50,
            3: 51,
            4: 52,
            5: 53,
            6: 54,
            7: 55,
            8: 56,
            9: 57,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90,
            num0: 96,
            num1: 97,
            num2: 98,
            num3: 99,
            num4: 100,
            num5: 101,
            num6: 102,
            num7: 103,
            num8: 104,
            num9: 105,
            "*": 106,
            "+": 107,
            "-": 109,
            numdel: 110,
            "/": 111,
            f1: 112,
            f2: 113,
            f3: 114,
            f4: 115,
            f5: 116,
            f6: 117,
            f7: 118,
            f8: 119,
            f9: 120,
            f10: 121,
            f11: 122,
            f12: 123,
            numlock: 144,
            scrolllock: 145,
            ";": 186,
            semicolon: 186,
            equal: 187,
            "=": 187,
            ",": 188,
            comma: 188,
            dash: 189,
            ".": 190,
            period: 190,
            forwardslash: 191,
            grave: 192,
            "[": 219,
            openbracket: 219,
            backslash: 220,
            "]": 221,
            closebracket: 221,
            quote: 222,
            dpadLeft: 1e3,
            dpadRight: 1001,
            dpadUp: 1003,
            dpadDown: 1004,
            dpadCenter: 1005
        },
        ImageFormat: cc.Enum({
            JPG: 0,
            PNG: 1,
            TIFF: 2,
            WEBP: 3,
            PVR: 4,
            ETC: 5,
            S3TC: 6,
            ATITC: 7,
            TGA: 8,
            RAWDATA: 9,
            UNKNOWN: 10
        }),
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 1.192092896e-7,
        MIN_ZINDEX: -Math.pow(2, 15),
        MAX_ZINDEX: Math.pow(2, 15) - 1,
        ORIENTATION_PORTRAIT: 1,
        ORIENTATION_LANDSCAPE: 2,
        ORIENTATION_AUTO: 3,
        DENSITYDPI_DEVICE: "device-dpi",
        DENSITYDPI_HIGH: "high-dpi",
        DENSITYDPI_MEDIUM: "medium-dpi",
        DENSITYDPI_LOW: "low-dpi",
        FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: !0,
        DIRECTOR_STATS_POSITION: new Vec2(0, 0),
        ENABLE_STACKABLE_ACTIONS: !0,
        TOUCH_TIMEOUT: 5e3,
        BATCH_VERTEX_COUNT: 2e4,
        ENABLE_TILEDMAP_CULLING: !0,
        DOWNLOAD_MAX_CONCURRENT: 64,
        ENABLE_TRANSPARENT_CANVAS: !1,
        ENABLE_WEBGL_ANTIALIAS: !1,
        ENABLE_CULLING: !1,
        CLEANUP_IMAGE_CACHE: !1,
        SHOW_MESH_WIREFRAME: !1
    };
    cc.macro = macro;
    var _vec2 = new Vec2(), Touch = function() {
        function Touch(x, y) {
            var id = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
            _classCallCheck(this, Touch), this._point = new Vec2(), this._prevPoint = new Vec2(), 
            this._lastModified = 0, this._id = null, this._startPoint = new Vec2(), this._startPointCaptured = !1, 
            this.setTouchInfo(id, x, y);
        }
        return _createClass(Touch, [ {
            key: "getLocation",
            value: function getLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._point.x, this._point.y), out;
            }
        }, {
            key: "getLocationX",
            value: function getLocationX() {
                return this._point.x;
            }
        }, {
            key: "getLocationY",
            value: function getLocationY() {
                return this._point.y;
            }
        }, {
            key: "getUILocation",
            value: function getUILocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._point.x, this._point.y), cc.view._convertPointWithScale(out), 
                out;
            }
        }, {
            key: "getUILocationX",
            value: function getUILocationX() {
                var viewport = cc.view.getViewportRect();
                return (this._point.x - viewport.x) / cc.view.getScaleX();
            }
        }, {
            key: "getUILocationY",
            value: function getUILocationY() {
                var viewport = cc.view.getViewportRect();
                return (this._point.y - viewport.y) / cc.view.getScaleY();
            }
        }, {
            key: "getPreviousLocation",
            value: function getPreviousLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._prevPoint.x, this._prevPoint.y), 
                out;
            }
        }, {
            key: "getUIPreviousLocation",
            value: function getUIPreviousLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._prevPoint.x, this._prevPoint.y), 
                cc.view._convertPointWithScale(out), out;
            }
        }, {
            key: "getStartLocation",
            value: function getStartLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._startPoint.x, this._startPoint.y), 
                out;
            }
        }, {
            key: "getUIStartLocation",
            value: function getUIStartLocation(out) {
                return out || (out = new Vec2()), vec2.set(out, this._startPoint.x, this._startPoint.y), 
                cc.view._convertPointWithScale(out), out;
            }
        }, {
            key: "getDelta",
            value: function getDelta(out) {
                return out || (out = new Vec2()), this._point.sub(this._prevPoint, out), out;
            }
        }, {
            key: "getUIDelta",
            value: function getUIDelta(out) {
                return out || (out = new Vec2()), this._point.sub(this._prevPoint, _vec2), vec2.set(out, cc.view.getScaleX(), cc.view.getScaleY()), 
                vec2.divide(out, _vec2, out), out;
            }
        }, {
            key: "getLocationInView",
            value: function getLocationInView(out) {
                return out || (out = new Vec2()), vec2.set(out, this._point.x, cc.view._designResolutionSize.height - this._point.y), 
                out;
            }
        }, {
            key: "getPreviousLocationInView",
            value: function getPreviousLocationInView(out) {
                return out || (out = new Vec2()), vec2.set(out, this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y), 
                out;
            }
        }, {
            key: "getStartLocationInView",
            value: function getStartLocationInView(out) {
                return out || (out = new Vec2()), vec2.set(out, this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y), 
                out;
            }
        }, {
            key: "getID",
            value: function getID() {
                return this._id;
            }
        }, {
            key: "setTouchInfo",
            value: function setTouchInfo() {
                var id = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null, x = 1 < arguments.length ? arguments[1] : void 0, y = 2 < arguments.length ? arguments[2] : void 0;
                this._prevPoint = this._point, this._point = new Vec2(x || 0, y || 0), this._id = id, 
                this._startPointCaptured || (this._startPoint = new Vec2(this._point), this._startPointCaptured = !0);
            }
        }, {
            key: "_setPoint",
            value: function _setPoint(x, y) {
                "object" === _typeof(x) ? (this._point.x = x.x, this._point.y = x.y) : (this._point.x = x || 0, 
                this._point.y = y || 0);
            }
        }, {
            key: "_setPrevPoint",
            value: function _setPrevPoint(x, y) {
                "object" === _typeof(x) ? this._prevPoint = new Vec2(x.x, x.y) : this._prevPoint = new Vec2(x || 0, y || 0);
            }
        } ]), Touch;
    }();
    cc.Touch = Touch;
    var _didAccelerateFun, SystemEventType, TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT, _vec2$1 = new Vec2(), _preLocation = new Vec2(), Acceleration$1 = function Acceleration() {
        var x = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, z = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, timestamp = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
        _classCallCheck(this, Acceleration), this.x = void 0, this.y = void 0, this.z = void 0, 
        this.timestamp = void 0, this.x = x, this.y = y, this.z = z, this.timestamp = timestamp;
    }, inputManager = new (function() {
        function InputManager() {
            _classCallCheck(this, InputManager), this._mousePressed = !1, this._isRegisterEvent = !1, 
            this._preTouchPoint = new Vec2(), this._prevMousePoint = new Vec2(), this._preTouchPool = [], 
            this._preTouchPoolPointer = 0, this._touches = [], this._touchesIntegerDict = {}, 
            this._indexBitsUsed = 0, this._maxTouches = 8, this._accelEnabled = !1, this._accelInterval = .2, 
            this._accelMinus = 1, this._accelCurTime = 0, this._acceleration = null, this._accelDeviceEvent = null, 
            this._glView = null, this._minus = 0, this._pointLocked = !1;
        }
        return _createClass(InputManager, [ {
            key: "handleTouchesBegin",
            value: function handleTouchesBegin(touches) {
                var handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now(), _iterator = touches, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var touch = _ref, touchID = touch.getID();
                    if (null !== touchID) if (void 0 === locTouchIntDict[touchID]) {
                        var unusedIndex = this._getUnUsedIndex();
                        if (-1 === unusedIndex) {
                            cc.logID(2300, unusedIndex);
                            continue;
                        }
                        var curTouch = new Touch(touch._point.x, touch._point.y, touch.getID());
                        (this._touches[unusedIndex] = curTouch)._lastModified = now, curTouch._setPrevPoint(touch._prevPoint), 
                        locTouchIntDict[touchID] = unusedIndex, handleTouches.push(curTouch);
                    }
                }
                if (0 < handleTouches.length) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.BEGAN, eventManager.dispatchEvent(touchEvent);
                }
            }
        }, {
            key: "handleTouchesMove",
            value: function handleTouchesMove(touches) {
                var handleTouches = [], locTouches = this._touches, now = sys.now(), _iterator2 = touches, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var touch = _ref2, touchID = touch.getID();
                    if (null !== touchID) {
                        var _index2 = this._touchesIntegerDict[touchID];
                        void 0 !== _index2 && locTouches[_index2] && (locTouches[_index2]._setPoint(touch._point), 
                        locTouches[_index2]._setPrevPoint(touch._prevPoint), locTouches[_index2]._lastModified = now, 
                        handleTouches.push(locTouches[_index2]));
                    }
                }
                if (0 < handleTouches.length) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.MOVED, eventManager.dispatchEvent(touchEvent);
                }
            }
        }, {
            key: "handleTouchesEnd",
            value: function handleTouchesEnd(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (0 < handleTouches.length) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.ENDED, eventManager.dispatchEvent(touchEvent);
                }
                this._preTouchPool.length = 0;
            }
        }, {
            key: "handleTouchesCancel",
            value: function handleTouchesCancel(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (0 < handleTouches.length) {
                    var touchEvent = new EventTouch(handleTouches);
                    touchEvent._eventCode = EventTouch.CANCELLED, eventManager.dispatchEvent(touchEvent);
                }
                this._preTouchPool.length = 0;
            }
        }, {
            key: "getSetOfTouchesEndOrCancel",
            value: function getSetOfTouchesEndOrCancel(touches) {
                var handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict, _iterator3 = touches, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var touch = _ref3, touchID = touch.getID();
                    if (null !== touchID) {
                        var _index3 = locTouchesIntDict[touchID];
                        void 0 !== _index3 && locTouches[_index3] && (locTouches[_index3]._setPoint(touch._point), 
                        locTouches[_index3]._setPrevPoint(touch._prevPoint), handleTouches.push(locTouches[_index3]), 
                        this._removeUsedIndexBit(_index3), delete locTouchesIntDict[touchID]);
                    }
                }
                return handleTouches;
            }
        }, {
            key: "getHTMLElementPosition",
            value: function getHTMLElementPosition(element) {
                if (sys.platform === sys.WECHAT_GAME) return {
                    left: 0,
                    top: 0,
                    width: window.innerWidth,
                    height: window.innerHeight
                };
                var docElem = document.documentElement, leftOffset = window.pageXOffset - docElem.clientLeft, topOffset = window.pageYOffset - docElem.clientTop;
                if (element.getBoundingClientRect) {
                    var box = element.getBoundingClientRect();
                    return {
                        left: box.left + leftOffset,
                        top: box.top + topOffset,
                        width: box.width,
                        height: box.height
                    };
                }
                return element instanceof HTMLCanvasElement ? {
                    left: leftOffset,
                    top: topOffset,
                    width: element.width,
                    height: element.height
                } : {
                    left: leftOffset,
                    top: topOffset,
                    width: parseInt(element.style.width || "0", void 0),
                    height: parseInt(element.style.height || "0", void 0)
                };
            }
        }, {
            key: "getPreTouch",
            value: function getPreTouch(touch) {
                for (var preTouch = null, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; 0 <= i; i--) if (locPreTouchPool[i].getID() === id) {
                    preTouch = locPreTouchPool[i];
                    break;
                }
                return preTouch || (preTouch = touch), preTouch;
            }
        }, {
            key: "setPreTouch",
            value: function setPreTouch(touch) {
                for (var find = !1, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; 0 <= i; i--) if (locPreTouchPool[i].getID() === id) {
                    locPreTouchPool[i] = touch, find = !0;
                    break;
                }
                find || (locPreTouchPool.length <= 50 ? locPreTouchPool.push(touch) : (locPreTouchPool[this._preTouchPoolPointer] = touch, 
                this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50));
            }
        }, {
            key: "getTouchByXY",
            value: function getTouchByXY(event, tx, ty, pos) {
                var locPreTouch = this._preTouchPoint, location = this._glView.convertToLocationInView(tx, ty, pos);
                this._pointLocked && (location.x = locPreTouch.x + event.movementX, location.y = locPreTouch.y - event.movementY);
                var touch = new Touch(location.x, location.y, 0);
                return touch._setPrevPoint(locPreTouch.x, locPreTouch.y), locPreTouch.x = location.x, 
                locPreTouch.y = location.y, touch;
            }
        }, {
            key: "getMouseEvent",
            value: function getMouseEvent(location, pos, eventType) {
                var locPreMouse = this._prevMousePoint, mouseEvent = new EventMouse(eventType);
                return mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y), locPreMouse.x = location.x, 
                locPreMouse.y = location.y, this._glView._convertMouseToLocation(locPreMouse, pos), 
                mouseEvent.setLocation(locPreMouse.x, locPreMouse.y), mouseEvent;
            }
        }, {
            key: "getPointByEvent",
            value: function getPointByEvent(event, pos) {
                return null != event.pageX ? {
                    x: event.pageX,
                    y: event.pageY
                } : (sys.platform === sys.WECHAT_GAME ? (pos.left = 0, pos.top = 0) : (pos.left -= document.body.scrollLeft, 
                pos.top -= document.body.scrollTop), {
                    x: event.clientX,
                    y: event.clientY
                });
            }
        }, {
            key: "getTouchesByEvent",
            value: function getTouchesByEvent(event, position) {
                for (var touches = [], locView = this._glView, locPreTouch = this._preTouchPoint, length = event.changedTouches.length, i = 0; i < length; i++) {
                    var changedTouch = event.changedTouches[i];
                    if (changedTouch) {
                        var location = void 0;
                        location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(changedTouch.pageX, changedTouch.pageY, position, _vec2$1) : locView.convertToLocationInView(changedTouch.clientX, changedTouch.clientY, position, _vec2$1);
                        var touch = void 0;
                        null != changedTouch.identifier ? (touch = new Touch(location.x, location.y, changedTouch.identifier), 
                        this.getPreTouch(touch).getLocation(_preLocation), touch._setPrevPoint(_preLocation.x, _preLocation.y), 
                        this.setPreTouch(touch)) : (touch = new Touch(location.x, location.y))._setPrevPoint(locPreTouch.x, locPreTouch.y), 
                        locPreTouch.x = location.x, locPreTouch.y = location.y, touches.push(touch);
                    }
                }
                return touches;
            }
        }, {
            key: "registerSystemEvent",
            value: function registerSystemEvent(element) {
                if (!this._isRegisterEvent) {
                    this._glView = cc.view;
                    var prohibition = sys.isMobile, supportMouse = "mouse" in sys.capabilities, supportTouches = "touches" in sys.capabilities;
                    sys.platform === sys.WECHAT_GAME && (supportMouse = !(supportTouches = !(prohibition = !1))), 
                    supportMouse && this._registerMouseEvents(element, prohibition), window.navigator.msPointerEnabled && this._registerMousePointerEvents(element), 
                    supportTouches && this._registerTouchEvents(element), cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent(), 
                    this._isRegisterEvent = !0;
                }
            }
        }, {
            key: "setAccelerometerEnabled",
            value: function setAccelerometerEnabled(isEnable) {
                if (this._accelEnabled !== isEnable) {
                    this._accelEnabled = isEnable;
                    var scheduler = cc.director.getScheduler();
                    scheduler.enableForTarget(this), this._accelEnabled ? (this._registerAccelerometerEvent(), 
                    this._accelCurTime = 0, scheduler.scheduleUpdate(this)) : (this._unregisterAccelerometerEvent(), 
                    this._accelCurTime = 0, scheduler.unscheduleUpdate(this));
                }
            }
        }, {
            key: "didAccelerate",
            value: function didAccelerate(eventData) {
                if (this._accelEnabled) {
                    var mAcceleration = this._acceleration, x = 0, y = 0, z = 0;
                    if (this._accelDeviceEvent === window.DeviceMotionEvent) {
                        var eventAcceleration = eventData.accelerationIncludingGravity;
                        eventAcceleration && (x = this._accelMinus * (eventAcceleration.x || 0) * .1, y = this._accelMinus * (eventAcceleration.y || 0) * .1, 
                        z = .1 * (eventAcceleration.z || 0));
                    } else {
                        var deviceOrientationEvent = eventData;
                        x = (deviceOrientationEvent.gamma || 0) / 90 * .981, y = -(deviceOrientationEvent.beta || 0) / 90 * .981, 
                        z = (deviceOrientationEvent.alpha || 0) / 90 * .981;
                    }
                    if (cc.view._isRotated) {
                        var tmp = x;
                        x = -y, y = tmp;
                    }
                    mAcceleration.x = x, mAcceleration.y = y, mAcceleration.z = z, mAcceleration.timestamp = eventData.timeStamp || Date.now();
                    var tmpX = mAcceleration.x;
                    90 === window.orientation ? (mAcceleration.x = -mAcceleration.y, mAcceleration.y = tmpX) : -90 === window.orientation ? (mAcceleration.x = mAcceleration.y, 
                    mAcceleration.y = -tmpX) : 180 === window.orientation && (mAcceleration.x = -mAcceleration.x, 
                    mAcceleration.y = -mAcceleration.y), cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ && (mAcceleration.x = -mAcceleration.x, 
                    mAcceleration.y = -mAcceleration.y);
                }
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, 
                eventManager.dispatchEvent(new EventAcceleration(this._acceleration))), this._accelCurTime += dt;
            }
        }, {
            key: "setAccelerometerInterval",
            value: function setAccelerometerInterval(interval) {
                this._accelInterval !== interval && (this._accelInterval = interval);
            }
        }, {
            key: "_getUnUsedIndex",
            value: function _getUnUsedIndex() {
                for (var temp = this._indexBitsUsed, now = cc.sys.now(), i = 0; i < this._maxTouches; i++) {
                    if (!(1 & temp)) return this._indexBitsUsed |= 1 << i, i;
                    var touch = this._touches[i];
                    if (now - touch._lastModified > TOUCH_TIMEOUT) {
                        this._removeUsedIndexBit(i);
                        var touchID = touch.getID();
                        return null !== touchID && delete this._touchesIntegerDict[touchID], i;
                    }
                    temp >>= 1;
                }
                return -1;
            }
        }, {
            key: "_removeUsedIndexBit",
            value: function _removeUsedIndexBit(index) {
                if (!(index < 0 || index >= this._maxTouches)) {
                    var temp = 1 << index;
                    temp = ~temp, this._indexBitsUsed &= temp;
                }
            }
        }, {
            key: "_registerMouseEvents",
            value: function _registerMouseEvents(element, prohibition) {
                this._registerPointerLockEvent(), prohibition || this._registerWindowMouseEvents(element), 
                this._registerElementMouseEvents(element, prohibition);
            }
        }, {
            key: "_registerPointerLockEvent",
            value: function _registerPointerLockEvent() {
                var _this = this, lockChangeAlert = function lockChangeAlert() {
                    var canvas = cc.game.canvas;
                    document.pointerLockElement === canvas || document.mozPointerLockElement === canvas ? _this._pointLocked = !0 : _this._pointLocked = !1;
                };
                "onpointerlockchange" in document ? document.addEventListener("pointerlockchange", lockChangeAlert, !1) : "onmozpointerlockchange" in document && document.addEventListener("mozpointerlockchange", lockChangeAlert, !1);
            }
        }, {
            key: "_registerWindowMouseEvents",
            value: function _registerWindowMouseEvents(element) {
                var _this2 = this;
                window.addEventListener("mousedown", function() {
                    _this2._mousePressed = !0;
                }, !1), window.addEventListener("mouseup", function(event) {
                    if (_this2._mousePressed) {
                        _this2._mousePressed = !1;
                        var position = _this2.getHTMLElementPosition(element), location = _this2.getPointByEvent(event, position);
                        if (!rect(position.left, position.top, position.width, position.height).contains(new Vec2(location.x, location.y))) {
                            _this2.handleTouchesEnd([ _this2.getTouchByXY(event, location.x, location.y, position) ]);
                            var mouseEvent = _this2.getMouseEvent(location, position, EventMouse.UP);
                            mouseEvent.setButton(event.button), eventManager.dispatchEvent(mouseEvent);
                        }
                    }
                }, !1);
            }
        }, {
            key: "_registerElementMouseEvents",
            value: function _registerElementMouseEvents(element, prohibition) {
                var _this3 = this, listenDOMMouseEvent = function listenDOMMouseEvent(eventName, type, handler) {
                    element.addEventListener(eventName, function(event) {
                        var pos = _this3.getHTMLElementPosition(element), location = _this3.getPointByEvent(event, pos), mouseEvent = _this3.getMouseEvent(location, pos, type);
                        mouseEvent.setButton(event.button), handler(event, mouseEvent, location, pos), eventManager.dispatchEvent(mouseEvent), 
                        event.stopPropagation(), event.preventDefault();
                    });
                };
                prohibition || (listenDOMMouseEvent("mousedown", EventMouse.DOWN, function(event, mouseEvent, location, pos) {
                    _this3._mousePressed = !0, _this3.handleTouchesBegin([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                    element.focus();
                }), listenDOMMouseEvent("mouseup", EventMouse.UP, function(event, mouseEvent, location, pos) {
                    _this3._mousePressed = !1, _this3.handleTouchesEnd([ _this3.getTouchByXY(event, location.x, location.y, pos) ]);
                }), listenDOMMouseEvent("mousemove", EventMouse.MOVE, function(event, mouseEvent, location, pos) {
                    _this3.handleTouchesMove([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                    _this3._mousePressed || mouseEvent.setButton(null), void 0 !== event.movementX && void 0 !== event.movementY && (mouseEvent.movementX = event.movementX, 
                    mouseEvent.movementY = event.movementY);
                })), listenDOMMouseEvent("mousewheel", EventMouse.SCROLL, function(event, mouseEvent, location, pos) {
                    mouseEvent.setScrollData(0, event.wheelDelta);
                }), listenDOMMouseEvent("DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent, location, pos) {
                    mouseEvent.setScrollData(0, -120 * event.detail);
                });
            }
        }, {
            key: "_registerMousePointerEvents",
            value: function _registerMousePointerEvents(element) {
                for (var _this4 = this, _pointerEventsMap = {
                    MSPointerDown: this.handleTouchesBegin,
                    MSPointerMove: this.handleTouchesMove,
                    MSPointerUp: this.handleTouchesEnd,
                    MSPointerCancel: this.handleTouchesCancel
                }, _arr = Object.keys(_pointerEventsMap), _loop = function _loop() {
                    var eventName = _arr[_i4], touchEvent = _pointerEventsMap[eventName];
                    element.addEventListener(eventName, function(event) {
                        var pos = _this4.getHTMLElementPosition(element);
                        pos.left -= document.documentElement.scrollLeft, pos.top -= document.documentElement.scrollTop, 
                        touchEvent.call(_this4, [ _this4.getTouchByXY(event, event.clientX, event.clientY, pos) ]), 
                        event.stopPropagation();
                    }, !1);
                }, _i4 = 0; _i4 < _arr.length; _i4++) _loop();
            }
        }, {
            key: "_registerTouchEvents",
            value: function _registerTouchEvents(element) {
                cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? this._registerWXGameTouchEvents(element) : this._registerHTMLTouchEvents(element);
            }
        }, {
            key: "_registerWXGameTouchEvents",
            value: function _registerWXGameTouchEvents(element) {
                var _this5 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                    return function(event) {
                        var pos = _this5.getHTMLElementPosition(element), body = document.body;
                        pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this5.getTouchesByEvent(event, pos));
                    };
                };
                wx.onTouchStart(makeTouchListener(function(touchesToHandle) {
                    _this5.handleTouchesBegin(touchesToHandle);
                })), wx.onTouchEnd(makeTouchListener(function(touchesToHandle) {
                    _this5.handleTouchesEnd(touchesToHandle);
                })), wx.onTouchMove(makeTouchListener(function(touchesToHandle) {
                    _this5.handleTouchesMove(touchesToHandle);
                })), wx.onTouchCancel(makeTouchListener(function(touchesToHandle) {
                    _this5.handleTouchesCancel(touchesToHandle);
                }));
            }
        }, {
            key: "_registerHTMLTouchEvents",
            value: function _registerHTMLTouchEvents(element) {
                var _this6 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                    return function(event) {
                        if (event.changedTouches) {
                            var pos = _this6.getHTMLElementPosition(element), body = document.body;
                            pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this6.getTouchesByEvent(event, pos)), 
                            event.stopPropagation(), event.preventDefault();
                        }
                    };
                };
                element.addEventListener("touchstart", makeTouchListener(function(touchesToHandle) {
                    _this6.handleTouchesBegin(touchesToHandle), sys.platform !== sys.WECHAT_GAME && element.focus();
                }), !1), element.addEventListener("touchmove", makeTouchListener(function(touchesToHandle) {
                    _this6.handleTouchesMove(touchesToHandle);
                }), !1), element.addEventListener("touchend", makeTouchListener(function(touchesToHandle) {
                    _this6.handleTouchesEnd(touchesToHandle);
                }), !1), element.addEventListener("touchcancel", makeTouchListener(function(touchesToHandle) {
                    _this6.handleTouchesCancel(touchesToHandle);
                }), !1);
            }
        }, {
            key: "_registerKeyboardEvent",
            value: function _registerKeyboardEvent() {
                var canvas = cc.game.canvas;
                canvas.addEventListener("keydown", function(event) {
                    eventManager.dispatchEvent(new EventKeyboard(event, !0)), event.stopPropagation(), 
                    event.preventDefault();
                }, !1), canvas.addEventListener("keyup", function(event) {
                    eventManager.dispatchEvent(new EventKeyboard(event, !1)), event.stopPropagation(), 
                    event.preventDefault();
                }, !1);
            }
        }, {
            key: "_registerAccelerometerEvent",
            value: function _registerAccelerometerEvent() {
                var _this7 = this;
                this._acceleration = new Acceleration$1(), this._accelDeviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent, 
                cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
                var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation", ua = navigator.userAgent;
                (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (this._minus = -1), 
                _didAccelerateFun = function _didAccelerateFun() {
                    return _this7.didAccelerate.apply(_this7, arguments);
                }, window.addEventListener(_deviceEventType, _didAccelerateFun, !1);
            }
        }, {
            key: "_unregisterAccelerometerEvent",
            value: function _unregisterAccelerometerEvent() {
                var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
                _didAccelerateFun && window.removeEventListener(_deviceEventType, _didAccelerateFun, !1);
            }
        } ]), InputManager;
    }())();
    cc.internal.inputManager = inputManager, (SystemEventType = exports.SystemEventType || (exports.SystemEventType = {})).TOUCH_START = "touch-start", 
    SystemEventType.TOUCH_MOVE = "touch-move", SystemEventType.TOUCH_END = "touch-end", 
    SystemEventType.TOUCH_CANCEL = "touch-cancel", SystemEventType.MOUSE_DOWN = "mouse-down", 
    SystemEventType.MOUSE_MOVE = "mouse-move", SystemEventType.MOUSE_UP = "mouse-up", 
    SystemEventType.MOUSE_WHEEL = "mouse-wheel", SystemEventType.MOUSE_ENTER = "mouse-enter", 
    SystemEventType.MOUSE_LEAVE = "mouse-leave", SystemEventType.KEY_DOWN = "keydown", 
    SystemEventType.KEY_UP = "keyup", SystemEventType.DEVICEMOTION = "devicemotion", 
    SystemEventType.TRANSFORM_CHANGED = "transform-changed", SystemEventType.POSITION_PART = "position-part", 
    SystemEventType.ROTATION_PART = "rotation-part", SystemEventType.SCALE_PART = "scale-part", 
    SystemEventType.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists", SystemEventType.SIZE_CHANGED = "size-changed", 
    SystemEventType.ANCHOR_CHANGED = "anchor-changed", SystemEventType.CHILD_ADDED = "child-added", 
    SystemEventType.CHILD_REMOVED = "child-removed", ccenum(exports.SystemEventType), 
    cc.SystemEventType = exports.SystemEventType;
    var keyboardListener = null, accelerationListener = null, touchListener = null, mouseListener = null, SystemEvent = function(_EventTarget) {
        function SystemEvent() {
            return _classCallCheck(this, SystemEvent), _possibleConstructorReturn(this, _getPrototypeOf(SystemEvent).call(this));
        }
        return _inherits(SystemEvent, EventTarget), _createClass(SystemEvent, [ {
            key: "setAccelerometerEnabled",
            value: function setAccelerometerEnabled(isEnable) {
                inputManager.setAccelerometerEnabled(isEnable);
            }
        }, {
            key: "setAccelerometerInterval",
            value: function setAccelerometerInterval(interval) {
                inputManager.setAccelerometerInterval(interval);
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                return _get(_getPrototypeOf(SystemEvent.prototype), "on", this).call(this, type, callback, target), 
                type !== exports.SystemEventType.KEY_DOWN && type !== exports.SystemEventType.KEY_UP || (keyboardListener || (keyboardListener = EventListener.create({
                    event: EventListener.KEYBOARD,
                    onKeyPressed: function onKeyPressed(keyCode, event) {
                        event.type = exports.SystemEventType.KEY_DOWN, systemEvent.emit(event.type, event);
                    },
                    onKeyReleased: function onKeyReleased(keyCode, event) {
                        event.type = exports.SystemEventType.KEY_UP, systemEvent.emit(event.type, event);
                    }
                })), eventManager.hasEventListener(EventListener.ListenerID.KEYBOARD) || eventManager.addListener(keyboardListener, 256)), 
                type === exports.SystemEventType.DEVICEMOTION && (accelerationListener || (accelerationListener = EventListener.create({
                    event: EventListener.ACCELERATION,
                    callback: function callback(acc, event) {
                        event.type = exports.SystemEventType.DEVICEMOTION, cc.systemEvent.emit(event.type, event);
                    }
                })), eventManager.hasEventListener(EventListener.ListenerID.ACCELERATION) || eventManager.addListener(accelerationListener, 256)), 
                type !== exports.SystemEventType.TOUCH_START && type !== exports.SystemEventType.TOUCH_MOVE && type !== exports.SystemEventType.TOUCH_END && type !== exports.SystemEventType.TOUCH_CANCEL || touchListener || (touchListener = EventListener.create({
                    event: EventListener.TOUCH_ONE_BY_ONE,
                    onTouchBegan: function onTouchBegan(touch, event) {
                        return event.type = exports.SystemEventType.TOUCH_START, cc.systemEvent.emit(event.type, touch, event), 
                        !0;
                    },
                    onTouchMoved: function onTouchMoved(touch, event) {
                        event.type = exports.SystemEventType.TOUCH_MOVE, cc.systemEvent.emit(event.type, touch, event);
                    },
                    onTouchEnded: function onTouchEnded(touch, event) {
                        event.type = exports.SystemEventType.TOUCH_END, cc.systemEvent.emit(event.type, touch, event);
                    },
                    onTouchCancelled: function onTouchCancelled(touch, event) {
                        event.type = exports.SystemEventType.TOUCH_CANCEL, cc.systemEvent.emit(event.type, touch, event);
                    }
                }), eventManager.addListener(touchListener, 256)), type !== exports.SystemEventType.MOUSE_DOWN && type !== exports.SystemEventType.MOUSE_MOVE && type !== exports.SystemEventType.MOUSE_UP && type !== exports.SystemEventType.MOUSE_WHEEL || mouseListener || (mouseListener = EventListener.create({
                    event: EventListener.MOUSE,
                    onMouseDown: function onMouseDown(event) {
                        event.type = exports.SystemEventType.MOUSE_DOWN, cc.systemEvent.emit(event.type, event);
                    },
                    onMouseMove: function onMouseMove(event) {
                        event.type = exports.SystemEventType.MOUSE_MOVE, cc.systemEvent.emit(event.type, event);
                    },
                    onMouseUp: function onMouseUp(event) {
                        event.type = exports.SystemEventType.MOUSE_UP, cc.systemEvent.emit(event.type, event);
                    },
                    onMouseScroll: function onMouseScroll(event) {
                        event.type = exports.SystemEventType.MOUSE_WHEEL, cc.systemEvent.emit(event.type, event);
                    }
                }), eventManager.addListener(mouseListener, 256)), callback;
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                if (_get(_getPrototypeOf(SystemEvent.prototype), "off", this).call(this, type, callback, target), 
                keyboardListener && (type === exports.SystemEventType.KEY_DOWN || type === exports.SystemEventType.KEY_UP)) {
                    var hasKeyDownEventListener = this.hasEventListener(exports.SystemEventType.KEY_DOWN), hasKeyUpEventListener = this.hasEventListener(exports.SystemEventType.KEY_UP);
                    hasKeyDownEventListener || hasKeyUpEventListener || eventManager.removeListener(keyboardListener);
                }
                accelerationListener && type === exports.SystemEventType.DEVICEMOTION && eventManager.removeListener(accelerationListener);
            }
        } ]), SystemEvent;
    }();
    SystemEvent.EventType = exports.SystemEventType;
    var _dec$i, _dec2$7, _dec3$1, _dec4, _dec5, _dec6, _dec7, _class$i, _class2$d, _descriptor$b, _descriptor2$5, _class3$6, _temp$f, systemEvent = new (cc.SystemEvent = SystemEvent)();
    cc.systemEvent = systemEvent;
    var idGenerator$1 = new IDGenerator("Comp"), IsOnLoadCalled$1 = (CCObject.Flags.IsOnEnableCalled, 
    CCObject.Flags.IsOnLoadCalled), Component = (_dec$i = ccclass("cc.Component"), _dec2$7 = property({
        visible: !1
    }), _dec3$1 = property({
        visible: !1
    }), _dec4 = property({
        displayName: "Script",
        type: Script,
        tooltip: void 0
    }), _dec5 = property({
        visible: !1
    }), _dec6 = property({
        visible: !1
    }), _dec7 = property({
        visible: !1
    }), _dec$i((_temp$f = _class3$6 = function(_CCObject) {
        function Component() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Component);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "node", _descriptor$b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_enabled", _descriptor2$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._sceneGetter = null, _this._id = idGenerator$1.getNewId(), _this._eventTargets = [], 
            _this;
        }
        return _inherits(Component, CCObject), _createClass(Component, [ {
            key: "_getRenderScene",
            value: function _getRenderScene() {
                return this._sceneGetter ? this._sceneGetter() : this.node.scene._renderScene;
            }
        }, {
            key: "addComponent",
            value: function addComponent(typeOrClassName) {
                return this.node.addComponent(typeOrClassName);
            }
        }, {
            key: "getComponent",
            value: function getComponent(typeOrClassName) {
                return this.node.getComponent(typeOrClassName);
            }
        }, {
            key: "getComponents",
            value: function getComponents(typeOrClassName) {
                return this.node.getComponents(typeOrClassName);
            }
        }, {
            key: "getComponentInChildren",
            value: function getComponentInChildren(typeOrClassName) {
                return this.node.getComponentInChildren(typeOrClassName);
            }
        }, {
            key: "getComponentsInChildren",
            value: function getComponentsInChildren(typeOrClassName) {
                return this.node.getComponentsInChildren(typeOrClassName);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Component.prototype), "destroy", this).call(this) && this._enabled && this.node.activeInHierarchy && cc.director._compScheduler.disableComp(this);
            }
        }, {
            key: "_onPreDestroy",
            value: function _onPreDestroy() {
                this.unscheduleAllCallbacks();
                for (var eventTargets = this._eventTargets, i = 0, l = eventTargets.length; i < l; ++i) {
                    var target = eventTargets[i];
                    target && target.targetOff(this);
                }
                eventTargets.length = 0, cc.director._nodeActivator.destroyComp(this), this.node._removeComponent(this);
            }
        }, {
            key: "_instantiate",
            value: function _instantiate(cloned) {
                return cloned || (cloned = cc.instantiate._clone(this, this)), cloned.node = null, 
                cloned;
            }
        }, {
            key: "schedule",
            value: function schedule(callback) {
                var interval = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, repeat = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : cc.macro.REPEAT_FOREVER, delay = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                cc.assertID(callback, 1619), cc.assertID(0 <= interval, 1620), interval = interval || 0, 
                repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat, delay = delay || 0;
                var scheduler = cc.director.getScheduler(), paused = scheduler.isTargetPaused(this);
                scheduler.schedule(callback, this, interval, repeat, delay, paused);
            }
        }, {
            key: "scheduleOnce",
            value: function scheduleOnce(callback) {
                var delay = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                this.schedule(callback, 0, 0, delay);
            }
        }, {
            key: "unschedule",
            value: function unschedule(callback_fn) {
                callback_fn && cc.director.getScheduler().unschedule(callback_fn, this);
            }
        }, {
            key: "unscheduleAllCallbacks",
            value: function unscheduleAllCallbacks() {
                cc.director.getScheduler().unscheduleAllForTarget(this);
            }
        }, {
            key: "name",
            get: function get$$1() {
                if (this._name) return this._name;
                var className = getClassName(this), trimLeft = className.lastIndexOf(".");
                return 0 <= trimLeft && (className = className.slice(trimLeft + 1)), this.node.name + "<" + className + ">";
            },
            set: function set(value$$1) {
                this._name = value$$1;
            }
        }, {
            key: "uuid",
            get: function get$$1() {
                return this._id;
            }
        }, {
            key: "__scriptAsset",
            get: function get$$1() {
                return null;
            }
        }, {
            key: "enabled",
            get: function get$$1() {
                return this._enabled;
            },
            set: function set(value$$1) {
                if (this._enabled !== value$$1 && (this._enabled = value$$1, this.node.activeInHierarchy)) {
                    var compScheduler = cc.director._compScheduler;
                    value$$1 ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
                }
            }
        }, {
            key: "enabledInHierarchy",
            get: function get$$1() {
                return this._enabled && this.node && this.node.activeInHierarchy;
            }
        }, {
            key: "_isOnLoadCalled",
            get: function get$$1() {
                return this._objFlags & IsOnLoadCalled$1;
            }
        } ]), Component;
    }(), _class3$6.system = null, _applyDecoratedDescriptor((_class2$d = _temp$f).prototype, "name", [ _dec2$7 ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "name"), _class2$d.prototype), 
    _applyDecoratedDescriptor(_class2$d.prototype, "uuid", [ _dec3$1 ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "uuid"), _class2$d.prototype), 
    _applyDecoratedDescriptor(_class2$d.prototype, "__scriptAsset", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "__scriptAsset"), _class2$d.prototype), 
    _applyDecoratedDescriptor(_class2$d.prototype, "enabled", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "enabled"), _class2$d.prototype), 
    _applyDecoratedDescriptor(_class2$d.prototype, "enabledInHierarchy", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "enabledInHierarchy"), _class2$d.prototype), 
    _descriptor$b = _applyDecoratedDescriptor(_class2$d.prototype, "node", [ _dec7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$d.prototype, "_enabled", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _class$i = _class2$d)) || _class$i), proto$1 = Component.prototype;
    proto$1.update = null, proto$1.lateUpdate = null, proto$1.__preload = null, proto$1.onLoad = null, 
    proto$1.start = null, proto$1.onEnable = null, proto$1.onDisable = null, proto$1.onDestroy = null, 
    proto$1.onFocusInEditor = null, proto$1.onLostFocusInEditor = null, proto$1.resetInEditor = null, 
    proto$1._getLocalBounds = null, proto$1.onRestore = null, Component._requireComponent = null, 
    Component._executionOrder = 0, value(Component, "_registerEditorProps", function(cls, props) {
        var reqComp = props.requireComponent;
        reqComp && (cls._requireComponent = reqComp);
        var order = props.executionOrder;
        order && "number" == typeof order && (cls._executionOrder = order);
    }), cc.Component = Component;
    var _class$j, _class2$e, _descriptor$c, _descriptor2$6, _descriptor3$3, _descriptor4$2, _descriptor5$1, _descriptor6$1, _class3$7, _temp$g;
    CCObject.Flags.Destroying;
    var Destroying$2 = CCObject.Flags.Destroying, DontDestroy$1 = CCObject.Flags.DontDestroy, Deactivating$1 = CCObject.Flags.Deactivating, idGenerator$2 = new IDGenerator("Node");
    function getConstructor(typeOrClassName) {
        return typeOrClassName ? "string" == typeof typeOrClassName ? getClassByName(typeOrClassName) : typeOrClassName : (cc.errorID(3804), 
        null);
    }
    var BaseNode = ccclass("cc._BaseNode")((_temp$g = _class3$7 = function(_CCObject) {
        function BaseNode(name) {
            var _this;
            return _classCallCheck(this, BaseNode), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name)), "_parent", _descriptor$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_children", _descriptor2$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_active", _descriptor3$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_level", _descriptor4$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_components", _descriptor5$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_prefab", _descriptor6$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._scene = null, _this._activeInHierarchy = !1, _this._id = idGenerator$2.getNewId(), 
            _this.__eventTargets = [], _this._name = void 0 !== name ? name : "New Node", cc.director._scheduler && cc.director._scheduler.enableForTarget(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(BaseNode, CCObject), _createClass(BaseNode, [ {
            key: "components",
            get: function get$$1() {
                return this._components;
            }
        }, {
            key: "_persistNode",
            get: function get$$1() {
                return 0 < (this._objFlags & DontDestroy$1);
            },
            set: function set(value$$1) {
                value$$1 ? this._objFlags |= DontDestroy$1 : this._objFlags &= ~DontDestroy$1;
            }
        }, {
            key: "name",
            get: function get$$1() {
                return this._name;
            },
            set: function set(value$$1) {
                this._name = value$$1;
            }
        }, {
            key: "uuid",
            get: function get$$1() {
                return this._id;
            }
        }, {
            key: "children",
            get: function get$$1() {
                return this._children;
            }
        }, {
            key: "childrenCount",
            get: function get$$1() {
                return this._children.length;
            }
        }, {
            key: "active",
            get: function get$$1() {
                return this._active;
            },
            set: function set(isActive) {
                if (this._active !== isActive) {
                    this._active = isActive;
                    var parent = this._parent;
                    if (parent) parent._activeInHierarchy && cc.director._nodeActivator.activateNode(this, isActive);
                }
            }
        }, {
            key: "activeInHierarchy",
            get: function get$$1() {
                return this._activeInHierarchy;
            }
        }, {
            key: "parent",
            get: function get$$1() {
                return this._parent;
            },
            set: function set(value$$1) {
                this.setParent(value$$1);
            }
        }, {
            key: "scene",
            get: function get$$1() {
                return this._scene;
            }
        } ], [ {
            key: "_setScene",
            value: function _setScene(node) {
                node instanceof cc.Scene ? node._scene = node : null == node._parent ? cc.error("Node %s(%s) has not attached to a scene.", node.name, node.uuid) : node._scene = node._parent._scene;
            }
        }, {
            key: "_findComponent",
            value: function _findComponent(node, constructor) {
                if (constructor._sealed) {
                    var _iterator = node._components, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var comp = _ref;
                        if (comp.constructor === constructor) return comp;
                    }
                } else {
                    var _iterator2 = node._components, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        if (_ref2 instanceof constructor) return _ref2;
                    }
                }
                return null;
            }
        }, {
            key: "_findComponents",
            value: function _findComponents(node, constructor, components) {
                if (constructor._sealed) {
                    var _iterator3 = node._components, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var comp = _ref3;
                        comp.constructor === constructor && components.push(comp);
                    }
                } else {
                    var _iterator4 = node._components, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        var _comp2 = _ref4;
                        _comp2 instanceof constructor && components.push(_comp2);
                    }
                }
            }
        }, {
            key: "_findChildComponent",
            value: function _findChildComponent(children, constructor) {
                var _iterator5 = children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    var node = _ref5, comp = BaseNode._findComponent(node, constructor);
                    if (comp) return comp;
                    if (0 < node._children.length && (comp = BaseNode._findChildComponent(node._children, constructor))) return comp;
                }
                return null;
            }
        }, {
            key: "_findChildComponents",
            value: function _findChildComponents(children, constructor, components) {
                var _iterator6 = children, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    var node = _ref6;
                    BaseNode._findComponents(node, constructor, components), 0 < node._children.length && BaseNode._findChildComponents(node._children, constructor, components);
                }
            }
        } ]), _createClass(BaseNode, [ {
            key: "getParent",
            value: function getParent() {
                return this._parent;
            }
        }, {
            key: "setParent",
            value: function setParent(value$$1) {
                var keepWorldTransform = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                if (this._parent !== value$$1) {
                    var oldParent = this._parent;
                    if (this._parent = value$$1, this._onSetParent(oldParent, keepWorldTransform), value$$1 && (this._level = value$$1._level + 1, 
                    value$$1._children.push(this), value$$1.emit && value$$1.emit(exports.SystemEventType.CHILD_ADDED, this)), 
                    oldParent && !(oldParent._objFlags & Destroying$2)) {
                        var removeAt = oldParent._children.indexOf(this);
                        0, oldParent._children.splice(removeAt, 1), oldParent.emit && oldParent.emit(exports.SystemEventType.CHILD_REMOVED, this);
                    }
                    this._onHierarchyChanged(oldParent);
                }
            }
        }, {
            key: "attr",
            value: function attr(attrs) {
                mixin(this, attrs);
            }
        }, {
            key: "getChildByUuid",
            value: function getChildByUuid(uuid) {
                if (!uuid) return cc.log("Invalid uuid"), null;
                for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
                return null;
            }
        }, {
            key: "getChildByName",
            value: function getChildByName(name) {
                if (!name) return cc.log("Invalid name"), null;
                for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
                return null;
            }
        }, {
            key: "getChildByPath",
            value: function getChildByPath(path) {
                var segments = path.split("/"), lastNode = this, _loop2 = function _loop2() {
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) return "break";
                        _ref7 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) return "break";
                        _ref7 = _i7.value;
                    }
                    var segment = _ref7;
                    if (0 === segment.length) return "continue";
                    var next = lastNode.children.find(function(childNode) {
                        return childNode.name === segment;
                    });
                    if (!next) return {
                        v: null
                    };
                    lastNode = next;
                };
                var _iterator7 = segments, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                _loop: for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7, _ret = _loop2();
                    switch (_ret) {
                      case "break":
                        break _loop;

                      case "continue":
                        continue;

                      default:
                        if ("object" === _typeof(_ret)) return _ret.v;
                    }
                }
                return lastNode;
            }
        }, {
            key: "addChild",
            value: function addChild(child) {
                cc.assertID(child, 1606), cc.assertID(null === child._parent, 1605), child.setParent(this);
            }
        }, {
            key: "insertChild",
            value: function insertChild(child, siblingIndex) {
                child.parent = this, child.setSiblingIndex(siblingIndex);
            }
        }, {
            key: "getSiblingIndex",
            value: function getSiblingIndex() {
                return this._parent ? this._parent._children.indexOf(this) : 0;
            }
        }, {
            key: "setSiblingIndex",
            value: function setSiblingIndex(index) {
                if (this._parent) if (this._parent._objFlags & Deactivating$1) cc.errorID(3821); else {
                    var siblings = this._parent._children;
                    index = -1 !== index ? index : siblings.length - 1;
                    var oldIndex = siblings.indexOf(this);
                    index !== oldIndex && (siblings.splice(oldIndex, 1), index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this), 
                    this._onSiblingIndexChanged && this._onSiblingIndexChanged(index));
                }
            }
        }, {
            key: "walk",
            value: function walk(prefunc, postfunc) {
                var index = 1, children = null, curr = null, i = 0, stack = BaseNode._stacks[BaseNode._stackId];
                stack || (stack = [], BaseNode._stacks.push(stack)), BaseNode._stackId++, stack.length = 0, 
                stack[0] = this;
                for (var parent = null, afterChildren = !1; index; ) if (curr = stack[--index]) if (!afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr), 
                stack[index] = null, afterChildren) {
                    if (afterChildren = !1, children) if (children[++i]) stack[index] = children[i], 
                    index++; else if (parent && (stack[index] = parent, index++, afterChildren = !0, 
                    parent._parent ? (i = (children = parent._parent._children).indexOf(parent), parent = parent._parent) : children = parent = null, 
                    i < 0)) break;
                } else 0 < curr._children.length ? (children = (parent = curr)._children, i = 0, 
                stack[index] = children[i], index++) : (stack[index] = curr, index++, afterChildren = !0);
                stack.length = 0, BaseNode._stackId--;
            }
        }, {
            key: "removeFromParent",
            value: function removeFromParent(cleanup) {
                this._parent && (void 0 === cleanup && (cleanup = !0), this._parent.removeChild(this, cleanup));
            }
        }, {
            key: "removeChild",
            value: function removeChild(child, cleanup) {
                -1 < this._children.indexOf(child) && ((cleanup || void 0 === cleanup) && child.cleanup(), 
                child.parent = null);
            }
        }, {
            key: "removeAllChildren",
            value: function removeAllChildren(cleanup) {
                var children = this._children;
                void 0 === cleanup && (cleanup = !0);
                for (var i = children.length - 1; 0 <= i; i--) {
                    var node = children[i];
                    node && (cleanup && node.cleanup(), node.parent = null);
                }
                this._children.length = 0;
            }
        }, {
            key: "isChildOf",
            value: function isChildOf(parent) {
                var child = this;
                do {
                    if (child === parent) return !0;
                    child = child._parent;
                } while (child);
                return !1;
            }
        }, {
            key: "getComponent",
            value: function getComponent(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                return constructor ? BaseNode._findComponent(this, constructor) : null;
            }
        }, {
            key: "getComponents",
            value: function getComponents(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName), components = [];
                return constructor && BaseNode._findComponents(this, constructor, components), components;
            }
        }, {
            key: "getComponentInChildren",
            value: function getComponentInChildren(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                return constructor ? BaseNode._findChildComponent(this._children, constructor) : null;
            }
        }, {
            key: "getComponentsInChildren",
            value: function getComponentsInChildren(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName), components = [];
                return constructor && (BaseNode._findComponents(this, constructor, components), 
                BaseNode._findChildComponents(this._children, constructor, components)), components;
            }
        }, {
            key: "addComponent",
            value: function addComponent(typeOrClassName) {
                var constructor;
                if ("string" == typeof typeOrClassName) {
                    if (!(constructor = getClassByName(typeOrClassName))) return cc.errorID(3807, typeOrClassName), 
                    cc._RF.peek() && cc.errorID(3808, typeOrClassName), null;
                } else {
                    if (!typeOrClassName) return cc.errorID(3804), null;
                    constructor = typeOrClassName;
                }
                if ("function" != typeof constructor) return cc.errorID(3809), null;
                if (!isChildClassOf(constructor, cc.Component)) return cc.errorID(3810), null;
                var ReqComp = constructor._requireComponent;
                if (ReqComp && !this.getComponent(ReqComp) && !this.addComponent(ReqComp)) return null;
                var component = new constructor();
                return (component.node = this)._components.push(component), this._activeInHierarchy && cc.director._nodeActivator.activateComp(component), 
                component;
            }
        }, {
            key: "removeComponent",
            value: function removeComponent(component) {
                if (component) {
                    var componentInstance = null;
                    (componentInstance = component instanceof Component ? component : this.getComponent(component)) && componentInstance.destroy();
                } else cc.errorID(3813);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return !!_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this) && (this._activeInHierarchy && this._disableChildComps(), 
                !0);
            }
        }, {
            key: "destroyAllChildren",
            value: function destroyAllChildren() {
                var _iterator8 = this._children, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i8 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i8++];
                    } else {
                        if ((_i8 = _iterator8.next()).done) break;
                        _ref8 = _i8.value;
                    }
                    _ref8.destroy();
                }
            }
        }, {
            key: "cleanup",
            value: function cleanup() {}
        }, {
            key: "_removeComponent",
            value: function _removeComponent(component) {
                if (component) {
                    if (!(this._objFlags & Destroying$2)) {
                        var i = this._components.indexOf(component);
                        -1 !== i ? this._components.splice(i, 1) : component.node !== this && cc.errorID(3815);
                    }
                } else cc.errorID(3814);
            }
        }, {
            key: "_onSetParent",
            value: function _onSetParent(oldParent) {
                this._parent && (null != oldParent && oldParent._scene === this._parent._scene || null == this._parent._scene || this.walk(function(node) {
                    BaseNode._setScene(node);
                }));
            }
        }, {
            key: "_onPostActivated",
            value: function _onPostActivated() {}
        }, {
            key: "_onBatchRestored",
            value: function _onBatchRestored() {}
        }, {
            key: "_onBatchCreated",
            value: function _onBatchCreated() {}
        }, {
            key: "_onPreDestroy",
            value: function _onPreDestroy() {
                this._onPreDestroyBase();
            }
        }, {
            key: "_onHierarchyChanged",
            value: function _onHierarchyChanged(oldParent) {
                return this._onHierarchyChangedBase(oldParent);
            }
        }, {
            key: "_instantiate",
            value: function _instantiate(cloned) {
                cloned || (cloned = cc.instantiate._clone(this, this));
                var thisPrefabInfo = this._prefab;
                thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
                return cloned._parent = null, cloned._onBatchRestored(), cloned;
            }
        }, {
            key: "_onHierarchyChangedBase",
            value: function _onHierarchyChangedBase(oldParent) {
                var newParent = this._parent;
                !this._persistNode || newParent instanceof cc.Scene || cc.game.removePersistRootNode(this);
                var shouldActiveNow = this._active && !(!newParent || !newParent._activeInHierarchy);
                this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
            }
        }, {
            key: "_onPreDestroyBase",
            value: function _onPreDestroyBase() {
                this._objFlags |= Destroying$2;
                var parent = this._parent, destroyByParent = null !== parent && 0 != (parent._objFlags & Destroying$2);
                var _iterator9 = this._children, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i9 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i9++];
                    } else {
                        if ((_i9 = _iterator9.next()).done) break;
                        _ref9 = _i9.value;
                    }
                    _ref9._destroyImmediate();
                }
                var _iterator10 = this._components, _isArray10 = Array.isArray(_iterator10), _i10 = 0;
                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                    var _ref10;
                    if (_isArray10) {
                        if (_i10 >= _iterator10.length) break;
                        _ref10 = _iterator10[_i10++];
                    } else {
                        if ((_i10 = _iterator10.next()).done) break;
                        _ref10 = _i10.value;
                    }
                    _ref10._destroyImmediate();
                }
                var _iterator11 = this.__eventTargets, _isArray11 = Array.isArray(_iterator11), _i11 = 0;
                for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                    var _ref11;
                    if (_isArray11) {
                        if (_i11 >= _iterator11.length) break;
                        _ref11 = _iterator11[_i11++];
                    } else {
                        if ((_i11 = _iterator11.next()).done) break;
                        _ref11 = _i11.value;
                    }
                    _ref11 && _ref11.targetOff(this);
                }
                if (this.__eventTargets.length = 0, this._persistNode && cc.game.removePersistRootNode(this), 
                !destroyByParent && parent) {
                    var childIndex = parent._children.indexOf(this);
                    parent._children.splice(childIndex, 1), parent.emit && parent.emit("child-removed", this);
                }
                return destroyByParent;
            }
        }, {
            key: "_disableChildComps",
            value: function _disableChildComps() {
                var _iterator12 = this._components, _isArray12 = Array.isArray(_iterator12), _i12 = 0;
                for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                    var _ref12;
                    if (_isArray12) {
                        if (_i12 >= _iterator12.length) break;
                        _ref12 = _iterator12[_i12++];
                    } else {
                        if ((_i12 = _iterator12.next()).done) break;
                        _ref12 = _i12.value;
                    }
                    var component = _ref12;
                    component._enabled && cc.director._compScheduler.disableComp(component);
                }
                var _iterator13 = this._children, _isArray13 = Array.isArray(_iterator13), _i13 = 0;
                for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                    var _ref13;
                    if (_isArray13) {
                        if (_i13 >= _iterator13.length) break;
                        _ref13 = _iterator13[_i13++];
                    } else {
                        if ((_i13 = _iterator13.next()).done) break;
                        _ref13 = _i13.value;
                    }
                    var node = _ref13;
                    node._active && node._disableChildComps();
                }
            }
        } ]), BaseNode;
    }(), _class3$7.idGenerator = idGenerator$2, _class3$7._stacks = [ [] ], _class3$7._stackId = 0, 
    _applyDecoratedDescriptor((_class2$e = _temp$g).prototype, "_persistNode", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "_persistNode"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "name", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "name"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "uuid", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "uuid"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "children", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "children"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "childrenCount", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "childrenCount"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "active", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "active"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "activeInHierarchy", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "activeInHierarchy"), _class2$e.prototype), 
    _applyDecoratedDescriptor(_class2$e.prototype, "parent", [ property ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "parent"), _class2$e.prototype), 
    _descriptor$c = _applyDecoratedDescriptor(_class2$e.prototype, "_parent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$e.prototype, "_children", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$e.prototype, "_active", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_level", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$e.prototype, "_components", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor6$1 = _applyDecoratedDescriptor(_class2$e.prototype, "_prefab", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$j = _class2$e)) || _class$j;
    cc._BaseNode = BaseNode;
    var _dec$k, _dec2$8, _class$k, _class2$f, _descriptor$d, _descriptor2$7, _descriptor3$4, _descriptor4$3, _descriptor5$2, _class3$8, _temp$h, Layers = function() {
        function Layers() {
            _classCallCheck(this, Layers);
        }
        return _createClass(Layers, null, [ {
            key: "addLayer",
            value: function addLayer(name) {
                if (!(31 < Layers._nextAvailable)) return Layers[name] = 1 << Layers._nextAvailable++;
                console.warn("maximum layers reached.");
            }
        }, {
            key: "makeInclusiveMask",
            value: function makeInclusiveMask(includes) {
                var mask = 0, _iterator = includes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    mask |= _ref;
                }
                return mask;
            }
        }, {
            key: "makeExclusiveMask",
            value: function makeExclusiveMask(excludes) {
                return ~Layers.makeInclusiveMask(excludes);
            }
        }, {
            key: "check",
            value: function check(layer, mask) {
                return (layer & mask) === layer;
            }
        } ]), Layers;
    }();
    Layers.Default = 1, Layers.IgnoreRaycast = 2, Layers.Gizmos = 4, Layers.Editor = 8, 
    Layers.UI = 16, Layers.All = Layers.makeExclusiveMask([ Layers.Gizmos, Layers.Editor ]), 
    Layers.RaycastMask = Layers.makeExclusiveMask([ Layers.Gizmos, Layers.Editor, Layers.IgnoreRaycast ]), 
    Layers._nextAvailable = 8, cc.Layers = Layers;
    var NodeSpace, v3_a = new Vec3(), q_a = new Quat(), array_a = new Array(10);
    !function(NodeSpace) {
        NodeSpace[NodeSpace.LOCAL = 0] = "LOCAL", NodeSpace[NodeSpace.WORLD = 1] = "WORLD";
    }(NodeSpace || (NodeSpace = {}));
    var _class$l, Node$1 = (_dec$k = ccclass("cc.Node"), _dec2$8 = property({
        type: Vec3
    }), _dec$k((_temp$h = _class3$8 = function(_BaseNode) {
        function Node() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Node);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._pos = new Vec3(), 
            _this._rot = new Quat(), _this._scale = new Vec3(1, 1, 1), _this._mat = new Mat4(), 
            _initializerDefineProperty(_this, "_lpos", _descriptor$d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_lrot", _descriptor2$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_lscale", _descriptor3$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_layer", _descriptor4$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_euler", _descriptor5$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._dirty = !1, _this._hasChanged = !1, _this._matDirty = !1, _this._eulerDirty = !1, 
            _this._eventProcessor = new cc.NodeEventProcessor(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this._eventMask = 0, _this._uiTransfromComp = null, _this;
        }
        return _inherits(Node, BaseNode), _createClass(Node, [ {
            key: "setParent",
            value: function setParent(value) {
                var keepWorldTransform = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                keepWorldTransform && this.updateWorldTransform(), _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
            }
        }, {
            key: "_onSetParent",
            value: function _onSetParent(oldParent, keepWorldTransform) {
                if (_get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform), 
                keepWorldTransform) {
                    var parent = this._parent, local = this._lpos;
                    parent ? (parent.updateWorldTransform(), vec3.subtract(local, this._pos, parent._pos), 
                    vec3.transformQuat(local, local, quat.conjugate(q_a, parent._rot)), vec3.divide(local, local, parent._scale), 
                    quat.multiply(this._lrot, quat.conjugate(q_a, parent._rot), this._rot), vec3.divide(this._lscale, this._scale, parent._scale)) : (vec3.copy(this._lpos, this._pos), 
                    quat.copy(this._lrot, this._rot), vec3.copy(this._lscale, this._scale)), this._eulerDirty = !0;
                } else vec3.copy(this._pos, this._lpos), quat.copy(this._rot, this._lrot), vec3.copy(this._scale, this._lscale);
                this.invalidateChildren();
            }
        }, {
            key: "_onBatchCreated",
            value: function _onBatchCreated() {
                vec3.copy(this._pos, this._lpos), quat.copy(this._rot, this._lrot), vec3.copy(this._scale, this._lscale), 
                this._dirty = this._hasChanged = !0, this._eventMask = 0;
                var _iterator = this._children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref._onBatchCreated();
                }
            }
        }, {
            key: "_onBatchRestored",
            value: function _onBatchRestored() {
                this._onBatchCreated();
            }
        }, {
            key: "_onBeforeSerialize",
            value: function _onBeforeSerialize() {
                this.eulerAngles;
            }
        }, {
            key: "translate",
            value: function translate(trans, ns) {
                var space = ns || NodeSpace.LOCAL;
                vec3.copy(v3_a, this._lpos), space === NodeSpace.LOCAL ? (vec3.transformQuat(v3_a, trans, this.worldRotation), 
                this.setPosition(vec3.add(v3_a, this._lpos, v3_a))) : space === NodeSpace.WORLD && this.setPosition(vec3.add(v3_a, this._lpos, trans));
            }
        }, {
            key: "rotate",
            value: function rotate(rot, ns) {
                var space = ns || NodeSpace.LOCAL;
                space === NodeSpace.LOCAL ? (this.getRotation(q_a), this.setRotation(quat.multiply(q_a, q_a, rot))) : space === NodeSpace.WORLD && (this.getWorldRotation(q_a), 
                this.setWorldRotation(quat.multiply(q_a, rot, q_a)));
            }
        }, {
            key: "lookAt",
            value: function lookAt(pos, up) {
                this.getWorldPosition(v3_a), vec3.subtract(v3_a, v3_a, pos), vec3.normalize(v3_a, v3_a), 
                quat.fromViewUp(q_a, v3_a, up), this.setWorldRotation(q_a);
            }
        }, {
            key: "resetHasChanged",
            value: function resetHasChanged() {
                this._hasChanged = !1;
                for (var len = this._children.length, i = 0; i < len; ++i) this._children[i].resetHasChanged();
            }
        }, {
            key: "invalidateChildren",
            value: function invalidateChildren() {
                if (!this._dirty || !this._hasChanged) {
                    this._dirty = this._hasChanged = !0;
                    var _iterator2 = this._children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        _ref2.invalidateChildren();
                    }
                }
            }
        }, {
            key: "updateWorldTransform",
            value: function updateWorldTransform() {
                if (this._dirty) {
                    for (var child, cur = this, i = 0; cur._dirty; ) if (!(cur = (array_a[i++] = cur)._parent) || !cur._parent) {
                        cur = null;
                        break;
                    }
                    for (;i; ) child = array_a[--i], cur && (vec3.multiply(child._pos, child._lpos, cur._scale), 
                    vec3.transformQuat(child._pos, child._pos, cur._rot), vec3.add(child._pos, child._pos, cur._pos), 
                    quat.multiply(child._rot, cur._rot, child._lrot), vec3.multiply(child._scale, cur._scale, child._lscale)), 
                    child._matDirty = !0, child._dirty = !1, cur = child;
                }
            }
        }, {
            key: "updateWorldTransformFull",
            value: function updateWorldTransformFull() {
                this.updateWorldTransform(), this._matDirty && (mat4.fromRTS(this._mat, this._rot, this._pos, this._scale), 
                this._matDirty = !1);
            }
        }, {
            key: "setPosition",
            value: function setPosition(val, y, z) {
                v3_a.set(this._lpos), void 0 === y || void 0 === z ? vec3.copy(this._lpos, val) : 3 === arguments.length && vec3.set(this._lpos, val, y, z), 
                vec3.copy(this._pos, this._lpos), this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.POSITION_PART);
            }
        }, {
            key: "getPosition",
            value: function getPosition(out) {
                return out ? vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z) : vec3.copy(new Vec3(), this._lpos);
            }
        }, {
            key: "setRotation",
            value: function setRotation(val, y, z, w) {
                void 0 === y || void 0 === z || void 0 === w ? quat.copy(this._lrot, val) : 4 === arguments.length && quat.set(this._lrot, val, y, z, w), 
                quat.copy(this._rot, this._lrot), this._eulerDirty = !0, this.invalidateChildren(), 
                1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.ROTATION_PART);
            }
        }, {
            key: "setRotationFromEuler",
            value: function setRotationFromEuler(x, y, z) {
                vec3.set(this._euler, x, y, z), this._eulerDirty = !1, quat.fromEuler(this._lrot, x, y, z), 
                quat.copy(this._rot, this._lrot), this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.ROTATION_PART);
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {
                return out ? quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w) : quat.copy(new Quat(), this._lrot);
            }
        }, {
            key: "setScale",
            value: function setScale(val, y, z) {
                void 0 === y || void 0 === z ? vec3.copy(this._lscale, val) : 3 === arguments.length && vec3.set(this._lscale, val, y, z), 
                vec3.copy(this._scale, this._lscale), this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.SCALE_PART);
            }
        }, {
            key: "getScale",
            value: function getScale(out) {
                return out ? vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z) : vec3.copy(new Vec3(), this._lscale);
            }
        }, {
            key: "setWorldPosition",
            value: function setWorldPosition(val, y, z) {
                void 0 === y || void 0 === z ? vec3.copy(this._pos, val) : 3 === arguments.length && vec3.set(this._pos, val, y, z);
                var parent = this._parent, local = this._lpos;
                v3_a.set(this._lpos), parent ? (parent.updateWorldTransform(), vec3.subtract(local, this._pos, parent._pos), 
                vec3.transformQuat(local, local, quat.conjugate(q_a, parent._rot)), vec3.divide(local, local, parent._scale)) : vec3.copy(local, this._pos), 
                this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.POSITION_PART);
            }
        }, {
            key: "getWorldPosition",
            value: function getWorldPosition(out) {
                return this.updateWorldTransform(), out ? vec3.copy(out, this._pos) : vec3.copy(new Vec3(), this._pos);
            }
        }, {
            key: "setWorldRotation",
            value: function setWorldRotation(val, y, z, w) {
                void 0 === y || void 0 === z || void 0 === w ? quat.copy(this._rot, val) : 4 === arguments.length && quat.set(this._rot, val, y, z, w), 
                this._parent ? (this._parent.getWorldRotation(q_a), quat.multiply(this._lrot, quat.conjugate(q_a, q_a), this._rot)) : quat.copy(this._lrot, this._rot), 
                this._eulerDirty = !0, this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.ROTATION_PART);
            }
        }, {
            key: "setWorldRotationFromEuler",
            value: function setWorldRotationFromEuler(x, y, z) {
                quat.fromEuler(this._rot, x, y, z), this._parent ? (this._parent.getWorldRotation(q_a), 
                quat.multiply(this._lrot, this._rot, quat.conjugate(q_a, q_a))) : quat.copy(this._lrot, this._rot), 
                this._eulerDirty = !0, this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.ROTATION_PART);
            }
        }, {
            key: "getWorldRotation",
            value: function getWorldRotation(out) {
                return this.updateWorldTransform(), out ? quat.copy(out, this._rot) : quat.copy(new Quat(), this._rot);
            }
        }, {
            key: "setWorldScale",
            value: function setWorldScale(val, y, z) {
                void 0 === y || void 0 === z ? vec3.copy(this._scale, val) : 3 === arguments.length && vec3.set(this._scale, val, y, z), 
                this._parent ? (this._parent.getWorldScale(v3_a), vec3.divide(this._lscale, this._scale, v3_a)) : vec3.copy(this._lscale, this._scale), 
                this.invalidateChildren(), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, exports.SystemEventType.SCALE_PART);
            }
        }, {
            key: "getWorldScale",
            value: function getWorldScale(out) {
                return this.updateWorldTransform(), out ? vec3.copy(out, this._scale) : vec3.copy(new Vec3(), this._scale);
            }
        }, {
            key: "getWorldMatrix",
            value: function getWorldMatrix(out) {
                return this.updateWorldTransformFull(), out || (out = new Mat4()), mat4.copy(out, this._mat);
            }
        }, {
            key: "getWorldRS",
            value: function getWorldRS(out) {
                return this.updateWorldTransformFull(), out || (out = new Mat4()), mat4.copy(out, this._mat), 
                out.m12 = 0, out.m13 = 0, out.m14 = 0, out;
            }
        }, {
            key: "getWorldRT",
            value: function getWorldRT(out) {
                return this.updateWorldTransform(), out || (out = new Mat4()), mat4.fromRT(out, this._rot, this._pos);
            }
        }, {
            key: "getAnchorPoint",
            value: function getAnchorPoint(out) {
                return out || (out = new Vec2()), out.set(this.uiTransfromComp.anchorPoint), out;
            }
        }, {
            key: "setAnchorPoint",
            value: function setAnchorPoint(point, y) {
                this.uiTransfromComp.setAnchorPoint(point, y);
            }
        }, {
            key: "getContentSize",
            value: function getContentSize(out) {
                return out || (out = new Size()), out.set(this.uiTransfromComp.contentSize), out;
            }
        }, {
            key: "setContentSize",
            value: function setContentSize(size$$1, height) {
                this.uiTransfromComp.setContentSize(size$$1, height);
            }
        }, {
            key: "on",
            value: function on(type, callback, target, useCapture) {
                switch (type) {
                  case exports.SystemEventType.TRANSFORM_CHANGED:
                    this._eventMask |= 1;
                }
                this._eventProcessor.on(type, callback, target, useCapture);
            }
        }, {
            key: "off",
            value: function off(type, callback, target, useCapture) {
                if (this._eventProcessor.off(type, callback, target, useCapture), !this._eventProcessor.hasEventListener(type)) switch (type) {
                  case exports.SystemEventType.TRANSFORM_CHANGED:
                    this._eventMask &= -2;
                }
            }
        }, {
            key: "once",
            value: function once(type, callback, target, useCapture) {
                this._eventProcessor.once(type, callback, target, useCapture);
            }
        }, {
            key: "emit",
            value: function emit(type) {
                for (var _this$_eventProcessor, _len2 = arguments.length, args = new Array(1 < _len2 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
                (_this$_eventProcessor = this._eventProcessor).emit.apply(_this$_eventProcessor, [ type ].concat(args));
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                this._eventProcessor.dispatchEvent(event);
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(type) {
                return this._eventProcessor.hasEventListener(type);
            }
        }, {
            key: "targetOff",
            value: function targetOff(target) {
                this._eventProcessor.targetOff(target), 1 & this._eventMask && !this._eventProcessor.hasEventListener(exports.SystemEventType.TRANSFORM_CHANGED) && (this._eventMask &= -2);
            }
        }, {
            key: "pauseSystemEvents",
            value: function pauseSystemEvents(recursive) {
                eventManager.pauseTarget(this, recursive);
            }
        }, {
            key: "resumeSystemEvents",
            value: function resumeSystemEvents(recursive) {
                eventManager.resumeTarget(this, recursive);
            }
        }, {
            key: "eulerAngles",
            set: function set(val) {
                this.setRotationFromEuler(val.x, val.y, val.z);
            },
            get: function get$$1() {
                return this._eulerDirty && (quat.toEuler(this._euler, this._lrot), this._eulerDirty = !1), 
                this._euler;
            }
        }, {
            key: "layer",
            set: function set(l) {
                this._layer = l;
            },
            get: function get$$1() {
                return this._layer;
            }
        }, {
            key: "hasChanged",
            get: function get$$1() {
                return this._hasChanged;
            }
        }, {
            key: "forward",
            get: function get$$1() {
                return this.getWorldRotation(q_a), vec3.transformQuat(new Vec3(), vec3.UNIT_Z, q_a);
            },
            set: function set(dir) {
                var len = vec3.magnitude(dir);
                vec3.scale(v3_a, dir, -1 / len), quat.fromViewUp(q_a, v3_a), this.setWorldRotation(q_a);
            }
        }, {
            key: "position",
            get: function get$$1() {
                return this._lpos;
            },
            set: function set(val) {
                this.setPosition(val);
            }
        }, {
            key: "rotation",
            get: function get$$1() {
                return this._lrot;
            },
            set: function set(val) {
                this.setRotation(val);
            }
        }, {
            key: "scale",
            get: function get$$1() {
                return this._lscale;
            },
            set: function set(val) {
                this.setScale(val);
            }
        }, {
            key: "worldPosition",
            get: function get$$1() {
                return this.updateWorldTransform(), this._pos;
            },
            set: function set(val) {
                this.setWorldPosition(val);
            }
        }, {
            key: "worldRotation",
            get: function get$$1() {
                return this.updateWorldTransform(), this._rot;
            },
            set: function set(val) {
                this.setWorldRotation(val);
            }
        }, {
            key: "worldScale",
            get: function get$$1() {
                return this.updateWorldTransform(), this._scale;
            },
            set: function set(val) {
                this.setWorldScale(val);
            }
        }, {
            key: "worldMatrix",
            get: function get$$1() {
                return this.updateWorldTransformFull(), this._mat;
            }
        }, {
            key: "uiTransfromComp",
            get: function get$$1() {
                return this._uiTransfromComp || (this._uiTransfromComp = this.getComponent("cc.UITransformComponent")), 
                this._uiTransfromComp;
            },
            set: function set(value) {
                this._uiTransfromComp = value;
            }
        }, {
            key: "width",
            get: function get$$1() {
                return this.uiTransfromComp.width;
            },
            set: function set(value) {
                this.uiTransfromComp.width = value;
            }
        }, {
            key: "height",
            get: function get$$1() {
                return this.uiTransfromComp.height;
            },
            set: function set(value) {
                this.uiTransfromComp.height = value;
            }
        }, {
            key: "anchorX",
            get: function get$$1() {
                return this.uiTransfromComp.anchorX;
            },
            set: function set(value) {
                this.uiTransfromComp.anchorX = value;
            }
        }, {
            key: "anchorY",
            get: function get$$1() {
                return this.uiTransfromComp.anchorY;
            },
            set: function set(value) {
                this.uiTransfromComp.anchorY = value;
            }
        }, {
            key: "eventProcessor",
            get: function get$$1() {
                return this._eventProcessor;
            }
        } ], [ {
            key: "isNode",
            value: function isNode(obj) {
                return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
            }
        } ]), Node;
    }(), _class3$8.EventType = exports.SystemEventType, _class3$8.NodeSpace = NodeSpace, 
    _descriptor$d = _applyDecoratedDescriptor((_class2$f = _temp$h).prototype, "_lpos", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3();
        }
    }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$f.prototype, "_lrot", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Quat();
        }
    }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$f.prototype, "_lscale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$f.prototype, "_layer", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Layers.Default;
        }
    }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$f.prototype, "_euler", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3();
        }
    }), _applyDecoratedDescriptor(_class2$f.prototype, "eulerAngles", [ _dec2$8 ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "eulerAngles"), _class2$f.prototype), 
    _applyDecoratedDescriptor(_class2$f.prototype, "layer", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "layer"), _class2$f.prototype), 
    _applyDecoratedDescriptor(_class2$f.prototype, "position", [ function constget(target, propertyKey) {} ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "position"), _class2$f.prototype), 
    _class$k = _class2$f)) || _class$k);
    cc.Node = Node$1;
    var _class$m, Counter = ccclass("cc.Counter")(_class$l = function() {
        function Counter(id, opts, now) {
            _classCallCheck(this, Counter), this._id = void 0, this._opts = void 0, this._accumStart = void 0, 
            this._total = 0, this._value = 0, this._averageValue = 0, this._accumValue = 0, 
            this._accumSamples = 0, this._id = id, this._opts = opts, this._accumStart = now;
        }
        return _createClass(Counter, [ {
            key: "value",
            get: function get() {
                return this._value;
            },
            set: function set(val) {
                this._value = val;
            }
        } ]), _createClass(Counter, [ {
            key: "sample",
            value: function sample(now) {
                this._average(this._value, now);
            }
        }, {
            key: "human",
            value: function human() {
                var v = this._opts.average ? this._averageValue : this._value;
                return Math.round(100 * v) / 100;
            }
        }, {
            key: "alarm",
            value: function alarm() {
                return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
            }
        }, {
            key: "_average",
            value: function _average(v) {
                var now = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                if (this._opts.average) {
                    this._accumValue += v, ++this._accumSamples;
                    var t = now;
                    t - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, 
                    this._accumValue = 0, this._accumStart = t, this._accumSamples = 0);
                }
            }
        } ]), Counter;
    }()) || _class$l, PerfCounter = ccclass("cc.PerfCounter")(_class$m = function(_Counter) {
        function PerfCounter(id, opts, now) {
            var _this;
            return _classCallCheck(this, PerfCounter), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PerfCounter).call(this, id, opts, now)))._time = void 0, 
            _this._time = now, _this;
        }
        return _inherits(PerfCounter, Counter), _createClass(PerfCounter, [ {
            key: "start",
            value: function start() {
                var now = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
                this._time = now;
            }
        }, {
            key: "end",
            value: function end() {
                var now = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
                this._value = now - this._time, this._average(this._value);
            }
        }, {
            key: "tick",
            value: function tick() {
                this.end(), this.start();
            }
        }, {
            key: "frame",
            value: function frame(now) {
                var t = now, e = t - this._time;
                this._total++, (this._opts.average || 1e3) < e && (this._value = 1e3 * this._total / e, 
                this._total = 0, this._time = t, this._average(this._value));
            }
        } ]), PerfCounter;
    }()) || _class$m, _showFPS = !1, _fontSize = 15, stringLeft = "left", stringRight = "right", _atlas = null, _stats = null, _rootNode = null, _label = new Map(), device = null;
    function beforeUpdate() {
        if (_stats) {
            !function generateNode() {
                if (!_rootNode || !_rootNode.isValid) {
                    (_rootNode = new Node$1("PROFILER-NODE")).addComponent("cc.UITransformComponent"), 
                    _rootNode.addComponent("cc.DebugCanvasComponent"), cc.game.addPersistRootNode(_rootNode);
                    var managerNode = new Node$1("ROOT");
                    managerNode.addComponent("cc.UITransformComponent"), managerNode.parent = _rootNode, 
                    managerNode.anchorX = managerNode.anchorY = 0;
                    var widgetComp = managerNode.addComponent("cc.WidgetComponent");
                    widgetComp && (widgetComp.isAlignBottom = !0, widgetComp.isAlignLeft = !0, widgetComp.left = 10, 
                    widgetComp.bottom = 10);
                    var left = new Node$1("LEFT-PANEL");
                    left.parent = managerNode;
                    var leftLabel = left.addComponent("cc.LabelComponent");
                    left.anchorX = left.anchorY = 0, leftLabel && (leftLabel.font = _atlas, leftLabel.fontSize = _fontSize, 
                    leftLabel.lineHeight = _fontSize + 1);
                    var right = new Node$1("RIGHT-PANEL");
                    right.parent = managerNode;
                    var rightLabel = right.addComponent("cc.LabelComponent");
                    right.anchorX = 1, right.anchorY = 0;
                    var pos = right.getPosition();
                    right.setPosition(200, pos.y, pos.z), rightLabel && (rightLabel.horizontalAlign = cc.LabelComponent.HorizontalAlign.RIGHT, 
                    rightLabel.font = _atlas, rightLabel.fontSize = _fontSize, rightLabel.lineHeight = _fontSize + 1), 
                    _label[stringLeft] = leftLabel, _label[stringRight] = rightLabel;
                }
            }();
            var now = cc.director._lastUpdate;
            getCounter("frame").start(now), getCounter("logic").start(now);
        }
    }
    function afterUpdate() {
        if (_stats) {
            var now = performance.now();
            cc.director.isPaused() ? getCounter("frame").start(now) : getCounter("logic").end(now), 
            getCounter("render").start(now);
        }
    }
    function afterDraw() {
        if (_stats) {
            var now = performance.now();
            getCounter("frame").end(now), getCounter("fps").frame(now), getCounter("draws").value = device.numDrawCalls, 
            getCounter("tricount").value = device.numTris, getCounter("render").end(now), getCounter("mode").value = device.gfxAPI;
            for (var left = "", right = "", _arr2 = Object.keys(_stats), _i2 = 0; _i2 < _arr2.length; _i2++) {
                var id = _arr2[_i2], stat = _stats[id];
                stat.counter.sample(now), left += stat.desc + "\n", right += stat.counter.human() + "\n";
            }
            _label[stringLeft].string = left, _label[stringRight].string = right;
        }
    }
    function getCounter(s) {
        return _stats[s].counter;
    }
    var profiler = {
        isShowingStats: function isShowingStats() {
            return _showFPS;
        },
        hideStats: function hideStats() {
            _showFPS && (_rootNode && (_rootNode.active = !1), cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate), 
            cc.director.off(cc.Director.EVENT_AFTER_UPDATE, afterUpdate), cc.director.off(cc.Director.EVENT_AFTER_DRAW, afterDraw), 
            _showFPS = !1);
        },
        showStats: function showStats() {
            _showFPS || (!function initDevice() {
                device || (device = cc.director.root.device);
            }(), function generateAtlas() {
                if (!_atlas) {
                    var canvas = document.createElement("canvas");
                    canvas.width = 256, canvas.height = 256, canvas.style.width = "".concat(canvas.width), 
                    canvas.style.height = "".concat(canvas.height);
                    var ctx = canvas.getContext("2d");
                    if (ctx) {
                        ctx.font = "".concat(_fontSize, "px Arial"), ctx.textBaseline = "top", ctx.textAlign = "left", 
                        ctx.fillStyle = "#fff";
                        var x = 2, y = 2, lineHeight = _fontSize;
                        (_atlas = new LabelAtlas()).fntConfig = {
                            atlasName: "profiler-arial",
                            commonHeight: lineHeight,
                            fontSize: _fontSize,
                            kerningDict: {},
                            fontDefDictionary: {}
                        }, _atlas.name = "profiler-arial", _atlas.fontSize = _fontSize;
                        for (var dict = _atlas.fntConfig.fontDefDictionary, i = 32; i <= 126; i++) {
                            var char = String.fromCharCode(i), width = ctx.measureText(char).width;
                            256 <= x + width && (y += lineHeight + (x = 2)), ctx.fillText(char, x, y), dict[i] = {
                                xAdvance: width,
                                xOffset: 0,
                                yOffset: 0,
                                rect: {
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: lineHeight
                                }
                            }, x += width + 2;
                        }
                        var image = new ImageAsset(canvas), spriteFrame = new SpriteFrame();
                        spriteFrame.mipmaps = [ image ], spriteFrame.onLoaded(), _atlas.spriteFrame = spriteFrame;
                    }
                }
            }(), function generateStats() {
                _stats = null;
                for (var now = performance.now(), opts = {
                    frame: {
                        desc: "Frame time (ms)",
                        min: 0,
                        max: 50,
                        average: 500
                    },
                    fps: {
                        desc: "Framerate (FPS)",
                        below: 30,
                        average: 500
                    },
                    draws: {
                        desc: "Draw call"
                    },
                    tricount: {
                        desc: "Triangle"
                    },
                    logic: {
                        desc: "Game Logic (ms)",
                        min: 0,
                        max: 50,
                        average: 500,
                        color: "#080"
                    },
                    render: {
                        desc: "Renderer (ms)",
                        min: 0,
                        max: 50,
                        average: 500,
                        color: "#f90"
                    },
                    mode: {
                        desc: cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WebGL" : "Canvas",
                        min: 1
                    }
                }, _arr = Object.keys(opts), _i = 0; _i < _arr.length; _i++) {
                    var id = _arr[_i];
                    opts[id].counter = new PerfCounter(id, opts[id], now);
                }
                _stats = opts;
            }(), _rootNode && (_rootNode.active = !0), cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate), 
            cc.director.on(cc.Director.EVENT_AFTER_UPDATE, afterUpdate), cc.director.on(cc.Director.EVENT_AFTER_DRAW, afterDraw), 
            _showFPS = !0);
        }
    };
    cc.profiler = profiler;
    var _class$n, _class2$g, _descriptor$e, _descriptor2$8, _descriptor3$5, _descriptor4$4, _descriptor5$3, eventRegx = /^(click)(\s)*=|(param)(\s)*=/, imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/, HtmlTextParser = function() {
        function HtmlTextParser() {
            _classCallCheck(this, HtmlTextParser), this._specialSymbolArray = [], this._stack = [], 
            this._resultObjectArray = [], this._specialSymbolArray.push([ /&lt;/g, "<" ]), this._specialSymbolArray.push([ /&gt;/g, ">" ]), 
            this._specialSymbolArray.push([ /&amp;/g, "&" ]), this._specialSymbolArray.push([ /&quot;/g, '"' ]), 
            this._specialSymbolArray.push([ /&apos;/g, "'" ]);
        }
        return _createClass(HtmlTextParser, [ {
            key: "parse",
            value: function parse(htmlString) {
                this._resultObjectArray.length = 0;
                for (var startIndex = this._stack.length = 0, length = htmlString.length; startIndex < length; ) {
                    var tagBeginIndex = htmlString.indexOf("<", startIndex);
                    if (tagBeginIndex < 0) this._stack.pop(), this._processResult(htmlString.substring(startIndex)), 
                    startIndex = length; else {
                        this._processResult(htmlString.substring(startIndex, tagBeginIndex));
                        var tagEndIndex = htmlString.indexOf(">", startIndex);
                        -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex)), 
                        startIndex = tagEndIndex + 1;
                    }
                }
                return this._resultObjectArray;
            }
        }, {
            key: "_attributeToObject",
            value: function _attributeToObject(attribute) {
                var obj = {}, header = (attribute = attribute.trim()).match(/^(color|size)(\s)*=/), tagName = "", nextSpace = 0, eventHanlderString = "";
                if (header) {
                    if (tagName = header[0], "" === (attribute = attribute.substring(tagName.length).trim())) return obj;
                    switch (nextSpace = attribute.indexOf(" "), tagName[0]) {
                      case "c":
                        obj.color = -1 < nextSpace ? attribute.substring(0, nextSpace).trim() : attribute;
                        break;

                      case "s":
                        obj.size = parseInt(attribute);
                    }
                    return -1 < nextSpace && (eventHanlderString = attribute.substring(nextSpace + 1).trim(), 
                    obj.event = this._processEventHandler(eventHanlderString)), obj;
                }
                if ((header = attribute.match(/^(br(\s)*\/)/)) && 0 < header[0].length && (tagName = header[0].trim()).startsWith("br") && "/" === tagName[tagName.length - 1]) return obj.isNewLine = !0, 
                this._resultObjectArray.push({
                    text: "",
                    style: {
                        newline: !0
                    }
                }), obj;
                var remainingArgument = "";
                if ((header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/)) && 0 < header[0].length && (tagName = header[0].trim()).startsWith("img") && "/" === tagName[tagName.length - 1]) {
                    var tagValue;
                    header = attribute.match(imageAttrReg);
                    for (var isValidImageTag = !1; header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                    tagValue = -1 < (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                    tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                    attribute = remainingArgument.substring(nextSpace).trim(), "src" === tagName ? (obj.isImage = !0, 
                    tagValue.endsWith("/") && (tagValue = tagValue.substring(0, tagValue.length - 1)), 
                    0 === tagValue.indexOf("'") ? (isValidImageTag = !0, tagValue = tagValue.substring(1, tagValue.length - 1)) : 0 === tagValue.indexOf('"') && (isValidImageTag = !0, 
                    tagValue = tagValue.substring(1, tagValue.length - 1)), obj.src = tagValue) : "height" === tagName ? obj.imageHeight = parseInt(tagValue) : "width" === tagName ? obj.imageWidth = parseInt(tagValue) : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue)), 
                    obj.event && "param" === tagName && (obj.event[tagName] = tagValue.replace(/^\"|\"$/g, "")), 
                    header = attribute.match(imageAttrReg);
                    return isValidImageTag && obj.isImage && this._resultObjectArray.push({
                        text: "",
                        style: obj
                    }), {};
                }
                if (header = attribute.match(/^(outline(\s)*[^>]*)/)) {
                    var defaultOutlineObject = {
                        color: "#ffffff",
                        width: 1
                    };
                    if (attribute = header[0].substring("outline".length).trim()) {
                        var _tagValue, outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                        for (header = attribute.match(outlineAttrReg); header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                        _tagValue = -1 < (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                        tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                        attribute = remainingArgument.substring(nextSpace).trim(), "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + _tagValue) : "color" === tagName ? defaultOutlineObject.color = _tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(_tagValue)), 
                        obj.event && "param" === tagName && (obj.event[tagName] = _tagValue.replace(/^\"|\"$/g, "")), 
                        header = attribute.match(outlineAttrReg);
                    }
                    obj.outline = defaultOutlineObject;
                }
                if ((header = attribute.match(/^(on|u|b|i)(\s)*/)) && 0 < header[0].length) {
                    switch (tagName = header[0], attribute = attribute.substring(tagName.length).trim(), 
                    tagName[0]) {
                      case "u":
                        obj.underline = !0;
                        break;

                      case "i":
                        obj.italic = !0;
                        break;

                      case "b":
                        obj.bold = !0;
                    }
                    if ("" === attribute) return obj;
                    obj.event = this._processEventHandler(attribute);
                }
                return obj;
            }
        }, {
            key: "_processEventHandler",
            value: function _processEventHandler(eventString) {
                for (var index = 0, obj = new Map(), eventNames = eventString.match(eventRegx), isValidTag = !1; eventNames; ) {
                    var eventName = eventNames[0], eventValue = "";
                    if (isValidTag = !1, '"' === (eventString = eventString.substring(eventName.length).trim()).charAt(0)) -1 < (index = eventString.indexOf('"', 1)) && (eventValue = eventString.substring(1, index).trim(), 
                    isValidTag = !0), index++; else if ("'" === eventString.charAt(0)) -1 < (index = eventString.indexOf("'", 1)) && (eventValue = eventString.substring(1, index).trim(), 
                    isValidTag = !0), index++; else {
                        var match = eventString.match(/(\S)+/);
                        index = (eventValue = match ? match[0] : "").length;
                    }
                    isValidTag && (obj[eventName = eventName.substring(0, eventName.length - 1).trim()] = eventValue), 
                    eventNames = (eventString = eventString.substring(index).trim()).match(eventRegx);
                }
                return obj;
            }
        }, {
            key: "_addToStack",
            value: function _addToStack(attribute) {
                var obj = this._attributeToObject(attribute);
                if (0 === this._stack.length) this._stack.push(obj); else {
                    if (obj.isNewLine || obj.isImage) return;
                    var previousTagObj = this._stack[this._stack.length - 1];
                    for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
                    this._stack.push(obj);
                }
            }
        }, {
            key: "_processResult",
            value: function _processResult(value) {
                0 !== value.length && (value = this._escapeSpecialSymbol(value), 0 < this._stack.length ? this._resultObjectArray.push({
                    text: value,
                    style: this._stack[this._stack.length - 1]
                }) : this._resultObjectArray.push({
                    text: value
                }));
            }
        }, {
            key: "_escapeSpecialSymbol",
            value: function _escapeSpecialSymbol(str) {
                var _iterator = this._specialSymbolArray, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var symbolArr = _ref, key = symbolArr[0], value = symbolArr[1];
                    str = str.replace(key, value);
                }
                return str;
            }
        } ]), HtmlTextParser;
    }();
    var property$1 = property, PrefabInfo = ccclass("cc.PrefabInfo")((_descriptor$e = _applyDecoratedDescriptor((_class2$g = function PrefabInfo() {
        _classCallCheck(this, PrefabInfo), _initializerDefineProperty(this, "root", _descriptor$e, this), 
        _initializerDefineProperty(this, "asset", _descriptor2$8, this), _initializerDefineProperty(this, "fileId", _descriptor3$5, this), 
        _initializerDefineProperty(this, "sync", _descriptor4$4, this), _initializerDefineProperty(this, "_synced", _descriptor5$3, this);
    }).prototype, "root", [ property$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$g.prototype, "asset", [ property$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$g.prototype, "fileId", [ property$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$g.prototype, "sync", [ property$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$g.prototype, "_synced", [ property$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {
                default: !1,
                serializable: !1
            };
        }
    }), _class$n = _class2$g)) || _class$n;
    cc._PrefabInfo = PrefabInfo;
    var visibleRect = {
        topLeft: cc.v2(0, 0),
        topRight: cc.v2(0, 0),
        top: cc.v2(0, 0),
        bottomLeft: cc.v2(0, 0),
        bottomRight: cc.v2(0, 0),
        bottom: cc.v2(0, 0),
        center: cc.v2(0, 0),
        left: cc.v2(0, 0),
        right: cc.v2(0, 0),
        width: 0,
        height: 0,
        init: function init(visibleRect_) {
            var w = this.width = visibleRect_.width, h = this.height = visibleRect_.height, l = visibleRect_.x, b = visibleRect_.y, t = b + h, r = l + w;
            this.topLeft.x = l, this.topLeft.y = t, this.topRight.x = r, this.topRight.y = t, 
            this.top.x = l + w / 2, this.top.y = t, this.bottomLeft.x = l, this.bottomLeft.y = b, 
            this.bottomRight.x = r, this.bottomRight.y = b, this.bottom.x = l + w / 2, this.bottom.y = b, 
            this.center.x = l + w / 2, this.center.y = b + h / 2, this.left.x = l, this.left.y = b + h / 2, 
            this.right.x = r, this.right.y = b + h / 2;
        }
    };
    cc.visibleRect = visibleRect;
    var Game = function(_EventTarget) {
        function Game() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Game);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Game)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).frame = null, 
            _this.container = null, _this.canvas = null, _this.renderType = -1, _this.eventTargetOn = _get(_getPrototypeOf(Game.prototype), "on", _assertThisInitialized(_this)), 
            _this.eventTargetOnce = _get(_getPrototypeOf(Game.prototype), "once", _assertThisInitialized(_this)), 
            _this.config = {}, _this.onStart = null, _this._persistRootNodes = {}, _this._paused = !0, 
            _this._configLoaded = !1, _this._isCloning = !1, _this._prepared = !1, _this._rendererInitialized = !1, 
            _this._gfxDevice = null, _this._intervalId = null, _this._lastTime = null, _this._frameTime = null, 
            _this._sceneInfos = [], _this.collisionMatrix = [], _this.groupList = [], _this;
        }
        return _inherits(Game, EventTarget), _createClass(Game, [ {
            key: "setFrameRate",
            value: function setFrameRate(frameRate) {
                var config = this.config;
                "number" != typeof frameRate && (frameRate = parseInt(frameRate), isNaN(frameRate) && (frameRate = 60)), 
                config.frameRate = frameRate, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
                this._intervalId = 0, this._paused = !0, this._setAnimFrame(), this._runMainLoop();
            }
        }, {
            key: "getFrameRate",
            value: function getFrameRate() {
                return this.config.frameRate;
            }
        }, {
            key: "step",
            value: function step() {
                cc.director.mainLoop();
            }
        }, {
            key: "pause",
            value: function pause() {
                this._paused || (this._paused = !0, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
                this._intervalId = 0);
            }
        }, {
            key: "resume",
            value: function resume() {
                this._paused && (this._paused = !1, this._runMainLoop());
            }
        }, {
            key: "isPaused",
            value: function isPaused() {
                return this._paused;
            }
        }, {
            key: "restart",
            value: function restart() {
                cc.director.once(cc.Director.EVENT_AFTER_DRAW, function() {
                    for (var id in cc.game._persistRootNodes) cc.game.removePersistRootNode(cc.game._persistRootNodes[id]);
                    cc.director.getScene().destroy(), cc.Object._deferredDestroy(), cc.director.purgeDirector(), 
                    cc.director.reset(), cc.game.onStart();
                });
            }
        }, {
            key: "end",
            value: function end() {
                this._gfxDevice && (this._gfxDevice.destroy(), this._gfxDevice = null), close();
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target);
            }
        }, {
            key: "once",
            value: function once(type, callback, target) {
                this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
            }
        }, {
            key: "run",
            value: function run(config, onStart) {
                this._initConfig(config), this.onStart = onStart, this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game));
            }
        }, {
            key: "addPersistRootNode",
            value: function addPersistRootNode(node) {
                if (cc.Node.isNode(node) && node.uuid) {
                    var id = node.uuid;
                    if (!this._persistRootNodes[id]) {
                        var scene = cc.director._scene;
                        if (cc.isValid(scene)) if (node.parent) {
                            if (!(node.parent instanceof cc.Scene)) return void cc.warnID(3801);
                            if (node.parent !== scene) return void cc.warnID(3802);
                        } else node.parent = scene;
                        (this._persistRootNodes[id] = node)._persistNode = !0;
                    }
                } else cc.warnID(3800);
            }
        }, {
            key: "removePersistRootNode",
            value: function removePersistRootNode(node) {
                var id = node.uuid || "";
                node === this._persistRootNodes[id] && (delete this._persistRootNodes[id], node._persistNode = !1);
            }
        }, {
            key: "isPersistRootNode",
            value: function isPersistRootNode(node) {
                return node._persistNode;
            }
        }, {
            key: "prepare",
            value: function prepare(cb) {
                if (this._prepared) cb && cb(); else {
                    var jsList = this.config.jsList;
                    if (jsList && 0 < jsList.length) {
                        var self = this;
                        cc.loader.load(jsList, function(err) {
                            if (err) throw new Error(JSON.stringify(err));
                            self._prepareFinished(cb);
                        });
                    } else this._prepareFinished(cb);
                }
            }
        }, {
            key: "_initEngine",
            value: function _initEngine() {
                this._rendererInitialized || (this._initRenderer(), this._initEvents(), this.emit(Game.EVENT_ENGINE_INITED));
            }
        }, {
            key: "_prepareFinished",
            value: function _prepareFinished(cb) {
                this._prepared = !0, this._initEngine(), console.log("Cocos3D v" + cc.ENGINE_VERSION), 
                this._setAnimFrame(), this._runMainLoop(), this.emit(Game.EVENT_GAME_INITED), cb && cb();
            }
        }, {
            key: "_setAnimFrame",
            value: function _setAnimFrame() {
                this._lastTime = new Date();
                var frameRate = cc.game.config.frameRate;
                this._frameTime = 1e3 / frameRate, window.cancelAnimationFrame = 60 !== frameRate && 30 !== frameRate ? (window.requestAnimationFrame = this._stTime, 
                this._ctTime) : (window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, 
                window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime);
            }
        }, {
            key: "_stTime",
            value: function _stTime(callback) {
                var currTime = new Date().getTime(), timeToCall = Math.max(0, cc.game._frameTime - (currTime - cc.game._lastTime)), id = window.setTimeout(function() {
                    callback();
                }, timeToCall);
                return cc.game._lastTime = currTime + timeToCall, id;
            }
        }, {
            key: "_ctTime",
            value: function _ctTime(id) {
                window.clearTimeout(id);
            }
        }, {
            key: "_runMainLoop",
            value: function _runMainLoop() {
                var _callback, self = this, config = self.config, director = cc.director, skip = !0, frameRate = config.frameRate;
                setDisplayStats(config.showFPS), _callback = function callback() {
                    if (!self._paused) {
                        if (self._intervalId = window.requestAnimationFrame(_callback), 30 === frameRate && (skip = !skip)) return;
                        director.mainLoop();
                    }
                }, self._intervalId = window.requestAnimationFrame(_callback), self._paused = !1;
            }
        }, {
            key: "_initConfig",
            value: function _initConfig(config) {
                "number" != typeof config.debugMode && (config.debugMode = 0), config.exposeClassName = !!config.exposeClassName, 
                "number" != typeof config.frameRate && (config.frameRate = 60);
                var renderMode = config.renderMode;
                ("number" != typeof renderMode || 2 < renderMode || renderMode < 0) && (config.renderMode = 0), 
                "boolean" != typeof config.registerSystemEvent && (config.registerSystemEvent = !0), 
                config.showFPS = !!config.showFPS, this._sceneInfos = config.scenes || [], this.collisionMatrix = config.collisionMatrix || [], 
                this.groupList = config.groupList || [], _resetDebugSetting(config.debugMode), this.config = config, 
                this._configLoaded = !0;
            }
        }, {
            key: "_determineRenderType",
            value: function _determineRenderType() {
                var config = this.config, userRenderMode = parseInt(config.renderMode) || 0;
                this.renderType = Game.RENDER_TYPE_CANVAS;
                var supportRender = !1;
                if (0 === userRenderMode ? cc.sys.capabilities.opengl ? (this.renderType = Game.RENDER_TYPE_WEBGL, 
                supportRender = !0) : cc.sys.capabilities.canvas && (this.renderType = Game.RENDER_TYPE_CANVAS, 
                supportRender = !0) : 1 === userRenderMode && cc.sys.capabilities.canvas ? (this.renderType = Game.RENDER_TYPE_CANVAS, 
                supportRender = !0) : 2 === userRenderMode && cc.sys.capabilities.opengl && (this.renderType = Game.RENDER_TYPE_WEBGL, 
                supportRender = !0), !supportRender) throw new Error(getError(3820, userRenderMode));
            }
        }, {
            key: "_initRenderer",
            value: function _initRenderer() {
                if (!this._rendererInitialized) {
                    var width, height, localCanvas, localContainer, el = this.config.id, isWeChatGame = cc.sys.platform === cc.sys.WECHAT_GAME, isQQPlay = cc.sys.platform === cc.sys.QQ_PLAY;
                    if (isWeChatGame) this.container = localContainer = document.createElement("div"), 
                    this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode, 
                    localCanvas = cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? window.sharedCanvas || wx.getSharedCanvas() : window.canvas, 
                    this.canvas = localCanvas; else if (isQQPlay) this.container = cc.container = document.createElement("div"), 
                    this.frame = document.documentElement, this.canvas = localCanvas = window.canvas; else {
                        var element = el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el);
                        "CANVAS" === element.tagName ? (width = element.width, height = element.height, 
                        this.canvas = localCanvas = element, this.container = localContainer = document.createElement("div"), 
                        localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas)) : ("DIV" !== element.tagName && cc.warnID(3819), 
                        width = element.clientWidth, height = element.clientHeight, this.canvas = localCanvas = document.createElement("CANVAS"), 
                        this.container = localContainer = document.createElement("div"), element.appendChild(localContainer)), 
                        localContainer.setAttribute("id", "Cocos3dGameContainer"), localContainer.appendChild(localCanvas), 
                        this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode, 
                        function addClass(element, name) {
                            -1 < (" " + element.className + " ").indexOf(" " + name + " ") || (element.className && (element.className += " "), 
                            element.className += name);
                        }(localCanvas, "gameCanvas"), localCanvas.setAttribute("width", width || "480"), 
                        localCanvas.setAttribute("height", height || "320"), localCanvas.setAttribute("tabindex", "99");
                    }
                    if (this._determineRenderType(), this.renderType === Game.RENDER_TYPE_WEBGL) {
                        var useWebGL2 = !!window.WebGL2RenderingContext, userAgent = navigator.userAgent.toLowerCase();
                        -1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") && (useWebGL2 = !1), 
                        this._gfxDevice = useWebGL2 ? new cc.WebGL2GFXDevice() : new cc.WebGLGFXDevice();
                        var opts = {
                            canvasElm: localCanvas,
                            debug: !0,
                            devicePixelRatio: window.devicePixelRatio,
                            nativeWidth: Math.floor(screen.width * cc.view._devicePixelRatio),
                            nativeHeight: Math.floor(screen.height * cc.view._devicePixelRatio)
                        };
                        !this._gfxDevice.initialize(opts) && useWebGL2 && (this._gfxDevice = new cc.WebGLGFXDevice(), 
                        this._gfxDevice.initialize(opts));
                    }
                    if (!this._gfxDevice) return console.error("can not support canvas rendering in 3D"), 
                    void (this.renderType = Game.RENDER_TYPE_CANVAS);
                    this.canvas.oncontextmenu = function() {
                        if (!cc._isContextMenuEnable) return !1;
                    }, this._rendererInitialized = !0;
                }
            }
        }, {
            key: "_initEvents",
            value: function _initEvents() {
                var hiddenPropName, win = window;
                this.config.registerSystemEvent && inputManager.registerSystemEvent(this.canvas), 
                void 0 !== document.hidden ? hiddenPropName = "hidden" : void 0 !== document.mozHidden ? hiddenPropName = "mozHidden" : void 0 !== document.msHidden ? hiddenPropName = "msHidden" : void 0 !== document.webkitHidden && (hiddenPropName = "webkitHidden");
                var hidden = !1;
                function onHidden() {
                    hidden || (hidden = !0, cc.game.emit(Game.EVENT_HIDE));
                }
                function onShown() {
                    hidden && (hidden = !1, cc.game.emit(Game.EVENT_SHOW));
                }
                if (hiddenPropName) for (var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ], i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], function(event) {
                    var visible = document[hiddenPropName];
                    (visible = visible || event.hidden) ? onHidden() : onShown();
                }); else win.addEventListener("blur", onHidden), win.addEventListener("focus", onShown);
                -1 < navigator.userAgent.indexOf("MicroMessenger") && (win.onfocus = onShown), "onpageshow" in window && "onpagehide" in window && (win.addEventListener("pagehide", onHidden), 
                win.addEventListener("pageshow", onShown), document.addEventListener("pagehide", onHidden), 
                document.addEventListener("pageshow", onShown)), this.on(Game.EVENT_HIDE, function() {
                    cc.game.pause();
                }), this.on(Game.EVENT_SHOW, function() {
                    cc.game.resume();
                });
            }
        } ]), Game;
    }();
    Game.EVENT_HIDE = "game_on_hide", Game.EVENT_SHOW = "game_on_show", Game.EVENT_GAME_INITED = "game_inited", 
    Game.EVENT_ENGINE_INITED = "engine_inited", Game.EVENT_RENDERER_INITED = "engine_inited", 
    Game.RENDER_TYPE_CANVAS = 0, Game.RENDER_TYPE_WEBGL = 1, Game.RENDER_TYPE_OPENGL = 2, 
    cc.Game = Game, cc.game = new Game();
    var _currentFrame = 0, __BrowserGetter = new (function() {
        function BrowserGetter() {
            _classCallCheck(this, BrowserGetter), this.html = void 0, this.meta = {
                width: "device-width"
            }, this.adaptationType = cc.sys.browserType;
        }
        return _createClass(BrowserGetter, [ {
            key: "init",
            value: function init() {
                this.html = document.getElementsByTagName("html")[0];
            }
        }, {
            key: "availWidth",
            value: function availWidth(frame) {
                return cc.sys.isMobile || !frame || frame === this.html ? window.innerWidth : frame.clientWidth;
            }
        }, {
            key: "availHeight",
            value: function availHeight(frame) {
                return cc.sys.isMobile || !frame || frame === this.html ? window.innerHeight : frame.clientHeight;
            }
        } ]), BrowserGetter;
    }())();
    switch (cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI), 
    __BrowserGetter.adaptationType) {
      case cc.sys.BROWSER_TYPE_SAFARI:
        __BrowserGetter.meta["minimal-ui"] = "true";

      case cc.sys.BROWSER_TYPE_SOUGOU:
      case cc.sys.BROWSER_TYPE_WECHAT_GAME:
        __BrowserGetter.availWidth = function() {
            return window.innerWidth;
        }, __BrowserGetter.availHeight = function() {
            return window.innerHeight;
        };
        break;

      case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
        var sharedCanvas = window.sharedCanvas || wx.getSharedCanvas();
        __BrowserGetter.availWidth = function() {
            return sharedCanvas.width;
        }, __BrowserGetter.availHeight = function() {
            return sharedCanvas.height;
        };
    }
    var _scissorRect = null, View = function(_EventTarget) {
        function View() {
            var _this;
            _classCallCheck(this, View), (_this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this)))._frameSize = void 0, 
            _this._designResolutionSize = void 0, _this._originalDesignResolutionSize = void 0, 
            _this._scaleX = void 0, _this._scaleY = void 0, _this._viewportRect = void 0, _this._visibleRect = void 0, 
            _this._autoFullScreen = void 0, _this._devicePixelRatio = void 0, _this._retinaEnabled = void 0, 
            _this._resizeCallback = void 0, _this._resizing = void 0, _this._resizeWithBrowserSize = void 0, 
            _this._orientationChanging = void 0, _this._isRotated = void 0, _this._orientation = void 0, 
            _this._isAdjustViewport = void 0, _this._antiAliasEnabled = void 0, _this._resolutionPolicy = void 0, 
            _this._rpExactFit = void 0, _this._rpShowAll = void 0, _this._rpNoBorder = void 0, 
            _this._rpFixedHeight = void 0, _this._rpFixedWidth = void 0;
            _assertThisInitialized(_assertThisInitialized(_this));
            var _strategyer = ContainerStrategy, _strategy = ContentStrategy;
            return _this._frameSize = new Size(0, 0), _this._designResolutionSize = new Size(0, 0), 
            _this._originalDesignResolutionSize = new Size(0, 0), _this._scaleX = 1, _this._scaleY = 1, 
            _this._viewportRect = new Rect(0, 0, 0, 0), _this._visibleRect = new Rect(0, 0, 0, 0), 
            _this._autoFullScreen = !1, _this._devicePixelRatio = 1, _this._retinaEnabled = !1, 
            _this._resizeCallback = null, _this._resizing = !1, _this._resizeWithBrowserSize = !1, 
            _this._orientationChanging = !0, _this._isRotated = !1, _this._orientation = cc.macro.ORIENTATION_AUTO, 
            _this._isAdjustViewport = !0, _this._antiAliasEnabled = !1, _this._resolutionPolicy = null, 
            _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT), 
            _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL), 
            _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER), 
            _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT), 
            _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH), 
            cc.game.once(Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(View, EventTarget), _createClass(View, [ {
            key: "init",
            value: function init() {
                __BrowserGetter.init(), this._initFrameSize(), this.enableAntiAlias(!0);
                var w = cc.game.canvas.width, h = cc.game.canvas.height;
                this._designResolutionSize.width = w, this._designResolutionSize.height = h, this._originalDesignResolutionSize.width = w, 
                this._originalDesignResolutionSize.height = h, this._viewportRect.width = w, this._viewportRect.height = h, 
                this._visibleRect.width = w, this._visibleRect.height = h, cc.winSize.width = this._visibleRect.width, 
                cc.winSize.height = this._visibleRect.height, cc.visibleRect && cc.visibleRect.init(this._visibleRect);
            }
        }, {
            key: "resizeWithBrowserSize",
            value: function resizeWithBrowserSize(enabled) {
                enabled ? this._resizeWithBrowserSize || (this._resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), 
                window.addEventListener("orientationchange", this._orientationChange)) : this._resizeWithBrowserSize && (this._resizeWithBrowserSize = !1, 
                window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._orientationChange));
            }
        }, {
            key: "setResizeCallback",
            value: function setResizeCallback(callback) {
                "function" != typeof callback && null != callback || (this._resizeCallback = callback);
            }
        }, {
            key: "setOrientation",
            value: function setOrientation(orientation) {
                (orientation &= cc.macro.ORIENTATION_AUTO) && this._orientation !== orientation && (this._orientation = orientation);
            }
        }, {
            key: "adjustViewportMeta",
            value: function adjustViewportMeta(enabled) {
                this._isAdjustViewport = enabled;
            }
        }, {
            key: "enableRetina",
            value: function enableRetina(enabled) {
                this._retinaEnabled = !!enabled;
            }
        }, {
            key: "isRetinaEnabled",
            value: function isRetinaEnabled() {
                return this._retinaEnabled;
            }
        }, {
            key: "enableAntiAlias",
            value: function enableAntiAlias(enabled) {
                if (this._antiAliasEnabled !== enabled) if (this._antiAliasEnabled = enabled, cc.game.renderType === Game.RENDER_TYPE_WEBGL) {
                    var cache = cc.loader._cache;
                    for (var key in cache) {
                        var item = cache[key], tex = item && item.content instanceof cc.Texture2D ? item.content : null;
                        if (tex) {
                            var Filter = cc.Texture2D.Filter;
                            enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
                        }
                    }
                } else if (cc.game.renderType === Game.RENDER_TYPE_CANVAS) {
                    var ctx = cc.game.canvas.getContext("2d");
                    ctx.imageSmoothingEnabled = enabled, ctx.mozImageSmoothingEnabled = enabled;
                }
            }
        }, {
            key: "isAntiAliasEnabled",
            value: function isAntiAliasEnabled() {
                return this._antiAliasEnabled;
            }
        }, {
            key: "enableAutoFullScreen",
            value: function enableAutoFullScreen(enabled) {
                enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT ? (this._autoFullScreen = !0, 
                cc.screen.autoFullScreen(cc.game.frame)) : this._autoFullScreen = !1;
            }
        }, {
            key: "isAutoFullScreenEnabled",
            value: function isAutoFullScreenEnabled() {
                return this._autoFullScreen;
            }
        }, {
            key: "setCanvasSize",
            value: function setCanvasSize(width, height) {
                var canvas = cc.game.canvas, container = cc.game.container;
                canvas.width = width * this._devicePixelRatio, canvas.height = height * this._devicePixelRatio, 
                canvas.style.width = width + "px", canvas.style.height = height + "px", container.style.width = width + "px", 
                container.style.height = height + "px", this._resizeEvent();
            }
        }, {
            key: "getCanvasSize",
            value: function getCanvasSize() {
                return cc.size(cc.game.canvas.width, cc.game.canvas.height);
            }
        }, {
            key: "getFrameSize",
            value: function getFrameSize() {
                return cc.size(this._frameSize.width, this._frameSize.height);
            }
        }, {
            key: "setFrameSize",
            value: function setFrameSize(width, height) {
                this._frameSize.width = width, this._frameSize.height = height, cc.frame.style.width = width + "px", 
                cc.frame.style.height = height + "px", this._resizeEvent();
            }
        }, {
            key: "getVisibleSize",
            value: function getVisibleSize() {
                return cc.size(this._visibleRect.width, this._visibleRect.height);
            }
        }, {
            key: "getVisibleSizeInPixel",
            value: function getVisibleSizeInPixel() {
                return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
            }
        }, {
            key: "getVisibleOrigin",
            value: function getVisibleOrigin() {
                return cc.v2(this._visibleRect.x, this._visibleRect.y);
            }
        }, {
            key: "getVisibleOriginInPixel",
            value: function getVisibleOriginInPixel() {
                return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
            }
        }, {
            key: "getResolutionPolicy",
            value: function getResolutionPolicy() {
                return this._resolutionPolicy;
            }
        }, {
            key: "setResolutionPolicy",
            value: function setResolutionPolicy(resolutionPolicy) {
                var _t = this;
                if (resolutionPolicy instanceof ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
                    var _locPolicy = ResolutionPolicy;
                    resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit), 
                    resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll), 
                    resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder), 
                    resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight), 
                    resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
                }
            }
        }, {
            key: "setDesignResolutionSize",
            value: function setDesignResolutionSize(width, height, resolutionPolicy) {
                if (0 < width || 0 < height) {
                    this.setResolutionPolicy(resolutionPolicy);
                    var policy = this._resolutionPolicy;
                    if (policy && policy.preApply(this), cc.sys.isMobile && this._adjustViewportMeta(), 
                    this._orientationChanging = !0, this._resizing || this._initFrameSize(), policy) {
                        this._originalDesignResolutionSize.width = this._designResolutionSize.width = width, 
                        this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                        var result = policy.apply(this, this._designResolutionSize);
                        if (result.scale && 2 === result.scale.length && (this._scaleX = result.scale[0], 
                        this._scaleY = result.scale[1]), result.viewport) {
                            var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
                            vp.x = rv.x, vp.y = rv.y, vp.width = rv.width, vp.height = rv.height, vb.x = 0, 
                            vb.y = 0, vb.width = rv.width / this._scaleX, vb.height = rv.height / this._scaleY;
                        }
                        policy.postApply(this), cc.winSize.width = this._visibleRect.width, cc.winSize.height = this._visibleRect.height, 
                        cc.visibleRect && cc.visibleRect.init(this._visibleRect), this.emit("design-resolution-changed");
                    } else cc.logID(2201);
                } else cc.logID(2200);
            }
        }, {
            key: "getDesignResolutionSize",
            value: function getDesignResolutionSize() {
                return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
            }
        }, {
            key: "setRealPixelResolution",
            value: function setRealPixelResolution(width, height, resolutionPolicy) {
                this._setViewportMeta({
                    width: width
                }, !0), document.documentElement.style.width = width + "px", document.body.style.width = width + "px", 
                document.body.style.left = "0px", document.body.style.top = "0px", this.setDesignResolutionSize(width, height, resolutionPolicy);
            }
        }, {
            key: "setViewportInPoints",
            value: function setViewportInPoints(x, y, w, h) {
                var locScaleX = this._scaleX, locScaleY = this._scaleY;
                cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
            }
        }, {
            key: "setScissorInPoints",
            value: function setScissorInPoints(x, y, w, h) {
                var scaleX = this._scaleX, scaleY = this._scaleY, sx = Math.ceil(x * scaleX + this._viewportRect.x), sy = Math.ceil(y * scaleY + this._viewportRect.y), sw = Math.ceil(w * scaleX), sh = Math.ceil(h * scaleY), gl = cc.game._renderContext;
                if (!_scissorRect) {
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                }
                _scissorRect.x === sx && _scissorRect.y === sy && _scissorRect.width === sw && _scissorRect.height === sh || (_scissorRect.x = sx, 
                _scissorRect.y = sy, _scissorRect.width = sw, _scissorRect.height = sh, gl.scissor(sx, sy, sw, sh));
            }
        }, {
            key: "isScissorEnabled",
            value: function isScissorEnabled() {
                var gl = cc.game._renderContext;
                return gl.isEnabled(gl.SCISSOR_TEST);
            }
        }, {
            key: "getScissorRect",
            value: function getScissorRect() {
                var gl = cc.game._renderContext;
                if (!_scissorRect) {
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                }
                var scaleXFactor = 1 / this._scaleX, scaleYFactor = 1 / this._scaleY;
                return new Rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
            }
        }, {
            key: "getViewportRect",
            value: function getViewportRect() {
                return this._viewportRect;
            }
        }, {
            key: "getScaleX",
            value: function getScaleX() {
                return this._scaleX;
            }
        }, {
            key: "getScaleY",
            value: function getScaleY() {
                return this._scaleY;
            }
        }, {
            key: "getDevicePixelRatio",
            value: function getDevicePixelRatio() {
                return this._devicePixelRatio;
            }
        }, {
            key: "convertToLocationInView",
            value: function convertToLocationInView(tx, ty, relatedPos, out) {
                var result = out || cc.v2(), x = this._devicePixelRatio * (tx - relatedPos.left), y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
                return this._isRotated ? (result.x = cc.game.canvas.width - y, result.y = x) : (result.x = x, 
                result.y = y), result;
            }
        }, {
            key: "_resizeEvent",
            value: function _resizeEvent() {
                var frameId = cc.director.getTotalFrames();
                if (_currentFrame !== frameId) {
                    var view;
                    _currentFrame = frameId;
                    var prevFrameW = (view = this.setDesignResolutionSize ? this : cc.view)._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
                    if (cc.sys.isMobile) {
                        var containerStyle = cc.game.container.style, margin = containerStyle.margin;
                        containerStyle.margin = "0", containerStyle.display = "none", view._initFrameSize(), 
                        containerStyle.margin = margin, containerStyle.display = "block";
                    } else view._initFrameSize();
                    if (view._orientationChanging || view._isRotated !== prevRotated || view._frameSize.width !== prevFrameW || view._frameSize.height !== prevFrameH) {
                        var width = view._originalDesignResolutionSize.width, height = view._originalDesignResolutionSize.height;
                        view._resizing = !0, 0 < width && view.setDesignResolutionSize(width, height, view._resolutionPolicy), 
                        view._resizing = !1, view._resizeCallback && view._resizeCallback.call();
                    }
                }
            }
        }, {
            key: "_orientationChange",
            value: function _orientationChange() {
                cc.view._orientationChanging = !0, cc.view._resizeEvent();
            }
        }, {
            key: "_initFrameSize",
            value: function _initFrameSize() {
                var locFrameSize = this._frameSize, w = __BrowserGetter.availWidth(cc.game.frame), h = __BrowserGetter.availHeight(cc.game.frame), isLandscape = h <= w;
                !cc.sys.isMobile || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT ? (locFrameSize.width = w, 
                locFrameSize.height = h, cc.game.container.style["-webkit-transform"] = "rotate(0deg)", 
                cc.game.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (locFrameSize.width = h, 
                locFrameSize.height = w, cc.game.container.style["-webkit-transform"] = "rotate(90deg)", 
                cc.game.container.style.transform = "rotate(90deg)", cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px", 
                cc.game.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0, cc.game.canvas.style["-webkit-transform"] = "translateZ(0px)", 
                cc.game.canvas.style.transform = "translateZ(0px)"), this._orientationChanging && setTimeout(function() {
                    cc.view._orientationChanging = !1;
                }, 1e3);
            }
        }, {
            key: "_adjustSizeKeepCanvasSize",
            value: function _adjustSizeKeepCanvasSize() {
                var designWidth = this._originalDesignResolutionSize.width, designHeight = this._originalDesignResolutionSize.height;
                0 < designWidth && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
            }
        }, {
            key: "_setViewportMeta",
            value: function _setViewportMeta(metas, overwrite) {
                var vp = document.getElementById("cocosMetaElement");
                vp && overwrite && document.head.removeChild(vp);
                var content, key, pattern, elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null;
                for (key in content = currentVP ? currentVP.content : "", (vp = vp || document.createElement("meta")).id = "cocosMetaElement", 
                vp.name = "viewport", vp.content = "", metas) -1 === content.indexOf(key) ? content += "," + key + "=" + metas[key] : overwrite && (pattern = new RegExp(key + "s*=s*[^,]+"), 
                content.replace(pattern, key + "=" + metas[key]));
                /^,/.test(content) && (content = content.substr(1)), vp.content = content, currentVP && (currentVP.content = content), 
                document.head.appendChild(vp);
            }
        }, {
            key: "_adjustViewportMeta",
            value: function _adjustViewportMeta() {
                this._isAdjustViewport && (this._setViewportMeta(__BrowserGetter.meta, !1), this._isAdjustViewport = !1);
            }
        }, {
            key: "_convertMouseToLocation",
            value: function _convertMouseToLocation(in_out_point, relatedPos) {
                in_out_point.x = this._devicePixelRatio * (in_out_point.x - relatedPos.left), in_out_point.y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y);
            }
        }, {
            key: "_convertPointWithScale",
            value: function _convertPointWithScale(point) {
                var viewport = this._viewportRect;
                point.x = (point.x - viewport.x) / this._scaleX, point.y = (point.y - viewport.y) / this._scaleY;
            }
        }, {
            key: "_convertTouchWidthScale",
            value: function _convertTouchWidthScale(selTouch) {
                var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY;
                selTouch._point.x = (selTouch._point.x - viewport.x) / scaleX, selTouch._point.y = (selTouch._point.y - viewport.y) / scaleY, 
                selTouch._prevPoint.x = (selTouch._prevPoint.x - viewport.x) / scaleX, selTouch._prevPoint.y = (selTouch._prevPoint.y - viewport.y) / scaleY;
            }
        }, {
            key: "_convertTouchesWithScale",
            value: function _convertTouchesWithScale(touches) {
                for (var selPoint, selPrePoint, viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, i = 0; i < touches.length; i++) {
                    var selTouch = touches[i];
                    selPoint = selTouch._point, selPrePoint = selTouch._prevPoint, selPoint.x = (selPoint.x - viewport.x) / scaleX, 
                    selPoint.y = (selPoint.y - viewport.y) / scaleY, selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX, 
                    selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
                }
            }
        } ]), View;
    }(), ContainerStrategy = function() {
        function ContainerStrategy() {
            _classCallCheck(this, ContainerStrategy), this.name = "ContainerStrategy";
        }
        return _createClass(ContainerStrategy, [ {
            key: "preApply",
            value: function preApply(view) {}
        }, {
            key: "apply",
            value: function apply(view, designedResolution) {}
        }, {
            key: "postApply",
            value: function postApply(view) {}
        }, {
            key: "_setupContainer",
            value: function _setupContainer(view, w, h) {
                var locCanvas = cc.game.canvas, locContainer = cc.game.container;
                cc.sys.platform !== cc.sys.WECHAT_GAME && (cc.sys.os === cc.sys.OS_ANDROID && (document.body.style.width = (view._isRotated ? h : w) + "px", 
                document.body.style.height = (view._isRotated ? w : h) + "px"), locContainer.style.width = locCanvas.style.width = w + "px", 
                locContainer.style.height = locCanvas.style.height = h + "px");
                var devicePixelRatio = view._devicePixelRatio = 1;
                view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1)), 
                locCanvas.width = w * devicePixelRatio, locCanvas.height = h * devicePixelRatio;
            }
        }, {
            key: "_fixContainer",
            value: function _fixContainer() {
                document.body.insertBefore(cc.game.container, document.body.firstChild);
                var bs = document.body.style;
                bs.width = window.innerWidth + "px", bs.height = window.innerHeight + "px", bs.overflow = "hidden";
                var contStyle = cc.game.container.style;
                contStyle.position = "fixed", contStyle.left = contStyle.top = "0px", document.body.scrollTop = 0;
            }
        } ]), ContainerStrategy;
    }();
    ContainerStrategy.EQUAL_TO_FRAME = void 0, ContainerStrategy.PROPORTION_TO_FRAME = void 0;
    var ContentStrategy = function() {
        function ContentStrategy() {
            _classCallCheck(this, ContentStrategy), this.name = "ContentStrategy", this._result = void 0, 
            this._result = {
                scale: [ 1, 1 ],
                viewport: null
            };
        }
        return _createClass(ContentStrategy, [ {
            key: "preApply",
            value: function preApply(view) {}
        }, {
            key: "apply",
            value: function apply(view, designedResolution) {
                return {
                    scale: [ 1, 1 ]
                };
            }
        }, {
            key: "postApply",
            value: function postApply(view) {}
        }, {
            key: "_buildResult",
            value: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                Math.abs(containerW - contentW) < 2 && (contentW = containerW), Math.abs(containerH - contentH) < 2 && (contentH = containerH);
                var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                return cc.game.renderType, Game.RENDER_TYPE_CANVAS, this._result.scale = [ scaleX, scaleY ], 
                this._result.viewport = viewport, this._result;
            }
        } ]), ContentStrategy;
    }();
    ContentStrategy.EXACT_FIT = void 0, ContentStrategy.SHOW_ALL = void 0, ContentStrategy.NO_BORDER = void 0, 
    ContentStrategy.FIXED_HEIGHT = void 0, ContentStrategy.FIXED_WIDTH = void 0, function() {
        var EqualToFrame = function(_ContainerStrategy) {
            function EqualToFrame() {
                var _getPrototypeOf2, _this2;
                _classCallCheck(this, EqualToFrame);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EqualToFrame)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).name = "EqualToFrame", 
                _this2;
            }
            return _inherits(EqualToFrame, ContainerStrategy), _createClass(EqualToFrame, [ {
                key: "apply",
                value: function apply(view) {
                    var frameH = view._frameSize.height, containerStyle = cc.game.container.style;
                    this._setupContainer(view, view._frameSize.width, view._frameSize.height), view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                    containerStyle.padding = "0px";
                }
            } ]), EqualToFrame;
        }(), ProportionalToFrame = function(_ContainerStrategy2) {
            function ProportionalToFrame() {
                var _getPrototypeOf3, _this3;
                _classCallCheck(this, ProportionalToFrame);
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                return (_this3 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ProportionalToFrame)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).name = "ProportionalToFrame", 
                _this3;
            }
            return _inherits(ProportionalToFrame, ContainerStrategy), _createClass(ProportionalToFrame, [ {
                key: "apply",
                value: function apply(view, designedResolution) {
                    var containerW, containerH, frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH;
                    containerH = scaleX < scaleY ? (containerW = frameW, designH * scaleX) : (containerW = designW * scaleY, 
                    frameH);
                    var offx = Math.round((frameW - containerW) / 2), offy = Math.round((frameH - containerH) / 2);
                    containerW = frameW - 2 * offx, containerH = frameH - 2 * offy, this._setupContainer(view, containerW, containerH), 
                    view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                    containerStyle.paddingLeft = offx + "px", containerStyle.paddingRight = offx + "px", 
                    containerStyle.paddingTop = offy + "px", containerStyle.paddingBottom = offy + "px";
                }
            } ]), ProportionalToFrame;
        }();
        ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame(), ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
        var ExactFit = function(_ContentStrategy) {
            function ExactFit() {
                var _getPrototypeOf4, _this4;
                _classCallCheck(this, ExactFit);
                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                return (_this4 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(ExactFit)).call.apply(_getPrototypeOf4, [ this ].concat(args)))).name = "ExactFit", 
                _this4;
            }
            return _inherits(ExactFit, ContentStrategy), _createClass(ExactFit, [ {
                key: "apply",
                value: function apply(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                    return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                }
            } ]), ExactFit;
        }(), ShowAll = function(_ContentStrategy2) {
            function ShowAll() {
                var _getPrototypeOf5, _this5;
                _classCallCheck(this, ShowAll);
                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                return (_this5 = _possibleConstructorReturn(this, (_getPrototypeOf5 = _getPrototypeOf(ShowAll)).call.apply(_getPrototypeOf5, [ this ].concat(args)))).name = "ShowAll", 
                _this5;
            }
            return _inherits(ShowAll, ContentStrategy), _createClass(ShowAll, [ {
                key: "apply",
                value: function apply(view, designedResolution) {
                    var contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0;
                    return contentH = scaleX < scaleY ? (contentW = containerW, designH * (scale = scaleX)) : (contentW = designW * (scale = scaleY), 
                    containerH), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), ShowAll;
        }(), NoBorder = function(_ContentStrategy3) {
            function NoBorder() {
                var _getPrototypeOf6, _this6;
                _classCallCheck(this, NoBorder);
                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                return (_this6 = _possibleConstructorReturn(this, (_getPrototypeOf6 = _getPrototypeOf(NoBorder)).call.apply(_getPrototypeOf6, [ this ].concat(args)))).name = "NoBorder", 
                _this6;
            }
            return _inherits(NoBorder, ContentStrategy), _createClass(NoBorder, [ {
                key: "apply",
                value: function apply(view, designedResolution) {
                    var scale, contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH;
                    return contentH = scaleX < scaleY ? (contentW = designW * (scale = scaleY), containerH) : (contentW = containerW, 
                    designH * (scale = scaleX)), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), NoBorder;
        }(), FixedHeight = function(_ContentStrategy4) {
            function FixedHeight() {
                var _getPrototypeOf7, _this7;
                _classCallCheck(this, FixedHeight);
                for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
                return (_this7 = _possibleConstructorReturn(this, (_getPrototypeOf7 = _getPrototypeOf(FixedHeight)).call.apply(_getPrototypeOf7, [ this ].concat(args)))).name = "FixedHeight", 
                _this7;
            }
            return _inherits(FixedHeight, ContentStrategy), _createClass(FixedHeight, [ {
                key: "apply",
                value: function apply(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerH / designedResolution.height, contentW = containerW, contentH = containerH;
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), FixedHeight;
        }(), FixedWidth = function(_ContentStrategy5) {
            function FixedWidth() {
                var _getPrototypeOf8, _this8;
                _classCallCheck(this, FixedWidth);
                for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
                return (_this8 = _possibleConstructorReturn(this, (_getPrototypeOf8 = _getPrototypeOf(FixedWidth)).call.apply(_getPrototypeOf8, [ this ].concat(args)))).name = "FixedWidth", 
                _this8;
            }
            return _inherits(FixedWidth, ContentStrategy), _createClass(FixedWidth, [ {
                key: "apply",
                value: function apply(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerW / designedResolution.width, contentW = containerW, contentH = containerH;
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            } ]), FixedWidth;
        }();
        ContentStrategy.EXACT_FIT = new ExactFit(), ContentStrategy.SHOW_ALL = new ShowAll(), 
        ContentStrategy.NO_BORDER = new NoBorder(), ContentStrategy.FIXED_HEIGHT = new FixedHeight(), 
        ContentStrategy.FIXED_WIDTH = new FixedWidth();
    }();
    var ResolutionPolicy = function() {
        function ResolutionPolicy(containerStg, contentStg) {
            _classCallCheck(this, ResolutionPolicy), this.name = "ResolutionPolicy", this._containerStrategy = void 0, 
            this._contentStrategy = void 0, this._containerStrategy = null, this._contentStrategy = null, 
            this.setContainerStrategy(containerStg), this.setContentStrategy(contentStg);
        }
        return _createClass(ResolutionPolicy, [ {
            key: "preApply",
            value: function preApply(view) {
                this._containerStrategy.preApply(view), this._contentStrategy.preApply(view);
            }
        }, {
            key: "apply",
            value: function apply(view, designedResolution) {
                return this._containerStrategy.apply(view, designedResolution), this._contentStrategy.apply(view, designedResolution);
            }
        }, {
            key: "postApply",
            value: function postApply(view) {
                this._containerStrategy.postApply(view), this._contentStrategy.postApply(view);
            }
        }, {
            key: "setContainerStrategy",
            value: function setContainerStrategy(containerStg) {
                containerStg instanceof ContainerStrategy && (this._containerStrategy = containerStg);
            }
        }, {
            key: "setContentStrategy",
            value: function setContentStrategy(contentStg) {
                contentStg instanceof ContentStrategy && (this._contentStrategy = contentStg);
            }
        }, {
            key: "canvasSize",
            get: function get() {
                return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
            }
        } ]), ResolutionPolicy;
    }();
    ResolutionPolicy.EXACT_FIT = void 0, ResolutionPolicy.SHOW_ALL = void 0, ResolutionPolicy.NO_BORDER = void 0, 
    ResolutionPolicy.FIXED_HEIGHT = void 0, ResolutionPolicy.FIXED_WIDTH = void 0, ResolutionPolicy.UNKNOWN = void 0, 
    ResolutionPolicy.ContainerStrategy = void 0, ResolutionPolicy.ContentStrategy = void 0, 
    ResolutionPolicy.EXACT_FIT = 0, ResolutionPolicy.NO_BORDER = 1, ResolutionPolicy.SHOW_ALL = 2, 
    ResolutionPolicy.FIXED_HEIGHT = 3, ResolutionPolicy.FIXED_WIDTH = 4, ResolutionPolicy.UNKNOWN = 5, 
    ResolutionPolicy.ContainerStrategy = ContainerStrategy, ResolutionPolicy.ContentStrategy = ContentStrategy, 
    cc.ResolutionPolicy = ResolutionPolicy;
    cc.view = new View();
    cc.winSize = cc.v2();
    var screen$1 = {
        _supportsFullScreen: !1,
        _preOnFullScreenChange: null,
        _touchEvent: "",
        _fn: null,
        _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
        init: function init() {
            this._fn = {};
            var i, l, val, valL, map = this._fnMap;
            for (i = 0, l = map.length; i < l; i++) if ((val = map[i]) && void 0 !== document[val[1]]) {
                for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
                break;
            }
            this._supportsFullScreen = void 0 !== this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
        },
        fullScreen: function fullScreen() {
            return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
        },
        requestFullScreen: function requestFullScreen(element, onFullScreenChange) {
            if (this._supportsFullScreen) {
                if (element = element || document.documentElement, onFullScreenChange) {
                    var eventName = this._fn.fullscreenchange;
                    this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange), 
                    this._preOnFullScreenChange = onFullScreenChange, document.addEventListener(eventName, onFullScreenChange, !1);
                }
                return element[this._fn.requestFullscreen]();
            }
        },
        exitFullScreen: function exitFullScreen() {
            return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
        },
        autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
            element = element || document.body;
            var touchTarget = cc.game.canvas || element, theScreen = this;
            this.requestFullScreen(element, onFullScreenChange), touchTarget.addEventListener(this._touchEvent, function callback() {
                touchTarget.removeEventListener(theScreen._touchEvent, callback), theScreen.requestFullScreen(element, onFullScreenChange);
            });
        }
    };
    screen$1.init(), cc.screen = screen$1;
    var idGenerator$3 = new IDGenerator("Scheduler"), ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
        _classCallCheck(this, ListEntry), this.target = void 0, this.priority = void 0, 
        this.paused = void 0, this.markedForDeletion = void 0, this.target = target, this.priority = priority, 
        this.paused = paused, this.markedForDeletion = markedForDeletion;
    };
    ListEntry.get = function(target, priority, paused, markedForDeletion) {
        var result = ListEntry._listEntries.pop();
        return result ? (result.target = target, result.priority = priority, result.paused = paused, 
        result.markedForDeletion = markedForDeletion) : result = new ListEntry(target, priority, paused, markedForDeletion), 
        result;
    }, ListEntry.put = function(entry) {
        ListEntry._listEntries.length < 20 && (entry.target = null, ListEntry._listEntries.push(entry));
    }, ListEntry._listEntries = [];
    var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
        _classCallCheck(this, HashUpdateEntry), this.list = void 0, this.entry = void 0, 
        this.target = void 0, this.callback = void 0, this.list = list, this.entry = entry, 
        this.target = target, this.callback = callback;
    };
    HashUpdateEntry.get = function(list, entry, target, callback) {
        var result = HashUpdateEntry._hashUpdateEntries.pop();
        return result ? (result.list = list, result.entry = entry, result.target = target, 
        result.callback = callback) : result = new HashUpdateEntry(list, entry, target, callback), 
        result;
    }, HashUpdateEntry.put = function(entry) {
        HashUpdateEntry._hashUpdateEntries.length < 20 && (entry.list = entry.entry = entry.target = entry.callback = null, 
        HashUpdateEntry._hashUpdateEntries.push(entry));
    }, HashUpdateEntry._hashUpdateEntries = [];
    var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
        _classCallCheck(this, HashTimerEntry), this.timers = void 0, this.target = void 0, 
        this.timerIndex = void 0, this.currentTimer = void 0, this.currentTimerSalvaged = void 0, 
        this.paused = void 0, this.timers = timers, this.target = target, this.timerIndex = timerIndex, 
        this.currentTimer = currentTimer, this.currentTimerSalvaged = currentTimerSalvaged, 
        this.paused = paused;
    };
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
        var result = HashTimerEntry._hashTimerEntries.pop();
        return result ? (result.timers = timers, result.target = target, result.timerIndex = timerIndex, 
        result.currentTimer = currentTimer, result.currentTimerSalvaged = currentTimerSalvaged, 
        result.paused = paused) : result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused), 
        result;
    }, HashTimerEntry.put = function(entry) {
        HashTimerEntry._hashTimerEntries.length < 20 && (entry.timers = entry.target = entry.currentTimer = null, 
        HashTimerEntry._hashTimerEntries.push(entry));
    }, HashTimerEntry._hashTimerEntries = [];
    var CallbackTimer = function() {
        function CallbackTimer() {
            _classCallCheck(this, CallbackTimer), this._lock = void 0, this._scheduler = void 0, 
            this._elapsed = void 0, this._runForever = void 0, this._useDelay = void 0, this._timesExecuted = void 0, 
            this._repeat = void 0, this._delay = void 0, this._interval = void 0, this._target = void 0, 
            this._callback = void 0, this._lock = !1, this._scheduler = null, this._elapsed = -1, 
            this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, 
            this._delay = 0, this._interval = 0, this._target = null, this._callback = null;
        }
        return _createClass(CallbackTimer, [ {
            key: "initWithCallback",
            value: function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
                return this._lock = !1, this._scheduler = scheduler, this._target = target, this._callback = callback, 
                this._elapsed = -1, this._interval = seconds, this._delay = delay, this._useDelay = 0 < this._delay, 
                this._repeat = repeat, this._runForever = this._repeat === cc.macro.REPEAT_FOREVER, 
                !0;
            }
        }, {
            key: "getInterval",
            value: function getInterval() {
                return this._interval;
            }
        }, {
            key: "setInterval",
            value: function setInterval(interval) {
                this._interval = interval;
            }
        }, {
            key: "update",
            value: function update(dt) {
                -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += dt, 
                this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), 
                this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), 
                this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), 
                this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
            }
        }, {
            key: "getCallback",
            value: function getCallback() {
                return this._callback;
            }
        }, {
            key: "trigger",
            value: function trigger() {
                this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), 
                this._lock = !1);
            }
        }, {
            key: "cancel",
            value: function cancel() {
                this._scheduler.unschedule(this._callback, this._target);
            }
        } ]), CallbackTimer;
    }();
    CallbackTimer._timers = [], CallbackTimer.get = function() {
        return CallbackTimer._timers.pop() || new CallbackTimer();
    }, CallbackTimer.put = function(timer) {
        CallbackTimer._timers.length < 20 && !timer._lock && (timer._scheduler = timer._target = timer._callback = null, 
        CallbackTimer._timers.push(timer));
    };
    var Scheduler = function() {
        function Scheduler() {
            _classCallCheck(this, Scheduler), this._timeScale = void 0, this._updatesNegList = void 0, 
            this._updates0List = void 0, this._updatesPosList = void 0, this._hashForUpdates = void 0, 
            this._hashForTimers = void 0, this._currentTarget = void 0, this._currentTargetSalvaged = void 0, 
            this._updateHashLocked = void 0, this._arrayForTimers = void 0, this._timeScale = 1, 
            this._updatesNegList = [], this._updates0List = [], this._updatesPosList = [], this._hashForUpdates = createMap(!0), 
            this._hashForTimers = createMap(!0), this._currentTarget = null, this._currentTargetSalvaged = !1, 
            this._updateHashLocked = !1, this._arrayForTimers = [];
        }
        return _createClass(Scheduler, [ {
            key: "enableForTarget",
            value: function enableForTarget(target) {
                target._id || (target.__instanceId ? cc.warnID(1513) : target._id = idGenerator$3.getNewId());
            }
        }, {
            key: "setTimeScale",
            value: function setTimeScale(timeScale) {
                this._timeScale = timeScale;
            }
        }, {
            key: "getTimeScale",
            value: function getTimeScale() {
                return this._timeScale;
            }
        }, {
            key: "update",
            value: function update(dt) {
                var i, list, len, entry, elt;
                for (this._updateHashLocked = !0, 1 !== this._timeScale && (dt *= this._timeScale), 
                i = 0, len = (list = this._updatesNegList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                for (i = 0, len = (list = this._updates0List).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                for (i = 0, len = (list = this._updatesPosList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
                var arr = this._arrayForTimers;
                for (i = 0; i < arr.length; i++) {
                    if (elt = arr[i], this._currentTarget = elt, this._currentTargetSalvaged = !1, !elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) elt.currentTimer = elt.timers[elt.timerIndex], 
                    elt.currentTimerSalvaged = !1, elt.currentTimer.update(dt), elt.currentTimer = null;
                    this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), 
                    --i);
                }
                for (i = 0, list = this._updatesNegList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                for (i = 0, list = this._updates0List; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                for (i = 0, list = this._updatesPosList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                this._updateHashLocked = !1, this._currentTarget = null;
            }
        }, {
            key: "schedule",
            value: function schedule(callback, target, interval, repeat, delay, paused) {
                if ("function" != typeof callback) {
                    var tmp = callback;
                    callback = target, target = tmp;
                }
                4 !== arguments.length && 5 !== arguments.length || (paused = !!repeat, repeat = cc.macro.REPEAT_FOREVER, 
                delay = 0), cc.assertID(target, 1502);
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var timer, i, element = this._hashForTimers[targetId];
                if (element ? element.paused !== paused && cc.warnID(1511) : (element = HashTimerEntry.get(null, target, 0, null, null, paused), 
                this._arrayForTimers.push(element), this._hashForTimers[targetId] = element), null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) if ((timer = element.timers[i]) && callback === timer._callback) return cc.logID(1507, timer.getInterval(), interval), 
                void (timer._interval = interval);
                (timer = CallbackTimer.get()).initWithCallback(this, callback, target, interval, repeat, delay), 
                element.timers.push(timer), this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1);
            }
        }, {
            key: "scheduleUpdate",
            value: function scheduleUpdate(target, priority, paused) {
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var hashElement = this._hashForUpdates[targetId];
                if (hashElement && hashElement.entry) {
                    if (hashElement.entry.priority === priority) return hashElement.entry.markedForDeletion = !1, 
                    void (hashElement.entry.paused = paused);
                    if (this._updateHashLocked) return cc.logID(1506), hashElement.entry.markedForDeletion = !1, 
                    void (hashElement.entry.paused = paused);
                    this.unscheduleUpdate(target);
                }
                var ppList, listElement = ListEntry.get(target, priority, paused, !1);
                0 === priority ? (ppList = this._updates0List, this._appendIn(ppList, listElement)) : (ppList = priority < 0 ? this._updatesNegList : this._updatesPosList, 
                this._priorityIn(ppList, listElement, priority)), this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
            }
        }, {
            key: "unschedule",
            value: function unschedule(callback, target) {
                if (target && callback) {
                    var targetId = target._id;
                    targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                    var element = this._hashForTimers[targetId];
                    if (element) for (var timers = element.timers, i = 0, li = timers.length; i < li; i++) {
                        var timer = timers[i];
                        if (callback === timer._callback) return timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = !0), 
                        timers.splice(i, 1), CallbackTimer.put(timer), element.timerIndex >= i && element.timerIndex--, 
                        void (0 === timers.length && (this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element)));
                    }
                }
            }
        }, {
            key: "unscheduleUpdate",
            value: function unscheduleUpdate(target) {
                if (target) {
                    var targetId = target._id;
                    targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                    var element = this._hashForUpdates[targetId];
                    element && (this._updateHashLocked ? element.entry.markedForDeletion = !0 : this._removeUpdateFromHash(element.entry));
                }
            }
        }, {
            key: "unscheduleAllForTarget",
            value: function unscheduleAllForTarget(target) {
                if (target) {
                    var targetId = target._id;
                    targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                    var element = this._hashForTimers[targetId];
                    if (element) {
                        var timers = element.timers;
                        -1 < timers.indexOf(element.currentTimer) && !element.currentTimerSalvaged && (element.currentTimerSalvaged = !0);
                        for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
                        timers.length = 0, this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element);
                    }
                    this.unscheduleUpdate(target);
                }
            }
        }, {
            key: "unscheduleAll",
            value: function unscheduleAll() {
                this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            }
        }, {
            key: "unscheduleAllWithMinPriority",
            value: function unscheduleAllWithMinPriority(minPriority) {
                var i, element, entry, arr = this._arrayForTimers;
                for (i = arr.length - 1; 0 <= i; i--) element = arr[i], this.unscheduleAllForTarget(element.target);
                var temp_length = 0;
                if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) temp_length = this._updatesNegList.length, 
                (entry = this._updatesNegList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
                temp_length === this._updatesNegList.length && i++;
                if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) temp_length = this._updates0List.length, 
                (entry = this._updates0List[i]) && this.unscheduleUpdate(entry.target), temp_length === this._updates0List.length && i++;
                for (i = 0; i < this._updatesPosList.length; ) temp_length = this._updatesPosList.length, 
                (entry = this._updatesPosList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
                temp_length === this._updatesPosList.length && i++;
            }
        }, {
            key: "isScheduled",
            value: function isScheduled(callback, target) {
                cc.assertID(callback, 1508), cc.assertID(target, 1509);
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForTimers[targetId];
                if (!element) return !1;
                if (null == element.timers) return !1;
                for (var timers = element.timers, i = 0; i < timers.length; ++i) {
                    if (callback === timers[i]._callback) return !0;
                }
                return !1;
            }
        }, {
            key: "pauseAllTargets",
            value: function pauseAllTargets() {
                return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            }
        }, {
            key: "pauseAllTargetsWithMinPriority",
            value: function pauseAllTargetsWithMinPriority(minPriority) {
                var element, i, li, entry, idsWithSelectors = [], locArrayForTimers = this._arrayForTimers;
                for (i = 0, li = locArrayForTimers.length; i < li; i++) (element = locArrayForTimers[i]) && (element.paused = !0, 
                idsWithSelectors.push(element.target));
                if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) (entry = this._updatesNegList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
                idsWithSelectors.push(entry.target));
                if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) (entry = this._updates0List[i]) && (entry.paused = !0, 
                idsWithSelectors.push(entry.target));
                for (i = 0; i < this._updatesPosList.length; i++) (entry = this._updatesPosList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
                idsWithSelectors.push(entry.target));
                return idsWithSelectors;
            }
        }, {
            key: "resumeTargets",
            value: function resumeTargets(targetsToResume) {
                if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
            }
        }, {
            key: "pauseTarget",
            value: function pauseTarget(target) {
                cc.assertID(target, 1503);
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForTimers[targetId];
                element && (element.paused = !0);
                var elementUpdate = this._hashForUpdates[targetId];
                elementUpdate && (elementUpdate.entry.paused = !0);
            }
        }, {
            key: "resumeTarget",
            value: function resumeTarget(target) {
                cc.assertID(target, 1504);
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForTimers[targetId];
                element && (element.paused = !1);
                var elementUpdate = this._hashForUpdates[targetId];
                elementUpdate && (elementUpdate.entry.paused = !1);
            }
        }, {
            key: "isTargetPaused",
            value: function isTargetPaused(target) {
                cc.assertID(target, 1505);
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForTimers[targetId];
                if (element) return element.paused;
                var elementUpdate = this._hashForUpdates[targetId];
                return !!elementUpdate && elementUpdate.entry.paused;
            }
        }, {
            key: "_removeHashElement",
            value: function _removeHashElement(element) {
                delete this._hashForTimers[element.target._id];
                for (var arr = this._arrayForTimers, i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
                    arr.splice(i, 1);
                    break;
                }
                HashTimerEntry.put(element);
            }
        }, {
            key: "_removeUpdateFromHash",
            value: function _removeUpdateFromHash(entry) {
                var targetId = entry.target._id, element = this._hashForUpdates[targetId];
                if (element) {
                    for (var list = element.list, listEntry = element.entry, i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
                        list.splice(i, 1);
                        break;
                    }
                    delete this._hashForUpdates[targetId], ListEntry.put(listEntry), HashUpdateEntry.put(element);
                }
            }
        }, {
            key: "_priorityIn",
            value: function _priorityIn(ppList, listElement, priority) {
                for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) return void ppList.splice(i, 0, listElement);
                ppList.push(listElement);
            }
        }, {
            key: "_appendIn",
            value: function _appendIn(ppList, listElement) {
                ppList.push(listElement);
            }
        } ]), Scheduler;
    }();
    Scheduler.PRIORITY_SYSTEM = 1 << 31, Scheduler.PRIORITY_NON_SYSTEM = Scheduler.PRIORITY_SYSTEM + 1, 
    cc.Scheduler = Scheduler;
    var RenderPassStage, RenderPriority;
    !function(RenderPassStage) {
        RenderPassStage[RenderPassStage.DEFAULT = 100] = "DEFAULT";
    }(RenderPassStage || (RenderPassStage = {})), function(RenderPriority) {
        RenderPriority[RenderPriority.MIN = 0] = "MIN", RenderPriority[RenderPriority.MAX = 255] = "MAX", 
        RenderPriority[RenderPriority.DEFAULT = 128] = "DEFAULT";
    }(RenderPriority || (RenderPriority = {}));
    var UniformBinding;
    !function(UniformBinding) {
        UniformBinding[UniformBinding.UBO_GLOBAL = 23] = "UBO_GLOBAL", UniformBinding[UniformBinding.UBO_SHADOW = 22] = "UBO_SHADOW", 
        UniformBinding[UniformBinding.UBO_LOCAL = 21] = "UBO_LOCAL", UniformBinding[UniformBinding.UBO_FORWARD_LIGHTS = 20] = "UBO_FORWARD_LIGHTS", 
        UniformBinding[UniformBinding.UBO_SKINNING = 19] = "UBO_SKINNING", UniformBinding[UniformBinding.UBO_SKINNING_TEXTURE = 18] = "UBO_SKINNING_TEXTURE", 
        UniformBinding[UniformBinding.UBO_UI = 17] = "UBO_UI", UniformBinding[UniformBinding.SAMPLER_JOINTS = 25] = "SAMPLER_JOINTS", 
        UniformBinding[UniformBinding.CUSTUM_UBO_BINDING_END_POINT = 17] = "CUSTUM_UBO_BINDING_END_POINT", 
        UniformBinding[UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT = 30] = "CUSTOM_SAMPLER_BINDING_START_POINT";
    }(UniformBinding || (UniformBinding = {}));
    var UBOGlobal = function UBOGlobal() {
        _classCallCheck(this, UBOGlobal), this.view = new Float32Array(UBOGlobal.COUNT);
    };
    UBOGlobal.SIZE = 4 * (UBOGlobal.COUNT = (UBOGlobal.AMBIENT_GROUND_OFFSET = (UBOGlobal.AMBIENT_SKY_OFFSET = (UBOGlobal.MAIN_LIT_COLOR_OFFSET = (UBOGlobal.MAIN_LIT_DIR_OFFSET = (UBOGlobal.EXPOSURE_OFFSET = (UBOGlobal.CAMERA_POS_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_OFFSET = (UBOGlobal.MAT_PROJ_INV_OFFSET = (UBOGlobal.MAT_PROJ_OFFSET = (UBOGlobal.MAT_VIEW_INV_OFFSET = (UBOGlobal.MAT_VIEW_OFFSET = (UBOGlobal.NATIVE_SIZE_OFFSET = (UBOGlobal.SCREEN_SCALE_OFFSET = (UBOGlobal.SCREEN_SIZE_OFFSET = (UBOGlobal.TIME_OFFSET = 0) + 4) + 4) + 4) + 4) + 16) + 16) + 16) + 16) + 16) + 16) + 4) + 4) + 4) + 4) + 4) + 4), 
    UBOGlobal.BLOCK = {
        binding: UniformBinding.UBO_GLOBAL,
        name: "CCGlobal",
        members: [ {
            name: "cc_time",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_screenSize",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_screenScale",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_nativeSize",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_matView",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matViewInv",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matProj",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matProjInv",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matViewProj",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matViewProjInv",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_cameraPos",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_exposure",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_mainLitDir",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_mainLitColor",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_ambientSky",
            type: GFXType.FLOAT4,
            count: 1
        }, {
            name: "cc_ambientGround",
            type: GFXType.FLOAT4,
            count: 1
        } ]
    };
    var UBOShadow = function UBOShadow() {
        _classCallCheck(this, UBOShadow), this.view = new Float32Array(UBOShadow.COUNT);
    };
    UBOShadow.SIZE = 4 * (UBOShadow.COUNT = (UBOShadow.SHADOW_COLOR_OFFSET = (UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0) + 16) + 4), 
    UBOShadow.BLOCK = {
        binding: UniformBinding.UBO_SHADOW,
        name: "CCShadow",
        members: [ {
            name: "cc_matLightPlaneProj",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_shadowColor",
            type: GFXType.FLOAT4,
            count: 1
        } ]
    };
    var localBindingsDesc = new Map(), UBOLocal = function UBOLocal() {
        _classCallCheck(this, UBOLocal), this.view = new Float32Array(UBOLocal.COUNT);
    };
    UBOLocal.SIZE = 4 * (UBOLocal.COUNT = (UBOLocal.MAT_WORLD_IT_OFFSET = (UBOLocal.MAT_WORLD_OFFSET = 0) + 16) + 16), 
    UBOLocal.BLOCK = {
        binding: UniformBinding.UBO_LOCAL,
        name: "CCLocal",
        members: [ {
            name: "cc_matWorld",
            type: GFXType.MAT4,
            count: 1
        }, {
            name: "cc_matWorldIT",
            type: GFXType.MAT4,
            count: 1
        } ]
    }, localBindingsDesc.set(UBOLocal.BLOCK.name, {
        type: GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOLocal.BLOCK
    });
    var UBOForwardLight = function UBOForwardLight() {
        _classCallCheck(this, UBOForwardLight), this.view = new Float32Array(UBOForwardLight.COUNT);
    };
    UBOForwardLight.MAX_SPHERE_LIGHTS = 2, UBOForwardLight.MAX_SPOT_LIGHTS = 2, UBOForwardLight.SIZE = 4 * (UBOForwardLight.COUNT = (UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPOT_LIGHT_DIR_OFFSET = (UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET = (UBOForwardLight.SPOT_LIGHT_POS_OFFSET = (UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET = (UBOForwardLight.SPHERE_LIGHT_POS_OFFSET = 0) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS), 
    UBOForwardLight.BLOCK = {
        binding: UniformBinding.UBO_FORWARD_LIGHTS,
        name: "CCForwardLight",
        members: [ {
            name: "cc_sphereLitPos",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPHERE_LIGHTS
        }, {
            name: "cc_sphereLitSizeRange",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPHERE_LIGHTS
        }, {
            name: "cc_sphereLitColor",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPHERE_LIGHTS
        }, {
            name: "cc_spotLitPos",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        }, {
            name: "cc_spotLitSizeRangeAngle",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        }, {
            name: "cc_spotLitDir",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        }, {
            name: "cc_spotLitColor",
            type: GFXType.FLOAT4,
            count: UBOForwardLight.MAX_SPOT_LIGHTS
        } ]
    }, localBindingsDesc.set(UBOForwardLight.BLOCK.name, {
        type: GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOForwardLight.BLOCK
    });
    var UBOSkinning = function UBOSkinning() {
        _classCallCheck(this, UBOSkinning);
    };
    UBOSkinning.MAT_JOINT_OFFSET = 0, UBOSkinning.SIZE = 4 * (UBOSkinning.COUNT = 360), 
    UBOSkinning.BLOCK = {
        binding: UniformBinding.UBO_SKINNING,
        name: "CCSkinning",
        members: [ {
            name: "cc_jointsData",
            type: GFXType.FLOAT4,
            count: 90
        } ]
    }, localBindingsDesc.set(UBOSkinning.BLOCK.name, {
        type: GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOSkinning.BLOCK
    });
    var UBOSkinningTexture = function UBOSkinningTexture() {
        _classCallCheck(this, UBOSkinningTexture);
    };
    UBOSkinningTexture.JOINTS_TEXTURE_SIZE_INV_OFFSET = 0, UBOSkinningTexture.SIZE = 4 * (UBOSkinningTexture.COUNT = 4), 
    UBOSkinningTexture.BLOCK = {
        binding: UniformBinding.UBO_SKINNING_TEXTURE,
        name: "CCSkinningTexture",
        members: [ {
            name: "cc_jointsTextureSizeInv",
            type: GFXType.FLOAT4,
            count: 1
        } ]
    }, localBindingsDesc.set(UBOSkinningTexture.BLOCK.name, {
        type: GFXBindingType.UNIFORM_BUFFER,
        blockInfo: UBOSkinningTexture.BLOCK
    });
    var UNIFORM_JOINTS_TEXTURE = {
        binding: UniformBinding.SAMPLER_JOINTS,
        name: "cc_jointsTexture",
        type: GFXType.SAMPLER2D,
        count: 1
    };
    localBindingsDesc.set(UNIFORM_JOINTS_TEXTURE.name, {
        type: GFXBindingType.SAMPLER,
        samplerInfo: UNIFORM_JOINTS_TEXTURE
    });
    var _class$o, _class2$h, _descriptor$f, _descriptor2$9, _class3$9, _temp$l, _shdID = 0, getBitCount = function getBitCount(cnt) {
        return Math.ceil(Math.log2(Math.max(cnt, 2)));
    }, mapDefine = function mapDefine(info, def) {
        switch (info.type) {
          case "boolean":
            return def ? "1" : "0";

          case "string":
            return void 0 !== def ? def : info.options[0];

          case "number":
            return (void 0 !== def ? def : info.range[0]) + "";
        }
        return console.warn("unknown define type '".concat(info.type, "'")), "0";
    }, insertBuiltinBindings = function insertBuiltinBindings(tmpl, source, type) {
        var target = tmpl.builtins[type], _iterator3 = target.blocks, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
            var _ref3;
            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                if ((_i3 = _iterator3.next()).done) break;
                _ref3 = _i3.value;
            }
            var b = _ref3, info = source.get(b);
            if (info && info.type === GFXBindingType.UNIFORM_BUFFER) tmpl.blocks.push(info.blockInfo); else console.warn("builtin UBO '".concat(b, "' not available!"));
        }
        var _iterator4 = target.samplers, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
            var _ref4;
            if (_isArray4) {
                if (_i4 >= _iterator4.length) break;
                _ref4 = _iterator4[_i4++];
            } else {
                if ((_i4 = _iterator4.next()).done) break;
                _ref4 = _i4.value;
            }
            var s = _ref4, _info = source.get(s);
            if (_info && _info.type === GFXBindingType.SAMPLER) tmpl.samplers.push(_info.samplerInfo); else console.warn("builtin sampler '".concat(s, "' not available!"));
        }
    }, programLib = new (function() {
        function ProgramLib() {
            _classCallCheck(this, ProgramLib), this._templates = void 0, this._cache = void 0, 
            this._templates = {}, this._cache = {};
        }
        return _createClass(ProgramLib, [ {
            key: "define",
            value: function define(prog) {
                var cur = this._templates[prog.name];
                if (!cur || cur.hash !== prog.hash) {
                    var tmpl = Object.assign({
                        id: ++_shdID
                    }, prog);
                    tmpl.localsInited || (insertBuiltinBindings(tmpl, localBindingsDesc, "locals"), 
                    tmpl.localsInited = !0);
                    var offset = 0, _loop = function _loop() {
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) return "break";
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) return "break";
                            _ref5 = _i5.value;
                        }
                        var def = _ref5, cnt = 1;
                        if ("number" === def.type) {
                            var range = def.range;
                            cnt = getBitCount(range[1] - range[0]), def._map = function(value) {
                                return value - range[0] << def._offset;
                            };
                        } else if ("string" === def.type) {
                            var _range = [ 0, def.options.length - 1 ];
                            cnt = getBitCount(_range[1] - _range[0]), def._map = function(value) {
                                return Math.max(0, def.options.findIndex(function(s) {
                                    return s === value;
                                })) << def._offset;
                            };
                        } else "boolean" === def.type && (def._map = function(value) {
                            return value ? 1 << def._offset : 0;
                        });
                        def._offset = offset, offset += cnt;
                    }, _iterator5 = tmpl.defines, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if ("break" === _loop()) break;
                    }
                    this._templates[prog.name] = tmpl;
                }
            }
        }, {
            key: "getTemplate",
            value: function getTemplate(name) {
                return this._templates[name];
            }
        }, {
            key: "hasProgram",
            value: function hasProgram(name) {
                return void 0 !== this._templates[name];
            }
        }, {
            key: "getKey",
            value: function getKey(name, defines) {
                var tmpl = this._templates[name], key = 0, _iterator6 = tmpl.defines, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    var tmplDef = _ref6, value = defines[tmplDef.name];
                    void 0 !== value && tmplDef._map && (key |= tmplDef._map(value));
                }
                return key << 8 | 255 & tmpl.id;
            }
        }, {
            key: "destroyShaderByDefines",
            value: function destroyShaderByDefines(defines) {
                var _this = this, defs = Object.keys(defines);
                if (defs.length) {
                    var regexes = defs.map(function(cur) {
                        var val = defs[cur];
                        return "boolean" == typeof val && (val = val ? "1" : "0"), new RegExp(cur + val);
                    }), _iterator7 = Object.keys(this._cache).filter(function(k) {
                        return regexes.every(function(re) {
                            return re.test(_this._cache[k].name);
                        });
                    }), _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                        var _ref7;
                        if (_isArray7) {
                            if (_i7 >= _iterator7.length) break;
                            _ref7 = _iterator7[_i7++];
                        } else {
                            if ((_i7 = _iterator7.next()).done) break;
                            _ref7 = _i7.value;
                        }
                        var k = _ref7;
                        console.log("destroyed shader ".concat(this._cache[k].name)), this._cache[k].destroy(), 
                        delete this._cache[k];
                    }
                }
            }
        }, {
            key: "getGFXShader",
            value: function getGFXShader(device, name, defines, pipeline) {
                Object.assign(defines, pipeline.macros);
                var key = this.getKey(name, defines), program = this._cache[key];
                if (void 0 !== program) return program;
                var tmpl = this._templates[name];
                tmpl.globalsInited || (insertBuiltinBindings(tmpl, pipeline.globalBindings, "globals"), 
                tmpl.globalsInited = !0);
                var defs = function prepareDefines(defs, tDefs) {
                    var defines = [], _iterator = tDefs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var tmpl = _ref, _name = tmpl.name, _result = mapDefine(tmpl, defs[_name]);
                        defines.push({
                            name: _name,
                            result: _result
                        });
                    }
                    return defines;
                }(defines, tmpl.defines);
                !function validateDefines(defines, device, deps) {
                    var _iterator2 = defines, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var info = _ref2, _name2 = info.name;
                        info.result && deps[_name2] && !device[deps[_name2]] && (console.warn("".concat(deps[_name2], " not supported on this platform, disabled ").concat(_name2)), 
                        info.result = "0");
                    }
                }(defs, device, tmpl.dependencies);
                var customDef = defs.reduce(function(acc, cur) {
                    return "".concat(acc, "#define ").concat(cur.name, " ").concat(cur.result, "\n");
                }, ""), vert = "", frag = "";
                return frag = device.gfxAPI === GFXAPI.WEBGL2 ? (vert = "#version 300 es\n".concat(customDef, "\n").concat(tmpl.glsl3.vert), 
                "#version 300 es\n".concat(customDef, "\n").concat(tmpl.glsl3.frag)) : (vert = "#version 100\n".concat(customDef, "\n").concat(tmpl.glsl1.vert), 
                "#version 100\n".concat(customDef, "\n").concat(tmpl.glsl1.frag)), program = device.createShader({
                    name: function getShaderInstanceName(name, defs) {
                        return name + defs.reduce(function(acc, cur) {
                            return cur.result ? "".concat(acc, "|").concat(cur.name).concat(cur.result) : acc;
                        }, "");
                    }(name, defs),
                    blocks: tmpl.blocks,
                    samplers: tmpl.samplers,
                    stages: [ {
                        type: GFXShaderType.VERTEX,
                        source: vert
                    }, {
                        type: GFXShaderType.FRAGMENT,
                        source: frag
                    } ]
                }), this._cache[key] = program;
            }
        } ]), ProgramLib;
    }())();
    cc.programLib = programLib;
    var effects = {}, EffectAsset = ccclass("cc.EffectAsset")((_temp$l = _class3$9 = function(_Asset) {
        function EffectAsset() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EffectAsset);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EffectAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "techniques", _descriptor$f, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "shaders", _descriptor2$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(EffectAsset, Asset), _createClass(EffectAsset, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.shaders.forEach(function(s) {
                    return programLib.define(s);
                }), EffectAsset.register(this);
            }
        } ], [ {
            key: "register",
            value: function register(asset) {
                effects[asset.name] = asset;
            }
        }, {
            key: "remove",
            value: function remove(name) {
                if (effects[name]) delete effects[name]; else for (var n in effects) if (effects[n]._uuid === name) return void delete effects[n];
            }
        }, {
            key: "get",
            value: function get(name) {
                if (effects[name]) return effects[name];
                for (var n in effects) if (effects[n]._uuid === name) return effects[n];
                return null;
            }
        }, {
            key: "getAll",
            value: function getAll() {
                return effects;
            }
        } ]), EffectAsset;
    }(), _class3$9._effects = {}, _descriptor$f = _applyDecoratedDescriptor((_class2$h = _temp$l).prototype, "techniques", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$h.prototype, "shaders", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$o = _class2$h)) || _class$o;
    cc.EffectAsset = EffectAsset;
    var GFXTextureView = function(_GFXObject) {
        function GFXTextureView(device) {
            var _this;
            return _classCallCheck(this, GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTextureView).call(this, GFXObjectType.TEXTURE_VIEW)))._device = void 0, 
            _this._texture = null, _this._type = GFXTextureViewType.TV2D, _this._format = exports.GFXFormat.UNKNOWN, 
            _this._baseLevel = 0, _this._levelCount = 1, _this._baseLayer = 0, _this._layerCount = 1, 
            _this._device = device, _this;
        }
        return _inherits(GFXTextureView, GFXObject), _createClass(GFXTextureView, [ {
            key: "texture",
            get: function get() {
                return this._texture;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "format",
            get: function get() {
                return this._format;
            }
        }, {
            key: "baseLevel",
            get: function get() {
                return this._baseLevel;
            }
        }, {
            key: "levelCount",
            get: function get() {
                return this._levelCount;
            }
        }, {
            key: "baseLayer",
            get: function get() {
                return this._baseLayer;
            }
        }, {
            key: "layerCount",
            get: function get() {
                return this._layerCount;
            }
        } ]), GFXTextureView;
    }(), Customization = function() {
        function Customization(info) {
            _classCallCheck(this, Customization), this._onAttach = void 0, this._onDetach = void 0, 
            this._models = {}, this._onAttach = info.onAttach, this._onDetach = info.onDetach;
        }
        return _createClass(Customization, [ {
            key: "attach",
            value: function attach(model) {
                var models = this._models, id = model.id;
                models[id] ? models[id]++ : (this._onAttach && this._onAttach(model), models[id] = 1);
            }
        }, {
            key: "detach",
            value: function detach(model) {
                var models = this._models, id = model.id;
                !models[id] || 0 < --models[id] || this._onDetach && this._onDetach(model);
            }
        } ]), Customization;
    }(), customizationManager = new (function() {
        function CustomizationManager() {
            _classCallCheck(this, CustomizationManager), this._customs = {};
        }
        return _createClass(CustomizationManager, [ {
            key: "register",
            value: function register(name, info) {
                this._customs[name] = new Customization(info);
            }
        }, {
            key: "attach",
            value: function attach(name, model) {
                var cus = this._customs[name];
                cus ? cus.attach(model) : console.warn("no customization named '".concat(name, "'"));
            }
        }, {
            key: "detach",
            value: function detach(name, model) {
                var cus = this._customs[name];
                cus ? cus.detach(model) : console.warn("no customization named '".concat(name, "'"));
            }
        } ]), CustomizationManager;
    }())();
    cc.customizationManager = customizationManager;
    var enums = {
        SHAPE_RAY: 1,
        SHAPE_LINE: 2,
        SHAPE_SPHERE: 4,
        SHAPE_AABB: 8,
        SHAPE_OBB: 16,
        SHAPE_PLANE: 32,
        SHAPE_TRIANGLE: 64,
        SHAPE_FRUSTUM: 128,
        SHAPE_FRUSTUM_ACCURATE: 256
    }, X = vec3.create(), Y = vec3.create(), Z = vec3.create(), d = vec3.create(), min$1 = vec3.create(), max$1 = vec3.create(), u = new Array(3), e = new Array(3);
    function point_plane(point, plane_) {
        return vec3.dot(plane_.n, point) - plane_.d;
    }
    function pt_point_aabb(out, point, aabb_) {
        return vec3.copy(out, point), vec3.subtract(min$1, aabb_.center, aabb_.halfExtents), 
        vec3.add(max$1, aabb_.center, aabb_.halfExtents), out.x = out.x < min$1.x ? min$1.x : out.x, 
        out.y = out.y < min$1.x ? min$1.y : out.y, out.z = out.z < min$1.x ? min$1.z : out.z, 
        out.x = out.x > max$1.x ? max$1.x : out.x, out.y = out.y > max$1.x ? max$1.y : out.y, 
        out.z = out.z > max$1.x ? max$1.z : out.z, out;
    }
    function pt_point_obb(out, point, obb_) {
        vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02), vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05), 
        vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08), u[0] = X, 
        u[1] = Y, u[2] = Z, e[0] = obb_.halfExtents.x, e[1] = obb_.halfExtents.y, e[2] = obb_.halfExtents.z, 
        vec3.sub(d, point, obb_.center), vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
        for (var i = 0; i < 3; i++) {
            var dist = vec3.dot(d, u[i]);
            dist > e[i] && (dist = e[i]), dist < -e[i] && (dist = -e[i]), out.x += dist * u[i].x, 
            out.y += dist * u[i].y, out.z += dist * u[i].z;
        }
        return out;
    }
    var pt, ab, min$$1, max$$1, aMin, aMax, bMin, bMax, distance = Object.freeze({
        point_plane: point_plane,
        pt_point_plane: function pt_point_plane(out, point, plane_) {
            var t = point_plane(point, plane_);
            return vec3.subtract(out, point, vec3.scale(out, plane_.n, t));
        },
        pt_point_aabb: pt_point_aabb,
        pt_point_obb: pt_point_obb
    }), ray_plane = (pt = vec3.create(0, 0, 0), function(ray, plane) {
        var denom = vec3.dot(ray.d, plane.n);
        if (Math.abs(denom) < Number.EPSILON) return 0;
        vec3.scale(pt, plane.n, plane.d);
        var t = vec3.dot(vec3.subtract(pt, pt, ray.o), plane.n) / denom;
        return t < 0 ? 0 : t;
    }), line_plane = (ab = vec3.create(0, 0, 0), function(line, plane) {
        vec3.subtract(ab, line.e, line.s);
        var t = (plane.d - vec3.dot(line.s, plane.n)) / vec3.dot(ab, plane.n);
        return t < 0 || 1 < t ? 0 : t;
    }), ray_triangle = function() {
        var ab = vec3.create(0, 0, 0), ac = vec3.create(0, 0, 0), pvec = vec3.create(0, 0, 0), tvec = vec3.create(0, 0, 0), qvec = vec3.create(0, 0, 0);
        return function(ray, triangle, doubleSided) {
            vec3.subtract(ab, triangle.b, triangle.a), vec3.subtract(ac, triangle.c, triangle.a), 
            vec3.cross(pvec, ray.d, ac);
            var det = vec3.dot(ab, pvec);
            if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) return 0;
            var inv_det = 1 / det;
            vec3.subtract(tvec, ray.o, triangle.a);
            var u = vec3.dot(tvec, pvec) * inv_det;
            if (u < 0 || 1 < u) return 0;
            vec3.cross(qvec, tvec, ab);
            var v = vec3.dot(ray.d, qvec) * inv_det;
            if (v < 0 || 1 < u + v) return 0;
            var t = vec3.dot(ac, qvec) * inv_det;
            return t < 0 ? 0 : t;
        };
    }(), line_triangle = function() {
        var ab = vec3.create(0, 0, 0), ac = vec3.create(0, 0, 0), qp = vec3.create(0, 0, 0), ap = vec3.create(0, 0, 0), n = vec3.create(0, 0, 0), e = vec3.create(0, 0, 0);
        return function(line, triangle, outPt) {
            vec3.subtract(ab, triangle.b, triangle.a), vec3.subtract(ac, triangle.c, triangle.a), 
            vec3.subtract(qp, line.s, line.e), vec3.cross(n, ab, ac);
            var det = vec3.dot(qp, n);
            if (det <= 0) return 0;
            vec3.subtract(ap, line.s, triangle.a);
            var t = vec3.dot(ap, n);
            if (t < 0 || det < t) return 0;
            vec3.cross(e, qp, ap);
            var v = vec3.dot(ac, e);
            if (v < 0 || det < v) return 0;
            var w = -vec3.dot(ab, e);
            if (w < 0 || det < v + w) return 0;
            if (outPt) {
                var invDet = 1 / det, u = 1 - (v *= invDet) - (w *= invDet);
                vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
            }
            return 1;
        };
    }(), line_quad = function() {
        var pq = vec3.create(0, 0, 0), pa = vec3.create(0, 0, 0), pb = vec3.create(0, 0, 0), pc = vec3.create(0, 0, 0), pd = vec3.create(0, 0, 0), m = vec3.create(0, 0, 0), tmp = vec3.create(0, 0, 0);
        return function(p, q, a, b, c, d, outPt) {
            vec3.subtract(pq, q, p), vec3.subtract(pa, a, p), vec3.subtract(pb, b, p), vec3.subtract(pc, c, p), 
            vec3.cross(m, pc, pq);
            var v = vec3.dot(pa, m);
            if (0 <= v) {
                var u = -vec3.dot(pb, m);
                if (u < 0) return 0;
                var w = vec3.dot(vec3.cross(tmp, pq, pb), pa);
                if (w < 0) return 0;
                if (outPt) {
                    var denom = 1 / (u + v + w);
                    u *= denom, v *= denom, w *= denom, vec3.set(outPt, a.x * u + b.x * v + c.x * w, a.y * u + b.y * v + c.y * w, a.z * u + b.z * v + c.z * w);
                }
            } else {
                vec3.subtract(pd, d, p);
                var _u = vec3.dot(pd, m);
                if (_u < 0) return 0;
                var _w = vec3.dot(vec3.cross(tmp, pq, pa), pd);
                if (_w < 0) return 0;
                if (outPt) {
                    var _denom = 1 / (_u + (v = -v) + _w);
                    _u *= _denom, v *= _denom, _w *= _denom, vec3.set(outPt, a.x * _u + d.x * v + c.x * _w, a.y * _u + d.y * v + c.y * _w, a.z * _u + d.z * v + c.z * _w);
                }
            }
            return 1;
        };
    }(), ray_sphere = function() {
        var e = vec3.create(0, 0, 0);
        return function(ray, sphere) {
            var r = sphere.radius, c = sphere.center, o = ray.o, d = ray.d, rSq = r * r;
            vec3.subtract(e, c, o);
            var eSq = vec3.sqrMag(e), aLength = vec3.dot(e, d), fSq = rSq - (eSq - aLength * aLength);
            if (fSq < 0) return 0;
            var f = Math.sqrt(fSq), t = eSq < rSq ? aLength + f : aLength - f;
            return t < 0 ? 0 : t;
        };
    }(), ray_aabb = (min$$1 = vec3.create(), max$$1 = vec3.create(), function(ray, aabb) {
        var o = ray.o, d = ray.d, ix = 1 / d.x, iy = 1 / d.y, iz = 1 / d.z;
        vec3.subtract(min$$1, aabb.center, aabb.halfExtents), vec3.add(max$$1, aabb.center, aabb.halfExtents);
        var t1 = (min$$1.x - o.x) * ix, t2 = (max$$1.x - o.x) * ix, t3 = (min$$1.y - o.y) * iy, t4 = (max$$1.y - o.y) * iy, t5 = (min$$1.z - o.z) * iz, t6 = (max$$1.z - o.z) * iz, tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6)), tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        return tmax < 0 || tmax < tmin ? 0 : tmin;
    }), ray_obb = function() {
        var center = vec3.create(), o = vec3.create(), d = vec3.create(), X = vec3.create(), Y = vec3.create(), Z = vec3.create(), p = vec3.create(), size = new Array(3), f = new Array(3), e = new Array(3), t = new Array(6);
        return function(ray, obb) {
            size[0] = obb.halfExtents.x, size[1] = obb.halfExtents.y, size[2] = obb.halfExtents.z, 
            center = obb.center, o = ray.o, d = ray.d, vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
            vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), 
            vec3.subtract(p, center, o), f[0] = vec3.dot(X, d), f[1] = vec3.dot(Y, d), f[2] = vec3.dot(Z, d), 
            e[0] = vec3.dot(X, p), e[1] = vec3.dot(Y, p), e[2] = vec3.dot(Z, p);
            for (var i = 0; i < 3; ++i) {
                if (0 === f[i]) {
                    if (0 < -e[i] - size[i] || -e[i] + size[i] < 0) return 0;
                    f[i] = 1e-7;
                }
                t[2 * i + 0] = (e[i] + size[i]) / f[i], t[2 * i + 1] = (e[i] - size[i]) / f[i];
            }
            var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5])), tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
            return tmax < 0 || tmax < tmin || tmin < 0 ? 0 : tmin;
        };
    }(), aabb_aabb = (aMin = vec3.create(), aMax = vec3.create(), bMin = vec3.create(), 
    bMax = vec3.create(), function(aabb1, aabb2) {
        return vec3.subtract(aMin, aabb1.center, aabb1.halfExtents), vec3.add(aMax, aabb1.center, aabb1.halfExtents), 
        vec3.subtract(bMin, aabb2.center, aabb2.halfExtents), vec3.add(bMax, aabb2.center, aabb2.halfExtents), 
        aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
    });
    function getOBBVertices(c, e, a1, a2, a3, out) {
        vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z), 
        vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z), 
        vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z), 
        vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z), 
        vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z), 
        vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z), 
        vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z), 
        vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
    }
    function getInterval(vertices, axis) {
        for (var min$$1 = vec3.dot(axis, vertices[0]), max$$1 = min$$1, i = 1; i < 8; ++i) {
            var projection = vec3.dot(axis, vertices[i]);
            min$$1 = projection < min$$1 ? projection : min$$1, max$$1 = max$$1 < projection ? projection : max$$1;
        }
        return [ min$$1, max$$1 ];
    }
    var absDot, aabb_obb = function() {
        for (var test = new Array(15), i = 0; i < 15; i++) test[i] = vec3.create(0, 0, 0);
        for (var vertices = new Array(8), vertices2 = new Array(8), _i = 0; _i < 8; _i++) vertices[_i] = vec3.create(0, 0, 0), 
        vertices2[_i] = vec3.create(0, 0, 0);
        var min$$1 = vec3.create(), max$$1 = vec3.create();
        return function(aabb, obb) {
            vec3.set(test[0], 1, 0, 0), vec3.set(test[1], 0, 1, 0), vec3.set(test[2], 0, 0, 1), 
            vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
            vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), 
            vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
            for (var _i2 = 0; _i2 < 3; ++_i2) vec3.cross(test[6 + 3 * _i2 + 0], test[_i2], test[0]), 
            vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[1]), vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[2]);
            vec3.subtract(min$$1, aabb.center, aabb.halfExtents), vec3.add(max$$1, aabb.center, aabb.halfExtents), 
            function getAABBVertices(min$$1, max$$1, out) {
                vec3.set(out[0], min$$1.x, max$$1.y, max$$1.z), vec3.set(out[1], min$$1.x, max$$1.y, min$$1.z), 
                vec3.set(out[2], min$$1.x, min$$1.y, max$$1.z), vec3.set(out[3], min$$1.x, min$$1.y, min$$1.z), 
                vec3.set(out[4], max$$1.x, max$$1.y, max$$1.z), vec3.set(out[5], max$$1.x, max$$1.y, min$$1.z), 
                vec3.set(out[6], max$$1.x, min$$1.y, max$$1.z), vec3.set(out[7], max$$1.x, min$$1.y, min$$1.z);
            }(min$$1, max$$1, vertices), getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
            for (var j = 0; j < 15; ++j) {
                var a = getInterval(vertices, test[j]), b = getInterval(vertices2, test[j]);
                if (b[0] > a[1] || a[0] > b[1]) return 0;
            }
            return 1;
        };
    }(), aabb_plane = function aabb_plane(aabb, plane) {
        var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z), dot = vec3.dot(plane.n, aabb.center);
        return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
    }, aabb_frustum = function aabb_frustum(aabb, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) if (-1 === aabb_plane(aabb, frustum.planes[i])) return 0;
        return 1;
    }, aabb_frustum_accurate = function() {
        for (var tmp = new Array(8), out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = vec3.create(0, 0, 0);
        return function(aabb, frustum) {
            for (var result = 0, intersects = !1, _i3 = 0; _i3 < frustum.planes.length; _i3++) {
                if (-1 === (result = aabb_plane(aabb, frustum.planes[_i3]))) return 0;
                1 === result && (intersects = !0);
            }
            if (!intersects) return 1;
            for (var _i4 = 0; _i4 < frustum.vertices.length; _i4++) vec3.subtract(tmp[_i4], frustum.vertices[_i4], aabb.center);
            for (var _i5 = out2 = out1 = 0; _i5 < frustum.vertices.length; _i5++) tmp[_i5].x > aabb.halfExtents.x ? out1++ : tmp[_i5].x < -aabb.halfExtents.x && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            for (var _i6 = out2 = out1 = 0; _i6 < frustum.vertices.length; _i6++) tmp[_i6].y > aabb.halfExtents.y ? out1++ : tmp[_i6].y < -aabb.halfExtents.y && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            for (var _i7 = out2 = out1 = 0; _i7 < frustum.vertices.length; _i7++) tmp[_i7].z > aabb.halfExtents.z ? out1++ : tmp[_i7].z < -aabb.halfExtents.z && out2++;
            return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
        };
    }(), obb_point = function() {
        var tmp = vec3.create(0, 0, 0), m3 = mat3.create();
        return function(obb, point) {
            return vec3.subtract(tmp, point, obb.center), vec3.transformMat3(tmp, tmp, mat3.transpose(m3, obb.orientation)), 
            function lessThan(a, b) {
                return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
            }(tmp, obb.halfExtents);
        };
    }(), obb_plane = (absDot = function absDot(n, x, y, z) {
        return Math.abs(n.x * x + n.y * y + n.z * z);
    }, function(obb, plane) {
        var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), dot = vec3.dot(plane.n, obb.center);
        return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
    }), obb_frustum = function obb_frustum(obb, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) if (-1 === obb_plane(obb, frustum.planes[i])) return 0;
        return 1;
    }, obb_frustum_accurate = function() {
        for (var tmp = new Array(8), dist = 0, out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = vec3.create(0, 0, 0);
        var dot = function dot(n, x, y, z) {
            return n.x * x + n.y * y + n.z * z;
        };
        return function(obb, frustum) {
            for (var result = 0, intersects = !1, _i8 = 0; _i8 < frustum.planes.length; _i8++) {
                if (-1 === (result = obb_plane(obb, frustum.planes[_i8]))) return 0;
                1 === result && (intersects = !0);
            }
            if (!intersects) return 1;
            for (var _i9 = 0; _i9 < frustum.vertices.length; _i9++) vec3.subtract(tmp[_i9], frustum.vertices[_i9], obb.center);
            for (var _i10 = out2 = out1 = 0; _i10 < frustum.vertices.length; _i10++) (dist = dot(tmp[_i10], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02)) > obb.halfExtents.x ? out1++ : dist < -obb.halfExtents.x && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            for (var _i11 = out2 = out1 = 0; _i11 < frustum.vertices.length; _i11++) (dist = dot(tmp[_i11], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05)) > obb.halfExtents.y ? out1++ : dist < -obb.halfExtents.y && out2++;
            if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
            for (var _i12 = out2 = out1 = 0; _i12 < frustum.vertices.length; _i12++) (dist = dot(tmp[_i12], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08)) > obb.halfExtents.z ? out1++ : dist < -obb.halfExtents.z && out2++;
            return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
        };
    }(), obb_obb = function() {
        for (var test = new Array(15), i = 0; i < 15; i++) test[i] = vec3.create(0, 0, 0);
        for (var vertices = new Array(8), vertices2 = new Array(8), _i13 = 0; _i13 < 8; _i13++) vertices[_i13] = vec3.create(0, 0, 0), 
        vertices2[_i13] = vec3.create(0, 0, 0);
        return function(obb1, obb2) {
            vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02), 
            vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05), 
            vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08), 
            vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02), 
            vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05), 
            vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
            for (var _i14 = 0; _i14 < 3; ++_i14) vec3.cross(test[6 + 3 * _i14 + 0], test[_i14], test[0]), 
            vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[1]), vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[2]);
            getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices), 
            getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
            for (var _i15 = 0; _i15 < 15; ++_i15) {
                var a = getInterval(vertices, test[_i15]), b = getInterval(vertices2, test[_i15]);
                if (b[0] > a[1] || a[0] > b[1]) return 0;
            }
            return 1;
        };
    }(), sphere_plane = function sphere_plane(sphere, plane) {
        var dot = vec3.dot(plane.n, sphere.center), r = sphere.radius * vec3.magnitude(plane.n);
        return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
    }, sphere_frustum = function sphere_frustum(sphere, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) if (-1 === sphere_plane(sphere, frustum.planes[i])) return 0;
        return 1;
    }, sphere_frustum_accurate = function() {
        var pt = vec3.create(0, 0, 0), map = [ 1, -1, 1, -1, 1, -1 ];
        return function(sphere, frustum) {
            for (var i = 0; i < 6; i++) {
                var plane = frustum.planes[i], r = sphere.radius, c = sphere.center, n = plane.n, d = plane.d, dot = vec3.dot(n, c);
                if (dot + r < d) return 0;
                if (!(d < dot - r)) {
                    vec3.add(pt, c, vec3.scale(pt, n, r));
                    for (var j = 0; j < 6; j++) if (j !== i && j !== i + map[i]) {
                        var test = frustum.planes[j];
                        if (vec3.dot(test.n, pt) < test.d) return 0;
                    }
                }
            }
            return 1;
        };
    }(), sphere_sphere = function sphere_sphere(sphere0, sphere1) {
        var r = sphere0.radius + sphere1.radius;
        return vec3.sqrDist(sphere0.center, sphere1.center) < r * r;
    }, sphere_aabb = function() {
        var pt = vec3.create();
        return function(sphere, aabb) {
            return pt_point_aabb(pt, sphere.center, aabb), vec3.sqrDist(sphere.center, pt) < sphere.radius * sphere.radius;
        };
    }(), sphere_obb = function() {
        var pt = vec3.create();
        return function(sphere, obb) {
            return pt_point_obb(pt, sphere.center, obb), vec3.sqrDist(sphere.center, pt) < sphere.radius * sphere.radius;
        };
    }(), intersect = {
        ray_sphere: ray_sphere,
        ray_aabb: ray_aabb,
        ray_obb: ray_obb,
        ray_plane: ray_plane,
        ray_triangle: ray_triangle,
        line_plane: line_plane,
        line_triangle: line_triangle,
        line_quad: line_quad,
        sphere_sphere: sphere_sphere,
        sphere_aabb: sphere_aabb,
        sphere_obb: sphere_obb,
        sphere_plane: sphere_plane,
        sphere_frustum: sphere_frustum,
        sphere_frustum_accurate: sphere_frustum_accurate,
        aabb_aabb: aabb_aabb,
        aabb_obb: aabb_obb,
        aabb_plane: aabb_plane,
        aabb_frustum: aabb_frustum,
        aabb_frustum_accurate: aabb_frustum_accurate,
        obb_obb: obb_obb,
        obb_plane: obb_plane,
        obb_frustum: obb_frustum,
        obb_frustum_accurate: obb_frustum_accurate,
        obb_point: obb_point,
        resolve: function resolve(g1, g2) {
            var outPt = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, type1 = g1._type, type2 = g2._type, resolver = this[type1 | type2];
            return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
        }
    };
    intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = ray_sphere, intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = ray_aabb, 
    intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = ray_obb, intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = ray_plane, 
    intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = ray_triangle, intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = line_plane, 
    intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = line_triangle, intersect[enums.SHAPE_SPHERE] = sphere_sphere, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphere_aabb, intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphere_obb, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = sphere_plane, intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphere_frustum, 
    intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate, 
    intersect[enums.SHAPE_AABB] = aabb_aabb, intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabb_obb, 
    intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabb_plane, intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabb_frustum, 
    intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate, 
    intersect[enums.SHAPE_OBB] = obb_obb, intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obb_plane, 
    intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obb_frustum, intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate;
    var line = function() {
        function line() {
            var sx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, sy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, sz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, ex = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, ey = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, ez = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : -1;
            _classCallCheck(this, line), this.s = void 0, this.e = void 0, this._type = void 0, 
            this._type = enums.SHAPE_LINE, this.s = vec3.create(sx, sy, sz), this.e = vec3.create(ex, ey, ez);
        }
        return _createClass(line, null, [ {
            key: "create",
            value: function create(sx, sy, sz, ex, ey, ez) {
                return new line(sx, sy, sz, ex, ey, ez);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return vec3.copy(out.s, a.s), vec3.copy(out.e, a.e), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, start, end) {
                return vec3.copy(out.s, start), vec3.copy(out.e, end), out;
            }
        }, {
            key: "set",
            value: function set(out, sx, sy, sz, ex, ey, ez) {
                return out.s.x = sx, out.s.y = sy, out.s.z = sz, out.e.x = ex, out.e.y = ey, out.e.z = ez, 
                out;
            }
        }, {
            key: "magnitude",
            value: function magnitude(a) {
                return vec3.distance(a.s, a.e);
            }
        }, {
            key: "mag",
            value: function mag(a) {
                return line.magnitude(a);
            }
        } ]), line;
    }(), v1 = vec3.create(0, 0, 0), v2$1 = vec3.create(0, 0, 0), temp_mat = cc.mat4(), temp_vec4 = cc.v4(), plane = function() {
        function plane() {
            var nx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, ny = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1, nz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, plane), this.n = void 0, this.d = void 0, this._type = void 0, 
            this._type = enums.SHAPE_PLANE, this.n = vec3.create(nx, ny, nz), this.d = d;
        }
        return _createClass(plane, null, [ {
            key: "create",
            value: function create(nx, ny, nz, d) {
                return new plane(nx, ny, nz, d);
            }
        }, {
            key: "clone",
            value: function clone(p) {
                return new plane(p.n.x, p.n.y, p.n.z, p.d);
            }
        }, {
            key: "copy",
            value: function copy(out, p) {
                return vec3.copy(out.n, p.n), out.d = p.d, out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, a, b, c) {
                return vec3.subtract(v1, b, a), vec3.subtract(v2$1, c, a), vec3.normalize(out.n, vec3.cross(out.n, v1, v2$1)), 
                out.d = vec3.dot(out.n, a), out;
            }
        }, {
            key: "set",
            value: function set(out, nx, ny, nz, d) {
                return out.n.x = nx, out.n.y = ny, out.n.z = nz, out.d = d, out;
            }
        }, {
            key: "fromNormalAndPoint",
            value: function fromNormalAndPoint(out, normal, point) {
                return vec3.copy(out.n, normal), out.d = vec3.dot(normal, point), out;
            }
        }, {
            key: "normalize",
            value: function normalize(out, a) {
                var len = vec3.magnitude(a.n);
                return vec3.normalize(out.n, a.n), 0 < len && (out.d = a.d / len), out;
            }
        } ]), _createClass(plane, [ {
            key: "transform",
            value: function transform(mat) {
                mat4.invert(temp_mat, mat), mat4.transpose(temp_mat, temp_mat), vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d), 
                vec4.transformMat4(temp_vec4, temp_vec4, temp_mat), vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z), 
                this.d = temp_vec4.w;
            }
        } ]), plane;
    }(), ray = function() {
        function ray() {
            var ox = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, oy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, oz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, dx = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, dy = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, dz = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : -1;
            _classCallCheck(this, ray), this.o = void 0, this.d = void 0, this._type = void 0, 
            this._type = enums.SHAPE_RAY, this.o = vec3.create(ox, oy, oz), this.d = vec3.create(dx, dy, dz);
        }
        return _createClass(ray, null, [ {
            key: "create",
            value: function create() {
                return new ray(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return vec3.copy(out.o, a.o), vec3.copy(out.d, a.d), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, origin, target) {
                return vec3.copy(out.o, origin), vec3.normalize(out.d, vec3.subtract(out.d, target, origin)), 
                out;
            }
        }, {
            key: "set",
            value: function set(out, ox, oy, oz, dx, dy, dz) {
                return out.o.x = ox, out.o.y = oy, out.o.z = oz, out.d.x = dx, out.d.y = dy, out.d.z = dz, 
                out;
            }
        } ]), ray;
    }(), triangle = function() {
        function triangle() {
            var ax = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, ay = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, az = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, bx = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, by = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, bz = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, cx = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, cy = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 1, cz = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0;
            _classCallCheck(this, triangle), this.a = void 0, this.b = void 0, this.c = void 0, 
            this._type = void 0, this._type = enums.SHAPE_TRIANGLE, this.a = vec3.create(ax, ay, az), 
            this.b = vec3.create(bx, by, bz), this.c = vec3.create(cx, cy, cz);
        }
        return _createClass(triangle, null, [ {
            key: "create",
            value: function create() {
                return new triangle(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0, 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 1);
            }
        }, {
            key: "clone",
            value: function clone(t) {
                return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
            }
        }, {
            key: "copy",
            value: function copy(out, t) {
                return vec3.copy(out.a, t.a), vec3.copy(out.b, t.b), vec3.copy(out.c, t.c), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, a, b, c) {
                return vec3.copy(out.a, a), vec3.copy(out.b, b), vec3.copy(out.c, c), out;
            }
        }, {
            key: "set",
            value: function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                return out.a.x = ax, out.a.y = ay, out.a.z = az, out.b.x = bx, out.b.y = by, out.b.z = bz, 
                out.c.x = cx, out.c.y = cy, out.c.z = cz, out;
            }
        } ]), triangle;
    }(), _v3_tmp = vec3.create();
    function maxComponent(v) {
        return Math.max(Math.max(v.x, v.y), v.z);
    }
    var sphere = function() {
        function sphere() {
            var cx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, cy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, cz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, sphere), this.center = void 0, this.radius = void 0, this._type = void 0, 
            this._type = enums.SHAPE_SPHERE, this.center = vec3.create(cx, cy, cz), this.radius = r;
        }
        return _createClass(sphere, null, [ {
            key: "create",
            value: function create(cx, cy, cz, r) {
                return new sphere(cx, cy, cz, r);
            }
        }, {
            key: "clone",
            value: function clone(p) {
                return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
            }
        }, {
            key: "copy",
            value: function copy(out, p) {
                return vec3.copy(out.center, p.center), out.radius = p.radius, out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, minPos, maxPos) {
                return vec3.scale(out.center, vec3.add(_v3_tmp, minPos, maxPos), .5), out.radius = .5 * vec3.mag(vec3.subtract(_v3_tmp, maxPos, minPos)), 
                out;
            }
        }, {
            key: "set",
            value: function set(out, cx, cy, cz, r) {
                return out.center.x = cx, out.center.y = cy, out.center.z = cz, out.radius = r, 
                out;
            }
        } ]), _createClass(sphere, [ {
            key: "clone",
            value: function clone() {
                return sphere.clone(this);
            }
        }, {
            key: "copy",
            value: function copy(a) {
                return sphere.copy(this, a);
            }
        }, {
            key: "getBoundary",
            value: function getBoundary(minPos, maxPos) {
                vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius), 
                vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                vec3.transformMat4(out.center, this.center, m), out.radius = this.radius * maxComponent(scale);
            }
        }, {
            key: "translateAndRotate",
            value: function translateAndRotate(m, rot, out) {
                vec3.transformMat4(out.center, this.center, m);
            }
        }, {
            key: "setScale",
            value: function setScale(scale, out) {
                out.radius = this.radius * maxComponent(scale);
            }
        } ]), sphere;
    }(), _v3_tmp$1 = vec3.create(), _v3_tmp2 = vec3.create(), _v3_tmp3 = vec3.create(), _v3_tmp4 = vec3.create(), _m3_tmp = mat3.create(), transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
        _m3_tmp.m00 = Math.abs(m4.m00), _m3_tmp.m01 = Math.abs(m4.m01), _m3_tmp.m02 = Math.abs(m4.m02), 
        _m3_tmp.m03 = Math.abs(m4.m04), _m3_tmp.m04 = Math.abs(m4.m05), _m3_tmp.m05 = Math.abs(m4.m06), 
        _m3_tmp.m06 = Math.abs(m4.m08), _m3_tmp.m07 = Math.abs(m4.m09), _m3_tmp.m08 = Math.abs(m4.m10), 
        vec3.transformMat3(out, extent, _m3_tmp);
    }, aabb = function() {
        function aabb() {
            var px = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, py = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, pz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, hw = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, hh = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, hl = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1;
            _classCallCheck(this, aabb), this.center = void 0, this.halfExtents = void 0, this._type = enums.SHAPE_AABB, 
            this.center = vec3.create(px, py, pz), this.halfExtents = vec3.create(hw, hh, hl);
        }
        return _createClass(aabb, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ], [ {
            key: "create",
            value: function create(px, py, pz, hw, hh, hl) {
                return new aabb(px, py, pz, hw, hh, hl);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return vec3.copy(out.center, a.center), vec3.copy(out.halfExtents, a.halfExtents), 
                out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, minPos, maxPos) {
                return vec3.scale(out.center, vec3.add(_v3_tmp$1, minPos, maxPos), .5), vec3.scale(out.halfExtents, vec3.subtract(_v3_tmp2, maxPos, minPos), .5), 
                out;
            }
        }, {
            key: "set",
            value: function set(out, px, py, pz, hw, hh, hl) {
                return vec3.set(out.center, px, py, pz), vec3.set(out.halfExtents, hw, hh, hl), 
                out;
            }
        }, {
            key: "merge",
            value: function merge(out, a, b) {
                return vec3.subtract(_v3_tmp$1, a.center, a.halfExtents), vec3.subtract(_v3_tmp2, b.center, b.halfExtents), 
                vec3.add(_v3_tmp3, a.center, a.halfExtents), vec3.add(_v3_tmp4, b.center, b.halfExtents), 
                vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4), vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2), 
                aabb.fromPoints(out, _v3_tmp3, _v3_tmp4);
            }
        }, {
            key: "transform",
            value: function transform(out, a, matrix) {
                return vec3.transformMat4(out.center, a.center, matrix), transform_extent_m4(out.halfExtents, a.halfExtents, matrix), 
                out;
            }
        } ]), _createClass(aabb, [ {
            key: "getBoundary",
            value: function getBoundary(minPos, maxPos) {
                vec3.subtract(minPos, this.center, this.halfExtents), vec3.add(maxPos, this.center, this.halfExtents);
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                vec3.transformMat4(out.center, this.center, m), transform_extent_m4(out.halfExtents, this.halfExtents, m);
            }
        }, {
            key: "clone",
            value: function clone() {
                return aabb.clone(this);
            }
        }, {
            key: "copy",
            value: function copy(a) {
                return aabb.copy(this, a);
            }
        } ]), aabb;
    }(), _v3_tmp$2 = vec3.create(), _v3_tmp2$1 = vec3.create(), _m3_tmp$1 = mat3.create(), obb = function() {
        function obb() {
            var cx = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, cy = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, cz = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, hw = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1, hh = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1, hl = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1, ox_1 = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 1, ox_2 = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 0, ox_3 = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, oy_1 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0, oy_2 = 10 < arguments.length && void 0 !== arguments[10] ? arguments[10] : 1, oy_3 = 11 < arguments.length && void 0 !== arguments[11] ? arguments[11] : 0, oz_1 = 12 < arguments.length && void 0 !== arguments[12] ? arguments[12] : 0, oz_2 = 13 < arguments.length && void 0 !== arguments[13] ? arguments[13] : 0, oz_3 = 14 < arguments.length && void 0 !== arguments[14] ? arguments[14] : 1;
            _classCallCheck(this, obb), this.center = void 0, this.halfExtents = void 0, this.orientation = void 0, 
            this._type = void 0, this._type = enums.SHAPE_OBB, this.center = vec3.create(cx, cy, cz), 
            this.halfExtents = vec3.create(hw, hh, hl), this.orientation = mat3.create(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
        return _createClass(obb, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ], [ {
            key: "create",
            value: function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
            }
        }, {
            key: "clone",
            value: function clone(a) {
                return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
            }
        }, {
            key: "copy",
            value: function copy(out, a) {
                return vec3.copy(out.center, a.center), vec3.copy(out.halfExtents, a.halfExtents), 
                mat3.copy(out.orientation, a.orientation), out;
            }
        }, {
            key: "fromPoints",
            value: function fromPoints(out, minPos, maxPos) {
                return vec3.scale(out.center, vec3.add(_v3_tmp$2, minPos, maxPos), .5), vec3.scale(out.halfExtents, vec3.subtract(_v3_tmp2$1, maxPos, minPos), .5), 
                mat3.identity(out.orientation), out;
            }
        }, {
            key: "set",
            value: function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return vec3.set(out.center, cx, cy, cz), vec3.set(out.halfExtents, hw, hh, hl), 
                mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3), 
                out;
            }
        } ]), _createClass(obb, [ {
            key: "getBoundary",
            value: function getBoundary(minPos, maxPos) {
                !function transform_extent_m3(out, extent, m3) {
                    _m3_tmp$1.m00 = Math.abs(m3.m00), _m3_tmp$1.m01 = Math.abs(m3.m01), _m3_tmp$1.m02 = Math.abs(m3.m02), 
                    _m3_tmp$1.m03 = Math.abs(m3.m03), _m3_tmp$1.m04 = Math.abs(m3.m04), _m3_tmp$1.m05 = Math.abs(m3.m05), 
                    _m3_tmp$1.m06 = Math.abs(m3.m06), _m3_tmp$1.m07 = Math.abs(m3.m07), _m3_tmp$1.m08 = Math.abs(m3.m08), 
                    vec3.transformMat3(out, extent, _m3_tmp$1);
                }(_v3_tmp$2, this.halfExtents, this.orientation), vec3.subtract(minPos, this.center, _v3_tmp$2), 
                vec3.add(maxPos, this.center, _v3_tmp$2);
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale, out) {
                vec3.transformMat4(out.center, this.center, m), mat3.fromQuat(out.orientation, rot), 
                vec3.multiply(out.halfExtents, this.halfExtents, scale);
            }
        }, {
            key: "translateAndRotate",
            value: function translateAndRotate(m, rot, out) {
                vec3.transformMat4(out.center, this.center, m), mat3.fromQuat(out.orientation, rot);
            }
        }, {
            key: "setScale",
            value: function setScale(scale, out) {
                vec3.multiply(out.halfExtents, this.halfExtents, scale);
            }
        } ]), obb;
    }(), _v = new Array(8);
    _v[0] = vec3.create(1, 1, 1), _v[1] = vec3.create(-1, 1, 1), _v[2] = vec3.create(-1, -1, 1), 
    _v[3] = vec3.create(1, -1, 1), _v[4] = vec3.create(1, 1, -1), _v[5] = vec3.create(-1, 1, -1), 
    _v[6] = vec3.create(-1, -1, -1), _v[7] = vec3.create(1, -1, -1);
    var frustum = function() {
        function frustum() {
            _classCallCheck(this, frustum), this.planes = void 0, this.vertices = void 0, this._type = void 0, 
            this._type = enums.SHAPE_FRUSTUM, this.planes = new Array(6);
            for (var i = 0; i < 6; ++i) this.planes[i] = plane.create(0, 0, 0, 0);
            this.vertices = new Array(8);
            for (var _i2 = 0; _i2 < 8; ++_i2) this.vertices[_i2] = vec3.create();
        }
        return _createClass(frustum, [ {
            key: "accurate",
            set: function set(b) {
                this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
            }
        } ], [ {
            key: "create",
            value: function create() {
                return new frustum();
            }
        }, {
            key: "clone",
            value: function clone(f) {
                return frustum.copy(new frustum(), f);
            }
        }, {
            key: "copy",
            value: function copy(out, f) {
                out._type = f._type;
                for (var i = 0; i < 6; ++i) plane.copy(out.planes[i], f.planes[i]);
                for (var _i = 0; _i < 8; ++_i) vec3.copy(out.vertices[_i], f.vertices[_i]);
                return out;
            }
        } ]), _createClass(frustum, [ {
            key: "update",
            value: function update(m, inv) {
                if (vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08), this.planes[0].d = -(m.m15 + m.m12), 
                vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08), this.planes[1].d = -(m.m15 - m.m12), 
                vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09), this.planes[2].d = -(m.m15 + m.m13), 
                vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09), this.planes[3].d = -(m.m15 - m.m13), 
                vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10), this.planes[4].d = -(m.m15 + m.m14), 
                vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10), this.planes[5].d = -(m.m15 - m.m14), 
                this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                    for (var i = 0; i < 6; i++) {
                        var pl = this.planes[i], invDist = 1 / vec3.magnitude(pl.n);
                        vec3.scale(pl.n, pl.n, invDist), pl.d *= invDist;
                    }
                    for (var _i3 = 0; _i3 < 8; _i3++) vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
                }
            }
        }, {
            key: "transform",
            value: function transform(mat) {
                if (this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                    for (var i = 0; i < 8; i++) vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                    plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]), 
                    plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]), 
                    plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]), 
                    plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]), 
                    plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]), 
                    plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
                }
            }
        } ]), frustum;
    }();
    frustum.createOrtho = function() {
        var _temp_v3 = new Vec3();
        return function(out, width, height, near, far, transform) {
            var halfWidth = width / 2, halfHeight = height / 2;
            vec3.set(_temp_v3, halfWidth, halfHeight, near), vec3.transformMat4(out.vertices[0], _temp_v3, transform), 
            vec3.set(_temp_v3, -halfWidth, halfHeight, near), vec3.transformMat4(out.vertices[1], _temp_v3, transform), 
            vec3.set(_temp_v3, -halfWidth, -halfHeight, near), vec3.transformMat4(out.vertices[2], _temp_v3, transform), 
            vec3.set(_temp_v3, halfWidth, -halfHeight, near), vec3.transformMat4(out.vertices[3], _temp_v3, transform), 
            vec3.set(_temp_v3, halfWidth, halfHeight, far), vec3.transformMat4(out.vertices[4], _temp_v3, transform), 
            vec3.set(_temp_v3, -halfWidth, halfHeight, far), vec3.transformMat4(out.vertices[5], _temp_v3, transform), 
            vec3.set(_temp_v3, -halfWidth, -halfHeight, far), vec3.transformMat4(out.vertices[6], _temp_v3, transform), 
            vec3.set(_temp_v3, halfWidth, -halfHeight, far), vec3.transformMat4(out.vertices[7], _temp_v3, transform), 
            plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]), 
            plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]), 
            plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]), 
            plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]), 
            plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]), 
            plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
        };
    }();
    var CircularPool = function() {
        function CircularPool(fn, size) {
            _classCallCheck(this, CircularPool), this._cursor = void 0, this._data = void 0, 
            this._cursor = 0, this._data = new Array(size);
            for (var i = 0; i < size; ++i) this._data[i] = fn();
        }
        return _createClass(CircularPool, [ {
            key: "request",
            value: function request() {
                var item = this._data[this._cursor];
                return this._cursor = (this._cursor + 1) % this._data.length, item;
            }
        } ]), CircularPool;
    }(), DEFAULT_MIN_MERGE = 32, POWERS_OF_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];
    function log10$1(x) {
        return x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
    }
    function alphabeticalCompare(a, b) {
        if (a === b) return 0;
        if (~~a === a && ~~b === b) {
            if (0 === a || 0 === b) return a < b ? -1 : 1;
            if (a < 0 || b < 0) {
                if (0 <= b) return -1;
                if (0 <= a) return 1;
                a = -a, b = -b;
            }
            var al = log10$1(a), bl = log10$1(b), t = 0;
            return al < bl ? (a *= POWERS_OF_TEN[bl - al - 1], b /= 10, t = -1) : bl < al && (b *= POWERS_OF_TEN[al - bl - 1], 
            a /= 10, t = 1), a === b ? t : a < b ? -1 : 1;
        }
        var aStr = String(a), bStr = String(b);
        return aStr === bStr ? 0 : aStr < bStr ? -1 : 1;
    }
    function makeAscendingRun(array, lo, hi, compare) {
        var runHi = lo + 1;
        if (runHi === hi) return 1;
        if (compare(array[runHi++], array[lo]) < 0) {
            for (;runHi < hi && compare(array[runHi], array[runHi - 1]) < 0; ) runHi++;
            !function reverseRun(array, lo, hi) {
                hi--;
                for (;lo < hi; ) {
                    var t = array[lo];
                    array[lo++] = array[hi], array[hi--] = t;
                }
            }(array, lo, runHi);
        } else for (;runHi < hi && 0 <= compare(array[runHi], array[runHi - 1]); ) runHi++;
        return runHi - lo;
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
        for (start === lo && start++; start < hi; start++) {
            for (var pivot = array[start], left = lo, right = start; left < right; ) {
                var mid = left + right >>> 1;
                compare(pivot, array[mid]) < 0 ? right = mid : left = mid + 1;
            }
            var n = start - left;
            switch (n) {
              case 3:
                array[left + 3] = array[left + 2];

              case 2:
                array[left + 2] = array[left + 1];

              case 1:
                array[left + 1] = array[left];
                break;

              default:
                for (;0 < n; ) array[left + n] = array[left + n - 1], n--;
            }
            array[left] = pivot;
        }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
        var lastOffset = 0, maxOffset = 0, offset = 1;
        if (0 < compare(value, array[start + hint])) {
            for (maxOffset = length - hint; offset < maxOffset && 0 < compare(value, array[start + hint + offset]); ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
            maxOffset < offset && (offset = maxOffset), lastOffset += hint, offset += hint;
        } else {
            for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) <= 0; ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
            maxOffset < offset && (offset = maxOffset);
            var tmp = lastOffset;
            lastOffset = hint - offset, offset = hint - tmp;
        }
        for (lastOffset++; lastOffset < offset; ) {
            var m = lastOffset + (offset - lastOffset >>> 1);
            0 < compare(value, array[start + m]) ? lastOffset = m + 1 : offset = m;
        }
        return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
        var lastOffset = 0, maxOffset = 0, offset = 1;
        if (compare(value, array[start + hint]) < 0) {
            for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) < 0; ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
            maxOffset < offset && (offset = maxOffset);
            var tmp = lastOffset;
            lastOffset = hint - offset, offset = hint - tmp;
        } else {
            for (maxOffset = length - hint; offset < maxOffset && 0 <= compare(value, array[start + hint + offset]); ) (offset = 1 + ((lastOffset = offset) << 1)) <= 0 && (offset = maxOffset);
            maxOffset < offset && (offset = maxOffset), lastOffset += hint, offset += hint;
        }
        for (lastOffset++; lastOffset < offset; ) {
            var m = lastOffset + (offset - lastOffset >>> 1);
            compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
        }
        return offset;
    }
    var TimSort = function() {
        function TimSort(array, compare) {
            _classCallCheck(this, TimSort), this.array = void 0, this.compare = void 0, this.minGallop = void 0, 
            this.length = void 0, this.tmpStorageLength = void 0, this.tmp = void 0, this.stackLength = void 0, 
            this.runStart = void 0, this.runLength = void 0, this.stackSize = void 0, this.array = array, 
            this.compare = compare, this.minGallop = 7, this.length = array.length, this.tmpStorageLength = 256, 
            this.length < 512 && (this.tmpStorageLength = this.length >>> 1), this.tmp = new Array(this.tmpStorageLength), 
            this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40, 
            this.runStart = new Array(this.stackLength), this.runLength = new Array(this.stackLength), 
            this.stackSize = 0;
        }
        return _createClass(TimSort, [ {
            key: "pushRun",
            value: function pushRun(runStart, runLength) {
                this.runStart[this.stackSize] = runStart, this.runLength[this.stackSize] = runLength, 
                this.stackSize += 1;
            }
        }, {
            key: "mergeRuns",
            value: function mergeRuns() {
                for (;1 < this.stackSize; ) {
                    var n = this.stackSize - 2;
                    if (1 <= n && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || 2 <= n && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) this.runLength[n - 1] < this.runLength[n + 1] && n--; else if (this.runLength[n] > this.runLength[n + 1]) break;
                    this.mergeAt(n);
                }
            }
        }, {
            key: "forceMergeRuns",
            value: function forceMergeRuns() {
                for (;1 < this.stackSize; ) {
                    var n = this.stackSize - 2;
                    0 < n && this.runLength[n - 1] < this.runLength[n + 1] && n--, this.mergeAt(n);
                }
            }
        }, {
            key: "mergeAt",
            value: function mergeAt(i) {
                var compare = this.compare, array = this.array, start1 = this.runStart[i], length1 = this.runLength[i], start2 = this.runStart[i + 1], length2 = this.runLength[i + 1];
                this.runLength[i] = length1 + length2, i === this.stackSize - 3 && (this.runStart[i + 1] = this.runStart[i + 2], 
                this.runLength[i + 1] = this.runLength[i + 2]), this.stackSize--;
                var k = gallopRight(array[start2], array, start1, length1, 0, compare);
                start1 += k, 0 !== (length1 -= k) && 0 !== (length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)) && (length1 <= length2 ? this.mergeLow(start1, length1, start2, length2) : this.mergeHigh(start1, length1, start2, length2));
            }
        }, {
            key: "mergeLow",
            value: function mergeLow(start1, length1, start2, length2) {
                var compare = this.compare, array = this.array, tmp = this.tmp, i = 0;
                for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
                var cursor1 = 0, cursor2 = start2, dest = start1;
                if (array[dest++] = array[cursor2++], 0 != --length2) if (1 !== length1) {
                    for (var minGallop = this.minGallop; ;) {
                        var count1 = 0, count2 = 0, exit = !1;
                        do {
                            if (compare(array[cursor2], tmp[cursor1]) < 0) {
                                if (array[dest++] = array[cursor2++], count2++, (count1 = 0) == --length2) {
                                    exit = !0;
                                    break;
                                }
                            } else if (array[dest++] = tmp[cursor1++], count1++, count2 = 0, 1 == --length1) {
                                exit = !0;
                                break;
                            }
                        } while ((count1 | count2) < minGallop);
                        if (exit) break;
                        do {
                            if (0 !== (count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare))) {
                                for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
                                if (dest += count1, cursor1 += count1, (length1 -= count1) <= 1) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest++] = array[cursor2++], 0 == --length2) {
                                exit = !0;
                                break;
                            }
                            if (0 !== (count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare))) {
                                for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
                                if (dest += count2, cursor2 += count2, 0 === (length2 -= count2)) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest++] = tmp[cursor1++], 1 == --length1) {
                                exit = !0;
                                break;
                            }
                            minGallop--;
                        } while (7 <= count1 || 7 <= count2);
                        if (exit) break;
                        minGallop < 0 && (minGallop = 0), minGallop += 2;
                    }
                    if ((this.minGallop = minGallop) < 1 && (this.minGallop = 1), 1 === length1) {
                        for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                        array[dest + length2] = tmp[cursor1];
                    } else {
                        if (0 === length1) throw new Error("mergeLow preconditions were not respected");
                        for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
                    }
                } else {
                    for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                    array[dest + length2] = tmp[cursor1];
                } else for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
            }
        }, {
            key: "mergeHigh",
            value: function mergeHigh(start1, length1, start2, length2) {
                var compare = this.compare, array = this.array, tmp = this.tmp, i = 0;
                for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
                var cursor1 = start1 + length1 - 1, cursor2 = length2 - 1, dest = start2 + length2 - 1, customCursor = 0, customDest = 0;
                if (array[dest--] = array[cursor1--], 0 != --length1) if (1 !== length2) {
                    for (var minGallop = this.minGallop; ;) {
                        var count1 = 0, count2 = 0, exit = !1;
                        do {
                            if (compare(tmp[cursor2], array[cursor1]) < 0) {
                                if (array[dest--] = array[cursor1--], count1++, (count2 = 0) == --length1) {
                                    exit = !0;
                                    break;
                                }
                            } else if (array[dest--] = tmp[cursor2--], count2++, count1 = 0, 1 == --length2) {
                                exit = !0;
                                break;
                            }
                        } while ((count1 | count2) < minGallop);
                        if (exit) break;
                        do {
                            if (0 !== (count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare))) {
                                for (length1 -= count1, customDest = (dest -= count1) + 1, customCursor = (cursor1 -= count1) + 1, 
                                i = count1 - 1; 0 <= i; i--) array[customDest + i] = array[customCursor + i];
                                if (0 === length1) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest--] = tmp[cursor2--], 1 == --length2) {
                                exit = !0;
                                break;
                            }
                            if (0 !== (count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare))) {
                                for (length2 -= count2, customDest = (dest -= count2) + 1, customCursor = (cursor2 -= count2) + 1, 
                                i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
                                if (length2 <= 1) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest--] = array[cursor1--], 0 == --length1) {
                                exit = !0;
                                break;
                            }
                            minGallop--;
                        } while (7 <= count1 || 7 <= count2);
                        if (exit) break;
                        minGallop < 0 && (minGallop = 0), minGallop += 2;
                    }
                    if ((this.minGallop = minGallop) < 1 && (this.minGallop = 1), 1 === length2) {
                        for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                        i = length1 - 1; 0 <= i; i--) array[customDest + i] = array[customCursor + i];
                        array[dest] = tmp[cursor2];
                    } else {
                        if (0 === length2) throw new Error("mergeHigh preconditions were not respected");
                        for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
                    }
                } else {
                    for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                    i = length1 - 1; 0 <= i; i--) array[customDest + i] = array[customCursor + i];
                    array[dest] = tmp[cursor2];
                } else for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
            }
        } ]), TimSort;
    }();
    function _sort(array, lo, hi, compare) {
        if (!Array.isArray(array)) throw new TypeError("Can only sort arrays");
        void 0 === lo && (lo = 0), void 0 === hi && (hi = array.length), void 0 === compare && (compare = alphabeticalCompare);
        var remaining = hi - lo;
        if (!(remaining < 2)) {
            var runLength = 0;
            if (remaining < DEFAULT_MIN_MERGE) binaryInsertionSort(array, lo, hi, lo + (runLength = makeAscendingRun(array, lo, hi, compare)), compare); else {
                var ts = new TimSort(array, compare), minRun = function minRunLength(n) {
                    for (var r = 0; DEFAULT_MIN_MERGE <= n; ) r |= 1 & n, n >>= 1;
                    return n + r;
                }(remaining);
                do {
                    if ((runLength = makeAscendingRun(array, lo, hi, compare)) < minRun) {
                        var force = remaining;
                        minRun < force && (force = minRun), binaryInsertionSort(array, lo, lo + force, lo + runLength, compare), 
                        runLength = force;
                    }
                    ts.pushRun(lo, runLength), ts.mergeRuns(), remaining -= runLength, lo += runLength;
                } while (0 !== remaining);
                ts.forceMergeRuns();
            }
        }
    }
    for (var FixedArray = function() {
        function FixedArray(size) {
            _classCallCheck(this, FixedArray), this._count = void 0, this._data = void 0, this._count = 0, 
            this._data = new Array(size);
        }
        return _createClass(FixedArray, [ {
            key: "_resize",
            value: function _resize(size) {
                if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = void 0;
            }
        }, {
            key: "reset",
            value: function reset() {
                for (var i = 0; i < this._count; ++i) this._data[i] = void 0;
                this._count = 0;
            }
        }, {
            key: "push",
            value: function push(val) {
                this._count >= this._data.length && this._resize(2 * this._data.length), this._data[this._count] = val, 
                ++this._count;
            }
        }, {
            key: "pop",
            value: function pop() {
                --this._count, this._count < 0 && (this._count = 0);
                var ret = this._data[this._count];
                return this._data[this._count] = void 0, ret;
            }
        }, {
            key: "fastRemove",
            value: function fastRemove(idx) {
                if (!(idx >= this._count || idx < 0)) {
                    var last = this._count - 1;
                    this._data[idx] = this._data[last], this._data[last] = void 0, this._count -= 1;
                }
            }
        }, {
            key: "indexOf",
            value: function indexOf(val) {
                return this._data.indexOf(val);
            }
        }, {
            key: "sort",
            value: function sort(cmp) {
                return _sort(this._data, 0, this._count, cmp);
            }
        }, {
            key: "length",
            get: function get() {
                return this._count;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        } ]), FixedArray;
    }(), LinkedArray = function() {
        function LinkedArray(fn, size) {
            _classCallCheck(this, LinkedArray), this._fn = void 0, this._count = void 0, this._head = void 0, 
            this._tail = void 0, this._pool = void 0, this._fn = fn, this._count = 0, this._head = null, 
            this._tail = null, this._pool = new Pool$1(fn, size);
        }
        return _createClass(LinkedArray, [ {
            key: "add",
            value: function add() {
                var node = this._pool.alloc();
                return this._tail ? (this._tail._next = node)._prev = this._tail : this._head = node, 
                this._tail = node, this._count += 1, node;
            }
        }, {
            key: "remove",
            value: function remove(node) {
                node._prev ? node._prev._next = node._next : this._head = node._next, node._next ? node._next._prev = node._prev : this._tail = node._prev, 
                node._next = null, node._prev = null, this._pool.free(node), this._count -= 1;
            }
        }, {
            key: "forEach",
            value: function forEach(fn, binder) {
                var cursor = this._head;
                if (cursor) {
                    binder && (fn = fn.bind(binder));
                    for (var idx = 0, next = cursor; cursor; ) next = cursor._next, fn(cursor, idx, this), 
                    cursor = next, ++idx;
                }
            }
        }, {
            key: "head",
            get: function get() {
                return this._head;
            }
        }, {
            key: "tail",
            get: function get() {
                return this._tail;
            }
        }, {
            key: "length",
            get: function get() {
                return this._count;
            }
        } ]), LinkedArray;
    }(), RecyclePool = function() {
        function RecyclePool(fn, size) {
            _classCallCheck(this, RecyclePool), this._fn = void 0, this._count = 0, this._data = void 0, 
            this._fn = fn, this._data = new Array(size);
            for (var i = 0; i < size; ++i) this._data[i] = fn();
        }
        return _createClass(RecyclePool, [ {
            key: "reset",
            value: function reset() {
                this._count = 0;
            }
        }, {
            key: "resize",
            value: function resize(size) {
                if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
            }
        }, {
            key: "add",
            value: function add() {
                return this._count >= this._data.length && this.resize(2 * this._data.length), this._data[this._count++];
            }
        }, {
            key: "removeAt",
            value: function removeAt(idx) {
                if (!(idx >= this._count)) {
                    var last = this._count - 1, tmp = this._data[idx];
                    this._data[idx] = this._data[last], this._data[last] = tmp, this._count -= 1;
                }
            }
        }, {
            key: "sort",
            value: function sort(compare) {
                return _sort(this._data, 0, this._count, compare);
            }
        }, {
            key: "length",
            get: function get() {
                return this._count;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        } ]), RecyclePool;
    }(), _bufferPools = Array(8), i$1 = 0; i$1 < 8; ++i$1) _bufferPools[i$1] = [];
    function _log2(v) {
        var r = (65535 < v) << 4, shift = (255 < (v >>>= r)) << 3;
        return r |= shift, r |= shift = (15 < (v >>>= shift)) << 2, (r |= shift = (3 < (v >>>= shift)) << 1) | (v >>>= shift) >> 1;
    }
    function _alloc(n) {
        var sz = function _nextPow16(v) {
            for (var _i = 16; _i <= 1 << 28; _i *= 16) if (v <= _i) return _i;
            return 0;
        }(n), bin = _bufferPools[_log2(sz) >> 2];
        return 0 < bin.length ? bin.pop() : new ArrayBuffer(sz);
    }
    var typedArrayPool = {
        alloc_int8: function alloc_int8(n) {
            var result = new Int8Array(_alloc(n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_uint8: function alloc_uint8(n) {
            var result = new Uint8Array(_alloc(n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_int16: function alloc_int16(n) {
            var result = new Int16Array(_alloc(2 * n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_uint16: function alloc_uint16(n) {
            var result = new Uint16Array(_alloc(2 * n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_int32: function alloc_int32(n) {
            var result = new Int32Array(_alloc(4 * n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_uint32: function alloc_uint32(n) {
            var result = new Uint32Array(_alloc(4 * n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_float32: function alloc_float32(n) {
            var result = new Float32Array(_alloc(4 * n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        alloc_float64: function alloc_float64(n) {
            var result = new Float64Array(_alloc(8 * n), 0, n);
            return result.length !== n ? result.subarray(0, n) : result;
        },
        free: function free(array) {
            !function _free(buf) {
                _bufferPools[_log2(buf.byteLength) >> 2].push(buf);
            }(array.buffer);
        },
        reset: function reset() {
            _bufferPools = Array(8);
            for (var _i2 = 0; _i2 < 8; ++_i2) _bufferPools[_i2] = [];
        }
    }, mul = function mul(out, v, x, y, z) {
        return vec3.set(out, v.x * x, v.y * y, v.z * z);
    }, OctreeBlock = function() {
        function OctreeBlock(minPos, maxPos, capacity, depth, maxDepth, getBoundingShape) {
            _classCallCheck(this, OctreeBlock), this.minPos = void 0, this.maxPos = void 0, 
            this.boundingBox = void 0, this.capacity = void 0, this.depth = void 0, this.maxDepth = void 0, 
            this.blocks = void 0, this.entries = void 0, this._getBoundingShape = void 0, this.minPos = minPos, 
            this.maxPos = maxPos, this.boundingBox = aabb.fromPoints(aabb.create(), minPos, maxPos), 
            this.capacity = capacity, this.depth = depth, this.maxDepth = maxDepth, this._getBoundingShape = getBoundingShape, 
            this.blocks = null, this.entries = new FixedArray(this.capacity);
        }
        return _createClass(OctreeBlock, [ {
            key: "addEntry",
            value: function addEntry(entry) {
                if (this.blocks) {
                    var _iterator = this.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.addEntry(entry);
                    }
                } else {
                    var shape = this._getBoundingShape(entry);
                    if (!intersect.resolve(this.boundingBox, shape)) return;
                    this.entries.push(entry), this.entries.length >= this.capacity && this.depth < this.maxDepth && (this.blocks = Octree.createBlocks(this.minPos, this.maxPos, this.entries, this.capacity, this.depth, this.maxDepth, this._getBoundingShape), 
                    this.entries.reset());
                }
            }
        }, {
            key: "removeEntry",
            value: function removeEntry(entry) {
                if (this.blocks) {
                    var _iterator2 = this.blocks, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        _ref2.removeEntry(entry);
                    }
                } else this.entries.fastRemove(this.entries.indexOf(entry));
            }
        }, {
            key: "select",
            value: function select(out, shape) {
                if (intersect.resolve(this.boundingBox, shape)) if (this.blocks) {
                    var _iterator3 = this.blocks, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        _ref3.select(out, shape);
                    }
                } else for (var i = 0; i < this.entries.length; i++) out.add(this.entries.data[i]);
            }
        }, {
            key: "frustumSelect",
            value: function frustumSelect(out, frustum) {
                if (intersect.aabb_frustum(this.boundingBox, frustum)) if (this.blocks) {
                    var _iterator4 = this.blocks, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        _ref4.frustumSelect(out, frustum);
                    }
                } else for (var i = 0; i < this.entries.length; i++) out.add(this.entries.data[i]);
            }
        } ]), OctreeBlock;
    }(), Octree = function() {
        function Octree() {
            var _this = this, blockCapacity = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 32, maxDepth = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 5;
            _classCallCheck(this, Octree), this.blockCapacity = void 0, this.maxDepth = void 0, 
            this.blocks = void 0, this.dynamics = void 0, this._selection = void 0, this._getBoundingShape = void 0, 
            this.blockCapacity = blockCapacity, this.maxDepth = maxDepth, this.blocks = [], 
            this.dynamics = [], this._selection = new Set(), this._getBoundingShape = function() {
                return _this._getBoundingShape;
            };
        }
        return _createClass(Octree, null, [ {
            key: "createBlocks",
            value: function createBlocks(worldMin, worldMax, entries, blockCapacity, curDepth, maxDepth, getBoundingShape) {
                var blocks = [], blockSize = vec3.create();
                vec3.scale(blockSize, vec3.subtract(blockSize, worldMax, worldMin), .5);
                for (var x = 0; x < 2; x++) for (var y = 0; y < 2; y++) for (var z = 0; z < 2; z++) {
                    var localMin = vec3.create(), localMax = vec3.create();
                    vec3.add(localMin, worldMin, mul(localMin, blockSize, x, y, z)), vec3.add(localMax, worldMin, mul(localMax, blockSize, x + 1, y + 1, z + 1));
                    for (var block = new OctreeBlock(localMin, localMax, blockCapacity, curDepth + 1, maxDepth, getBoundingShape), i = 0; i < entries.length; i++) {
                        var entry = (entries.data || entries)[i];
                        block.addEntry(entry);
                    }
                    blocks.push(block);
                }
                return blocks;
            }
        } ]), _createClass(Octree, [ {
            key: "build",
            value: function build(entries, getBoundingShape) {
                var worldMin = vec3.create(1 / 0, 1 / 0, 1 / 0), worldMax = vec3.create(-1 / 0, -1 / 0, -1 / 0), minPos = vec3.create(), maxPos = vec3.create(), staticEntries = [];
                this.dynamics = [];
                for (var i = 0; i < entries.length; i++) {
                    var entry = (entries.data || entries)[i], shape = getBoundingShape(entry);
                    shape ? (shape.getBoundary(minPos, maxPos), vec3.min(worldMin, worldMin, minPos), 
                    vec3.max(worldMax, worldMax, maxPos), staticEntries.push(entry)) : this.dynamics.push(entry);
                }
                this.blocks = Octree.createBlocks(worldMin, worldMax, staticEntries, this.blockCapacity, 0, this.maxDepth, getBoundingShape), 
                this._getBoundingShape = getBoundingShape;
            }
        }, {
            key: "addEntry",
            value: function addEntry(entry) {
                if (this._getBoundingShape(entry).shape) {
                    var _iterator5 = this.blocks, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        _ref5.addEntry(entry);
                    }
                } else this.dynamics.push(entry);
            }
        }, {
            key: "removeEntry",
            value: function removeEntry(entry) {
                if (this._getBoundingShape(entry).shape) {
                    var _iterator6 = this.blocks, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray6) {
                            if (_i6 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i6++];
                        } else {
                            if ((_i6 = _iterator6.next()).done) break;
                            _ref6 = _i6.value;
                        }
                        _ref6.removeEntry(entry);
                    }
                } else this.dynamics.splice(this.dynamics.indexOf(entry), 1);
            }
        }, {
            key: "select",
            value: function select(shape) {
                this._selection.clear();
                var _iterator7 = this.blocks, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) break;
                        _ref7 = _i7.value;
                    }
                    _ref7.select(this._selection, shape);
                }
                var _iterator8 = this.dynamics, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i8 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i8++];
                    } else {
                        if ((_i8 = _iterator8.next()).done) break;
                        _ref8 = _i8.value;
                    }
                    var dynamic = _ref8;
                    this._selection.add(dynamic);
                }
                return this._selection;
            }
        }, {
            key: "frustumSelect",
            value: function frustumSelect(frustum) {
                this._selection.clear();
                var _iterator9 = this.blocks, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i9 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i9++];
                    } else {
                        if ((_i9 = _iterator9.next()).done) break;
                        _ref9 = _i9.value;
                    }
                    _ref9.frustumSelect(this._selection, frustum);
                }
                var _iterator10 = this.dynamics, _isArray10 = Array.isArray(_iterator10), _i10 = 0;
                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                    var _ref10;
                    if (_isArray10) {
                        if (_i10 >= _iterator10.length) break;
                        _ref10 = _iterator10[_i10++];
                    } else {
                        if ((_i10 = _iterator10.next()).done) break;
                        _ref10 = _i10.value;
                    }
                    var dynamic = _ref10;
                    this._selection.add(dynamic);
                }
                return this._selection;
            }
        } ]), Octree;
    }(), WrapMode$1 = Enum({
        Default: 0,
        Once: 1,
        Loop: 2,
        PingPong: 3,
        ClampForever: 4
    }), Keyframe = function Keyframe() {
        _classCallCheck(this, Keyframe), this.time = 0, this.value = 0, this.inTangent = 0, 
        this.outTangent = 0;
    };
    CCClass.fastDefine("cc.Keyframe", Keyframe, {
        time: 0,
        value: 0,
        inTangent: 0,
        outTangent: 0
    });
    var OptimizedKey = function() {
        function OptimizedKey() {
            _classCallCheck(this, OptimizedKey), this.index = void 0, this.time = void 0, this.endTime = void 0, 
            this.coefficient = void 0, this.index = -1, this.time = 0, this.endTime = 0, this.coefficient = new Float32Array(4);
        }
        return _createClass(OptimizedKey, [ {
            key: "evaluate",
            value: function evaluate(T) {
                return function evalOptCurve(t, coefs) {
                    return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
                }(T - this.time, this.coefficient);
            }
        } ]), OptimizedKey;
    }();
    var AnimationCurve = function() {
        function AnimationCurve() {
            var keyFrames = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null;
            _classCallCheck(this, AnimationCurve), this.keyFrames = void 0, this.preWrapMode = WrapMode$1.Loop, 
            this.postWrapMode = WrapMode$1.Loop, this.cachedKey = void 0, this.keyFrames = keyFrames || [].concat(AnimationCurve.defaultKF), 
            this.cachedKey = new OptimizedKey();
        }
        return _createClass(AnimationCurve, [ {
            key: "addKey",
            value: function addKey(keyFrame) {
                null == this.keyFrames && (this.keyFrames = []), this.keyFrames.push(keyFrame);
            }
        }, {
            key: "evaluate_slow",
            value: function evaluate_slow(time) {
                var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
                switch (wrapMode) {
                  case WrapMode$1.Loop:
                    wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode$1.PingPong:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode$1.ClampForever:
                    wrappedTime = clamp(time, startTime, endTime);
                }
                var preKFIndex = 0;
                if (wrappedTime > this.keyFrames[0].time) if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) preKFIndex = this.keyFrames.length - 2; else for (var i = 0; i < this.keyFrames.length - 1; i++) if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
                    preKFIndex = i;
                    break;
                }
                var keyframe0 = this.keyFrames[preKFIndex], keyframe1 = this.keyFrames[preKFIndex + 1], t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime), dt = keyframe1.time - keyframe0.time, m0 = keyframe0.outTangent * dt, m1 = keyframe1.inTangent * dt, t2 = t * t, t3 = t2 * t, b = t3 - 2 * t2 + t, c = t3 - t2, d = -2 * t3 + 3 * t2;
                return (2 * t3 - 3 * t2 + 1) * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
            }
        }, {
            key: "evaluate",
            value: function evaluate(time) {
                var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
                switch (wrapMode) {
                  case WrapMode$1.Loop:
                    wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode$1.PingPong:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;

                  case WrapMode$1.ClampForever:
                    wrappedTime = clamp(time, startTime, endTime);
                }
                if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) return this.cachedKey.evaluate(wrappedTime);
                var leftIndex = this.findIndex(this.cachedKey, wrappedTime), rightIndex = leftIndex + 1;
                return rightIndex === this.keyFrames.length && (rightIndex -= 1), this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex), 
                this.cachedKey.evaluate(wrappedTime);
            }
        }, {
            key: "calcOptimizedKey",
            value: function calcOptimizedKey(optKey, leftIndex, rightIndex) {
                var lhs = this.keyFrames[leftIndex], rhs = this.keyFrames[rightIndex];
                optKey.index = leftIndex, optKey.time = lhs.time, optKey.endTime = rhs.time;
                var dx = rhs.time - lhs.time, dy = rhs.value - lhs.value, length = 1 / (dx * dx), d1 = lhs.outTangent * dx, d2 = rhs.inTangent * dx;
                optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx, optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length, 
                optKey.coefficient[2] = lhs.outTangent, optKey.coefficient[3] = lhs.value;
            }
        }, {
            key: "findIndex",
            value: function findIndex(optKey, t) {
                var cachedIndex = optKey.index;
                if (-1 !== cachedIndex) if (this.keyFrames[cachedIndex].time < t) for (var i = 0; i < 3; i++) {
                    var currIndex = cachedIndex + i;
                    if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) return currIndex;
                } else for (var _i = 0; _i < 3; _i++) {
                    var _currIndex = cachedIndex - _i;
                    if (0 <= _currIndex && this.keyFrames[_currIndex - 1].time <= t) return _currIndex - 1;
                }
                for (var left = 0, right = this.keyFrames.length, mid = Math.floor((left + right) / 2); 1 < right - left; ) this.keyFrames[mid].time >= t ? right = mid : left = mid + 1, 
                mid = Math.floor((left + right) / 2);
                return left;
            }
        } ]), AnimationCurve;
    }();
    AnimationCurve.defaultKF = [ {
        time: 0,
        value: 1,
        inTangent: 0,
        outTangent: 0
    }, {
        time: 1,
        value: 1,
        inTangent: 0,
        outTangent: 0
    } ], CCClass.fastDefine("cc.AnimationCurve", AnimationCurve, {
        preWrapMode: WrapMode$1.Default,
        postWrapMode: WrapMode$1.Default,
        keyFrames: []
    });
    var geometry = Object.freeze({
        distance: distance,
        enums: enums,
        intersect: intersect,
        line: line,
        plane: plane,
        ray: ray,
        triangle: triangle,
        sphere: sphere,
        aabb: aabb,
        obb: obb,
        frustum: frustum,
        Octree: Octree,
        Keyframe: Keyframe,
        AnimationCurve: AnimationCurve
    }), SubModel = function() {
        function SubModel() {
            _classCallCheck(this, SubModel), this._subMeshObject = void 0, this._inputAssembler = void 0, 
            this._material = void 0, this._cmdBuffers = void 0, this._psos = void 0, this._castShadow = void 0, 
            this._priority = void 0, this._subMeshObject = null, this._material = null, this._cmdBuffers = new Array(), 
            this._psos = null, this._castShadow = !1, this._inputAssembler = null, this._priority = RenderPriority.DEFAULT;
        }
        return _createClass(SubModel, [ {
            key: "initialize",
            value: function initialize(subMesh, mat, psos) {
                this._psos = psos, this.subMeshData = subMesh, this.material = mat;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._inputAssembler && this._inputAssembler.destroy();
                for (var i = 0; i < this.passes.length; i++) this.passes[i].destroyPipelineState(this._psos[i]);
                var _iterator = this._cmdBuffers, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.destroy();
                }
                this._cmdBuffers.splice(0), this._material = null;
            }
        }, {
            key: "updateCommandBuffer",
            value: function updateCommandBuffer() {
                if (this._material) {
                    for (var i = 0; i < this._material.passes.length; i++) this._subMeshObject && this._material.passes[i].primitive !== this._subMeshObject.primitiveMode && console.warn("mesh primitive type doesn't match with pass settings"), 
                    this.recordCommandBuffer(i);
                    for (var _i2 = this._cmdBuffers.length - 1; _i2 >= this._material.passes.length; _i2--) {
                        var cmdBuff = this._cmdBuffers.pop();
                        cmdBuff && cmdBuff.destroy();
                    }
                }
            }
        }, {
            key: "recordCommandBuffer",
            value: function recordCommandBuffer(index) {
                var device = cc.director.root.device, pso = this._psos[index];
                if (null == this._cmdBuffers[index]) {
                    var cmdBufferInfo = {
                        allocator: device.commandAllocator,
                        type: GFXCommandBufferType.SECONDARY
                    };
                    this._cmdBuffers[index] = device.createCommandBuffer(cmdBufferInfo);
                } else this._cmdBuffers[index].status === GFXStatus.UNREADY && this._cmdBuffers[index].initialize({
                    allocator: device.commandAllocator,
                    type: GFXCommandBufferType.SECONDARY
                });
                var inputAssembler = this._inputAssembler, cmdBuff = this._cmdBuffers[index];
                cmdBuff.begin(), cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                cmdBuff.bindInputAssembler(inputAssembler), cmdBuff.draw(inputAssembler), cmdBuff.end();
            }
        }, {
            key: "priority",
            set: function set(val) {
                this._priority = val;
            },
            get: function get() {
                return this._priority;
            }
        }, {
            key: "subMeshData",
            set: function set(sm) {
                this._inputAssembler && this._inputAssembler.destroy(), this._subMeshObject = sm;
                var iaInfo = {};
                iaInfo.attributes = this._subMeshObject.attributes, iaInfo.vertexBuffers = this._subMeshObject.vertexBuffers, 
                this._subMeshObject.indexBuffer && (iaInfo.indexBuffer = this._subMeshObject.indexBuffer), 
                this._subMeshObject.indirectBuffer && (iaInfo.indirectBuffer = this._subMeshObject.indirectBuffer), 
                this._inputAssembler ? this._inputAssembler.initialize(iaInfo) : this._inputAssembler = cc.director.root.device.createInputAssembler(iaInfo);
            },
            get: function get() {
                return this._subMeshObject;
            }
        }, {
            key: "psos",
            get: function get() {
                return this._psos;
            },
            set: function set(val) {
                this._psos = val;
            }
        }, {
            key: "material",
            set: function set(material) {
                null != (this._material = material) && this.updateCommandBuffer();
            },
            get: function get() {
                return this._material;
            }
        }, {
            key: "inputAssembler",
            get: function get() {
                return this._inputAssembler;
            }
        }, {
            key: "castShadow",
            get: function get() {
                return this._castShadow;
            },
            set: function set(val) {
                this._castShadow = val;
            }
        }, {
            key: "passes",
            get: function get() {
                return this._material.passes;
            }
        }, {
            key: "commandBuffers",
            get: function get() {
                return this._cmdBuffers;
            }
        } ]), SubModel;
    }(), f32_1 = new Float32Array(16), m4_1 = mat4.create(), _subMeshPool = new Pool$1(function() {
        return new SubModel();
    }, 32);
    function getUniformBlockSize(block) {
        var size = 0, _iterator = block.members, _isArray = Array.isArray(_iterator), _i = 0;
        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                if ((_i = _iterator.next()).done) break;
                _ref = _i.value;
            }
            var mem = _ref;
            size += GFXGetTypeSize(mem.type) * mem.count;
        }
        return size;
    }
    var _class$p, _class2$i, _descriptor$g, _class3$a, _temp$m, FaceIndex, Model = function() {
        function Model(scene, node) {
            _classCallCheck(this, Model), this._type = "default", this._device = void 0, this._scene = void 0, 
            this._node = void 0, this._transform = void 0, this._id = void 0, this._enabled = !1, 
            this._viewID = 1, this._cameraID = -1, this._userKey = -1, this._worldBounds = null, 
            this._modelBounds = null, this._subModels = [], this._matPSORecord = void 0, this._matRefCount = void 0, 
            this._uboLocal = void 0, this._localUBO = void 0, this._localBindings = new Map(), 
            this._inited = void 0, this._uboUpdated = void 0, this._device = cc.director.root.device, 
            this._scene = scene, this._id = this._scene.generateModelId(), this._transform = this._node = node, 
            this._matPSORecord = new Map(), this._matRefCount = new Map(), this._uboLocal = new UBOLocal(), 
            this._localUBO = null, this._inited = !1, this._uboUpdated = !1;
        }
        return _createClass(Model, [ {
            key: "scene",
            set: function set(scene) {
                this._scene = scene, this._id = this._scene.generateModelId();
            },
            get: function get() {
                return this._scene;
            }
        }, {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "subModelNum",
            get: function get() {
                return this._subModels.length;
            }
        }, {
            key: "inited",
            get: function get() {
                return this._inited;
            }
        }, {
            key: "enabled",
            set: function set(val) {
                this._enabled = val;
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "node",
            get: function get() {
                return this._node;
            },
            set: function set(node) {
                this._node = node;
            }
        }, {
            key: "transform",
            get: function get() {
                return this._transform;
            },
            set: function set(transform) {
                this._transform = transform;
            }
        }, {
            key: "worldBounds",
            get: function get() {
                return this._worldBounds;
            }
        }, {
            key: "modelBounds",
            get: function get() {
                return this._modelBounds;
            }
        }, {
            key: "viewID",
            get: function get() {
                return this._viewID;
            },
            set: function set(id) {
                this._viewID = id;
            }
        }, {
            key: "userKey",
            set: function set(key) {
                this._userKey = key;
            }
        }, {
            key: "uboLocal",
            get: function get() {
                return this._uboLocal;
            }
        }, {
            key: "localUBO",
            get: function get() {
                return this._localUBO;
            }
        }, {
            key: "localBindings",
            get: function get() {
                return this._localBindings;
            }
        } ]), _createClass(Model, [ {
            key: "destroy",
            value: function destroy() {
                var _iterator2 = this._subModels, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var subModel = _ref2;
                    subModel.destroy(), _subMeshPool.free(subModel);
                }
                for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                    var localBinding = lbResult.value;
                    localBinding.buffer && (localBinding.buffer.destroy(), localBinding.buffer = void 0), 
                    lbResult = lbIter.next();
                }
                this._localBindings.has(UBOForwardLight.BLOCK.name) && this._localBindings.delete(UBOForwardLight.BLOCK.name), 
                this._worldBounds = null, this._modelBounds = null, this._subModels.splice(0), this._matPSORecord.clear(), 
                this._matRefCount.clear(), this._inited = !1;
            }
        }, {
            key: "getSubModel",
            value: function getSubModel(idx) {
                return this._subModels[idx];
            }
        }, {
            key: "updateTransform",
            value: function updateTransform() {
                var node = this._transform;
                node.hasChanged && (node.updateWorldTransformFull(), this._modelBounds && this._worldBounds && this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds));
            }
        }, {
            key: "_resetUBOUpdateFlag",
            value: function _resetUBOUpdateFlag() {
                this._uboUpdated = !1;
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs() {
                if (this._uboUpdated) return !1;
                this._uboUpdated = !0;
                var worldMatrix = this._transform._mat;
                mat4.array(f32_1, worldMatrix), this._uboLocal.view.set(f32_1, UBOLocal.MAT_WORLD_OFFSET), 
                mat4.inverseTranspose(m4_1, worldMatrix), mat4.array(f32_1, m4_1), this._uboLocal.view.set(f32_1, UBOLocal.MAT_WORLD_IT_OFFSET);
                var commonLocal = this._localBindings.get(UBOLocal.BLOCK.name);
                commonLocal && commonLocal.buffer && commonLocal.buffer.update(this._uboLocal.view);
                var _iterator3 = this._matPSORecord.keys(), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var mat = _ref3, _iterator4 = mat.passes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        _ref4.update();
                    }
                    var _iterator5 = this._matPSORecord.get(mat), _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        _ref5.pipelineLayout.layouts[0].update();
                    }
                }
                return !0;
            }
        }, {
            key: "createBoundingShape",
            value: function createBoundingShape(minPos, maxPos) {
                minPos && maxPos && (this._modelBounds = aabb.fromPoints(aabb.create(), minPos, maxPos), 
                this._worldBounds = aabb.clone(this._modelBounds), this._transform.updateWorldTransformFull(), 
                this._modelBounds.transform(this._transform._mat, this._transform._pos, this._transform._rot, this._transform._scale, this._worldBounds));
            }
        }, {
            key: "initSubModel",
            value: function initSubModel(idx, subMeshData, mat) {
                if (this.initLocalBindings(mat), null == this._subModels[idx]) this._subModels[idx] = _subMeshPool.alloc(); else {
                    var oldMat = this._subModels[idx].material;
                    this._subModels[idx].destroy(), this.releasePSO(oldMat);
                }
                this.allocatePSO(mat), this._subModels[idx].initialize(subMeshData, mat, this._matPSORecord.get(mat)), 
                this._inited = !0;
            }
        }, {
            key: "setSubModelMesh",
            value: function setSubModelMesh(idx, subMeshData) {
                null == this._subModels[idx] && (this._subModels[idx] = _subMeshPool.alloc()), this._subModels[idx].subMeshData = subMeshData;
            }
        }, {
            key: "setSubModelMaterial",
            value: function setSubModelMaterial(idx, mat) {
                null != this._subModels[idx] && (this.initLocalBindings(mat), this._subModels[idx].material === mat ? mat && (this.destroyPipelineState(mat, this._matPSORecord.get(mat)), 
                this._matPSORecord.set(mat, this.createPipelineState(mat))) : (this._subModels[idx].material && this.releasePSO(this._subModels[idx].material), 
                mat && this.allocatePSO(mat)), this._subModels[idx].psos = mat && this._matPSORecord.get(mat) || null, 
                this._subModels[idx].material = mat);
            }
        }, {
            key: "onPipelineChange",
            value: function onPipelineChange() {
                var _iterator6 = this._subModels, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    for (var mat = _ref6.material, pso = this._matPSORecord.get(mat), i = 0; i < mat.passes.length; i++) {
                        var pass = mat.passes[i];
                        pass.destroyPipelineState(pso[i]), pso[i] = this._doCreatePSO(pass);
                    }
                }
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState(mat) {
                for (var ret = new Array(mat.passes.length), i = 0; i < ret.length; i++) {
                    var pass = mat.passes[i], _iterator7 = pass.customizations, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                        var _ref7;
                        if (_isArray7) {
                            if (_i7 >= _iterator7.length) break;
                            _ref7 = _iterator7[_i7++];
                        } else {
                            if ((_i7 = _iterator7.next()).done) break;
                            _ref7 = _i7.value;
                        }
                        var cus = _ref7;
                        customizationManager.attach(cus, this);
                    }
                    ret[i] = this._doCreatePSO(pass);
                }
                return ret;
            }
        }, {
            key: "destroyPipelineState",
            value: function destroyPipelineState(mat, pso) {
                for (var i = 0; i < mat.passes.length; i++) {
                    var pass = mat.passes[i];
                    pass.destroyPipelineState(pso[i]);
                    var _iterator8 = pass.customizations, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray8) {
                            if (_i8 >= _iterator8.length) break;
                            _ref8 = _iterator8[_i8++];
                        } else {
                            if ((_i8 = _iterator8.next()).done) break;
                            _ref8 = _i8.value;
                        }
                        var cus = _ref8;
                        customizationManager.detach(cus, this);
                    }
                }
            }
        }, {
            key: "_doCreatePSO",
            value: function _doCreatePSO(pass) {
                var pso = pass.createPipelineState();
                return pso.pipelineLayout.layouts[0].bindBuffer(UBOLocal.BLOCK.binding, this._localBindings.get(UBOLocal.BLOCK.name).buffer), 
                this._localBindings.has(UBOForwardLight.BLOCK.name) && pso.pipelineLayout.layouts[0].bindBuffer(UBOForwardLight.BLOCK.binding, this._localBindings.get(UBOForwardLight.BLOCK.name).buffer), 
                pso;
            }
        }, {
            key: "onSetLocalBindings",
            value: function onSetLocalBindings(mat) {
                this._localBindings.has(UBOLocal.BLOCK.name) || this._localBindings.set(UBOLocal.BLOCK.name, {
                    type: GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOLocal.BLOCK
                });
                var hasForwardLight = !1, _iterator9 = mat.passes, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i9 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i9++];
                    } else {
                        if ((_i9 = _iterator9.next()).done) break;
                        _ref9 = _i9.value;
                    }
                    if (_ref9.bindings.find(function(b) {
                        return b.name === UBOForwardLight.BLOCK.name;
                    })) {
                        hasForwardLight = !0;
                        break;
                    }
                }
                hasForwardLight && "ForwardPipeline" === cc.director.root.pipeline.name && (this._localBindings.has(UBOForwardLight.BLOCK.name) || this._localBindings.set(UBOForwardLight.BLOCK.name, {
                    type: GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOForwardLight.BLOCK
                }));
            }
        }, {
            key: "initLocalBindings",
            value: function initLocalBindings(mat) {
                if (mat) {
                    this.onSetLocalBindings(mat);
                    for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                        var localBinding = lbResult.value;
                        localBinding.buffer || (localBinding.buffer = this._device.createBuffer({
                            usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: getUniformBlockSize(localBinding.blockInfo)
                        })), lbResult = lbIter.next();
                    }
                }
            }
        }, {
            key: "allocatePSO",
            value: function allocatePSO(mat) {
                null == this._matRefCount.get(mat) ? (this._matRefCount.set(mat, 1), this._matPSORecord.set(mat, this.createPipelineState(mat))) : this._matRefCount.set(mat, this._matRefCount.get(mat) + 1);
            }
        }, {
            key: "releasePSO",
            value: function releasePSO(mat) {
                this._matRefCount.set(mat, this._matRefCount.get(mat) - 1), 0 === this._matRefCount.get(mat) && (this.destroyPipelineState(mat, this._matPSORecord.get(mat)), 
                this._matPSORecord.delete(mat), this._matRefCount.delete(mat));
            }
        } ]), Model;
    }();
    !function(FaceIndex) {
        FaceIndex[FaceIndex.right = 0] = "right", FaceIndex[FaceIndex.left = 1] = "left", 
        FaceIndex[FaceIndex.top = 2] = "top", FaceIndex[FaceIndex.bottom = 3] = "bottom", 
        FaceIndex[FaceIndex.front = 4] = "front", FaceIndex[FaceIndex.back = 5] = "back";
    }(FaceIndex || (FaceIndex = {}));
    var TextureCube = ccclass("cc.TextureCube")((_temp$m = _class3$a = function(_TextureBase) {
        function TextureCube() {
            var _this;
            return _classCallCheck(this, TextureCube), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this)), "_mipmaps", _descriptor$g, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(TextureCube, TextureBase), _createClass(TextureCube, [ {
            key: "mipmaps",
            get: function get$$1() {
                return this._mipmaps;
            },
            set: function set(value) {
                var _this2 = this;
                if (this._mipmaps = value, 0 < this._mipmaps.length) {
                    var imageAsset = this._mipmaps[0].front;
                    this.create(imageAsset.width, imageAsset.height, imageAsset.format, this._mipmaps.length), 
                    this._mipmaps.forEach(function(mipmap, level) {
                        _forEachFace(mipmap, function(face, faceIndex) {
                            _this2._assignImage(face, level, faceIndex);
                        });
                    });
                } else this.create(0, 0, void 0, this._mipmaps.length);
            }
        }, {
            key: "image",
            get: function get$$1() {
                return 0 === this._mipmaps.length ? null : this._mipmaps[0];
            },
            set: function set(value) {
                this.mipmaps = value ? [ value ] : [];
            }
        } ], [ {
            key: "fromTexture2DArray",
            value: function fromTexture2DArray(textures, out) {
                for (var mipmaps = [], nMipmaps = textures.length / 6, i = 0; i < nMipmaps; i++) {
                    var x = 6 * i;
                    mipmaps.push({
                        front: textures[x + FaceIndex.front].image,
                        back: textures[x + FaceIndex.back].image,
                        left: textures[x + FaceIndex.left].image,
                        right: textures[x + FaceIndex.right].image,
                        top: textures[x + FaceIndex.top].image,
                        bottom: textures[x + FaceIndex.bottom].image
                    });
                }
                return (out = out || new TextureCube()).mipmaps = mipmaps, out;
            }
        } ]), _createClass(TextureCube, [ {
            key: "onLoaded",
            value: function onLoaded() {
                this.mipmaps = this._mipmaps, this.loaded = !0, this.emit("load");
            }
        }, {
            key: "updateMipmaps",
            value: function updateMipmaps() {
                var _this3 = this, firstLevel = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, count = 1 < arguments.length ? arguments[1] : void 0;
                if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), _loop = function _loop(i) {
                    var level = firstLevel + i;
                    _forEachFace(_this3._mipmaps[level], function(face, faceIndex) {
                        _this3._assignImage(face, level, faceIndex);
                    });
                }, i = 0; i < nUpdate; ++i) _loop(i);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this._mipmaps = [], _get(_getPrototypeOf(TextureCube.prototype), "destroy", this).call(this);
            }
        }, {
            key: "releaseTexture",
            value: function releaseTexture() {
                this.mipmaps = [];
            }
        }, {
            key: "_serialize",
            value: function _serialize(exporting) {
                return {
                    base: _get(_getPrototypeOf(TextureCube.prototype), "_serialize", this).call(this),
                    mipmaps: this._mipmaps.map(function(mipmap) {
                        return exporting ? {
                            front: Editor.Utils.UuidUtils.compressUuid(mipmap.front._uuid, !0),
                            back: Editor.Utils.UuidUtils.compressUuid(mipmap.back._uuid, !0),
                            left: Editor.Utils.UuidUtils.compressUuid(mipmap.left._uuid, !0),
                            right: Editor.Utils.UuidUtils.compressUuid(mipmap.right._uuid, !0),
                            top: Editor.Utils.UuidUtils.compressUuid(mipmap.top._uuid, !0),
                            bottom: Editor.Utils.UuidUtils.compressUuid(mipmap.bottom._uuid, !0)
                        } : {
                            front: mipmap.front._uuid,
                            back: mipmap.back._uuid,
                            left: mipmap.left._uuid,
                            right: mipmap.right._uuid,
                            top: mipmap.top._uuid,
                            bottom: mipmap.bottom._uuid
                        };
                    })
                };
            }
        }, {
            key: "_deserialize",
            value: function _deserialize(serializedData, handle) {
                var data = serializedData;
                _get(_getPrototypeOf(TextureCube.prototype), "_deserialize", this).call(this, data.base, handle), 
                this._mipmaps = new Array(data.mipmaps.length);
                for (var i = 0; i < data.mipmaps.length; ++i) {
                    this._mipmaps[i] = {
                        front: new ImageAsset(),
                        back: new ImageAsset(),
                        left: new ImageAsset(),
                        right: new ImageAsset(),
                        top: new ImageAsset(),
                        bottom: new ImageAsset()
                    };
                    var mipmap = data.mipmaps[i];
                    handle.result.push(this._mipmaps[i], "front", mipmap.front), handle.result.push(this._mipmaps[i], "back", mipmap.back), 
                    handle.result.push(this._mipmaps[i], "left", mipmap.left), handle.result.push(this._mipmaps[i], "right", mipmap.right), 
                    handle.result.push(this._mipmaps[i], "top", mipmap.top), handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom);
                }
            }
        }, {
            key: "_getTextureCreateInfo",
            value: function _getTextureCreateInfo() {
                var result = _get(_getPrototypeOf(TextureCube.prototype), "_getTextureCreateInfo", this).call(this);
                return result.arrayLayer = 6, result.flags = (result.flags || 0) | GFXTextureFlagBit.CUBEMAP, 
                result;
            }
        }, {
            key: "_getTextureViewCreateInfo",
            value: function _getTextureViewCreateInfo() {
                var result = _get(_getPrototypeOf(TextureCube.prototype), "_getTextureViewCreateInfo", this).call(this);
                return result.type = GFXTextureViewType.CUBE, result.layerCount = 6, result;
            }
        } ]), TextureCube;
    }(), _class3$a.FaceIndex = FaceIndex, _descriptor$g = _applyDecoratedDescriptor((_class2$i = _temp$m).prototype, "_mipmaps", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$p = _class2$i)) || _class$p;
    function _forEachFace(mipmap, callback) {
        callback(mipmap.front, FaceIndex.front), callback(mipmap.back, FaceIndex.back), 
        callback(mipmap.left, FaceIndex.left), callback(mipmap.right, FaceIndex.right), 
        callback(mipmap.top, FaceIndex.top), callback(mipmap.bottom, FaceIndex.bottom);
    }
    cc.TextureCube = TextureCube;
    var phases, phaseNum, _type2fn2, _type2default2, effects$1 = [ {
        name: "builtin-billboard",
        techniques: [ {
            name: "add",
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 1,
                        blendSrcAlpha: 2,
                        blendDstAlpha: 1
                    } ]
                },
                program: "builtin-billboard|vert:vs_main|tinted-fs:add",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    mainTiling_Offset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    tintColor: {
                        value: [ .5, .5, .5, .5 ],
                        inspector: {
                            type: "color"
                        },
                        type: 16
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-billboard|vert:vs_main|tinted-fs:add",
            hash: 1837336543,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if 1 || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if 1\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nuniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = (a_texCoord.xy - 0.5) * cc_size_rotation.xy;\n  rotateCorner(vertOffset, cc_size_rotation.z);\n  computeVertPos(pos, vertOffset, cc_matView);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if 1 || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if 1\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = (a_texCoord.xy - 0.5) * cc_size_rotation.xy;\n  rotateCorner(vertOffset, cc_size_rotation.z);\n  computeVertPos(pos, vertOffset, cc_matView);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal" ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_STRETCHED_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HORIZONTAL_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_VERTICAL_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            } ],
            blocks: [ {
                name: "Constants",
                size: 32,
                defines: [],
                binding: 0,
                members: [ {
                    name: "mainTiling_Offset",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "frameTile_velLenScale",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            }, {
                name: "builtin",
                size: 16,
                defines: [],
                binding: 1,
                members: [ {
                    name: "cc_size_rotation",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            }, {
                name: "FragConstants",
                size: 16,
                defines: [],
                binding: 2,
                members: [ {
                    name: "tintColor",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 3
            } ],
            dependencies: {}
        } ]
    }, {
        name: "builtin-particle-trail",
        techniques: [ {
            name: "add",
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 1,
                        blendSrcAlpha: 2,
                        blendDstAlpha: 1
                    } ]
                },
                program: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    mainTiling_Offset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    frameTile_velLenScale: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    tintColor: {
                        value: [ .5, .5, .5, .5 ],
                        inspector: {
                            type: "color"
                        },
                        type: 16
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
            hash: 3035112421,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec4 a_color;\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec4 a_color;\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
                frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal" ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_STRETCHED_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HORIZONTAL_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_VERTICAL_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_WORLD_SPACE",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            } ],
            blocks: [ {
                name: "Constants",
                size: 32,
                defines: [],
                binding: 0,
                members: [ {
                    name: "mainTiling_Offset",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "frameTile_velLenScale",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            }, {
                name: "FragConstants",
                size: 16,
                defines: [],
                binding: 1,
                members: [ {
                    name: "tintColor",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 2
            } ],
            dependencies: {}
        } ]
    }, {
        name: "builtin-particle",
        techniques: [ {
            name: "add",
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 1,
                        blendSrcAlpha: 2,
                        blendDstAlpha: 1
                    } ]
                },
                program: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "grey",
                        type: 28
                    },
                    mainTiling_Offset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    frameTile_velLenScale: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    tintColor: {
                        value: [ .5, .5, .5, .5 ],
                        inspector: {
                            type: "color"
                        },
                        type: 16
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
            hash: 1777415840,
            glsl3: {
                vert: "\nprecision highp float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec2 a_texCoord1;\nin vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\n  in vec3 a_color1;\n#endif\n#if CC_USE_MESH\n  in vec3 a_texCoord2;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n    computeVertPos(pos, cornerOffset\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n",
                frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * vertOffset.x) + (camUp * vertOffset.y);\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  vertIndex.x = 1. - vertIndex.x;\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec2 a_texCoord1;\nattribute vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\n  attribute vec3 a_color1;\n#endif\n#if CC_USE_MESH\n  attribute vec3 a_texCoord2;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n    computeVertPos(pos, cornerOffset\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n    color = a_color;\n  #else\n    uv = a_texCoord.xy;\n    color = a_color * a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n",
                frag: "\nprecision highp float;\nuniform vec4 cc_exposure;\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal" ],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_STRETCHED_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HORIZONTAL_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_VERTICAL_BILLBOARD",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_MESH",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_WORLD_SPACE",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            } ],
            blocks: [ {
                name: "Constants",
                size: 32,
                defines: [],
                binding: 0,
                members: [ {
                    name: "mainTiling_Offset",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "frameTile_velLenScale",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            }, {
                name: "FragConstants",
                size: 16,
                defines: [],
                binding: 1,
                members: [ {
                    name: "tintColor",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [],
                binding: 2
            } ],
            dependencies: {}
        } ]
    }, {
        name: "builtin-skybox",
        techniques: [ {
            passes: [ {
                rasterizerState: {
                    cullMode: 0
                },
                program: "builtin-skybox|sky-vs:vert|sky-fs:frag",
                priority: 245,
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    cubeMap: {
                        value: "default-cube",
                        type: 31
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-skybox|sky-vs:vert|sky-fs:frag",
            hash: 316228518,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform CCSkinning {\n    vec4 cc_jointsData[30 * 3];\n  };\n#else\n  uniform CCSkinningTexture {\n    vec4 cc_jointsTextureSizeInv;\n  };\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nout vec3 viewDir;\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 clipPos = cc_matProj * matViewRotOnly * vec4(In.position, 1.0);\n  viewDir = a_position;\n  clipPos.z = clipPos.w * 0.99999;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec3 viewDir;\nuniform samplerCube cubeMap;\nvec4 frag () {\n  vec4 o;\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cubeMap, viewDir));\n    c = LinearToSRGB(c / (1.0 + c));\n    o = vec4(c, 1.0);\n  #else\n    o = texture(cubeMap, viewDir);\n  #endif\n  return CCOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform vec4 cc_jointsData[90];\n#else\n  uniform vec4 cc_jointsTextureSizeInv;\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture2D(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture2D(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture2D(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nvarying vec3 viewDir;\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 clipPos = cc_matProj * matViewRotOnly * vec4(In.position, 1.0);\n  viewDir = a_position;\n  clipPos.z = clipPos.w * 0.99999;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nuniform vec4 cc_exposure;\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec3 viewDir;\nuniform samplerCube cubeMap;\nvec4 frag () {\n  vec4 o;\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cubeMap, viewDir));\n    c = LinearToSRGB(c / (1.0 + c));\n    o = vec4(c, 1.0);\n  #else\n    o = textureCube(cubeMap, viewDir);\n  #endif\n  return CCOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCSkinning", "CCSkinningTexture" ],
                    samplers: [ "cc_jointsTexture" ]
                }
            },
            defines: [ {
                name: "CC_USE_SKINNING",
                type: "number",
                defines: [],
                range: [ 0, 3 ]
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            }, {
                name: "USE_RGBE_CUBEMAP",
                type: "boolean",
                defines: []
            } ],
            blocks: [],
            samplers: [ {
                name: "cubeMap",
                type: 31,
                count: 1,
                defines: [],
                binding: 0
            } ],
            dependencies: {}
        } ]
    }, {
        name: "builtin-sprite",
        techniques: [ {
            passes: [ {
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 4,
                        blendDstAlpha: 4
                    } ]
                },
                rasterizerState: {
                    cullMode: 0
                },
                program: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
                priority: 244,
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1
                },
                properties: {
                    mainTexture: {
                        value: "white",
                        type: 28
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
            hash: 3400569611,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#if USE_LOCAL\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#endif\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal" ],
                    samplers: []
                }
            },
            defines: [ {
                name: "USE_LOCAL",
                type: "boolean",
                defines: []
            }, {
                name: "USE_TEXTURE",
                type: "boolean",
                defines: []
            } ],
            blocks: [],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [ "USE_TEXTURE" ],
                binding: 0
            } ],
            dependencies: {}
        } ]
    }, {
        name: "builtin-standard",
        techniques: [ {
            name: "opaque",
            passes: [ {
                program: "builtin-standard|standard-vs:vert|standard-fs:frag",
                properties: {
                    tilingOffset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    albedo: {
                        value: [ 1, 1, 1, 1 ],
                        inspector: {
                            type: "color"
                        },
                        type: 16
                    },
                    albedoScale: {
                        value: [ 1, 1, 1, 0 ],
                        type: 16
                    },
                    pbrParams: {
                        value: [ .8, .6, 0, 1 ],
                        type: 16
                    },
                    pbrScale: {
                        value: [ 1, 1, 1, 1 ],
                        type: 16
                    },
                    emissive: {
                        value: [ 1, 1, 1, 1 ],
                        inspector: {
                            type: "color"
                        },
                        type: 16
                    },
                    emissiveScale: {
                        value: [ 1, 1, 1, 1 ],
                        type: 16
                    },
                    albedoMap: {
                        value: "grey",
                        type: 28
                    },
                    normalMap: {
                        value: "normal",
                        type: 28
                    },
                    pbrMap: {
                        value: "grey",
                        type: 28
                    },
                    emissiveMap: {
                        value: "grey",
                        type: 28
                    },
                    envMap: {
                        value: "default-cube",
                        type: 31
                    }
                }
            }, {
                customizations: [ "bounds-merge-shadow" ],
                blendState: {
                    targets: [ {
                        blend: !0,
                        blendSrc: 2,
                        blendDst: 4,
                        blendDstAlpha: 4
                    } ]
                },
                program: "builtin-standard|planar-shadow-vs:vert|planar-shadow-fs:frag",
                depthStencilState: {
                    depthTest: !0,
                    depthWrite: !1,
                    stencilTestFront: !0,
                    stencilFuncFront: 5,
                    stencilPassOpFront: 2,
                    stencilWriteMaskBack: 128,
                    stencilWriteMaskFront: 128,
                    stencilReadMaskBack: 128,
                    stencilReadMaskFront: 128,
                    stencilRefBack: 128,
                    stencilRefFront: 128
                },
                switch: "USE_PLANAR_SHADOW"
            } ]
        } ],
        shaders: [ {
            name: "builtin-standard|standard-vs:vert|standard-fs:frag",
            hash: 2674111314,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform CCSkinning {\n    vec4 cc_jointsData[30 * 3];\n  };\n#else\n  uniform CCSkinningTexture {\n    vec4 cc_jointsTextureSizeInv;\n  };\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n  vec4 pbrParams;\n  vec4 pbrScale;\n  vec4 emissive;\n  vec4 emissiveScale;\n};\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n#endif\nout vec3 v_worldPos;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  vec4 pos = cc_matWorld * vec4(In.position, 1.0);\n  vec4 normal = cc_matWorldIT * vec4(In.normal, 0.0);\n  v_worldPos = pos.xyz;\n  v_normal = normal.xyz;\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = (cc_matWorldIT * vec4(In.tangent, 0.0)).xyz;\n    v_bitangent = cross(v_tangent, v_normal);\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCForwardLight {\n  vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float factor2 = factor * factor;\n  float factor3 = factor2 * factor2;\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n  vec4 pbrParams;\n  vec4 pbrScale;\n  vec4 emissive;\n  vec4 emissiveScale;\n};\nin vec3 v_worldPos;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  in vec2 v_uv;\n#endif\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_IBL\n  uniform samplerCube envMap;\n#endif\nvec4 frag () {\n  #if USE_ALBEDO_MAP\n    vec4 baseColor = texture(albedoMap, v_uv) * albedo;\n  #else\n    vec4 baseColor = albedo;\n  #endif\n  baseColor.rgb *= albedoScale.rgb;\n  baseColor.rgb = SRGBToLinear(baseColor.rgb);\n  #if USE_ALPHA_TEST\n    if(baseColor.a < albedoScale.a)\n      discard;\n  #endif\n  vec3 N = normalize(v_normal);\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    N = normalize(\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * N);\n  #endif\n  #if USE_PBR_MAP\n    vec4 pbr = texture(pbrMap, v_uv);\n  #else\n    vec4 pbr = pbrParams;\n  #endif\n  pbr *= pbrScale;\n  float roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  float metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  vec3 diffuse = baseColor.rgb * (1.0 - metallic);\n  vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);\n  vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, roughness, NV);\n  vec3 specularContrib = specular * CalcSpecular(roughness, NH, H, N);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(v_worldPos, N, V, diffuse, specular, roughness);\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 env = texture(envMap, R);\n    env.rgb = SRGBToLinear(env.rgb) * cc_ambientSky.w;\n    finalColor += (env.rgb * specular);\n  #endif\n  finalColor = mix(finalColor, finalColor * pbr.AO_CHANNEL, pbrParams.z);\n  #if USE_EMISSIVE_MAP\n    vec3 emissiveColor = texture(emissiveMap, v_uv).rgb;\n    emissiveColor = SRGBToLinear(emissiveColor);\n    #if CC_USE_HDR\n      emissiveColor *= cc_exposure.w;\n    #endif\n    finalColor += emissiveColor * emissive.rgb * emissiveScale.xyz;\n  #endif\n  #if !CC_USE_HDR\n    finalColor = LinearToSRGB(finalColor);\n  #endif\n  return vec4(finalColor, baseColor.a);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform vec4 cc_jointsData[90];\n#else\n  uniform vec4 cc_jointsTextureSizeInv;\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture2D(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture2D(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture2D(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nuniform vec4 tilingOffset;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n#endif\nvarying vec3 v_worldPos;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  vec4 pos = cc_matWorld * vec4(In.position, 1.0);\n  vec4 normal = cc_matWorldIT * vec4(In.normal, 0.0);\n  v_worldPos = pos.xyz;\n  v_normal = normal.xyz;\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = (cc_matWorldIT * vec4(In.tangent, 0.0)).xyz;\n    v_bitangent = cross(v_tangent, v_normal);\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float factor2 = factor * factor;\n  float factor3 = factor2 * factor2;\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScale;\nuniform vec4 pbrParams;\nuniform vec4 pbrScale;\nuniform vec4 emissive;\nuniform vec4 emissiveScale;\nvarying vec3 v_worldPos;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP\n  varying vec2 v_uv;\n#endif\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_IBL\n  uniform samplerCube envMap;\n#endif\nvec4 frag () {\n  #if USE_ALBEDO_MAP\n    vec4 baseColor = texture2D(albedoMap, v_uv) * albedo;\n  #else\n    vec4 baseColor = albedo;\n  #endif\n  baseColor.rgb *= albedoScale.rgb;\n  baseColor.rgb = SRGBToLinear(baseColor.rgb);\n  #if USE_ALPHA_TEST\n    if(baseColor.a < albedoScale.a)\n      discard;\n  #endif\n  vec3 N = normalize(v_normal);\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    N = normalize(\n      nmmp.x * normalize(v_tangent) +\n      nmmp.y * normalize(v_bitangent) +\n      nmmp.z * N);\n  #endif\n  #if USE_PBR_MAP\n    vec4 pbr = texture2D(pbrMap, v_uv);\n  #else\n    vec4 pbr = pbrParams;\n  #endif\n  pbr *= pbrScale;\n  float roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  float metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  vec3 diffuse = baseColor.rgb * (1.0 - metallic);\n  vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);\n  vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, roughness, NV);\n  vec3 specularContrib = specular * CalcSpecular(roughness, NH, H, N);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(v_worldPos, N, V, diffuse, specular, roughness);\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 env = textureCube(envMap, R);\n    env.rgb = SRGBToLinear(env.rgb) * cc_ambientSky.w;\n    finalColor += (env.rgb * specular);\n  #endif\n  finalColor = mix(finalColor, finalColor * pbr.AO_CHANNEL, pbrParams.z);\n  #if USE_EMISSIVE_MAP\n    vec3 emissiveColor = texture2D(emissiveMap, v_uv).rgb;\n    emissiveColor = SRGBToLinear(emissiveColor);\n    #if CC_USE_HDR\n      emissiveColor *= cc_exposure.w;\n    #endif\n    finalColor += emissiveColor * emissive.rgb * emissiveScale.xyz;\n  #endif\n  #if !CC_USE_HDR\n    finalColor = LinearToSRGB(finalColor);\n  #endif\n  return vec4(finalColor, baseColor.a);\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal", "CCSkinning", "CCSkinningTexture", "CCForwardLight" ],
                    samplers: [ "cc_jointsTexture" ]
                }
            },
            defines: [ {
                name: "CC_USE_SKINNING",
                type: "number",
                defines: [],
                range: [ 0, 3 ]
            }, {
                name: "USE_ALBEDO_MAP",
                type: "boolean",
                defines: []
            }, {
                name: "USE_NORMAL_MAP",
                type: "boolean",
                defines: []
            }, {
                name: "USE_PBR_MAP",
                type: "boolean",
                defines: []
            }, {
                name: "USE_EMISSIVE_MAP",
                type: "boolean",
                defines: []
            }, {
                name: "USE_IBL",
                type: "boolean",
                defines: []
            }, {
                name: "ROUGHNESS_CHANNEL",
                type: "string",
                defines: [],
                options: [ "r", "g", "b", "a" ]
            }, {
                name: "METALLIC_CHANNEL",
                type: "string",
                defines: [],
                options: [ "g", "r", "b", "a" ]
            }, {
                name: "AO_CHANNEL",
                type: "string",
                defines: [],
                options: [ "b", "r", "g", "a" ]
            }, {
                name: "USE_ALPHA_TEST",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            } ],
            blocks: [ {
                name: "Constants",
                size: 112,
                defines: [],
                binding: 0,
                members: [ {
                    name: "tilingOffset",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "albedo",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "albedoScale",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "pbrParams",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "pbrScale",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "emissive",
                    type: 16,
                    count: 1,
                    size: 16
                }, {
                    name: "emissiveScale",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            } ],
            samplers: [ {
                name: "albedoMap",
                type: 28,
                count: 1,
                defines: [ "USE_ALBEDO_MAP" ],
                binding: 1
            }, {
                name: "normalMap",
                type: 28,
                count: 1,
                defines: [ "USE_NORMAL_MAP" ],
                binding: 2
            }, {
                name: "pbrMap",
                type: 28,
                count: 1,
                defines: [ "USE_PBR_MAP" ],
                binding: 3
            }, {
                name: "emissiveMap",
                type: 28,
                count: 1,
                defines: [ "USE_EMISSIVE_MAP" ],
                binding: 4
            }, {
                name: "envMap",
                type: 31,
                count: 1,
                defines: [ "USE_IBL" ],
                binding: 5
            } ],
            dependencies: {}
        }, {
            name: "builtin-standard|planar-shadow-vs:vert|planar-shadow-fs:frag",
            hash: 71711775,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CCShadow {\n  mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform CCSkinning {\n    vec4 cc_jointsData[30 * 3];\n  };\n#else\n  uniform CCSkinningTexture {\n    vec4 cc_jointsTextureSizeInv;\n  };\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  vec4 pos = cc_matWorld * vec4(In.position, 1.0);\n  pos = cc_matViewProj * cc_matLightPlaneProj * pos;\n  pos.z -= 0.0001;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nuniform CCShadow {\n  mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matLightPlaneProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform vec4 cc_jointsData[90];\n#else\n  uniform vec4 cc_jointsTextureSizeInv;\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture2D(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture2D(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture2D(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  vec4 pos = cc_matWorld * vec4(In.position, 1.0);\n  pos = cc_matViewProj * cc_matLightPlaneProj * pos;\n  pos.z -= 0.0001;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nuniform vec4 cc_shadowColor;\nuniform vec4 cc_exposure;\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal", "CCShadow" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal", "CCSkinning", "CCSkinningTexture" ],
                    samplers: [ "cc_jointsTexture" ]
                }
            },
            defines: [ {
                name: "CC_USE_SKINNING",
                type: "number",
                defines: [],
                range: [ 0, 3 ]
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            } ],
            blocks: [],
            samplers: [],
            dependencies: {}
        } ]
    }, {
        name: "builtin-unlit",
        techniques: [ {
            name: "opaque",
            passes: [ {
                program: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
                properties: {
                    color: {
                        value: [ 1, 1, 1, 1 ],
                        inspector: {
                            type: "color"
                        },
                        type: 16
                    },
                    tilingOffset: {
                        value: [ 1, 1, 0, 0 ],
                        type: 16
                    },
                    mainTexture: {
                        value: "grey",
                        type: 28
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
            hash: 502451384,
            glsl3: {
                vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform CCSkinning {\n    vec4 cc_jointsData[30 * 3];\n  };\n#else\n  uniform CCSkinningTexture {\n    vec4 cc_jointsTextureSizeInv;\n  };\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\n#if USE_TEXTURE\n  in vec2 a_texCoord;\n  out vec2 uv0;\n  uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  vec4 pos = cc_matViewProj * cc_matWorld * vec4(In.position, 1.0);\n  #if USE_TEXTURE\n    uv0 = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform Constant {\n    vec4 color;\n  };\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  return CCOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec3 a_tangent;struct CCAttributes {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};void CCDecode (out CCAttributes attr) {\n  attr.position = a_position;\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_SKINNING == 1\n  uniform vec4 cc_jointsData[90];\n#else\n  uniform vec4 cc_jointsTextureSizeInv;\n  uniform sampler2D cc_jointsTexture;\n#endif\n#if CC_USE_SKINNING == 2\n  float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    int idx = 3 * int(i);\n    Qr = cc_jointsData[idx];\n    Qt = cc_jointsData[idx + 1];\n    return cc_jointsData[idx + 2].xyz;\n  }\n#elif CC_USE_SKINNING == 2\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((0.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((1.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((2.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((3.5 / 12.0), y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((4.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((5.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((6.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((7.5 / 12.0), y)))\n    );\n    return vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((8.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((9.5 / 12.0), y))),\n      decode32(texture2D(cc_jointsTexture, vec2((10.5 / 12.0), y)))\n    );\n  }\n#elif CC_USE_SKINNING == 3\n  vec3 getJointDQ(float i, out vec4 Qr, out vec4 Qt) {\n    float y = (i + 0.5) * cc_jointsTextureSizeInv.y;\n    Qr = texture2D(cc_jointsTexture, vec2((0.5 / 3.0), y));\n    Qt = texture2D(cc_jointsTexture, vec2((1.5 / 3.0), y));\n    return texture2D(cc_jointsTexture, vec2((2.5 / 3.0), y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0);\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    S += getJointDQ(a_joints[i], r, t) * w;\n    R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout CCAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position = VectorTransformQuat(attr.position * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent = VectorTransformQuat(attr.tangent, R);\n}\n#endif\nstruct StandardInput {\n  vec3 position;\n  vec3 normal;\n  vec3 tangent;\n};\nvoid CCAttrToInput (in CCAttributes attr, out StandardInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCGetStandardInput (out StandardInput In) {\n  CCAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n  varying vec2 uv0;\n  uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  StandardInput In;\n  CCGetStandardInput(In);\n  vec4 pos = cc_matViewProj * cc_matWorld * vec4(In.position, 1.0);\n  #if USE_TEXTURE\n    uv0 = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec4 CCOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, pow(color.rgb, vec3(2.2)) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform vec4 color;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  return CCOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [ "CCLocal", "CCSkinning", "CCSkinningTexture" ],
                    samplers: [ "cc_jointsTexture" ]
                }
            },
            defines: [ {
                name: "CC_USE_SKINNING",
                type: "number",
                defines: [],
                range: [ 0, 3 ]
            }, {
                name: "USE_VERTEX_COLOR",
                type: "boolean",
                defines: []
            }, {
                name: "USE_TEXTURE",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            }, {
                name: "USE_COLOR",
                type: "boolean",
                defines: []
            } ],
            blocks: [ {
                name: "TexCoords",
                size: 16,
                defines: [ "USE_TEXTURE" ],
                binding: 0,
                members: [ {
                    name: "tilingOffset",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            }, {
                name: "Constant",
                size: 16,
                defines: [ "USE_COLOR" ],
                binding: 1,
                members: [ {
                    name: "color",
                    type: 16,
                    count: 1,
                    size: 16
                } ]
            } ],
            samplers: [ {
                name: "mainTexture",
                type: 28,
                count: 1,
                defines: [ "USE_TEXTURE" ],
                binding: 2
            } ],
            dependencies: {}
        } ]
    }, {
        name: "pipeline/smaa",
        techniques: [ {
            name: "smaa",
            passes: [ {
                program: "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
                depthStencilState: {
                    depthTest: !1,
                    depthWrite: !1
                },
                properties: {
                    u_texSampler: {
                        sampler: [ 2, 2, null, 2, 2 ],
                        type: 28
                    }
                }
            }, {
                program: "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
                depthStencilState: {
                    depthTest: !1,
                    depthWrite: !1
                },
                properties: {
                    u_edgeTexSampler: {
                        sampler: [ 2, 2, null, 2, 2 ],
                        type: 28
                    },
                    u_areaTexSampler: {
                        sampler: [ 2, 2, null, 2, 2 ],
                        type: 28
                    },
                    u_searchTexSampler: {
                        sampler: [ 1, 1, null, 2, 2 ],
                        type: 28
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
            hash: 1827337539,
            glsl3: {
                vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision highp float;\nuniform vec4 cc_exposure;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture2D(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture2D(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture2D(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture2D(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture2D(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture2D(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture2D(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            } ],
            blocks: [],
            samplers: [ {
                name: "u_texSampler",
                type: 28,
                count: 1,
                defines: [],
                binding: 0
            } ],
            dependencies: {}
        }, {
            name: "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
            hash: 2477120406,
            glsl3: {
                vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nout vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 v_uv;\nin vec4 v_offsets[3];\nin vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision highp float;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision highp float;\nuniform vec4 cc_nativeSize;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture2D(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture2D(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture2D(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture2D(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture2D(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [],
                    samplers: []
                }
            },
            defines: [],
            blocks: [],
            samplers: [ {
                name: "u_edgeTexSampler",
                type: 28,
                count: 1,
                defines: [],
                binding: 0
            }, {
                name: "u_areaTexSampler",
                type: 28,
                count: 1,
                defines: [],
                binding: 1
            }, {
                name: "u_searchTexSampler",
                type: 28,
                count: 1,
                defines: [],
                binding: 2
            } ],
            dependencies: {}
        } ]
    }, {
        name: "pipeline/tonemap",
        techniques: [ {
            name: "tonemap",
            passes: [ {
                program: "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
                depthStencilState: {
                    depthTest: !1,
                    depthWrite: !1
                },
                properties: {
                    u_texSampler: {
                        sampler: [ 2, 2, null, 2, 2 ],
                        type: 28
                    },
                    u_blendTexSampler: {
                        sampler: [ 2, 2, null, 2, 2 ],
                        type: 28
                    }
                }
            } ]
        } ],
        shaders: [ {
            name: "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
            hash: 1101183755,
            glsl3: {
                vert: "\nprecision highp float;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#else\n  color = SRGBToLinear(color);\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n#if CC_USE_SMAA\n  vec4 a;\n  a.rb = texture(u_blendTexSampler, v_uv).rb;\n  a.g = texture(u_blendTexSampler, v_offset.zw).g;\n  a.a = texture(u_blendTexSampler, v_offset.xy).a;\n  if (dot(a, vec4(1.0)) < 1e-5) {\n    vec4 o = texture(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  } else {\n    vec2 offset;\n    offset.x = a.a > a.b ? a.a : -a.b;\n    offset.y = a.g > a.r ? -a.g : a.r;\n    if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n    } else {\n        offset.x = 0.0;\n    }\n    vec4 C = texture(u_texSampler, v_uv);\n    C.rgb = ToLDR(C.rgb);\n    vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n    vec4 Cop = texture(u_texSampler, uv);\n    Cop.rgb = ToLDR(Cop.rgb);\n    float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n    C.rgb = pow(C.rgb, vec3(2.2));\n    Cop.rgb = pow(Cop.rgb, vec3(2.2));\n    vec4 mixed = mix(C, Cop, s);\n    mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n    return mixed;\n  }\n#else\n  vec4 o = texture(u_texSampler, v_uv);\n  o.rgb = ToLDR(o.rgb);\n  return o;\n#endif\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
            },
            glsl1: {
                vert: "\nprecision highp float;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
                frag: "\nprecision highp float;\nuniform vec4 cc_nativeSize;\nuniform vec4 cc_exposure;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#else\n  color = SRGBToLinear(color);\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n#if CC_USE_SMAA\n  vec4 a;\n  a.rb = texture2D(u_blendTexSampler, v_uv).rb;\n  a.g = texture2D(u_blendTexSampler, v_offset.zw).g;\n  a.a = texture2D(u_blendTexSampler, v_offset.xy).a;\n  if (dot(a, vec4(1.0)) < 1e-5) {\n    vec4 o = texture2D(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  } else {\n    vec2 offset;\n    offset.x = a.a > a.b ? a.a : -a.b;\n    offset.y = a.g > a.r ? -a.g : a.r;\n    if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n    } else {\n        offset.x = 0.0;\n    }\n    vec4 C = texture2D(u_texSampler, v_uv);\n    C.rgb = ToLDR(C.rgb);\n    vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n    vec4 Cop = texture2D(u_texSampler, uv);\n    Cop.rgb = ToLDR(Cop.rgb);\n    float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n    C.rgb = pow(C.rgb, vec3(2.2));\n    Cop.rgb = pow(Cop.rgb, vec3(2.2));\n    vec4 mixed = mix(C, Cop, s);\n    mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n    return mixed;\n  }\n#else\n  vec4 o = texture2D(u_texSampler, v_uv);\n  o.rgb = ToLDR(o.rgb);\n  return o;\n#endif\n}\nvoid main() { gl_FragColor = frag(); }\n"
            },
            builtins: {
                globals: {
                    blocks: [ "CCGlobal" ],
                    samplers: []
                },
                locals: {
                    blocks: [],
                    samplers: []
                }
            },
            defines: [ {
                name: "CC_USE_HDR",
                type: "boolean",
                defines: []
            }, {
                name: "CC_USE_SMAA",
                type: "boolean",
                defines: []
            } ],
            blocks: [],
            samplers: [ {
                name: "u_texSampler",
                type: 28,
                count: 1,
                defines: [],
                binding: 0
            }, {
                name: "u_blendTexSampler",
                type: 28,
                count: 1,
                defines: [],
                binding: 1
            } ],
            dependencies: {}
        } ]
    } ], BuiltinResMgr = function() {
        function BuiltinResMgr() {
            _classCallCheck(this, BuiltinResMgr), this._device = null, this._resources = {};
        }
        return _createClass(BuiltinResMgr, [ {
            key: "initBuiltinRes",
            value: function initBuiltinRes(device) {
                this._device = device;
                var resources = this._resources, canvas = document.createElement("canvas"), context = canvas.getContext("2d"), imgAsset = new ImageAsset(canvas), l = canvas.width = canvas.height = 2;
                context.fillStyle = "#000", context.fillRect(0, 0, l, l);
                var blackTexture = new Texture2D();
                blackTexture._uuid = "black-texture", blackTexture.image = imgAsset, resources[blackTexture._uuid] = blackTexture;
                var blackCubeTexture = new TextureCube();
                blackCubeTexture._uuid = "black-cube-texture", blackCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
                blackCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                }, blackCubeTexture.onLoaded(), resources[blackCubeTexture._uuid] = blackCubeTexture, 
                context.fillStyle = "#777", context.fillRect(0, 0, l, l);
                var greyTexture = new Texture2D();
                greyTexture._uuid = "grey-texture", greyTexture.image = imgAsset, greyTexture.onLoaded(), 
                resources[greyTexture._uuid] = greyTexture, context.fillStyle = "#fff", context.fillRect(0, 0, l, l);
                var whiteTexture = new Texture2D();
                whiteTexture._uuid = "white-texture", whiteTexture.image = imgAsset, whiteTexture.onLoaded(), 
                resources[whiteTexture._uuid] = whiteTexture;
                var whiteCubeTexture = new TextureCube();
                whiteCubeTexture._uuid = "white-cube-texture", whiteCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
                whiteCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                }, whiteCubeTexture.onLoaded(), resources[whiteCubeTexture._uuid] = whiteCubeTexture, 
                context.fillStyle = "#7f7fff", context.fillRect(0, 0, l, l);
                var normalTexture = new Texture2D();
                normalTexture._uuid = "normal-texture", normalTexture.image = imgAsset, resources[normalTexture._uuid] = normalTexture, 
                canvas.width = canvas.height = 16, context.fillStyle = "#ddd", context.fillRect(0, 0, 16, 16), 
                context.fillStyle = "#555", context.fillRect(0, 0, 8, 8), context.fillStyle = "#555", 
                context.fillRect(8, 8, 8, 8);
                var defaultTexture = new Texture2D();
                defaultTexture._uuid = "default-texture", defaultTexture.image = imgAsset, defaultTexture.onLoaded(), 
                resources[defaultTexture._uuid] = defaultTexture;
                var defaultCubeTexture = new TextureCube();
                defaultCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), defaultCubeTexture._uuid = "default-cube-texture", 
                defaultCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                }, defaultCubeTexture.onLoaded(), resources[defaultCubeTexture._uuid] = defaultCubeTexture;
                var spriteFrame = new SpriteFrame();
                spriteFrame._uuid = "default-spriteframe", spriteFrame.setOriginalSize(cc.size(imgAsset.width, imgAsset.height)), 
                spriteFrame.setRect(new Rect(0, 0, imgAsset.width, imgAsset.height)), spriteFrame.image = imgAsset, 
                spriteFrame.onLoaded(), resources[spriteFrame._uuid] = spriteFrame, effects$1.forEach(function(e) {
                    Object.assign(new cc.EffectAsset(), e).onLoaded();
                });
                var standardMtl = new cc.Material();
                standardMtl._uuid = "standard-material", standardMtl.initialize({
                    effectName: "builtin-standard"
                }), standardMtl.onLoaded(), resources[standardMtl._uuid] = standardMtl;
                var missingMtl = new cc.Material();
                missingMtl._uuid = "missing-material", missingMtl.initialize({
                    effectName: "builtin-unlit",
                    defines: {
                        USE_COLOR: !0
                    }
                }), missingMtl.setProperty("color", cc.color("#ff00ff")), missingMtl.onLoaded(), 
                resources[missingMtl._uuid] = missingMtl;
                var missingSkinningMtl = new cc.Material();
                missingSkinningMtl._uuid = "missing-skinning-material", missingSkinningMtl.initialize({
                    effectName: "builtin-unlit",
                    defines: {
                        USE_COLOR: !0,
                        CC_USE_SKINNING: 1
                    }
                }), missingSkinningMtl.setProperty("color", cc.color("#ff00ff")), missingSkinningMtl.onLoaded(), 
                resources[missingSkinningMtl._uuid] = missingSkinningMtl;
                var missingEfxMtl = new cc.Material();
                missingEfxMtl._uuid = "missing-effect-material", missingEfxMtl.initialize({
                    effectName: "builtin-unlit",
                    defines: {
                        USE_COLOR: !0
                    }
                }), missingEfxMtl.setProperty("color", cc.color("#ffff00")), missingEfxMtl.onLoaded(), 
                resources[missingEfxMtl._uuid] = missingEfxMtl;
                var spriteMtl = new cc.Material();
                spriteMtl._uuid = "ui-base-material", spriteMtl.initialize({
                    defines: {
                        USE_TEXTURE: !1
                    },
                    effectName: "builtin-sprite"
                }), spriteMtl.onLoaded(), resources[spriteMtl._uuid] = spriteMtl;
                var spriteColorMtl = new cc.Material();
                spriteColorMtl._uuid = "ui-sprite-material", spriteColorMtl.initialize({
                    defines: {
                        USE_TEXTURE: !0
                    },
                    effectName: "builtin-sprite"
                }), spriteColorMtl.onLoaded(), resources[spriteColorMtl._uuid] = spriteColorMtl;
                var defaultParticleMtl = new cc.Material();
                defaultParticleMtl._uuid = "default-particle-material", defaultParticleMtl.initialize({
                    effectName: "builtin-particle"
                }), defaultParticleMtl.onLoaded(), resources[defaultParticleMtl._uuid] = defaultParticleMtl;
                var defaultTrailMtl = new cc.Material();
                defaultTrailMtl._uuid = "default-trail-material", defaultTrailMtl.initialize({
                    effectName: "builtin-particle-trail"
                }), defaultTrailMtl.onLoaded(), resources[defaultTrailMtl._uuid] = defaultTrailMtl;
                var defaultBillboardMtl = new cc.Material();
                defaultBillboardMtl._uuid = "default-billboard-material", defaultBillboardMtl.initialize({
                    effectName: "builtin-billboard"
                }), defaultBillboardMtl.onLoaded(), resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
                var tmp = aabb.create();
                customizationManager.register("bounds-merge-shadow", {
                    onAttach: function onAttach(m) {
                        var light = m.scene.mainLight, shadow = m.scene.planarShadow;
                        m.updateTransform = function() {
                            var bounds = m.worldBounds;
                            (m.transform.hasChanged || light.node.hasChanged) && (bounds ? (m.modelBounds.transform(m.transform.worldMatrix, null, null, null, bounds), 
                            bounds.transform(shadow.matLight, null, null, null, tmp), aabb.merge(bounds, bounds, tmp)) : m.transform.updateWorldTransformFull());
                        };
                    },
                    onDetach: function onDetach(m) {
                        m.updateTransform = Model.prototype.updateTransform.bind(m);
                    }
                });
            }
        }, {
            key: "get",
            value: function get(uuid) {
                return this._resources[uuid];
            }
        } ]), BuiltinResMgr;
    }(), builtinResMgr = cc.builtinResMgr = new BuiltinResMgr(), GFXRasterizerState = function() {
        function GFXRasterizerState() {
            _classCallCheck(this, GFXRasterizerState), this.isDiscard = !1, this.polygonMode = GFXPolygonMode.FILL, 
            this.shadeModel = GFXShadeModel.GOURAND, this.cullMode = GFXCullMode.BACK, this.isFrontFaceCCW = !0, 
            this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, this.isDepthClip = !0, 
            this.isMultisample = !1, this.lineWidth = 1;
        }
        return _createClass(GFXRasterizerState, [ {
            key: "compare",
            value: function compare(state) {
                return this.isDiscard === state.isDiscard && this.polygonMode === state.polygonMode && this.shadeModel === state.shadeModel && this.cullMode === state.cullMode && this.isFrontFaceCCW === state.isFrontFaceCCW && this.depthBias === state.depthBias && this.depthBiasClamp === state.depthBiasClamp && this.depthBiasSlop === state.depthBiasSlop && this.isDepthClip === state.isDepthClip && this.lineWidth === state.lineWidth && this.isMultisample === state.isMultisample;
            }
        } ]), GFXRasterizerState;
    }(), GFXDepthStencilState = function() {
        function GFXDepthStencilState() {
            _classCallCheck(this, GFXDepthStencilState), this.depthTest = !0, this.depthWrite = !0, 
            this.depthFunc = GFXComparisonFunc.LESS, this.stencilTestFront = !1, this.stencilFuncFront = GFXComparisonFunc.ALWAYS, 
            this.stencilReadMaskFront = 4294967295, this.stencilWriteMaskFront = 4294967295, 
            this.stencilFailOpFront = GFXStencilOp.KEEP, this.stencilZFailOpFront = GFXStencilOp.KEEP, 
            this.stencilPassOpFront = GFXStencilOp.KEEP, this.stencilRefFront = 1, this.stencilTestBack = !1, 
            this.stencilFuncBack = GFXComparisonFunc.ALWAYS, this.stencilReadMaskBack = 4294967295, 
            this.stencilWriteMaskBack = 4294967295, this.stencilFailOpBack = GFXStencilOp.KEEP, 
            this.stencilZFailOpBack = GFXStencilOp.KEEP, this.stencilPassOpBack = GFXStencilOp.KEEP, 
            this.stencilRefBack = 1;
        }
        return _createClass(GFXDepthStencilState, [ {
            key: "compare",
            value: function compare(state) {
                return this.depthTest === state.depthTest && this.depthWrite === state.depthWrite && this.depthFunc === state.depthFunc && this.stencilTestFront === state.stencilTestFront && this.stencilFuncFront === state.stencilFuncFront && this.stencilReadMaskFront === state.stencilReadMaskFront && this.stencilWriteMaskFront === state.stencilWriteMaskFront && this.stencilFailOpFront === state.stencilFailOpFront && this.stencilZFailOpFront === state.stencilZFailOpFront && this.stencilPassOpFront === state.stencilPassOpFront && this.stencilRefFront === state.stencilRefFront && this.stencilTestBack === state.stencilTestBack && this.stencilFuncBack === state.stencilFuncBack && this.stencilReadMaskBack === state.stencilReadMaskBack && this.stencilWriteMaskBack === state.stencilWriteMaskBack && this.stencilFailOpBack === state.stencilFailOpBack && this.stencilZFailOpBack === state.stencilZFailOpBack && this.stencilPassOpBack === state.stencilPassOpBack && this.stencilRefBack === state.stencilRefBack;
            }
        } ]), GFXDepthStencilState;
    }(), GFXBlendTarget = function() {
        function GFXBlendTarget() {
            _classCallCheck(this, GFXBlendTarget), this.blend = !1, this.blendSrc = GFXBlendFactor.ONE, 
            this.blendDst = GFXBlendFactor.ZERO, this.blendEq = GFXBlendOp.ADD, this.blendSrcAlpha = GFXBlendFactor.ONE, 
            this.blendDstAlpha = GFXBlendFactor.ZERO, this.blendAlphaEq = GFXBlendOp.ADD, this.blendColorMask = GFXColorMask.ALL;
        }
        return _createClass(GFXBlendTarget, [ {
            key: "compare",
            value: function compare(target) {
                return this.blend === target.blend && this.blendSrc === target.blendSrc && this.blendDst === target.blendDst && this.blendEq === target.blendEq && this.blendSrcAlpha === target.blendSrcAlpha && this.blendDstAlpha === target.blendDstAlpha && this.blendAlphaEq === target.blendAlphaEq && this.blendColorMask === target.blendColorMask;
            }
        } ]), GFXBlendTarget;
    }(), GFXBlendState = function GFXBlendState() {
        _classCallCheck(this, GFXBlendState), this.isA2C = !1, this.isIndepend = !1, this.blendColor = [ 0, 0, 0, 0 ], 
        this.targets = [ new GFXBlendTarget() ];
    }, GFXInputState = function GFXInputState() {
        _classCallCheck(this, GFXInputState), this.attributes = [];
    }, GFXPipelineState = function(_GFXObject) {
        function GFXPipelineState(device) {
            var _this;
            return _classCallCheck(this, GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineState).call(this, GFXObjectType.PIPELINE_STATE)))._device = void 0, 
            _this._shader = null, _this._primitive = exports.GFXPrimitiveMode.TRIANGLE_LIST, 
            _this._is = null, _this._rs = null, _this._dss = null, _this._bs = null, _this._dynamicStates = [], 
            _this._layout = null, _this._renderPass = null, _this._device = device, _this;
        }
        return _inherits(GFXPipelineState, GFXObject), _createClass(GFXPipelineState, [ {
            key: "shader",
            get: function get() {
                return this._shader;
            }
        }, {
            key: "primitive",
            get: function get() {
                return this._primitive;
            }
        }, {
            key: "rasterizerState",
            get: function get() {
                return this._rs;
            }
        }, {
            key: "depthStencilState",
            get: function get() {
                return this._dss;
            }
        }, {
            key: "blendState",
            get: function get() {
                return this._bs;
            }
        }, {
            key: "dynamicStates",
            get: function get() {
                return this._dynamicStates;
            }
        }, {
            key: "pipelineLayout",
            get: function get() {
                return this._layout;
            }
        }, {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        } ]), GFXPipelineState;
    }(), getPhaseID = (phases = new Map(), phaseNum = 0, function(phaseName) {
        return phases.has(phaseName) || (phases.set(phaseName, 1 << phaseNum), phaseNum++), 
        phases.get(phaseName);
    }), _type2fn = (_defineProperty(_type2fn2 = {}, GFXType.INT, function(a, v) {
        return a[2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0] = v;
    }), _defineProperty(_type2fn2, GFXType.INT2, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return vec2.array(a, v, 2 * idx);
    }), _defineProperty(_type2fn2, GFXType.INT3, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return vec3.array(a, v, 3 * idx);
    }), _defineProperty(_type2fn2, GFXType.INT4, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return vec4.array(a, v, 4 * idx);
    }), _defineProperty(_type2fn2, GFXType.FLOAT, function(a, v) {
        return a[2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0] = v;
    }), _defineProperty(_type2fn2, GFXType.FLOAT2, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return vec2.array(a, v, 2 * idx);
    }), _defineProperty(_type2fn2, GFXType.FLOAT3, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return vec3.array(a, v, 3 * idx);
    }), _defineProperty(_type2fn2, GFXType.FLOAT4, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return vec4.array(a, v, 4 * idx);
    }), _defineProperty(_type2fn2, GFXType.MAT3, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return mat3.array(a, v, 9 * idx);
    }), _defineProperty(_type2fn2, GFXType.MAT4, function(a, v) {
        var idx = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
        return mat4.array(a, v, 16 * idx);
    }), _type2fn2), _type2default = (_defineProperty(_type2default2 = {}, GFXType.INT, [ 0 ]), 
    _defineProperty(_type2default2, GFXType.INT2, [ 0, 0 ]), _defineProperty(_type2default2, GFXType.INT3, [ 0, 0, 0 ]), 
    _defineProperty(_type2default2, GFXType.INT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default2, GFXType.FLOAT, [ 0 ]), 
    _defineProperty(_type2default2, GFXType.FLOAT2, [ 0, 0 ]), _defineProperty(_type2default2, GFXType.FLOAT3, [ 0, 0, 0 ]), 
    _defineProperty(_type2default2, GFXType.FLOAT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default2, GFXType.MAT3, [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 
    _defineProperty(_type2default2, GFXType.MAT4, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
    _defineProperty(_type2default2, GFXType.SAMPLER2D, "default-texture"), _defineProperty(_type2default2, GFXType.SAMPLER_CUBE, "default-cube-texture"), 
    _type2default2), genHandle = function genHandle(bt, type, binding) {
        return bt << 28 & 4026531840 | type << 22 & 264241152 | binding << 11 & 4192256 | 2047 & (3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0);
    }, Pass = function() {
        function Pass(device) {
            _classCallCheck(this, Pass), this._buffers = {}, this._samplers = {}, this._textureViews = {}, 
            this._resources = [], this._phase = 0, this._idxInTech = 0, this._programName = "", 
            this._priority = RenderPriority.DEFAULT, this._primitive = exports.GFXPrimitiveMode.TRIANGLE_LIST, 
            this._stage = RenderPassStage.DEFAULT, this._bindings = [], this._bs = new GFXBlendState(), 
            this._dss = new GFXDepthStencilState(), this._rs = new GFXRasterizerState(), this._dynamicStates = [], 
            this._dynamics = {}, this._customizations = [], this._handleMap = {}, this._blocks = [], 
            this._shaderInfo = null, this._defines = {}, this._properties = {}, this._device = void 0, 
            this._renderPass = null, this._shader = null, this._device = device;
        }
        return _createClass(Pass, [ {
            key: "initialize",
            value: function initialize(info) {
                var _this = this;
                this._idxInTech = info.idxInTech, this._programName = info.program, this._defines = info.curDefs, 
                this._shaderInfo = programLib.getTemplate(info.program), this._properties = info.properties || this._properties;
                var device = this._device;
                this._fillinPipelineInfo(info), this._fillinPipelineInfo(info.states);
                var _loop2 = function _loop2() {
                    if (_isArray) {
                        if (_i >= _iterator.length) return "break";
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) return "break";
                        _ref = _i.value;
                    }
                    var u = _ref;
                    if (u.name.startsWith("CC")) return "continue";
                    _this._buffers[u.binding] = device.createBuffer({
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: u.size,
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST
                    });
                    var block = _this._blocks[u.binding] = {
                        buffer: new ArrayBuffer(u.size),
                        dirty: !1,
                        views: []
                    };
                    u.members.reduce(function(acc, cur, idx) {
                        var view = new Float32Array(block.buffer, acc, cur.size / Float32Array.BYTES_PER_ELEMENT);
                        return block.views.push(view), _this._handleMap[cur.name] = genHandle(GFXBindingType.UNIFORM_BUFFER, cur.type, u.binding, idx), 
                        acc + cur.size;
                    }, 0);
                };
                var _iterator = this._shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    switch (_loop2()) {
                      case "break":
                        break _loop;

                      case "continue":
                        continue;
                    }
                }
                var _iterator2 = this._shaderInfo.samplers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var u = _ref2;
                    this._handleMap[u.name] = genHandle(GFXBindingType.SAMPLER, u.type, u.binding);
                }
                this.resetUBOs(), this.resetTextures(), this.tryCompile();
            }
        }, {
            key: "getHandle",
            value: function getHandle(name) {
                return this._handleMap[name];
            }
        }, {
            key: "getBinding",
            value: function getBinding(name) {
                return Pass.getBindingFromHandle(this.getHandle(name));
            }
        }, {
            key: "setUniform",
            value: function setUniform(handle, value) {
                var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), idx = Pass.getIndexFromHandle(handle), block = this._blocks[binding];
                _type2fn[type](block.views[idx], value), block.dirty = !0;
            }
        }, {
            key: "setUniformArray",
            value: function setUniformArray(handle, value) {
                for (var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), idx = Pass.getIndexFromHandle(handle), block = this._blocks[binding], i = 0; i < value.length; i++) null !== value[i] && _type2fn[type](block.views[idx], value[i], i);
                block.dirty = !0;
            }
        }, {
            key: "bindBuffer",
            value: function bindBuffer(binding, value) {
                this._buffers[binding] = value;
                var _iterator3 = this._resources, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.bindingLayout.bindBuffer(binding, value);
                }
            }
        }, {
            key: "bindTextureView",
            value: function bindTextureView(binding, value) {
                this._textureViews[binding] = value;
                var _iterator4 = this._resources, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.bindingLayout.bindTextureView(binding, value);
                }
            }
        }, {
            key: "bindSampler",
            value: function bindSampler(binding, value) {
                this._samplers[binding] = value;
                var _iterator5 = this._resources, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.bindingLayout.bindSampler(binding, value);
                }
            }
        }, {
            key: "setDynamicState",
            value: function setDynamicState(state, value) {
                var ds = this._dynamics[state];
                ds && ds.value === value || (ds.value = value, ds.dirty = !0);
            }
        }, {
            key: "overridePipelineStates",
            value: function overridePipelineStates(original, overrides) {
                this._bs = new GFXBlendState(), this._dss = new GFXDepthStencilState(), this._rs = new GFXRasterizerState(), 
                this._fillinPipelineInfo(original), this._fillinPipelineInfo(overrides);
            }
        }, {
            key: "update",
            value: function update() {
                for (var len = this._blocks.length, i = 0; i < len; i++) {
                    var block = this._blocks[i];
                    block.dirty && (this._buffers[i].update(block.buffer), block.dirty = !1);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var buffers = Object.values(this._buffers);
                if (buffers.length) {
                    for (var _i6 = 0; _i6 < buffers.length; _i6++) {
                        buffers[_i6].destroy();
                    }
                    this._buffers = {};
                }
                Object.values(this._samplers).length && (this._samplers = {});
            }
        }, {
            key: "resetUBOs",
            value: function resetUBOs() {
                var _iterator6 = this._shaderInfo.blocks, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i7 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i7++];
                    } else {
                        if ((_i7 = _iterator6.next()).done) break;
                        _ref6 = _i7.value;
                    }
                    var u = _ref6;
                    if (!u.name.startsWith("CC")) {
                        for (var block = this._blocks[u.binding], i = 0; i < u.members.length; i++) for (var cur = u.members[i], view = block.views[i], inf = this._properties[cur.name], givenDefault = inf && inf.value, _value = givenDefault || _type2default[cur.type], j = 0; j < cur.count; j++) view.set(_value, j * _value.length);
                        block.dirty = !0;
                    }
                }
            }
        }, {
            key: "resetTextures",
            value: function resetTextures() {
                var device = this._device, _iterator7 = this._shaderInfo.samplers, _isArray7 = Array.isArray(_iterator7), _i8 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i8 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i8++];
                    } else {
                        if ((_i8 = _iterator7.next()).done) break;
                        _ref7 = _i8.value;
                    }
                    var u = _ref7, inf = this._properties[u.name];
                    inf && inf.sampler && (this._samplers[u.binding] = samplerLib.getSampler(device, inf.sampler));
                    var texName = inf && inf.value ? inf.value + "-texture" : _type2default[u.type], texture = builtinResMgr.get(texName);
                    if (texture) {
                        this._textureViews[u.binding] = texture.getGFXTextureView();
                        var samplerInfo = texture.getGFXSamplerInfo();
                        this._samplers[u.binding] && !samplerInfo.length || (this._samplers[u.binding] = samplerLib.getSampler(device, samplerInfo));
                    } else console.warn("illegal texture default value " + texName);
                }
            }
        }, {
            key: "tryCompile",
            value: function tryCompile(defineOverrides) {
                defineOverrides && Object.assign(this._defines, defineOverrides);
                var pipeline = cc.director.root.pipeline;
                return !!pipeline && (this._renderPass = pipeline.getRenderPass(this._stage), this._renderPass ? (this._shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline), 
                this._shader ? (this._bindings.length || (this._bindings = this._shaderInfo.blocks.map(function(u) {
                    return {
                        name: u.name,
                        binding: u.binding,
                        type: GFXBindingType.UNIFORM_BUFFER
                    };
                }).concat(this._shaderInfo.samplers.map(function(u) {
                    return {
                        name: u.name,
                        binding: u.binding,
                        type: GFXBindingType.SAMPLER
                    };
                }))), !0) : (console.warn("create shader ".concat(this._programName, " failed")), 
                !1)) : (console.warn("illegal pass stage."), !1));
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState() {
                if (!(this._renderPass && this._shader && this._bindings.length || this.tryCompile())) return console.warn("pass resources not complete, create PSO failed"), 
                null;
                for (var bindingLayout = this._device.createBindingLayout({
                    bindings: this._bindings
                }), _arr = Object.keys(this._buffers), _i9 = 0; _i9 < _arr.length; _i9++) {
                    var b = _arr[_i9];
                    bindingLayout.bindBuffer(parseInt(b), this._buffers[b]);
                }
                for (var _arr2 = Object.keys(this._samplers), _i10 = 0; _i10 < _arr2.length; _i10++) {
                    var s = _arr2[_i10];
                    bindingLayout.bindSampler(parseInt(s), this._samplers[s]);
                }
                for (var _arr3 = Object.keys(this._textureViews), _i11 = 0; _i11 < _arr3.length; _i11++) {
                    var t = _arr3[_i11];
                    bindingLayout.bindTextureView(parseInt(t), this._textureViews[t]);
                }
                var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, _iterator8 = target.blocks, _isArray8 = Array.isArray(_iterator8), _i12 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i12 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i12++];
                    } else {
                        if ((_i12 = _iterator8.next()).done) break;
                        _ref8 = _i12.value;
                    }
                    var _b = _ref8, info = source.get(_b);
                    info && info.type === GFXBindingType.UNIFORM_BUFFER ? bindingLayout.bindBuffer(info.blockInfo.binding, info.buffer) : console.warn("builtin UBO '".concat(_b, "' not available!"));
                }
                var _iterator9 = target.samplers, _isArray9 = Array.isArray(_iterator9), _i13 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i13 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i13++];
                    } else {
                        if ((_i13 = _iterator9.next()).done) break;
                        _ref9 = _i13.value;
                    }
                    var _s = _ref9, _info = source.get(_s);
                    _info && _info.type === GFXBindingType.SAMPLER ? (_info.sampler && bindingLayout.bindSampler(_info.samplerInfo.binding, _info.sampler), 
                    bindingLayout.bindTextureView(_info.samplerInfo.binding, _info.textureView)) : console.warn("builtin texture '".concat(_s, "' not available!"));
                }
                var pipelineLayout = this._device.createPipelineLayout({
                    layouts: [ bindingLayout ]
                }), pipelineState = this._device.createPipelineState({
                    bs: this._bs,
                    dss: this._dss,
                    dynamicStates: this._dynamicStates,
                    is: new GFXInputState(),
                    layout: pipelineLayout,
                    primitive: this._primitive,
                    renderPass: this._renderPass,
                    rs: this._rs,
                    shader: this._shader
                });
                return this._resources.push({
                    bindingLayout: bindingLayout,
                    pipelineLayout: pipelineLayout,
                    pipelineState: pipelineState
                }), pipelineState;
            }
        }, {
            key: "destroyPipelineState",
            value: function destroyPipelineState(pipelineStates) {
                var idx = this._resources.findIndex(function(res) {
                    return res.pipelineState === pipelineStates;
                });
                if (0 <= idx) {
                    var _this$_resources$idx = this._resources[idx], bl = _this$_resources$idx.bindingLayout, pl = _this$_resources$idx.pipelineLayout, ps = _this$_resources$idx.pipelineState;
                    bl.destroy(), pl.destroy(), ps.destroy(), this._resources.splice(idx, 1);
                }
            }
        }, {
            key: "serializePipelineStates",
            value: function serializePipelineStates() {
                var shaderKey = programLib.getKey(this._programName, this._defines), res = "".concat(shaderKey, ",").concat(this._stage, ",").concat(this._primitive);
                return res += serializeBlendState(this._bs), res += serializeDepthStencilState(this._dss), 
                res += serializeRasterizerState(this._rs);
            }
        }, {
            key: "_fillinPipelineInfo",
            value: function _fillinPipelineInfo(info) {
                if (void 0 !== info.priority && (this._priority = info.priority), void 0 !== info.primitive && (this._primitive = info.primitive), 
                void 0 !== info.stage && (this._stage = info.stage), void 0 !== info.dynamics && (this._dynamicStates = info.dynamics), 
                info.customizations && (this._customizations = info.customizations), 0 === this._phase) {
                    var phaseName = info.phase || "default";
                    this._phase = getPhaseID(phaseName);
                }
                var bs = this._bs;
                if (info.blendState) {
                    var bsInfo = Object.assign({}, info.blendState);
                    bsInfo.targets && bsInfo.targets.forEach(function(t, i) {
                        return Object.assign(bs.targets[i] || (bs.targets[i] = new GFXBlendTarget()), t);
                    }), delete bsInfo.targets, Object.assign(bs, bsInfo);
                }
                Object.assign(this._rs, info.rasterizerState), Object.assign(this._dss, info.depthStencilState);
            }
        }, {
            key: "idxInTech",
            get: function get() {
                return this._idxInTech;
            }
        }, {
            key: "programName",
            get: function get() {
                return this._programName;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            }
        }, {
            key: "primitive",
            get: function get() {
                return this._primitive;
            }
        }, {
            key: "stage",
            get: function get() {
                return this._stage;
            }
        }, {
            key: "phase",
            get: function get() {
                return this._phase;
            }
        }, {
            key: "bindings",
            get: function get() {
                return this._bindings;
            }
        }, {
            key: "blendState",
            get: function get() {
                return this._bs;
            }
        }, {
            key: "depthStencilState",
            get: function get() {
                return this._dss;
            }
        }, {
            key: "rasterizerState",
            get: function get() {
                return this._rs;
            }
        }, {
            key: "dynamics",
            get: function get() {
                return this._dynamics;
            }
        }, {
            key: "customizations",
            get: function get() {
                return this._customizations;
            }
        }, {
            key: "shader",
            get: function get() {
                return this._shader;
            }
        } ]), Pass;
    }();
    Pass.getBindingTypeFromHandle = function getBindingTypeFromHandle(handle) {
        return (4026531840 & handle) >>> 28;
    }, Pass.getTypeFromHandle = function getTypeFromHandle(handle) {
        return (264241152 & handle) >>> 22;
    }, Pass.getBindingFromHandle = function getBindingFromHandle(handle) {
        return (4192256 & handle) >>> 11;
    }, Pass.getIndexFromHandle = function getIndexFromHandle(handle) {
        return 2047 & handle;
    };
    var _dec$q, _dec2$9, _class$q, _class2$j, _descriptor$h, _descriptor2$a, _descriptor3$6, _descriptor4$5, _descriptor5$4, serializeBlendState = function serializeBlendState(bs) {
        var res = ",bs,".concat(bs.isA2C, ",").concat(bs.blendColor), _iterator10 = bs.targets, _isArray10 = Array.isArray(_iterator10), _i14 = 0;
        for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
            var _ref10;
            if (_isArray10) {
                if (_i14 >= _iterator10.length) break;
                _ref10 = _iterator10[_i14++];
            } else {
                if ((_i14 = _iterator10.next()).done) break;
                _ref10 = _i14.value;
            }
            var t = _ref10;
            res += ",bt,".concat(t.blend, ",").concat(t.blendEq, ",").concat(t.blendAlphaEq, ",").concat(t.blendColorMask), 
            res += ",".concat(t.blendSrc, ",").concat(t.blendDst, ",").concat(t.blendSrcAlpha, ",").concat(t.blendDstAlpha);
        }
        return res;
    }, serializeRasterizerState = function serializeRasterizerState(rs) {
        return ",rs,".concat(rs.cullMode, ",").concat(rs.depthBias, ",").concat(rs.isFrontFaceCCW);
    }, serializeDepthStencilState = function serializeDepthStencilState(dss) {
        var res = ",dss,".concat(dss.depthTest, ",").concat(dss.depthWrite, ",").concat(dss.depthFunc);
        return res += ",".concat(dss.stencilTestFront, ",").concat(dss.stencilFuncFront, ",").concat(dss.stencilRefFront, ",").concat(dss.stencilReadMaskFront), 
        res += ",".concat(dss.stencilFailOpFront, ",").concat(dss.stencilZFailOpFront, ",").concat(dss.stencilPassOpFront, ",").concat(dss.stencilWriteMaskFront), 
        res += ",".concat(dss.stencilTestBack, ",").concat(dss.stencilFuncBack, ",").concat(dss.stencilRefBack, ",").concat(dss.stencilReadMaskBack), 
        res += ",".concat(dss.stencilFailOpBack, ",").concat(dss.stencilZFailOpBack, ",").concat(dss.stencilPassOpBack, ",").concat(dss.stencilWriteMaskBack);
    }, Material = (_dec$q = ccclass("cc.Material"), _dec2$9 = property(EffectAsset), 
    _dec$q((_descriptor$h = _applyDecoratedDescriptor((_class2$j = function(_Asset) {
        function Material() {
            var _this;
            return _classCallCheck(this, Material), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)), "_effectAsset", _descriptor$h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_techIdx", _descriptor2$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_defines", _descriptor3$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_states", _descriptor4$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_props", _descriptor5$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._passes = [], _this._owner = null, _this._hash = 0, _this.loaded = !1, _this;
        }
        return _inherits(Material, Asset), _createClass(Material, [ {
            key: "effectAsset",
            get: function get$$1() {
                return this._effectAsset;
            }
        }, {
            key: "effectName",
            get: function get$$1() {
                return this._effectAsset ? this._effectAsset.name : "";
            }
        }, {
            key: "technique",
            get: function get$$1() {
                return this._techIdx;
            }
        }, {
            key: "passes",
            get: function get$$1() {
                return this._passes;
            }
        }, {
            key: "hash",
            get: function get$$1() {
                return this._hash;
            }
        } ], [ {
            key: "getInstantiatedMaterial",
            value: function getInstantiatedMaterial(mat, rndCom, inEditor) {
                if (mat._owner === rndCom) return mat;
                var instance = new Material();
                return instance.copy(mat), instance._native = mat._native + " (Instance)", instance._owner = rndCom, 
                inEditor && (instance._uuid = mat._uuid), instance;
            }
        } ]), _createClass(Material, [ {
            key: "initialize",
            value: function initialize(info) {
                this._defines || (this._defines = []), this._states || (this._states = []), this._props || (this._props = []), 
                void 0 !== info.technique && (this._techIdx = info.technique), info.effectAsset ? this._effectAsset = info.effectAsset : info.effectName && (this._effectAsset = EffectAsset.get(info.effectName)), 
                info.defines && this._prepareInfo(info.defines, this._defines), info.states && this._prepareInfo(info.states, this._states), 
                this._update();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                if (this._passes && this._passes.length) {
                    var _iterator = this._passes, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.destroy();
                    }
                }
                return this._passes = [], this._effectAsset = null, this._props = [], this._defines = [], 
                this._states = [], _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
            }
        }, {
            key: "resetUniforms",
            value: function resetUniforms() {
                var clearPasses = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0];
                if (this._props.length = this._passes.length, this._props.fill({}), clearPasses) {
                    var _iterator2 = this._passes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var pass = _ref2;
                        pass.resetUBOs(), pass.resetTextures();
                    }
                }
            }
        }, {
            key: "recompileShaders",
            value: function recompileShaders(overrides, passIdx) {
                if (this._passes && this._effectAsset) {
                    if (void 0 === passIdx) {
                        var _iterator3 = this._passes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                if ((_i3 = _iterator3.next()).done) break;
                                _ref3 = _i3.value;
                            }
                            _ref3.tryCompile(overrides);
                        }
                    } else this._passes[passIdx].tryCompile(overrides);
                    this._onPassesChange();
                }
            }
        }, {
            key: "overridePipelineStates",
            value: function overridePipelineStates(overrides, passIdx) {
                if (this._passes && this._effectAsset) {
                    var passInfos = this._effectAsset.techniques[this._techIdx].passes;
                    if (void 0 === passIdx) {
                        var _iterator4 = this._passes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                            var _ref4;
                            if (_isArray4) {
                                if (_i4 >= _iterator4.length) break;
                                _ref4 = _iterator4[_i4++];
                            } else {
                                if ((_i4 = _iterator4.next()).done) break;
                                _ref4 = _i4.value;
                            }
                            var pass = _ref4;
                            pass.overridePipelineStates(passInfos[pass.idxInTech], overrides);
                        }
                    } else this._passes[passIdx].overridePipelineStates(passInfos[passIdx], overrides);
                    this._onPassesChange();
                }
            }
        }, {
            key: "onLoaded",
            value: function onLoaded() {
                this._update(), this.loaded = !0, this.emit("load");
            }
        }, {
            key: "setProperty",
            value: function setProperty(name, val, passIdx) {
                var success = !1;
                if (void 0 === passIdx) for (var passes = this._passes, len = passes.length, i = 0; i < len; i++) {
                    var pass = passes[i];
                    this._uploadProperty(pass, name, val) && (this._props[i][name] = val, success = !0);
                } else {
                    if (passIdx >= this._passes.length) return void console.warn("illegal pass index: ".concat(passIdx, "."));
                    var _pass = this._passes[passIdx];
                    this._uploadProperty(_pass, name, val) && (this._props[passIdx][name] = val, success = !0);
                }
                success || console.warn("illegal property name: ".concat(name, "."));
            }
        }, {
            key: "getProperty",
            value: function getProperty(name, passIdx) {
                if (void 0 === passIdx) for (var propsArray = this._props, len = propsArray.length, i = 0; i < len; i++) for (var props = propsArray[i], _arr = Object.keys(props), _i5 = 0; _i5 < _arr.length; _i5++) {
                    var p = _arr[_i5];
                    if (p === name) return props[p];
                } else {
                    if (passIdx >= this._props.length) return void console.warn("illegal pass index: ".concat(passIdx, "."));
                    for (var _props = this._props[passIdx], _arr2 = Object.keys(_props), _i6 = 0; _i6 < _arr2.length; _i6++) {
                        var _p = _arr2[_i6];
                        if (_p === name) return _props[_p];
                    }
                }
                return null;
            }
        }, {
            key: "copy",
            value: function copy(mat) {
                this._techIdx = mat._techIdx, this._props.length = mat._props.length, this._props.fill({});
                for (var i = 0; i < mat._props.length; i++) Object.assign(this._props[i], mat._props[i]);
                this._defines.length = mat._defines.length, this._defines.fill({});
                for (var _i7 = 0; _i7 < mat._defines.length; _i7++) Object.assign(this._defines[_i7], mat._defines[_i7]);
                Object.assign(this._states, mat._states), this._effectAsset = mat._effectAsset, 
                this._update();
            }
        }, {
            key: "_prepareInfo",
            value: function _prepareInfo(patch, cur) {
                if (!Array.isArray(patch)) {
                    var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                    patch = Array(len).fill(patch);
                }
                for (var i = 0; i < patch.length; i++) Object.assign(cur[i] || (cur[i] = {}), patch[i]);
            }
        }, {
            key: "_update",
            value: function _update() {
                var _this2 = this, keepProps = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0];
                if (this._effectAsset) {
                    if (this._passes && this._passes.length) {
                        var _iterator5 = this._passes, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i8 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i8++];
                            } else {
                                if ((_i8 = _iterator5.next()).done) break;
                                _ref5 = _i8.value;
                            }
                            _ref5.destroy();
                        }
                    }
                    this._passes = createPasses(this._effectAsset, {
                        techIdx: this._techIdx,
                        defines: this._defines,
                        states: this._states
                    }), this._props.length = this._passes.length, keepProps ? this._passes.forEach(function(pass, i) {
                        var props = _this2._props[i];
                        props || (props = _this2._props[i] = {});
                        for (var _arr3 = Object.keys(props), _i9 = 0; _i9 < _arr3.length; _i9++) {
                            var p = _arr3[_i9];
                            props[p] && _this2._uploadProperty(pass, p, props[p]);
                        }
                    }) : this._props.fill({});
                } else this._passes = builtinResMgr.get("missing-effect-material")._passes.slice();
                this._onPassesChange();
            }
        }, {
            key: "_uploadProperty",
            value: function _uploadProperty(pass, name, val) {
                var handle = pass.getHandle(name);
                if (void 0 === handle) return !1;
                var bindingType = Pass.getBindingTypeFromHandle(handle);
                if (bindingType === GFXBindingType.UNIFORM_BUFFER) Array.isArray(val) ? pass.setUniformArray(handle, val) : pass.setUniform(handle, val); else if (bindingType === GFXBindingType.SAMPLER) {
                    var binding = Pass.getBindingFromHandle(handle);
                    if (val instanceof GFXTextureView) pass.bindTextureView(binding, val); else if (val instanceof TextureBase) {
                        var textureView = val.getGFXTextureView();
                        if (!textureView || !textureView.texture.width || !textureView.texture.height) return console.warn("material '".concat(this._uuid, "' received incomplete texture asset '").concat(val._uuid, "'")), 
                        !1;
                        pass.bindTextureView(binding, textureView), pass.bindSampler(binding, samplerLib.getSampler(cc.game._gfxDevice, val.getGFXSamplerInfo()));
                    }
                }
                return !0;
            }
        }, {
            key: "_onPassesChange",
            value: function _onPassesChange() {
                var _this3 = this, str = "", _iterator6 = this._passes, _isArray6 = Array.isArray(_iterator6), _i10 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i10 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i10++];
                    } else {
                        if ((_i10 = _iterator6.next()).done) break;
                        _ref6 = _i10.value;
                    }
                    str += _ref6.serializePipelineStates();
                }
                if (this._hash = function murmurhash2_32_gc(str, seed) {
                    for (var l = str.length, h = seed ^ l, i = 0; 4 <= l; ) {
                        var k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
                        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (k = 1540483477 * (65535 & (k ^= k >>> 24)) + ((1540483477 * (k >>> 16) & 65535) << 16)), 
                        l -= 4, ++i;
                    }
                    switch (l) {
                      case 3:
                        h ^= (255 & str.charCodeAt(i + 2)) << 16;

                      case 2:
                        h ^= (255 & str.charCodeAt(i + 1)) << 8;

                      case 1:
                        h = 1540483477 * (65535 & (h ^= 255 & str.charCodeAt(i))) + ((1540483477 * (h >>> 16) & 65535) << 16);
                    }
                    return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), 
                    (h ^= h >>> 15) >>> 0;
                }(str, 666), this._owner) {
                    var comp = this._owner, index = comp.sharedMaterials.findIndex(function(m) {
                        return m === _this3;
                    });
                    0 <= index && comp._onRebuildPSO(index, this);
                }
            }
        } ]), Material;
    }()).prototype, "_effectAsset", [ _dec2$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$a = _applyDecoratedDescriptor(_class2$j.prototype, "_techIdx", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$j.prototype, "_defines", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$j.prototype, "_states", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$j.prototype, "_props", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$q = _class2$j)) || _class$q), createPasses = function createPasses(effect, info) {
        if (!effect.techniques) return [];
        for (var techIdx = info.techIdx, defines = info.defines, states = info.states, tech = effect.techniques[techIdx || 0], passNum = tech.passes.length, passes = [], k = 0; k < passNum; ++k) {
            var passInfo = tech.passes[k], defs = passInfo.curDefs = defines.length > k ? defines[k] : {};
            if (!passInfo.switch || defs[passInfo.switch]) {
                passInfo.states = states.length > k ? states[k] : {}, passInfo.idxInTech = k;
                var pass = new Pass(cc.game._gfxDevice);
                pass.initialize(passInfo), passes.push(pass);
            }
        }
        return passes;
    };
    cc.Material = Material;
    var _class$r, _class2$k, _descriptor$i, _descriptor2$b, BufferBlob = function() {
        function BufferBlob() {
            _classCallCheck(this, BufferBlob), this._arrayBufferOrPaddings = [], this._length = 0;
        }
        return _createClass(BufferBlob, [ {
            key: "setNextAlignment",
            value: function setNextAlignment(align) {
                if (0 !== align) {
                    var remainder = this._length % align;
                    if (0 !== remainder) {
                        var padding = align - remainder;
                        this._arrayBufferOrPaddings.push(padding), this._length += padding;
                    }
                }
            }
        }, {
            key: "addBuffer",
            value: function addBuffer(arrayBuffer) {
                var result = this._length;
                return this._arrayBufferOrPaddings.push(arrayBuffer), this._length += arrayBuffer.byteLength, 
                result;
            }
        }, {
            key: "getLength",
            value: function getLength() {
                return this._length;
            }
        }, {
            key: "getCombined",
            value: function getCombined() {
                var result = new Uint8Array(this._length), counter = 0;
                return this._arrayBufferOrPaddings.forEach(function(arrayBufferOrPadding) {
                    "number" == typeof arrayBufferOrPadding ? counter += arrayBufferOrPadding : (result.set(new Uint8Array(arrayBufferOrPadding), counter), 
                    counter += arrayBufferOrPadding.byteLength);
                }), result.buffer;
            }
        } ]), BufferBlob;
    }();
    var RenderingMesh = function() {
        function RenderingMesh(_subMeshes) {
            _classCallCheck(this, RenderingMesh), this._subMeshes = _subMeshes;
        }
        return _createClass(RenderingMesh, [ {
            key: "getSubmesh",
            value: function getSubmesh(index) {
                return this._subMeshes[index];
            }
        }, {
            key: "clearSubMeshes",
            value: function clearSubMeshes() {
                var _iterator = this._subMeshes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var subMesh = _ref, _iterator2 = subMesh.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        _ref2.destroy();
                    }
                    subMesh.indexBuffer && subMesh.indexBuffer.destroy();
                }
                this._subMeshes.splice(0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.clearSubMeshes(), this._subMeshes.length = 0;
            }
        }, {
            key: "subMeshes",
            get: function get$$1() {
                return this._subMeshes;
            }
        }, {
            key: "subMeshCount",
            get: function get$$1() {
                return this._subMeshes.length;
            }
        } ]), RenderingMesh;
    }(), Mesh = ccclass("cc.Mesh")((_descriptor$i = _applyDecoratedDescriptor((_class2$k = function(_Asset) {
        function Mesh() {
            var _this;
            return _classCallCheck(this, Mesh), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)), "_struct", _descriptor$i, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_dataLength", _descriptor2$b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._data = null, _this._initialized = !1, _this._renderingMesh = null, _this.loaded = !1, 
            _this;
        }
        return _inherits(Mesh, Asset), _createClass(Mesh, [ {
            key: "_nativeAsset",
            get: function get$$1() {
                return this._data.buffer;
            },
            set: function set(value) {
                this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
                cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
                this.loaded = !0, this.emit("load");
            }
        }, {
            key: "subMeshCount",
            get: function get$$1() {
                var renderingMesh = this.renderingMesh;
                return renderingMesh ? renderingMesh.subMeshCount : 0;
            }
        }, {
            key: "minPosition",
            get: function get$$1() {
                return this.struct.minPosition;
            }
        }, {
            key: "maxPosition",
            get: function get$$1() {
                return this.struct.maxPosition;
            }
        }, {
            key: "struct",
            get: function get$$1() {
                return this._struct;
            }
        }, {
            key: "data",
            get: function get$$1() {
                return this._data;
            }
        } ]), _createClass(Mesh, [ {
            key: "initialize",
            value: function initialize() {
                var _this2 = this;
                if (!this._initialized) {
                    this._initialized = !0, this._data || (this._data = new Uint8Array(this._dataLength), 
                    function postLoadMesh(mesh, callback) {
                        mesh.loaded ? callback && callback() : mesh.nativeUrl ? cc.loader.load({
                            url: mesh.nativeUrl
                        }, function(err, arrayBuffer) {
                            arrayBuffer && (mesh.loaded || (mesh._nativeAsset = arrayBuffer)), callback && callback(err);
                        }) : callback && callback();
                    }(this));
                    var buffer = this._data.buffer, gfxDevice = cc.director.root.device, vertexBuffers = this._createVertexBuffers(gfxDevice, buffer), submeshes = [], _loop2 = function _loop2() {
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) return "break";
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) return "break";
                            _ref3 = _i3.value;
                        }
                        var prim = _ref3;
                        if (0 === prim.vertexBundelIndices.length) return "continue";
                        var indexBuffer = null, ib = null;
                        if (prim.indexView) {
                            var idxView = prim.indexView;
                            indexBuffer = gfxDevice.createBuffer({
                                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                                size: idxView.length,
                                stride: idxView.stride
                            }), ib = new (function getIndexStrideCtor(stride) {
                                switch (stride) {
                                  case 1:
                                    return Uint8Array;

                                  case 2:
                                    return Uint16Array;

                                  case 4:
                                    return Uint32Array;
                                }
                                return Uint8Array;
                            }(idxView.stride))(buffer, idxView.offset, idxView.count), _this2.loaded ? indexBuffer.update(ib) : _this2.once("load", function() {
                                indexBuffer.update(ib);
                            });
                        }
                        var vbReference = prim.vertexBundelIndices.map(function(i) {
                            return vertexBuffers[i];
                        }), gfxAttributes = [];
                        if (0 < prim.vertexBundelIndices.length) {
                            var idx = prim.vertexBundelIndices[0];
                            gfxAttributes = _this2._struct.vertexBundles[idx].attributes;
                        }
                        var subMesh = {
                            primitiveMode: prim.primitiveMode,
                            vertexBuffers: vbReference,
                            indexBuffer: indexBuffer,
                            attributes: gfxAttributes
                        };
                        if (prim.geometricInfo) {
                            var info = prim.geometricInfo, _positions = new Float32Array(buffer, info.view.offset, info.view.length / 4);
                            subMesh.geometricInfo = {
                                indices: ib,
                                positions: _positions
                            };
                        }
                        submeshes.push(subMesh);
                    };
                    var _iterator3 = this._struct.primitives, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    _loop: for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        switch (_loop2()) {
                          case "break":
                            break _loop;

                          case "continue":
                            continue;
                        }
                    }
                    this._renderingMesh = new RenderingMesh(submeshes);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                return this.destroyRenderingMesh(), _get(_getPrototypeOf(Mesh.prototype), "destroy", this).call(this);
            }
        }, {
            key: "destroyRenderingMesh",
            value: function destroyRenderingMesh() {
                this._renderingMesh && (this._renderingMesh.destroy(), this._renderingMesh = null, 
                this._data = null, this._initialized = !1);
            }
        }, {
            key: "assign",
            value: function assign(struct, data) {
                this.destroyRenderingMesh(), this._struct = struct, this._data = data, this.loaded = !0, 
                this.emit("load");
            }
        }, {
            key: "getSubMesh",
            value: function getSubMesh(index) {
                return this.renderingMesh.getSubmesh(index);
            }
        }, {
            key: "merge",
            value: function merge(mesh, validate) {
                if (void 0 !== validate && validate && (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh))) return !1;
                if (!this._initialized && mesh._data) {
                    var struct = JSON.parse(JSON.stringify(mesh._struct)), data = mesh._data.slice();
                    return this.assign(struct, data), this.initialize(), !0;
                }
                for (var vb, vbView, srcVBView, dstVBView, dstAttrView, bufferBlob = new BufferBlob(), vertCount = 0, vertStride = 0, srcOffset = 0, dstOffset = 0, srcAttrOffset = 0, srcVBOffset = 0, dstVBOffset = 0, attrSize = 0, hasAttr = !1, vertexBundles = new Array(this._struct.vertexBundles.length), i = 0; i < this._struct.vertexBundles.length; ++i) {
                    var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                    srcOffset = bundle.view.offset, dstOffset = dstBundle.view.offset, vertStride = bundle.view.stride, 
                    vertCount = bundle.view.count + dstBundle.view.count, vb = new ArrayBuffer(vertCount * vertStride), 
                    vbView = new Uint8Array(vb), srcOffset += (srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length)).length, 
                    dstOffset += (dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length)).length, 
                    vbView.set(srcVBView), srcAttrOffset = 0;
                    var _iterator4 = bundle.attributes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        var attr = _ref4;
                        dstVBOffset = 0, hasAttr = !1;
                        var _iterator5 = dstBundle.attributes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref5 = _i5.value;
                            }
                            var dstAttr = _ref5;
                            if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                                hasAttr = !0;
                                break;
                            }
                            dstVBOffset += GFXFormatInfos[dstAttr.format].size;
                        }
                        if (hasAttr) {
                            attrSize = GFXFormatInfos[attr.format].size, srcVBOffset = bundle.view.length + srcAttrOffset;
                            for (var v = 0; v < dstBundle.view.count; ++v) dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize), 
                            vbView.set(dstAttrView, srcVBOffset), srcVBOffset += bundle.view.stride, dstVBOffset += dstBundle.view.stride;
                        }
                        srcAttrOffset += GFXFormatInfos[attr.format].size;
                    }
                    vertexBundles[i] = {
                        attributes: bundle.attributes,
                        view: {
                            offset: bufferBlob.getLength(),
                            length: vb.byteLength,
                            count: vertCount,
                            stride: vertStride
                        }
                    }, bufferBlob.addBuffer(vb);
                }
                for (var ibView, srcIBView, dstIBView, idxCount = 0, idxStride = 2, vertBatchCount = 0, primitives = new Array(this._struct.primitives.length), _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
                    var prim = this._struct.primitives[_i6], dstPrim = mesh._struct.primitives[_i6];
                    primitives[_i6] = {
                        primitiveMode: prim.primitiveMode,
                        vertexBundelIndices: prim.vertexBundelIndices
                    };
                    var _iterator6 = prim.vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray6) {
                            if (_i7 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i7++];
                        } else {
                            if ((_i7 = _iterator6.next()).done) break;
                            _ref6 = _i7.value;
                        }
                        var bundleIdx = _ref6;
                        vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                    }
                    if (prim.indexView && dstPrim.indexView) {
                        idxCount = prim.indexView.count, idxCount += dstPrim.indexView.count, srcOffset = prim.indexView.offset, 
                        dstOffset = dstPrim.indexView.offset, idxStride = idxCount < 256 ? 1 : idxCount < 65536 ? 2 : 4;
                        var ib = new ArrayBuffer(idxCount * idxStride);
                        if (ibView = 2 === idxStride ? new Uint16Array(ib) : 1 === idxStride ? new Uint8Array(ib) : new Uint32Array(ib), 
                        srcIBView = 2 === prim.indexView.stride ? new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count) : 1 === prim.indexView.stride ? new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count) : new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count), 
                        idxStride === prim.indexView.stride) ibView.set(srcIBView); else for (var n = 0; n < prim.indexView.count; ++n) ibView[n] = srcIBView[n];
                        srcOffset += prim.indexView.length, dstIBView = 2 === dstPrim.indexView.stride ? new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : 1 === dstPrim.indexView.stride ? new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                        for (var _n = 0; _n < dstPrim.indexView.count; ++_n) ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                        dstOffset += dstPrim.indexView.length, primitives[_i6].indexView = {
                            offset: bufferBlob.getLength(),
                            length: ib.byteLength,
                            count: idxCount,
                            stride: idxStride
                        }, bufferBlob.setNextAlignment(idxStride), bufferBlob.addBuffer(ib);
                    }
                    if (prim.geometricInfo && dstPrim.geometricInfo) {
                        var geomBuffSize = prim.geometricInfo.view.length + dstPrim.geometricInfo.view.length, geomBuff = new ArrayBuffer(geomBuffSize), geomBuffView = new Uint8Array(geomBuff), srcView = new Uint8Array(this._data.buffer, prim.geometricInfo.view.offset, prim.geometricInfo.view.length), dstView = new Uint8Array(mesh._data.buffer, dstPrim.geometricInfo.view.offset, dstPrim.geometricInfo.view.length);
                        geomBuffView.set(srcView), geomBuffView.set(dstView, srcView.length), bufferBlob.setNextAlignment(4), 
                        primitives[_i6].geometricInfo = {
                            doubleSided: prim.geometricInfo.doubleSided,
                            view: {
                                offset: bufferBlob.getLength(),
                                length: geomBuffView.length,
                                count: prim.geometricInfo.view.count + dstPrim.geometricInfo.view.count,
                                stride: prim.geometricInfo.view.stride
                            }
                        }, bufferBlob.addBuffer(geomBuff);
                    }
                }
                var meshStruct = {
                    vertexBundles: vertexBundles,
                    primitives: primitives,
                    minPosition: this._struct.minPosition,
                    maxPosition: this._struct.maxPosition
                };
                return meshStruct.minPosition && mesh._struct.minPosition && vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition), 
                meshStruct.maxPosition && mesh._struct.maxPosition && vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition), 
                this.assign(meshStruct, new Uint8Array(bufferBlob.getCombined())), this.initialize(), 
                !0;
            }
        }, {
            key: "validateMergingMesh",
            value: function validateMergingMesh(mesh) {
                if (!this._data && mesh._data) return !0;
                if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) return !1;
                for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                    var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                    if (bundle.attributes.length !== dstBundle.attributes.length) return !1;
                    for (var j = 0; j < bundle.attributes.length; ++j) if (bundle.attributes[j].format !== dstBundle.attributes[j].format) return !1;
                }
                if (this._struct.primitives.length !== mesh._struct.primitives.length) return !1;
                for (var _i8 = 0; _i8 < this._struct.primitives.length; ++_i8) {
                    var prim = this._struct.primitives[_i8], dstPrim = mesh._struct.primitives[_i8];
                    if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) return !1;
                    for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) return !1;
                    if (prim.primitiveMode !== dstPrim.primitiveMode) return !1;
                    if (prim.indexView) {
                        if (void 0 === dstPrim.indexView) return !1;
                    } else if (dstPrim.indexView) return !1;
                }
                return !0;
            }
        }, {
            key: "readAttribute",
            value: function readAttribute(primitiveIndex, attributeName) {
                var _this3 = this, result = null;
                return this._accessAttribute(primitiveIndex, attributeName, function(vertexBundle, iAttribute) {
                    var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), formatInfo = GFXFormatInfos[format], storageConstructor = getStorageConstructor(format), reader = getReader(inputView, format);
                    if (storageConstructor && reader) {
                        for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, storage = new storageConstructor(vertexCount * componentCount), inputStride = vertexBundle.view.stride, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                        result = storage;
                    }
                }), result;
            }
        }, {
            key: "copyAttribute",
            value: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                var _this4 = this, written = !1;
                return this._accessAttribute(primitiveIndex, attributeName, function(vertexBundle, iAttribute) {
                    var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), outputView = new DataView(buffer, offset), formatInfo = GFXFormatInfos[format], reader = getReader(inputView, format), writer = function getWriter(dataView, format) {
                        var info = GFXFormatInfos[format], stride = info.size / info.count;
                        switch (info.type) {
                          case GFXFormatType.UNORM:
                            switch (stride) {
                              case 1:
                                return function(offset, value) {
                                    return dataView.setUint8(offset, value);
                                };

                              case 2:
                                return function(offset, value) {
                                    return dataView.setUint16(offset, value, isLittleEndian);
                                };

                              case 4:
                                return function(offset, value) {
                                    return dataView.setUint32(offset, value, isLittleEndian);
                                };
                            }
                            break;

                          case GFXFormatType.SNORM:
                          case GFXFormatType.INT:
                            switch (stride) {
                              case 1:
                                return function(offset, value) {
                                    return dataView.setInt8(offset, value);
                                };

                              case 2:
                                return function(offset, value) {
                                    return dataView.setInt16(offset, value, isLittleEndian);
                                };

                              case 4:
                                return function(offset, value) {
                                    return dataView.setInt32(offset, value, isLittleEndian);
                                };
                            }
                            break;

                          case GFXFormatType.UINT:
                            switch (stride) {
                              case 1:
                                return function(offset, value) {
                                    return dataView.setUint8(offset, value);
                                };

                              case 2:
                                return function(offset, value) {
                                    return dataView.setUint16(offset, value, isLittleEndian);
                                };

                              case 4:
                                return function(offset, value) {
                                    return dataView.setUint32(offset, value, isLittleEndian);
                                };
                            }
                            break;

                          case GFXFormatType.FLOAT:
                            return function(offset, value) {
                                return dataView.setFloat32(offset, value, isLittleEndian);
                            };
                        }
                        return null;
                    }(outputView, format);
                    if (reader && writer) {
                        for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, inputStride = vertexBundle.view.stride, inputComponentByteLength = function getComponentByteLength(format) {
                            var info = GFXFormatInfos[format];
                            return info.size / info.count;
                        }(format), outputStride = stride, outputComponentByteLength = inputComponentByteLength, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                            writer(outputStride * iVertex + outputComponentByteLength * iComponent, reader(inputStride * iVertex + inputComponentByteLength * iComponent));
                        }
                        written = !0;
                    }
                }), written;
            }
        }, {
            key: "readIndices",
            value: function readIndices(primitiveIndex) {
                if (!this._data || primitiveIndex >= this._struct.primitives.length) return null;
                var primitive = this._struct.primitives[primitiveIndex];
                if (!primitive.indexView) return null;
                for (var indexCount = primitive.indexView.count, indexFormat = indexCount < 256 ? exports.GFXFormat.R8UI : indexCount < 65536 ? exports.GFXFormat.R16UI : exports.GFXFormat.R32UI, storage = new (getStorageConstructor(indexFormat))(indexCount), reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) storage[i] = reader(primitive.indexView.offset + storage.BYTES_PER_ELEMENT * i);
                return storage;
            }
        }, {
            key: "copyIndices",
            value: function copyIndices(primitiveIndex, outputArray) {
                if (!this._data || primitiveIndex >= this._struct.primitives.length) return !1;
                var primitive = this._struct.primitives[primitiveIndex];
                if (!primitive.indexView) return !1;
                for (var indexCount = primitive.indexView.count, indexFormat = 1 === primitive.indexView.stride ? exports.GFXFormat.R8UI : 2 === primitive.indexView.stride ? exports.GFXFormat.R16UI : exports.GFXFormat.R32UI, reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) outputArray[i] = reader(primitive.indexView.offset + GFXFormatInfos[indexFormat].size * i);
                return !0;
            }
        }, {
            key: "_accessAttribute",
            value: function _accessAttribute(primitiveIndex, attributeName, accessor) {
                if (this._data && !(primitiveIndex >= this._struct.primitives.length)) {
                    var _iterator7 = this._struct.primitives[primitiveIndex].vertexBundelIndices, _isArray7 = Array.isArray(_iterator7), _i9 = 0;
                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                        var _ref7;
                        if (_isArray7) {
                            if (_i9 >= _iterator7.length) break;
                            _ref7 = _iterator7[_i9++];
                        } else {
                            if ((_i9 = _iterator7.next()).done) break;
                            _ref7 = _i9.value;
                        }
                        var vertexBundleIndex = _ref7, vertexBundle = this._struct.vertexBundles[vertexBundleIndex], iAttribute = vertexBundle.attributes.findIndex(function(a) {
                            return a.name === attributeName;
                        });
                        if (!(iAttribute < 0)) {
                            accessor(vertexBundle, iAttribute);
                            break;
                        }
                    }
                }
            }
        }, {
            key: "_createVertexBuffers",
            value: function _createVertexBuffers(gfxDevice, data) {
                var _this5 = this;
                return this._struct.vertexBundles.map(function(vertexBundle) {
                    var vertexBuffer = gfxDevice.createBuffer({
                        usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: vertexBundle.view.length,
                        stride: vertexBundle.view.stride
                    }), view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                    return _this5.loaded ? vertexBuffer.update(view) : _this5.once("load", function() {
                        vertexBuffer.update(view);
                    }), vertexBuffer;
                });
            }
        }, {
            key: "renderingMesh",
            get: function get$$1() {
                return this.initialize(), this._renderingMesh;
            }
        } ]), Mesh;
    }()).prototype, "_struct", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {
                vertexBundles: [],
                primitives: []
            };
        }
    }), _descriptor2$b = _applyDecoratedDescriptor(_class2$k.prototype, "_dataLength", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$r = _class2$k)) || _class$r;
    function getOffset(attributes, attributeIndex) {
        for (var result = 0, i = 0; i < attributeIndex; ++i) {
            var attribute = attributes[i];
            result += GFXFormatInfos[attribute.format].size;
        }
        return result;
    }
    function getStorageConstructor(format) {
        var info = GFXFormatInfos[format], stride = info.size / info.count;
        switch (info.type) {
          case GFXFormatType.UNORM:
          case GFXFormatType.UINT:
            switch (stride) {
              case 1:
                return Uint8Array;

              case 2:
                return Uint16Array;

              case 4:
                return Uint32Array;
            }
            break;

          case GFXFormatType.SNORM:
          case GFXFormatType.INT:
            switch (stride) {
              case 1:
                return Int8Array;

              case 2:
                return Int16Array;

              case 4:
                return Int32Array;
            }
            break;

          case GFXFormatType.FLOAT:
            return Float32Array;
        }
        return null;
    }
    cc.Mesh = Mesh;
    var _dec$s, _dec2$a, _dec3$2, _class$s, _class2$l, _descriptor$j, _descriptor2$c, isLittleEndian = cc.sys.isLittleEndian;
    function getReader(dataView, format) {
        var info = GFXFormatInfos[format], stride = info.size / info.count;
        switch (info.type) {
          case GFXFormatType.UNORM:
            switch (stride) {
              case 1:
                return function(offset) {
                    return dataView.getUint8(offset);
                };

              case 2:
                return function(offset) {
                    return dataView.getUint16(offset, isLittleEndian);
                };

              case 4:
                return function(offset) {
                    return dataView.getUint32(offset, isLittleEndian);
                };
            }
            break;

          case GFXFormatType.SNORM:
          case GFXFormatType.INT:
            switch (stride) {
              case 1:
                return function(offset) {
                    return dataView.getInt8(offset);
                };

              case 2:
                return function(offset) {
                    return dataView.getInt16(offset, isLittleEndian);
                };

              case 4:
                return function(offset) {
                    return dataView.getInt32(offset, isLittleEndian);
                };
            }
            break;

          case GFXFormatType.UINT:
            switch (stride) {
              case 1:
                return function(offset) {
                    return dataView.getUint8(offset);
                };

              case 2:
                return function(offset) {
                    return dataView.getUint16(offset, isLittleEndian);
                };

              case 4:
                return function(offset) {
                    return dataView.getUint32(offset, isLittleEndian);
                };
            }
            break;

          case GFXFormatType.FLOAT:
            return function(offset) {
                return dataView.getFloat32(offset, isLittleEndian);
            };
        }
        return null;
    }
    var _class$t, _class2$m, _descriptor$k, _descriptor2$d, Skeleton = (_dec$s = ccclass("cc.Skeleton"), 
    _dec2$a = property([ String ]), _dec3$2 = property([ Node$1 ]), _dec$s((_descriptor$j = _applyDecoratedDescriptor((_class2$l = function(_Asset) {
        function Skeleton() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Skeleton);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Skeleton)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_joints", _descriptor$j, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_bindposes", _descriptor2$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(Skeleton, Asset), _createClass(Skeleton, [ {
            key: "bindposes",
            get: function get() {
                return this._bindposes;
            },
            set: function set(value) {
                this._bindposes = value;
            }
        }, {
            key: "joints",
            get: function get() {
                return this._joints;
            },
            set: function set(value) {
                this._joints = value;
            }
        } ]), Skeleton;
    }()).prototype, "_joints", [ _dec2$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$c = _applyDecoratedDescriptor(_class2$l.prototype, "_bindposes", [ _dec3$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$s = _class2$l)) || _class$s);
    cc.Skeleton = Skeleton;
    var _dec$u, _dec2$b, _dec3$3, _dec4$1, _class$u, _class2$n, _descriptor$l, _descriptor2$e, _descriptor3$7, _descriptor4$6, PhysicsMaterial = ccclass("cc.PhysicsMaterial")((_descriptor$k = _applyDecoratedDescriptor((_class2$m = function(_Asset) {
        function PhysicsMaterial() {
            var _this;
            return _classCallCheck(this, PhysicsMaterial), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsMaterial).call(this)), "_friction", _descriptor$k, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_restitution", _descriptor2$d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(PhysicsMaterial, Asset), _createClass(PhysicsMaterial, [ {
            key: "friction",
            get: function get() {
                return this._friction;
            },
            set: function set(value) {
                this._friction = value;
            }
        }, {
            key: "restitution",
            get: function get() {
                return this._restitution;
            },
            set: function set(value) {
                this._restitution = value;
            }
        } ]), PhysicsMaterial;
    }()).prototype, "_friction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor2$d = _applyDecoratedDescriptor(_class2$m.prototype, "_restitution", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _class$t = _class2$m)) || _class$t;
    cc.PhysicsMaterial = PhysicsMaterial;
    var AudioSourceComponent = (_dec$u = ccclass("cc.AudioSourceComponent"), _dec2$b = menu("Components/AudioSourceComponent"), 
    _dec3$3 = property(AudioClip), _dec4$1 = property({
        type: AudioClip
    }), _dec$u(_class$u = _dec2$b((_descriptor$l = _applyDecoratedDescriptor((_class2$n = function(_Component) {
        function AudioSourceComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AudioSourceComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AudioSourceComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_clip", _descriptor$l, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_loop", _descriptor2$e, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_playOnAwake", _descriptor3$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_volume", _descriptor4$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._cachedCurrentTime = 0, _this;
        }
        return _inherits(AudioSourceComponent, Component), _createClass(AudioSourceComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._syncStates(), this._playOnAwake && this.play();
            }
        }, {
            key: "play",
            value: function play() {
                this._clip && (this.playing ? this.currentTime = 0 : this._clip.play());
            }
        }, {
            key: "pause",
            value: function pause() {
                this._clip && this._clip.pause();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._clip && this._clip.stop();
            }
        }, {
            key: "playOneShot",
            value: function playOneShot(clip) {
                var volumeScale = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
                clip.playOneShot(this._volume * volumeScale);
            }
        }, {
            key: "_syncStates",
            value: function _syncStates() {
                this._clip && (this._clip.setCurrentTime(this._cachedCurrentTime), this._clip.setLoop(this._loop), 
                this._clip.setVolume(this._volume, !0), this._volume = this._clip.getVolume());
            }
        }, {
            key: "clip",
            set: function set(val) {
                this._clip = val, this._syncStates();
            },
            get: function get() {
                return this._clip;
            }
        }, {
            key: "loop",
            set: function set(val) {
                this._loop = val, this._clip && this._clip.setLoop(val);
            },
            get: function get() {
                return this._loop;
            }
        }, {
            key: "playOnAwake",
            set: function set(val) {
                this._playOnAwake = val;
            },
            get: function get() {
                return this._playOnAwake;
            }
        }, {
            key: "volume",
            set: function set(val) {
                this._clip ? (this._clip.setVolume(val), this._volume = this._clip.getVolume()) : this._volume = val;
            },
            get: function get() {
                return this._volume;
            }
        }, {
            key: "currentTime",
            set: function set(num) {
                this._cachedCurrentTime = num, this._clip && this._clip.setCurrentTime(this._cachedCurrentTime);
            },
            get: function get() {
                return this._clip ? this._clip.getCurrentTime() : this._cachedCurrentTime;
            }
        }, {
            key: "duration",
            get: function get() {
                return this._clip ? this._clip.getDuration() : 0;
            }
        }, {
            key: "state",
            get: function get() {
                return this._clip ? this._clip.state : AudioClip.PlayingState.INITIALIZING;
            }
        }, {
            key: "playing",
            get: function get() {
                return this.state === AudioClip.PlayingState.PLAYING;
            }
        } ]), AudioSourceComponent;
    }()).prototype, "_clip", [ _dec3$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$e = _applyDecoratedDescriptor(_class2$n.prototype, "_loop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$n.prototype, "_playOnAwake", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$n.prototype, "_volume", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$n.prototype, "clip", [ _dec4$1 ], Object.getOwnPropertyDescriptor(_class2$n.prototype, "clip"), _class2$n.prototype), 
    _applyDecoratedDescriptor(_class2$n.prototype, "loop", [ property ], Object.getOwnPropertyDescriptor(_class2$n.prototype, "loop"), _class2$n.prototype), 
    _applyDecoratedDescriptor(_class2$n.prototype, "playOnAwake", [ property ], Object.getOwnPropertyDescriptor(_class2$n.prototype, "playOnAwake"), _class2$n.prototype), 
    _applyDecoratedDescriptor(_class2$n.prototype, "volume", [ property ], Object.getOwnPropertyDescriptor(_class2$n.prototype, "volume"), _class2$n.prototype), 
    _class$u = _class2$n)) || _class$u) || _class$u), fastRemove$2 = array.fastRemove, _cachedArray = new Array(16), _currentHovered = null, pos = new Vec2(), _touchEvents = [ exports.SystemEventType.TOUCH_START.toString(), exports.SystemEventType.TOUCH_MOVE.toString(), exports.SystemEventType.TOUCH_END.toString(), exports.SystemEventType.TOUCH_CANCEL.toString() ], _mouseEvents = [ exports.SystemEventType.MOUSE_DOWN.toString(), exports.SystemEventType.MOUSE_ENTER.toString(), exports.SystemEventType.MOUSE_MOVE.toString(), exports.SystemEventType.MOUSE_LEAVE.toString(), exports.SystemEventType.MOUSE_UP.toString(), exports.SystemEventType.MOUSE_WHEEL.toString() ];
    function _touchStartHandler(touch, event) {
        var node = this.owner;
        return !(!node || !node.uiTransfromComp) && (touch.getUILocation(pos), !!node.uiTransfromComp.isHit(pos, this) && (event.type = exports.SystemEventType.TOUCH_START.toString(), 
        event.touch = touch, event.bubbles = !0, node.dispatchEvent(event), !0));
    }
    function _touchMoveHandler(touch, event) {
        var node = this.owner;
        if (!node || !node.uiTransfromComp) return !1;
        event.type = exports.SystemEventType.TOUCH_MOVE.toString(), event.touch = touch, 
        event.bubbles = !0, node.dispatchEvent(event);
    }
    function _touchEndHandler(touch, event) {
        var node = this.owner;
        node && node.uiTransfromComp && (touch.getUILocation(pos), node.uiTransfromComp.isHit(pos, this) ? event.type = exports.SystemEventType.TOUCH_END.toString() : event.type = exports.SystemEventType.TOUCH_CANCEL.toString(), 
        event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
    }
    function _touchCancelHandler(touch, event) {
        var node = this.owner;
        node && node.uiTransfromComp && (event.type = exports.SystemEventType.TOUCH_CANCEL.toString(), 
        event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
    }
    function _mouseDownHandler(event) {
        var node = this.owner;
        node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_DOWN.toString(), 
        event.bubbles = !0, node.dispatchEvent(event)));
    }
    function _mouseMoveHandler(event) {
        var node = this.owner;
        if (node && node.uiTransfromComp) {
            if (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this)) this._previousIn || (_currentHovered && _currentHovered.eventProcessor.mouseListener && (event.type = exports.SystemEventType.MOUSE_LEAVE, 
            _currentHovered.dispatchEvent(event), _currentHovered.eventProcessor.mouseListener && (_currentHovered.eventProcessor.mouseListener._previousIn = !1)), 
            _currentHovered = node, event.type = exports.SystemEventType.MOUSE_ENTER.toString(), 
            node.dispatchEvent(event), this._previousIn = !0), event.type = exports.SystemEventType.MOUSE_MOVE.toString(), 
            event.bubbles = !0, node.dispatchEvent(event); else {
                if (!this._previousIn) return;
                event.type = exports.SystemEventType.MOUSE_LEAVE.toString(), node.dispatchEvent(event), 
                this._previousIn = !1, _currentHovered = null;
            }
            event.propagationStopped = !0;
        }
    }
    function _mouseUpHandler(event) {
        var node = this.owner;
        node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_UP.toString(), 
        event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
    }
    function _mouseWheelHandler(event) {
        var node = this.owner;
        node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_WHEEL.toString(), 
        event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
    }
    function _searchMaskInParent(node) {
        var Mask = cc.MaskComponent;
        if (Mask) for (var index = 0, curr = node; curr && Node$1.isNode(curr); curr = curr.parent, 
        ++index) if (curr.getComponent(Mask)) return {
            index: index,
            node: curr
        };
        return null;
    }
    function _checkListeners(node, events) {
        if (node._persistNode) return !0;
        var i = 0;
        if (node.eventProcessor.bubblingTargets) for (;i < events.length; ++i) if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) return !0;
        if (node.eventProcessor.capturingTargets) for (;i < events.length; ++i) if (node.eventProcessor.capturingTargets.hasEventListener(events[i])) return !0;
        return !1;
    }
    var NodeEventProcessor = function() {
        function NodeEventProcessor(node) {
            _classCallCheck(this, NodeEventProcessor), this.bubblingTargets = null, this.capturingTargets = null, 
            this.touchListener = null, this.mouseListener = null, this._node = void 0, this._node = node;
        }
        return _createClass(NodeEventProcessor, [ {
            key: "node",
            get: function get$$1() {
                return this._node;
            }
        } ]), _createClass(NodeEventProcessor, [ {
            key: "on",
            value: function on(type, callback, target, useCapture) {
                return this._checknSetupSysEvent(type) ? this._onDispatch(type, callback, target, useCapture) : (this.bubblingTargets || (this.bubblingTargets = new EventTarget()), 
                this.bubblingTargets.on(type, callback, target));
            }
        }, {
            key: "once",
            value: function once(type, callback, target, useCapture) {
                (this._checknSetupSysEvent(type) && useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget() : this.bubblingTargets = this.bubblingTargets || new EventTarget()).once(type, callback, target);
            }
        }, {
            key: "off",
            value: function off(type, callback, target, useCapture) {
                var touchEvent = -1 !== _touchEvents.indexOf(type), mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
                touchEvent || mouseEvent ? (this._offDispatch(type, callback, target, useCapture), 
                touchEvent ? this.touchListener && !_checkListeners(this._node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
                this.touchListener = null) : mouseEvent && this.mouseListener && !_checkListeners(this._node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
                this.mouseListener = null)) : this.bubblingTargets && this.bubblingTargets.off(type, callback, target);
            }
        }, {
            key: "emit",
            value: function emit(type) {
                if (this.bubblingTargets) {
                    for (var _this$bubblingTargets, _len = arguments.length, args = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    (_this$bubblingTargets = this.bubblingTargets).emit.apply(_this$bubblingTargets, [ type ].concat(args));
                }
            }
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                !function _doDispatchEvent(owner, event) {
                    var target, i = 0;
                    for (event.target = owner, _cachedArray.length = 0, owner.eventProcessor.getCapturingTargets(event.type, _cachedArray), 
                    event.eventPhase = 1, i = _cachedArray.length - 1; 0 <= i; --i) if ((target = _cachedArray[i]).eventProcessor.capturingTargets && ((event.currentTarget = target).eventProcessor.capturingTargets.emit(event.type, event, _cachedArray), 
                    event.propagationStopped)) return void (_cachedArray.length = 0);
                    if (_cachedArray.length = 0, event.eventPhase = 2, (event.currentTarget = owner).eventProcessor.capturingTargets && owner.eventProcessor.capturingTargets.emit(event.type, event), 
                    !event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets && owner.eventProcessor.bubblingTargets.emit(event.type, event), 
                    !event.propagationStopped && event.bubbles) for (owner.eventProcessor.getBubblingTargets(event.type, _cachedArray), 
                    event.eventPhase = 3, i = 0; i < _cachedArray.length; ++i) if ((target = _cachedArray[i]).eventProcessor.bubblingTargets && ((event.currentTarget = target).eventProcessor.bubblingTargets.emit(event.type, event), 
                    event.propagationStopped)) return void (_cachedArray.length = 0);
                    _cachedArray.length = 0;
                }(this._node, event), _cachedArray.length = 0;
            }
        }, {
            key: "hasEventListener",
            value: function hasEventListener(type) {
                var has = !1;
                return this.bubblingTargets && (has = this.bubblingTargets.hasEventListener(type)), 
                !has && this.capturingTargets && (has = this.capturingTargets.hasEventListener(type)), 
                has;
            }
        }, {
            key: "targetOff",
            value: function targetOff(target) {
                this.capturingTargets && this.capturingTargets.targetOff(target), this.bubblingTargets && this.bubblingTargets.targetOff(target), 
                this.touchListener && !_checkListeners(this.node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
                this.touchListener = null), this.mouseListener && !_checkListeners(this.node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
                this.mouseListener = null);
            }
        }, {
            key: "getCapturingTargets",
            value: function getCapturingTargets(type, targets) {
                for (var parent = this._node.parent; parent; ) parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type) && targets.push(parent), 
                parent = parent.parent;
            }
        }, {
            key: "getBubblingTargets",
            value: function getBubblingTargets(type, targets) {
                for (var parent = this._node.parent; parent; ) parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type) && targets.push(parent), 
                parent = parent.parent;
            }
        }, {
            key: "_checknSetupSysEvent",
            value: function _checknSetupSysEvent(type) {
                var _this = this, newAdded = !1, forDispatch = !1;
                return -1 !== _touchEvents.indexOf(type) ? (this.touchListener || (this.touchListener = cc.EventListener.create({
                    event: cc.EventListener.TOUCH_ONE_BY_ONE,
                    swallowTouches: !0,
                    owner: this._node,
                    mask: _searchMaskInParent(this._node),
                    onTouchBegan: _touchStartHandler,
                    onTouchMoved: _touchMoveHandler,
                    onTouchEnded: _touchEndHandler,
                    onTouchCancelled: _touchCancelHandler
                }), eventManager.addListener(this.touchListener, this._node), newAdded = !0), forDispatch = !0) : -1 !== _mouseEvents.indexOf(type) && (this.mouseListener || (this.mouseListener = cc.EventListener.create({
                    event: cc.EventListener.MOUSE,
                    _previousIn: !1,
                    owner: this._node,
                    mask: _searchMaskInParent(this._node),
                    onMouseDown: _mouseDownHandler,
                    onMouseMove: _mouseMoveHandler,
                    onMouseUp: _mouseUpHandler,
                    onMouseScroll: _mouseWheelHandler
                }), eventManager.addListener(this.mouseListener, this._node), newAdded = !0), forDispatch = !0), 
                newAdded && !this._node.activeInHierarchy && cc.director.getScheduler().schedule(function() {
                    _this._node.activeInHierarchy || eventManager.pauseTarget(_this._node);
                }, this._node, 0, 0, 0, !1), forDispatch;
            }
        }, {
            key: "_onDispatch",
            value: function _onDispatch(type, callback, target, useCapture) {
                if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
                callback) {
                    var listeners = null;
                    if (!(listeners = useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget() : this.bubblingTargets = this.bubblingTargets || new EventTarget()).hasEventListener(type, callback, target)) {
                        listeners.on(type, callback, target);
                        var targetImpl = target;
                        target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                    }
                    return callback;
                }
                cc.errorID(6800);
            }
        }, {
            key: "_offDispatch",
            value: function _offDispatch(type, callback, target, useCapture) {
                if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
                callback) {
                    var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;
                    if (listeners) {
                        listeners.off(type, callback, target);
                        var targetImpl = target;
                        target && (targetImpl.__eventTargets ? fastRemove$2(targetImpl.__eventTargets, this) : targetImpl.node && targetImpl.node.__eventTargets && fastRemove$2(targetImpl.node.__eventTargets, this));
                    }
                } else this.capturingTargets && this.capturingTargets.removeAll(type), this.bubblingTargets && this.bubblingTargets.removeAll(type);
            }
        } ]), NodeEventProcessor;
    }();
    cc.NodeEventProcessor = NodeEventProcessor;
    var _dec$v, _dec2$c, _dec3$4, _dec4$2, _class$v, _class2$o, _descriptor$m, _descriptor2$f, _descriptor3$8, _dec5$1, _dec6$1, _dec7$1, _dec8, _dec9, _class4, _class5, _descriptor4$7, _descriptor5$5, _descriptor6$2, _dec10, _dec11, _dec12, _dec13, _dec14, _class7, _class8, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10$1, _dec15, _dec16, _dec17, _dec18, _class10, _class11, _descriptor11, _descriptor12, _descriptor13, Ambient = function() {
        function Ambient(scene) {
            _classCallCheck(this, Ambient), this._enabled = !0, this._skyColor = Float32Array.from([ .2, .5, .8, 1 ]), 
            this._skyIllum = Ambient.SKY_ILLUM, this._groundAlbedo = Float32Array.from([ .2, .2, .2, 1 ]), 
            this._scene = void 0, this._scene = scene;
        }
        return _createClass(Ambient, [ {
            key: "enabled",
            set: function set(val) {
                this._enabled = val;
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "skyColor",
            get: function get() {
                return this._skyColor;
            },
            set: function set(color) {
                this._skyColor = color;
            }
        }, {
            key: "skyIllum",
            set: function set(illum) {
                this._skyIllum = illum;
            },
            get: function get() {
                return this._skyIllum;
            }
        }, {
            key: "groundAlbedo",
            get: function get() {
                return this._groundAlbedo;
            },
            set: function set(color) {
                this._groundAlbedo = color;
            }
        } ]), _createClass(Ambient, [ {
            key: "update",
            value: function update() {}
        } ]), Ambient;
    }();
    Ambient.SUN_ILLUM = 65e3, Ambient.SKY_ILLUM = 2e4;
    var _up = new Vec3(0, 1, 0), _v3 = new Vec3(), _qt = new Quat(), AmbientInfo = (_dec$v = ccclass("cc.AmbientInfo"), 
    _dec2$c = property({
        type: Color
    }), _dec3$4 = property({
        type: Number
    }), _dec4$2 = property({
        type: Color
    }), _dec$v((_descriptor$m = _applyDecoratedDescriptor((_class2$o = function() {
        function AmbientInfo() {
            _classCallCheck(this, AmbientInfo), _initializerDefineProperty(this, "_skyColor", _descriptor$m, this), 
            _initializerDefineProperty(this, "_skyIllum", _descriptor2$f, this), _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$8, this), 
            this._resource = null;
        }
        return _createClass(AmbientInfo, [ {
            key: "skyColor",
            set: function set(val) {
                this._skyColor.set(val), this._resource && color4.array(this._resource.skyColor, this.skyColor);
            },
            get: function get() {
                return this._skyColor;
            }
        }, {
            key: "skyIllum",
            set: function set(val) {
                this._skyIllum = val, this._resource && (this._resource.skyIllum = this.skyIllum);
            },
            get: function get() {
                return this._skyIllum;
            }
        }, {
            key: "groundAlbedo",
            set: function set(val) {
                this._groundAlbedo.set(val), this._resource && color4.array(this._resource.groundAlbedo, this.groundAlbedo);
            },
            get: function get() {
                return this._groundAlbedo;
            }
        }, {
            key: "renderScene",
            set: function set(rs) {
                this._resource = rs.ambient, this.skyColor = this._skyColor, this.skyIllum = this._skyIllum, 
                this.groundAlbedo = this._groundAlbedo;
            }
        } ]), AmbientInfo;
    }()).prototype, "_skyColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(51, 128, 204, 1);
        }
    }), _descriptor2$f = _applyDecoratedDescriptor(_class2$o.prototype, "_skyIllum", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Ambient.SKY_ILLUM;
        }
    }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$o.prototype, "_groundAlbedo", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(51, 51, 51, 255);
        }
    }), _applyDecoratedDescriptor(_class2$o.prototype, "skyColor", [ _dec2$c ], Object.getOwnPropertyDescriptor(_class2$o.prototype, "skyColor"), _class2$o.prototype), 
    _applyDecoratedDescriptor(_class2$o.prototype, "skyIllum", [ _dec3$4 ], Object.getOwnPropertyDescriptor(_class2$o.prototype, "skyIllum"), _class2$o.prototype), 
    _applyDecoratedDescriptor(_class2$o.prototype, "groundAlbedo", [ _dec4$2 ], Object.getOwnPropertyDescriptor(_class2$o.prototype, "groundAlbedo"), _class2$o.prototype), 
    _class$v = _class2$o)) || _class$v);
    cc.AmbientInfo = AmbientInfo;
    var SkyboxInfo = (_dec5$1 = ccclass("cc.SkyboxInfo"), _dec6$1 = property(TextureCube), 
    _dec7$1 = property({
        type: Boolean
    }), _dec8 = property({
        type: TextureCube
    }), _dec9 = property({
        type: Boolean
    }), _dec5$1((_descriptor4$7 = _applyDecoratedDescriptor((_class5 = function() {
        function SkyboxInfo() {
            _classCallCheck(this, SkyboxInfo), _initializerDefineProperty(this, "_cubemap", _descriptor4$7, this), 
            _initializerDefineProperty(this, "_isRGBE", _descriptor5$5, this), _initializerDefineProperty(this, "_enabled", _descriptor6$2, this), 
            this._resource = null;
        }
        return _createClass(SkyboxInfo, [ {
            key: "enabled",
            set: function set(val) {
                this._enabled = val, this._resource && (this._resource.enabled = this._enabled);
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "cubemap",
            set: function set(val) {
                this._cubemap = val, this._resource && (this._resource.cubemap = this._cubemap);
            },
            get: function get() {
                return this._cubemap;
            }
        }, {
            key: "isRGBE",
            set: function set(val) {
                this._isRGBE = val, this._resource && (this._resource.isRGBE = this._isRGBE);
            },
            get: function get() {
                return this._isRGBE;
            }
        }, {
            key: "renderScene",
            set: function set(val) {
                this._resource = val.skybox, this.isRGBE = this._isRGBE, this.cubemap = this._cubemap, 
                this.enabled = this._enabled;
            }
        } ]), SkyboxInfo;
    }()).prototype, "_cubemap", [ _dec6$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor5$5 = _applyDecoratedDescriptor(_class5.prototype, "_isRGBE", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor6$2 = _applyDecoratedDescriptor(_class5.prototype, "_enabled", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class5.prototype, "enabled", [ _dec7$1 ], Object.getOwnPropertyDescriptor(_class5.prototype, "enabled"), _class5.prototype), 
    _applyDecoratedDescriptor(_class5.prototype, "cubemap", [ _dec8 ], Object.getOwnPropertyDescriptor(_class5.prototype, "cubemap"), _class5.prototype), 
    _applyDecoratedDescriptor(_class5.prototype, "isRGBE", [ _dec9 ], Object.getOwnPropertyDescriptor(_class5.prototype, "isRGBE"), _class5.prototype), 
    _class4 = _class5)) || _class4);
    cc.SkyboxInfo = SkyboxInfo;
    var PlanarShadowInfo = (_dec10 = ccclass("cc.PlanarShadowInfo"), _dec11 = property({
        type: Boolean
    }), _dec12 = property({
        type: Vec3
    }), _dec13 = property({
        type: Number
    }), _dec14 = property({
        type: Color
    }), _dec10((_descriptor7$1 = _applyDecoratedDescriptor((_class8 = function() {
        function PlanarShadowInfo() {
            _classCallCheck(this, PlanarShadowInfo), _initializerDefineProperty(this, "_enabled", _descriptor7$1, this), 
            _initializerDefineProperty(this, "_normal", _descriptor8$1, this), _initializerDefineProperty(this, "_distance", _descriptor9$1, this), 
            _initializerDefineProperty(this, "_shadowColor", _descriptor10$1, this), this._resource = null;
        }
        return _createClass(PlanarShadowInfo, [ {
            key: "setPlaneFromNode",
            value: function setPlaneFromNode(node) {
                node.getWorldRotation(_qt), this.normal = vec3.transformQuat(_v3, _up, _qt), node.getWorldPosition(_v3), 
                this.distance = vec3.dot(this._normal, _v3);
            }
        }, {
            key: "enabled",
            set: function set(val) {
                this._enabled = val, this._resource && (this._resource.enabled = val);
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "normal",
            set: function set(val) {
                vec3.copy(this._normal, val), this._resource && (this._resource.normal = val);
            },
            get: function get() {
                return this._normal;
            }
        }, {
            key: "distance",
            set: function set(val) {
                this._distance = val, this._resource && (this._resource.distance = val);
            },
            get: function get() {
                return this._distance;
            }
        }, {
            key: "shadowColor",
            set: function set(val) {
                this._shadowColor.set(val), this._resource && (this._resource.shadowColor = val);
            },
            get: function get() {
                return this._shadowColor;
            }
        }, {
            key: "renderScene",
            set: function set(val) {
                this._resource = val.planarShadow, this.normal = this._normal, this.distance = this._distance, 
                this.shadowColor = this._shadowColor, this.enabled = this._enabled;
            }
        } ]), PlanarShadowInfo;
    }()).prototype, "_enabled", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor8$1 = _applyDecoratedDescriptor(_class8.prototype, "_normal", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 1, 0);
        }
    }), _descriptor9$1 = _applyDecoratedDescriptor(_class8.prototype, "_distance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$1 = _applyDecoratedDescriptor(_class8.prototype, "_shadowColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(76, 76, 76, 255);
        }
    }), _applyDecoratedDescriptor(_class8.prototype, "enabled", [ _dec11 ], Object.getOwnPropertyDescriptor(_class8.prototype, "enabled"), _class8.prototype), 
    _applyDecoratedDescriptor(_class8.prototype, "normal", [ _dec12 ], Object.getOwnPropertyDescriptor(_class8.prototype, "normal"), _class8.prototype), 
    _applyDecoratedDescriptor(_class8.prototype, "distance", [ _dec13 ], Object.getOwnPropertyDescriptor(_class8.prototype, "distance"), _class8.prototype), 
    _applyDecoratedDescriptor(_class8.prototype, "shadowColor", [ _dec14 ], Object.getOwnPropertyDescriptor(_class8.prototype, "shadowColor"), _class8.prototype), 
    _class7 = _class8)) || _class7);
    cc.PlanarShadowInfo = PlanarShadowInfo;
    var _class$w, _class2$p, _descriptor$n, _descriptor2$g, SceneGlobals = (_dec15 = ccclass("cc.SceneGlobals"), 
    _dec16 = property({
        type: AmbientInfo
    }), _dec17 = property({
        type: SkyboxInfo
    }), _dec18 = property({
        type: PlanarShadowInfo
    }), _dec15((_descriptor11 = _applyDecoratedDescriptor((_class11 = function() {
        function SceneGlobals() {
            _classCallCheck(this, SceneGlobals), _initializerDefineProperty(this, "ambient", _descriptor11, this), 
            _initializerDefineProperty(this, "skybox", _descriptor12, this), _initializerDefineProperty(this, "planarShadow", _descriptor13, this);
        }
        return _createClass(SceneGlobals, [ {
            key: "renderScene",
            set: function set(rs) {
                this.ambient.renderScene = rs, this.skybox.renderScene = rs, this.planarShadow.renderScene = rs;
            }
        } ]), SceneGlobals;
    }()).prototype, "ambient", [ _dec16 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AmbientInfo();
        }
    }), _descriptor12 = _applyDecoratedDescriptor(_class11.prototype, "skybox", [ _dec17 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new SkyboxInfo();
        }
    }), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "planarShadow", [ _dec18 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new PlanarShadowInfo();
        }
    }), _class10 = _class11)) || _class10);
    cc.SceneGlobals = SceneGlobals;
    var _class$x, Scene = ccclass("cc.Scene")((_descriptor$n = _applyDecoratedDescriptor((_class2$p = function(_Node) {
        function Scene(name) {
            var _this;
            return _classCallCheck(this, Scene), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, name)), "autoReleaseAssets", _descriptor$n, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_globals", _descriptor2$g, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._renderScene = null, _this.dependAssets = null, _this._inited = !cc.game._isCloning, 
            _this._prefabSyncedInLiveReload = !1, _this._activeInHierarchy = !1, cc.director && cc.director.root && (_this._renderScene = cc.director.root.createScene({})), 
            _this;
        }
        return _inherits(Scene, Node$1), _createClass(Scene, [ {
            key: "renderScene",
            get: function get$$1() {
                return this._renderScene;
            }
        }, {
            key: "globals",
            get: function get$$1() {
                return this._globals;
            }
        } ]), _createClass(Scene, [ {
            key: "destroy",
            value: function destroy() {
                var success = _get(_getPrototypeOf(Scene.prototype), "destroy", this).call(this);
                return cc.director.root.destroyScene(this._renderScene), this._activeInHierarchy = !1, 
                success;
            }
        }, {
            key: "_onHierarchyChanged",
            value: function _onHierarchyChanged() {}
        }, {
            key: "_instantiate",
            value: function _instantiate() {}
        }, {
            key: "_load",
            value: function _load() {
                this._inited || (this._onBatchCreated(), this._inited = !0), this.walk(BaseNode._setScene), 
                this._globals.renderScene = this._renderScene;
            }
        }, {
            key: "_activate",
            value: function _activate(active) {
                active = !1 !== active, cc.director._nodeActivator.activateNode(this, active);
            }
        } ]), Scene;
    }()).prototype, "autoReleaseAssets", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$g = _applyDecoratedDescriptor(_class2$p.prototype, "_globals", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new SceneGlobals();
        }
    }), _class$w = _class2$p)) || _class$w;
    function find(path, referenceNode) {
        if (referenceNode) 0; else {
            var scene = cc.director.getScene();
            if (!scene) return null;
            referenceNode = scene;
        }
        return referenceNode.getChildByPath(path);
    }
    cc.Scene = Scene, cc.find = find;
    var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy, PrivateNode = ccclass("cc.PrivateNode")(_class$x = function(_Node) {
        function PrivateNode(name) {
            var _this;
            return _classCallCheck(this, PrivateNode), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PrivateNode).call(this, name)))._objFlags |= HideInHierarchy$1, 
            _this;
        }
        return _inherits(PrivateNode, Node$1), PrivateNode;
    }()) || _class$x;
    cc.PrivateNode = PrivateNode;
    array.fastRemoveAt;
    var IsStartCalled$1 = CCObject.Flags.IsStartCalled, IsOnEnableCalled$2 = CCObject.Flags.IsOnEnableCalled, callStart = (CCObject.Flags.IsEditorOnEnableCalled, 
    "c.start();c._objFlags|=" + IsStartCalled$1);
    function sortedIndex(array$$1, comp) {
        for (var order = comp.constructor._executionOrder, id = comp._id, l = 0, h = array$$1.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
            var test = array$$1[m], testOrder = test.constructor._executionOrder;
            if (order < testOrder) h = m - 1; else if (testOrder < order) l = m + 1; else {
                var testId = test._id;
                if (id < testId) h = m - 1; else {
                    if (!(testId < id)) return m;
                    l = m + 1;
                }
            }
        }
        return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
        for (var array$$1 = iterator.array, next = iterator.i + 1; next < array$$1.length; ) {
            var comp = array$$1[next];
            comp._enabled && comp.node._activeInHierarchy ? ++next : (iterator.removeAt(next), 
            flagToClear && (comp._objFlags &= ~flagToClear));
        }
    }
    var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
        _classCallCheck(this, LifeCycleInvoker), this._zero = void 0, this._neg = void 0, 
        this._pos = void 0, this._invoke = void 0;
        var Iterator = MutableForwardIterator;
        this._zero = new Iterator([]), this._neg = new Iterator([]), this._pos = new Iterator([]), 
        this._invoke = invokeFunc;
    };
    function compareOrder(a, b) {
        return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;
    var OneOffInvoker = function(_LifeCycleInvoker) {
        function OneOffInvoker() {
            return _classCallCheck(this, OneOffInvoker), _possibleConstructorReturn(this, _getPrototypeOf(OneOffInvoker).apply(this, arguments));
        }
        return _inherits(OneOffInvoker, LifeCycleInvoker), _createClass(OneOffInvoker, [ {
            key: "add",
            value: function add(comp) {
                var order = comp.constructor._executionOrder;
                (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
            }
        }, {
            key: "remove",
            value: function remove$$1(comp) {
                var order = comp.constructor._executionOrder;
                (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
            }
        }, {
            key: "cancelInactive",
            value: function cancelInactive(flagToClear) {
                stableRemoveInactive(this._zero, flagToClear), stableRemoveInactive(this._neg, flagToClear), 
                stableRemoveInactive(this._pos, flagToClear);
            }
        }, {
            key: "invoke",
            value: function invoke() {
                var compsNeg = this._neg;
                0 < compsNeg.array.length && (compsNeg.array.sort(compareOrder), this._invoke(compsNeg), 
                compsNeg.array.length = 0), this._invoke(this._zero), this._zero.array.length = 0;
                var compsPos = this._pos;
                0 < compsPos.array.length && (compsPos.array.sort(compareOrder), this._invoke(compsPos), 
                compsPos.array.length = 0);
            }
        } ]), OneOffInvoker;
    }(), ReusableInvoker = function(_LifeCycleInvoker2) {
        function ReusableInvoker() {
            return _classCallCheck(this, ReusableInvoker), _possibleConstructorReturn(this, _getPrototypeOf(ReusableInvoker).apply(this, arguments));
        }
        return _inherits(ReusableInvoker, LifeCycleInvoker), _createClass(ReusableInvoker, [ {
            key: "add",
            value: function add(comp) {
                var order = comp.constructor._executionOrder;
                if (0 === order) this._zero.array.push(comp); else {
                    var array$$1 = order < 0 ? this._neg.array : this._pos.array, i = sortedIndex(array$$1, comp);
                    i < 0 && array$$1.splice(~i, 0, comp);
                }
            }
        }, {
            key: "remove",
            value: function remove$$1(comp) {
                var order = comp.constructor._executionOrder;
                if (0 === order) this._zero.fastRemove(comp); else {
                    var iterator = order < 0 ? this._neg : this._pos, i = sortedIndex(iterator.array, comp);
                    0 <= i && iterator.removeAt(i);
                }
            }
        }, {
            key: "invoke",
            value: function invoke(dt) {
                0 < this._neg.array.length && this._invoke(this._neg, dt), this._invoke(this._zero, dt), 
                0 < this._pos.array.length && this._invoke(this._pos, dt);
            }
        } ]), ReusableInvoker;
    }();
    function createInvokeImpl(funcOrCode, useDt) {
        if ("function" == typeof funcOrCode) return useDt ? function(iterator, dt) {
            var array$$1 = iterator.array;
            for (iterator.i = 0; iterator.i < array$$1.length; ++iterator.i) {
                var comp = array$$1[iterator.i];
                funcOrCode(comp, dt);
            }
        } : function(iterator) {
            var array$$1 = iterator.array;
            for (iterator.i = 0; iterator.i < array$$1.length; ++iterator.i) {
                var comp = array$$1[iterator.i];
                funcOrCode(comp);
            }
        };
        var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
        return useDt ? Function("it", "dt", body) : Function("it", body);
    }
    var ComponentScheduler = function() {
        function ComponentScheduler() {
            _classCallCheck(this, ComponentScheduler), this.startInvoker = void 0, this.updateInvoker = void 0, 
            this.lateUpdateInvoker = void 0, this.scheduleInNextFrame = void 0, this._updating = void 0, 
            this.unscheduleAll();
        }
        return _createClass(ComponentScheduler, [ {
            key: "unscheduleAll",
            value: function unscheduleAll() {
                this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart)), this.updateInvoker = new ReusableInvoker(createInvokeImpl("c.update(dt)", !0)), 
                this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl("c.lateUpdate(dt)", !0)), 
                this.scheduleInNextFrame = [], this._updating = !1;
            }
        }, {
            key: "_onEnabled",
            value: function _onEnabled(comp) {
                cc.director.getScheduler().resumeTarget(comp), comp._objFlags |= IsOnEnableCalled$2, 
                this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
            }
        }, {
            key: "_onDisabled",
            value: function _onDisabled(comp) {
                cc.director.getScheduler().pauseTarget(comp), comp._objFlags &= ~IsOnEnableCalled$2;
                var index = this.scheduleInNextFrame.indexOf(comp);
                0 <= index ? array.fastRemoveAt(this.scheduleInNextFrame, index) : (!comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.remove(comp), 
                comp.update && this.updateInvoker.remove(comp), comp.lateUpdate && this.lateUpdateInvoker.remove(comp));
            }
        }, {
            key: "enableComp",
            value: function enableComp(comp, invoker) {
                if (!(comp._objFlags & IsOnEnableCalled$2)) {
                    if (comp.onEnable) {
                        if (invoker) return void invoker.add(comp);
                        if (comp.onEnable(), !comp.node._activeInHierarchy) return;
                    }
                    this._onEnabled(comp);
                }
            }
        }, {
            key: "disableComp",
            value: function disableComp(comp) {
                comp._objFlags & IsOnEnableCalled$2 && (comp.onDisable && comp.onDisable(), this._onDisabled(comp));
            }
        }, {
            key: "startPhase",
            value: function startPhase() {
                this._updating = !0, 0 < this.scheduleInNextFrame.length && this._deferredSchedule(), 
                this.startInvoker.invoke();
            }
        }, {
            key: "updatePhase",
            value: function updatePhase(dt) {
                this.updateInvoker.invoke(dt);
            }
        }, {
            key: "lateUpdatePhase",
            value: function lateUpdatePhase(dt) {
                this.lateUpdateInvoker.invoke(dt), this._updating = !1;
            }
        }, {
            key: "_scheduleImmediate",
            value: function _scheduleImmediate(comp) {
                !comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.add(comp), 
                comp.update && this.updateInvoker.add(comp), comp.lateUpdate && this.lateUpdateInvoker.add(comp);
            }
        }, {
            key: "_deferredSchedule",
            value: function _deferredSchedule() {
                for (var comps = this.scheduleInNextFrame, i = 0, len = comps.length; i < len; i++) {
                    var comp = comps[i];
                    this._scheduleImmediate(comp);
                }
                comps.length = 0;
            }
        } ]), ComponentScheduler;
    }();
    ComponentScheduler.LifeCycleInvoker = LifeCycleInvoker, ComponentScheduler.OneOffInvoker = OneOffInvoker, 
    ComponentScheduler.createInvokeImpl = createInvokeImpl, ComponentScheduler.invokeOnEnable = function(iterator) {
        var compScheduler = cc.director._compScheduler, array$$1 = iterator.array;
        for (iterator.i = 0; iterator.i < array$$1.length; ++iterator.i) {
            var comp = array$$1[iterator.i];
            if (comp._enabled) comp.onEnable(), !comp.node._activeInHierarchy || compScheduler._onEnabled(comp);
        }
    };
    var IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted, IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted, IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled, Deactivating$2 = CCObject.Flags.Deactivating, callOnLoad = "c.onLoad();c._objFlags|=" + IsOnLoadCalled$2, UnsortedInvoker = function(_ComponentScheduler$L) {
        function UnsortedInvoker() {
            return _classCallCheck(this, UnsortedInvoker), _possibleConstructorReturn(this, _getPrototypeOf(UnsortedInvoker).apply(this, arguments));
        }
        return _inherits(UnsortedInvoker, ComponentScheduler.LifeCycleInvoker), _createClass(UnsortedInvoker, [ {
            key: "add",
            value: function add(comp) {
                this._zero.array.push(comp);
            }
        }, {
            key: "remove",
            value: function remove(comp) {
                this._zero.fastRemove(comp);
            }
        }, {
            key: "cancelInactive",
            value: function cancelInactive(flagToClear) {
                ComponentScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
            }
        }, {
            key: "invoke",
            value: function invoke() {
                this._invoke(this._zero), this._zero.array.length = 0;
            }
        } ]), UnsortedInvoker;
    }(), invokePreload = ComponentScheduler.createInvokeImpl("c.__preload();"), invokeOnLoad = ComponentScheduler.createInvokeImpl(callOnLoad), activateTasksPool = new Pool(4);
    function _componentCorrupted(node, comp, index) {
        comp ? node._removeComponent(comp) : array.removeAt(node._components, index);
    }
    activateTasksPool.get = function getActivateTask() {
        var task = this._get() || {
            preload: new UnsortedInvoker(invokePreload),
            onLoad: new ComponentScheduler.OneOffInvoker(invokeOnLoad),
            onEnable: new ComponentScheduler.OneOffInvoker(ComponentScheduler.invokeOnEnable)
        };
        task.preload._zero.i = -1;
        var invoker = task.onLoad;
        return invoker._zero.i = -1, invoker._neg.i = -1, invoker._pos.i = -1, (invoker = task.onEnable)._zero.i = -1, 
        invoker._neg.i = -1, invoker._pos.i = -1, task;
    };
    var _typeMap2, _keyMap, NodeActivator = function() {
        function NodeActivator() {
            _classCallCheck(this, NodeActivator), this.resetComp = void 0, this._activatingStack = void 0, 
            this.reset();
        }
        return _createClass(NodeActivator, [ {
            key: "reset",
            value: function reset() {
                this._activatingStack = [];
            }
        }, {
            key: "activateNode",
            value: function activateNode(node, active) {
                if (active) {
                    var task = activateTasksPool.get();
                    this._activatingStack.push(task), this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable), 
                    task.preload.invoke(), task.onLoad.invoke(), task.onEnable.invoke(), this._activatingStack.pop(), 
                    activateTasksPool.put(task);
                } else {
                    this._deactivateNodeRecursively(node);
                    var _iterator = this._activatingStack, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var lastTask = _ref;
                        lastTask.preload.cancelInactive(IsPreloadStarted$1), lastTask.onLoad.cancelInactive(IsOnLoadStarted$1), 
                        lastTask.onEnable.cancelInactive();
                    }
                }
                node.emit("active-in-hierarchy-changed", node);
            }
        }, {
            key: "activateComp",
            value: function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (comp._objFlags & IsPreloadStarted$1 || (comp._objFlags |= IsPreloadStarted$1, 
                comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload())), 
                comp._objFlags & IsOnLoadStarted$1 || (comp._objFlags |= IsOnLoadStarted$1, comp.onLoad ? onLoadInvoker ? onLoadInvoker.add(comp) : (comp.onLoad(), 
                comp._objFlags |= IsOnLoadCalled$2) : comp._objFlags |= IsOnLoadCalled$2), comp._enabled) {
                    if (!comp.node._activeInHierarchy) return;
                    cc.director._compScheduler.enableComp(comp, onEnableInvoker);
                }
            }
        }, {
            key: "destroyComp",
            value: function destroyComp(comp) {
                cc.director._compScheduler.disableComp(comp), comp.onDestroy && comp._objFlags & IsOnLoadCalled$2 && comp.onDestroy();
            }
        }, {
            key: "_activateNodeRecursively",
            value: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (node._objFlags & Deactivating$2) cc.errorID(3816, node.name); else {
                    node._activeInHierarchy = !0;
                    for (var originCount = node._components.length, i = 0; i < originCount; ++i) {
                        var component = node._components[i];
                        component instanceof cc.Component ? this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker) : (_componentCorrupted(node, component, i), 
                        --i, --originCount);
                    }
                    for (var _i2 = 0, len = node._children.length; _i2 < len; ++_i2) {
                        var child = node._children[_i2];
                        child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                    }
                    node._onPostActivated(!0);
                }
            }
        }, {
            key: "_deactivateNodeRecursively",
            value: function _deactivateNodeRecursively(node) {
                node._objFlags |= Deactivating$2, node._activeInHierarchy = !1;
                for (var originCount = node._components.length, c = 0; c < originCount; ++c) {
                    var component = node._components[c];
                    if (component._enabled && (cc.director._compScheduler.disableComp(component), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
                }
                for (var i = 0, len = node._children.length; i < len; ++i) {
                    var child = node._children[i];
                    if (child._activeInHierarchy && (this._deactivateNodeRecursively(child), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
                }
                node._onPostActivated(!1), node._objFlags &= ~Deactivating$2;
            }
        } ]), NodeActivator;
    }();
    (function(_keyMap) {
        _keyMap[_keyMap.positions = exports.GFXAttributeName.ATTR_POSITION] = "positions", 
        _keyMap[_keyMap.normals = exports.GFXAttributeName.ATTR_NORMAL] = "normals", _keyMap[_keyMap.uvs = exports.GFXAttributeName.ATTR_TEX_COORD] = "uvs", 
        _keyMap[_keyMap.colors = exports.GFXAttributeName.ATTR_COLOR] = "colors";
    })(_keyMap || (_keyMap = {}));
    var _defAttrs = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_NORMAL,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA32F
    } ], v3_1$4 = new Vec3();
    function createMesh(geometry, out, options) {
        options = options || {};
        var attr, attributes = [], stride = 0, channels = [], vertCount = 0;
        if (0 < geometry.positions.length) {
            if (attr = null, geometry.attributes) {
                var _iterator = geometry.attributes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var att = _ref;
                    if (att.name === exports.GFXAttributeName.ATTR_POSITION) {
                        attr = att;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[0]);
            var info = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.positions.length / info.count)), 
            channels.push({
                offset: stride,
                data: geometry.positions,
                attribute: attr
            }), stride += info.size;
        }
        if (geometry.normals && 0 < geometry.normals.length) {
            if (attr = null, geometry.attributes) {
                var _iterator2 = geometry.attributes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _att = _ref2;
                    if (_att.name === exports.GFXAttributeName.ATTR_NORMAL) {
                        attr = _att;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[1]);
            var _info = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count)), 
            channels.push({
                offset: stride,
                data: geometry.normals,
                attribute: attr
            }), stride += _info.size;
        }
        if (geometry.uvs && 0 < geometry.uvs.length) {
            if (attr = null, geometry.attributes) {
                var _iterator3 = geometry.attributes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _att2 = _ref3;
                    if (_att2.name === exports.GFXAttributeName.ATTR_TEX_COORD) {
                        attr = _att2;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[2]);
            var _info2 = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count)), 
            channels.push({
                offset: stride,
                data: geometry.uvs,
                attribute: attr
            }), stride += _info2.size;
        }
        if (geometry.colors && 0 < geometry.colors.length) {
            if (attr = null, geometry.attributes) {
                var _iterator4 = geometry.attributes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var _att3 = _ref4;
                    if (_att3.name === exports.GFXAttributeName.ATTR_COLOR) {
                        attr = _att3;
                        break;
                    }
                }
            }
            attr || (attr = _defAttrs[3]);
            var _info3 = GFXFormatInfos[attr.format];
            attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info3.count)), 
            channels.push({
                offset: stride,
                data: geometry.colors,
                attribute: attr
            }), stride += _info3.size;
        }
        if (geometry.customAttributes) {
            var _iterator5 = geometry.customAttributes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                var ca = _ref5, _info4 = GFXFormatInfos[ca.attr.format];
                attributes.push(ca.attr), vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info4.count)), 
                channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                }), stride += _info4.size;
            }
        }
        for (var bufferBlob = new BufferBlob(), vertexBuffer = new ArrayBuffer(vertCount * stride), vertexBufferView = new DataView(vertexBuffer), _i6 = 0; _i6 < channels.length; _i6++) {
            var channel = channels[_i6];
            writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
        }
        bufferBlob.setNextAlignment(0);
        var vertexBundle = {
            attributes: attributes,
            view: {
                offset: bufferBlob.getLength(),
                length: vertexBuffer.byteLength,
                count: vertCount,
                stride: stride
            }
        };
        bufferBlob.addBuffer(vertexBuffer);
        var indexBuffer = null, idxCount = 0;
        if (geometry.indices) {
            var indices = geometry.indices;
            idxCount = indices.length, indexBuffer = new ArrayBuffer(2 * idxCount), writeBuffer(new DataView(indexBuffer), indices, exports.GFXFormat.R16UI);
        }
        var primitive = {
            primitiveMode: geometry.primitiveMode || exports.GFXPrimitiveMode.TRIANGLE_LIST,
            vertexBundelIndices: [ 0 ]
        };
        if (primitive.primitiveMode >= exports.GFXPrimitiveMode.TRIANGLE_LIST) {
            var geomInfo = Float32Array.from(geometry.positions);
            bufferBlob.setNextAlignment(4), primitive.geometricInfo = {
                doubleSided: geometry.doubleSided,
                view: {
                    offset: bufferBlob.getLength(),
                    length: geomInfo.byteLength,
                    count: geometry.positions.length / 4,
                    stride: 4
                }
            }, bufferBlob.addBuffer(geomInfo.buffer);
        }
        indexBuffer && (bufferBlob.setNextAlignment(2), primitive.indexView = {
            offset: bufferBlob.getLength(),
            length: indexBuffer.byteLength,
            count: idxCount,
            stride: 2
        }, bufferBlob.addBuffer(indexBuffer));
        var minPosition = geometry.minPos;
        if (!minPosition && options.calculateBounds) {
            minPosition = vec3.set(new vec3(), 1 / 0, 1 / 0, 1 / 0);
            for (var iVertex = 0; iVertex < vertCount; ++iVertex) vec3.set(v3_1$4, geometry.positions[3 * iVertex + 0], geometry.positions[3 * iVertex + 1], geometry.positions[3 * iVertex + 2]), 
            vec3.min(minPosition, minPosition, v3_1$4);
        }
        var maxPosition = geometry.maxPos;
        if (!maxPosition && options.calculateBounds) {
            maxPosition = vec3.set(new vec3(), -1 / 0, -1 / 0, -1 / 0);
            for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) vec3.set(v3_1$4, geometry.positions[3 * _iVertex + 0], geometry.positions[3 * _iVertex + 1], geometry.positions[3 * _iVertex + 2]), 
            vec3.max(maxPosition, maxPosition, v3_1$4);
        }
        var meshStruct = {
            vertexBundles: [ vertexBundle ],
            primitives: [ primitive ]
        };
        return minPosition && (meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z)), 
        maxPosition && (meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z)), 
        out || (out = new Mesh()), out.assign(meshStruct, new Uint8Array(bufferBlob.getCombined())), 
        out;
    }
    var isLittleEndian$1 = cc.sys.isLittleEndian, _typeMap = (_defineProperty(_typeMap2 = {}, GFXFormatType.UNORM, "Uint"), 
    _defineProperty(_typeMap2, GFXFormatType.SNORM, "Int"), _defineProperty(_typeMap2, GFXFormatType.UINT, "Uint"), 
    _defineProperty(_typeMap2, GFXFormatType.INT, "Int"), _defineProperty(_typeMap2, GFXFormatType.UFLOAT, "Float"), 
    _defineProperty(_typeMap2, GFXFormatType.FLOAT, "Float"), _defineProperty(_typeMap2, "default", "Uint"), 
    _typeMap2);
    function _getDataViewType(info) {
        return (_typeMap[info.type] || _typeMap.default) + info.size / info.count * 8;
    }
    function writeBuffer(target, data) {
        var format = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.R32F, offset = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, stride = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, info = GFXFormatInfos[format];
        stride || (stride = info.size);
        for (var writer = "set" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(data.length / info.count), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent;
            target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian$1);
        }
    }
    function readBuffer(target) {
        var format = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : exports.GFXFormat.R32F, offset = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, length = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : target.byteLength - offset, stride = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, out = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : [], info = GFXFormatInfos[format];
        stride || (stride = info.size);
        for (var reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent;
            out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian$1);
        }
        return out;
    }
    function mapBuffer(target, callback) {
        var format = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.R32F, offset = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, length = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : target.byteLength - offset, stride = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0, out = 6 < arguments.length ? arguments[6] : void 0;
        out || (out = new DataView(new ArrayBuffer(target.byteLength)));
        var info = GFXFormatInfos[format];
        stride || (stride = info.size);
        for (var writer = "set" + _getDataViewType(info), reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent, cur = target[reader](y, isLittleEndian$1);
            out[writer](y, callback(cur, iComponent, target), isLittleEndian$1);
        }
        return out;
    }
    var _path = [], LCA = function LCA(a, b) {
        if (a === b) return a;
        var cur = b;
        for (_path.length = 0; cur; ) _path.push(cur), cur = cur.parent;
        for (cur = a; cur; ) {
            if (_path.find(function(n) {
                return n === cur;
            })) return cur;
            cur = cur.parent;
        }
        return null;
    }, v3_2$2 = new Vec3();
    var boneSpaceBoundsManager = new (function() {
        function BoneSpaceBoundsManager() {
            _classCallCheck(this, BoneSpaceBoundsManager), this._cached = new Map();
        }
        return _createClass(BoneSpaceBoundsManager, [ {
            key: "use",
            value: function use(mesh, skeleton) {
                var bucket = this._cached.get(mesh);
                bucket || (bucket = new Map(), this._cached.set(mesh, bucket));
                var cached = bucket.get(skeleton);
                return cached || (cached = {
                    bounds: function calculateBoneSpaceBounds(mesh, skeleton) {
                        for (var result = new Array(skeleton.joints.length), i = 0; i < result.length; ++i) result[i] = {
                            hasValue: !1,
                            min: new Vec3(1 / 0, 1 / 0, 1 / 0),
                            max: new Vec3(-1 / 0, -1 / 0, -1 / 0)
                        };
                        for (var iPrimitive = 0; iPrimitive < mesh.struct.primitives.length; ++iPrimitive) {
                            var joints = mesh.readAttribute(iPrimitive, exports.GFXAttributeName.ATTR_JOINTS);
                            if (joints) {
                                var weights = mesh.readAttribute(iPrimitive, exports.GFXAttributeName.ATTR_WEIGHTS);
                                if (weights) {
                                    var _positions = mesh.readAttribute(iPrimitive, exports.GFXAttributeName.ATTR_POSITION);
                                    if (_positions) for (var vertexCount = Math.min(joints.length / 4, weights.length / 4, _positions.length / 3), iVertex = 0; iVertex < vertexCount; ++iVertex) {
                                        vec3.set(v3_1$4, _positions[3 * iVertex + 0], _positions[3 * iVertex + 1], _positions[3 * iVertex + 2]);
                                        for (var _i9 = 0; _i9 < 4; ++_i9) if (0 !== weights[4 * iVertex + _i9]) {
                                            var refJointIndex = joints[4 * iVertex + _i9];
                                            if (!(refJointIndex >= skeleton.joints.length)) {
                                                var bindpose = skeleton.bindposes[refJointIndex], jointBounds = result[refJointIndex];
                                                vec3.multiply(v3_2$2, v3_1$4, bindpose.scale), vec3.transformQuat(v3_2$2, v3_2$2, bindpose.rotation), 
                                                vec3.add(v3_2$2, v3_2$2, bindpose.position), jointBounds.hasValue = !0, vec3.min(jointBounds.min, jointBounds.min, v3_2$2), 
                                                vec3.max(jointBounds.max, jointBounds.max, v3_2$2);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result.map(function(bounds) {
                            return bounds.hasValue ? aabb.fromPoints(new aabb(), bounds.min, bounds.max) : null;
                        });
                    }(mesh, skeleton),
                    referenceCount: 0
                }, bucket.set(skeleton, cached)), ++cached.referenceCount, cached.bounds;
            }
        }, {
            key: "unuse",
            value: function unuse(mesh, skeleton) {
                var bucket = this._cached.get(mesh);
                if (bucket) {
                    var cached = bucket.get(skeleton);
                    cached && (--cached.referenceCount, 0 === cached.referenceCount && bucket.delete(skeleton)), 
                    0 === bucket.size && this._cached.delete(mesh);
                }
            }
        } ]), BoneSpaceBoundsManager;
    }())(), m4_1$1 = new Mat4(), ab_1 = new aabb(), v3_3 = new Vec3(), v3_4 = new Vec3();
    var _jointsFormat2, JointsMediumType, utils = Object.freeze({
        toPPM: function toPPM(buffer, w, h) {
            return "P3 ".concat(w, " ").concat(h, " 255\n").concat(buffer.filter(function(e, i) {
                return i % 4 < 3;
            }).toString(), "\n");
        },
        createMesh: createMesh,
        readMesh: function readMesh(mesh) {
            var iPrimitive = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, out = {
                positions: []
            }, dataView = new DataView(mesh._nativeAsset), struct = mesh.struct, primitive = struct.primitives[iPrimitive], _iterator6 = primitive.vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i7 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i7++];
                } else {
                    if ((_i7 = _iterator6.next()).done) break;
                    _ref6 = _i7.value;
                }
                var idx = _ref6, bundle = struct.vertexBundles[idx], _offset = bundle.view.offset, _bundle$view = bundle.view, length = _bundle$view.length, stride = _bundle$view.stride, _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i8 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i8 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i8++];
                    } else {
                        if ((_i8 = _iterator7.next()).done) break;
                        _ref7 = _i8.value;
                    }
                    var attr = _ref7, name = _keyMap[attr.name];
                    name && (out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, _offset, length, stride))), 
                    _offset += GFXFormatInfos[attr.format].size;
                }
            }
            var view = primitive.indexView;
            return out.indices = readBuffer(dataView, exports.GFXFormat["R".concat(8 * view.stride, "UI")], view.offset, view.length), 
            out;
        },
        writeBuffer: writeBuffer,
        readBuffer: readBuffer,
        mapBuffer: mapBuffer,
        LCA: LCA,
        calculateSkinnedBounds: function calculateSkinnedBounds(out, comp) {
            if (comp.model && comp.mesh && comp.skeleton) {
                var mesh = comp.mesh, skeleton = comp.skeleton, joints = comp.model.joints;
                vec3.set(v3_3, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), 
                vec3.set(v3_4, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
                for (var boundList = boneSpaceBoundsManager.use(mesh, skeleton), len = joints.length, i = 0; i < len; ++i) {
                    var _bounds = boundList[i], targetNode = joints[i].node;
                    _bounds && targetNode && (targetNode.getWorldMatrix(m4_1$1), aabb.transform(ab_1, _bounds, m4_1$1), 
                    ab_1.getBoundary(v3_1$4, v3_2$2), vec3.min(v3_3, v3_3, v3_1$4), vec3.max(v3_4, v3_4, v3_2$2));
                }
                return aabb.fromPoints(out, v3_3, v3_4), !0;
            }
        },
        find: find
    });
    function selectJointsMediumType(device, jointCount) {
        return jointCount <= 30 ? JointsMediumType.UNIFORM : device.hasFeature(GFXFeature.TEXTURE_FLOAT) ? JointsMediumType.RGBA32F : JointsMediumType.RGBA8;
    }
    !function(JointsMediumType) {
        JointsMediumType[JointsMediumType.NONE = 0] = "NONE", JointsMediumType[JointsMediumType.UNIFORM = 1] = "UNIFORM", 
        JointsMediumType[JointsMediumType.RGBA8 = 2] = "RGBA8", JointsMediumType[JointsMediumType.RGBA32F = 3] = "RGBA32F";
    }(JointsMediumType || (JointsMediumType = {}));
    var _jointsFormat = (_defineProperty(_jointsFormat2 = {}, JointsMediumType.UNIFORM, PixelFormat.RGBA32F), 
    _defineProperty(_jointsFormat2, JointsMediumType.RGBA8, PixelFormat.RGBA8888), _defineProperty(_jointsFormat2, JointsMediumType.RGBA32F, PixelFormat.RGBA32F), 
    _jointsFormat2), v3_1$5 = new Vec3(), v3_2$3 = new Vec3(), qt_0 = new Quat(), qt_1$1 = new Quat(), qt_2$1 = new Quat(), m4_1$2 = new Mat4(), f4_1 = new Float32Array(4), Joint = function() {
        function Joint(node) {
            _classCallCheck(this, Joint), this.node = void 0, this.position = new Vec3(), this.rotation = new Quat(), 
            this.scale = new Vec3(1, 1, 1), this.parent = null, this._lastUpdate = -1, this.node = node;
        }
        return _createClass(Joint, [ {
            key: "update",
            value: function update() {
                var totalFrames = cc.director.getTotalFrames();
                if (!(this._lastUpdate >= totalFrames)) {
                    this._lastUpdate = totalFrames;
                    var parent = this.parent;
                    parent && (parent.update(), vec3.multiply(this.position, this.node.position, parent.scale), 
                    vec3.transformQuat(this.position, this.position, parent.rotation), vec3.add(this.position, this.position, parent.position), 
                    quat.multiply(this.rotation, parent.rotation, this.node.rotation), vec3.multiply(this.scale, parent.scale, this.node.scale));
                }
            }
        } ]), Joint;
    }(), JointManager = function() {
        function JointManager() {
            _classCallCheck(this, JointManager);
        }
        return _createClass(JointManager, null, [ {
            key: "get",
            value: function get$$1(node, root) {
                var joint = JointManager._joints.get(node);
                return joint || (joint = new Joint(node), node !== root && node.parent && (joint.parent = JointManager.get(node.parent, root)), 
                JointManager._joints.set(node, joint), joint);
            }
        } ]), JointManager;
    }();
    JointManager._joints = new Map();
    var _dec$y, _dec2$d, _dec3$5, _class$y, _class2$q, _descriptor$o, _dec$z, _dec2$e, _dec3$6, _dec4$3, _class$z, _class2$r, _descriptor$p, _descriptor2$h, _descriptor3$9, _class3$b, _temp$v, _dec$A, _dec2$f, _dec3$7, _dec4$4, _dec5$2, _dec6$2, _dec7$2, _class$A, _class2$s, _descriptor$q, _descriptor2$i, _dec$B, _dec2$g, _dec3$8, _dec4$5, _dec5$3, _dec6$3, _dec7$3, _class$B, _class2$t, _descriptor$r, _descriptor2$j, _descriptor3$a, _descriptor4$8, _descriptor5$6, _descriptor6$3, _dec8$1, _dec9$1, _dec10$1, _dec11$1, _dec12$1, _dec13$1, _dec14$1, _dec15$1, _dec16$1, _class4$1, _class5$1, _descriptor7$2, _descriptor8$2, _descriptor9$2, _dec$C, _dec2$h, _dec3$9, _dec4$6, _dec5$4, _dec6$4, _class$C, _class2$u, _descriptor$s, _descriptor2$k, _descriptor3$b, _descriptor4$9, _descriptor5$7, _descriptor6$4, _dec7$4, _dec8$2, _dec9$2, _dec10$2, _dec11$2, _dec12$2, _dec13$2, _dec14$2, _class4$2, _class5$2, _descriptor7$3, _descriptor8$3, _descriptor9$3, _dec$D, _dec2$i, _dec3$a, _dec4$7, _class$D, _class2$v, _descriptor$t, _descriptor2$l, _descriptor3$c, _descriptor4$a, _descriptor5$8, _descriptor6$5, _descriptor7$4, _descriptor8$4, _descriptor9$4, _descriptor10$2, _descriptor11$1, _descriptor12$1, _descriptor13$1, _class3$c, _temp$z, LightType, SkinningModel = function(_Model) {
        function SkinningModel(scene, node) {
            var _this;
            return _classCallCheck(this, SkinningModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModel).call(this, scene, node))).updateJointData = _this.updateJointDataDQS, 
            _this._skeleton = null, _this._joints = [], _this._jointsMedium = null, _this._type = "skinning", 
            node.parent && (_this._transform = node.parent), _this;
        }
        return _inherits(SkinningModel, Model), _createClass(SkinningModel, [ {
            key: "joints",
            get: function get$$1() {
                return this._joints;
            }
        } ]), _createClass(SkinningModel, [ {
            key: "bindSkeleton",
            value: function bindSkeleton(skeleton) {
                if (this._destroyJointsMedium(), this._skeleton = skeleton) {
                    var type = selectJointsMediumType(this._device, skeleton.joints.length), format = _jointsFormat[type], UBO = type === JointsMediumType.UNIFORM ? UBOSkinning : UBOSkinningTexture, binding = UBO.BLOCK.binding, buffer = this._device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: UBO.SIZE,
                        stride: UBO.SIZE
                    }), width = Math.ceil(48 / GFXFormatInfos[format].size), height = skeleton.joints.length, nativeData = new Float32Array(width * height * 4);
                    if (this._jointsMedium = {
                        type: type,
                        binding: binding,
                        buffer: buffer,
                        nativeData: nativeData
                    }, type !== JointsMediumType.UNIFORM) {
                        var _texture = this._jointsMedium.texture = new Texture2D();
                        _texture.create(width, height, format), _texture.setFilters(Filter.NEAREST, Filter.NEAREST), 
                        _texture.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE), f4_1[0] = 1 / width, 
                        f4_1[1] = 1 / height, buffer.update(f4_1, UBOSkinningTexture.JOINTS_TEXTURE_SIZE_INV_OFFSET, f4_1.byteLength);
                    }
                }
            }
        }, {
            key: "commitJointData",
            value: function commitJointData() {
                if (this._jointsMedium) {
                    var _this$_jointsMedium = this._jointsMedium, type = _this$_jointsMedium.type, nativeData = _this$_jointsMedium.nativeData, buffer = _this$_jointsMedium.buffer, texture = _this$_jointsMedium.texture;
                    type === JointsMediumType.UNIFORM ? buffer.update(nativeData, UBOSkinning.MAT_JOINT_OFFSET) : texture.uploadData(nativeData.buffer);
                }
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs() {
                if (!_get(_getPrototypeOf(SkinningModel.prototype), "updateUBOs", this).call(this) || !this._skeleton) return !1;
                for (var len = this._joints.length, i = 0; i < len; ++i) {
                    var cur = this._joints[i];
                    cur.update();
                    var bindpose = this._skeleton.bindposes[i];
                    vec3.multiply(v3_1$5, bindpose.position, cur.scale), vec3.transformQuat(v3_1$5, v3_1$5, cur.rotation), 
                    vec3.add(v3_1$5, v3_1$5, cur.position), quat.multiply(qt_1$1, cur.rotation, bindpose.rotation), 
                    vec3.multiply(v3_2$3, cur.scale, bindpose.scale), this.updateJointData(i, v3_1$5, qt_1$1, v3_2$3, 0 === i);
                }
                return this.commitJointData(), !0;
            }
        }, {
            key: "resetSkinningTarget",
            value: function resetSkinningTarget(skinningRoot) {
                var _this2 = this, root = LCA(this.node, skinningRoot);
                root && this._skeleton && (this._joints.length = 0, this._skeleton.joints.forEach(function(path) {
                    var targetNode = skinningRoot.getChildByPath(path);
                    targetNode ? _this2._joints.push(JointManager.get(targetNode, root)) : console.warn("Skinning target ".concat(path, " not found in scene graph."));
                }));
            }
        }, {
            key: "updateJointDataLBS",
            value: function updateJointDataLBS(idx, pos, rot, scale) {
                if (this._jointsMedium) {
                    var out = this._jointsMedium.nativeData, base = 12 * idx;
                    mat4.fromRTS(m4_1$2, rot, pos, scale), out[base + 0] = m4_1$2.m00, out[base + 1] = m4_1$2.m01, 
                    out[base + 2] = m4_1$2.m02, out[base + 3] = m4_1$2.m12, out[base + 4] = m4_1$2.m04, 
                    out[base + 5] = m4_1$2.m05, out[base + 6] = m4_1$2.m06, out[base + 7] = m4_1$2.m13, 
                    out[base + 8] = m4_1$2.m08, out[base + 9] = m4_1$2.m09, out[base + 10] = m4_1$2.m10, 
                    out[base + 11] = m4_1$2.m14;
                }
            }
        }, {
            key: "updateJointDataDQS",
            value: function updateJointDataDQS(idx, pos, rot, scale) {
                var first = 4 < arguments.length && void 0 !== arguments[4] && arguments[4];
                if (this._jointsMedium) {
                    var out = this._jointsMedium.nativeData, base = 12 * idx;
                    first ? quat.copy(qt_0, rot) : quat.dot(qt_0, rot) < 0 && quat.scale(rot, rot, -1), 
                    quat.set(qt_2$1, pos.x, pos.y, pos.z, 0), quat.scale(qt_2$1, quat.multiply(qt_2$1, qt_2$1, rot), .5), 
                    out[base + 0] = rot.x, out[base + 1] = rot.y, out[base + 2] = rot.z, out[base + 3] = rot.w, 
                    out[base + 4] = qt_2$1.x, out[base + 5] = qt_2$1.y, out[base + 6] = qt_2$1.z, out[base + 7] = qt_2$1.w, 
                    out[base + 8] = scale.x, out[base + 9] = scale.y, out[base + 10] = scale.z;
                }
            }
        }, {
            key: "_doCreatePSO",
            value: function _doCreatePSO(pass) {
                var pso = _get(_getPrototypeOf(SkinningModel.prototype), "_doCreatePSO", this).call(this, pass);
                if (!this._jointsMedium) return pso;
                var _this$_jointsMedium2 = this._jointsMedium, type = _this$_jointsMedium2.type, buffer = _this$_jointsMedium2.buffer, binding = _this$_jointsMedium2.binding, texture = _this$_jointsMedium2.texture;
                if (pso.pipelineLayout.layouts[0].bindBuffer(binding, buffer), type !== JointsMediumType.UNIFORM) {
                    var view = texture.getGFXTextureView(), sampler = samplerLib.getSampler(this._device, texture.getGFXSamplerInfo());
                    view && sampler && (pso.pipelineLayout.layouts[0].bindTextureView(UNIFORM_JOINTS_TEXTURE.binding, view), 
                    pso.pipelineLayout.layouts[0].bindSampler(UNIFORM_JOINTS_TEXTURE.binding, sampler));
                }
                return pso;
            }
        }, {
            key: "_destroyJointsMedium",
            value: function _destroyJointsMedium() {
                if (this._jointsMedium) {
                    var _this$_jointsMedium3 = this._jointsMedium, type = _this$_jointsMedium3.type, buffer = _this$_jointsMedium3.buffer, texture = _this$_jointsMedium3.texture;
                    buffer.destroy(), type !== JointsMediumType.UNIFORM && texture.destroy(), this._jointsMedium = null;
                }
            }
        } ]), SkinningModel;
    }(), property$2 = property, RenderableComponent = (_dec$y = ccclass("cc.RenderableComponent"), 
    _dec2$d = property$2({
        type: [ Material ]
    }), _dec3$5 = property$2({
        type: Material,
        displayName: "Materials"
    }), _dec$y((_descriptor$o = _applyDecoratedDescriptor((_class2$q = function(_Component) {
        function RenderableComponent() {
            var _this;
            return _classCallCheck(this, RenderableComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RenderableComponent).call(this)), "_materials", _descriptor$o, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(RenderableComponent, Component), _createClass(RenderableComponent, [ {
            key: "getMaterial",
            value: function getMaterial(idx) {
                var inEditor = 1 < arguments.length && void 0 !== arguments[1] && arguments[1], autoUpdate = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], mat = this._materials[idx];
                if (!mat) return null;
                var instantiated = Material.getInstantiatedMaterial(mat, this, inEditor);
                return instantiated !== this._materials[idx] && this.setMaterial(instantiated, idx, autoUpdate || !inEditor), 
                this._materials[idx];
            }
        }, {
            key: "getSharedMaterial",
            value: function getSharedMaterial(idx) {
                return idx < 0 || idx >= this._materials.length ? null : this._materials[idx];
            }
        }, {
            key: "setMaterial",
            value: function setMaterial(material, index) {
                var notify = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2];
                this._materials[index] = material, notify && this._onMaterialModified(index, material);
            }
        }, {
            key: "recreateModel",
            value: function recreateModel() {}
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {}
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(index, material) {}
        }, {
            key: "_clearMaterials",
            value: function _clearMaterials() {}
        }, {
            key: "sharedMaterials",
            get: function get() {
                return this._materials.slice();
            },
            set: function set(val) {
                for (var i = 0; i < val.length; i++) val[i] !== this._materials[i] && this.setMaterial(val[i], i);
                if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) this.setMaterial(null, _i);
                    this._materials.splice(val.length);
                }
            }
        }, {
            key: "materials",
            get: function get() {
                for (var i = 0; i < this._materials.length; i++) this._materials[i] = this.getMaterial(i);
                return this._materials;
            },
            set: function set(val) {
                var dLen = val.length - this._materials.length;
                if (0 < dLen) this._materials = this._materials.concat(new Array(dLen).fill(null)); else if (dLen < 0) {
                    for (var i = -dLen; i < this._materials.length; ++i) this.setMaterial(null, i);
                    this._materials = this._materials.splice(-dLen);
                }
            }
        }, {
            key: "material",
            get: function get() {
                return this.getMaterial(0);
            },
            set: function set(val) {
                1 === this._materials.length && this._materials[0] === val || this.setMaterial(val, 0);
            }
        }, {
            key: "sharedMaterial",
            get: function get() {
                return this.getSharedMaterial(0);
            }
        } ]), RenderableComponent;
    }()).prototype, "_materials", [ _dec2$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class2$q.prototype, "sharedMaterials", [ _dec3$5 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "sharedMaterials"), _class2$q.prototype), 
    _class$y = _class2$q)) || _class$y), ModelShadowCastingMode = Enum({
        Off: 0,
        On: 1,
        TwoSided: 2,
        ShadowsOnly: 3
    }), ModelComponent = (_dec$z = ccclass("cc.ModelComponent"), _dec2$e = executionOrder(100), 
    _dec3$6 = menu("Components/ModelComponent"), _dec4$3 = property({
        type: Mesh
    }), _dec$z(_class$z = _dec2$e(_class$z = _dec3$6(_class$z = executeInEditMode((_temp$v = _class3$b = function(_RenderableComponent) {
        function ModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
            _initializerDefineProperty(_this, "_mesh", _descriptor$p, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor2$h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_receiveShadows", _descriptor3$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(ModelComponent, RenderableComponent), _createClass(ModelComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow(), this._model && (this._model.enabled = !0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._model && (this._model.enabled = !1);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._model && (this._getRenderScene().destroyModel(this._model), this._model = null);
            }
        }, {
            key: "recreateModel",
            value: function recreateModel() {
                this._model && (this._model.destroy(), this._model.scene.destroyModel(this._model), 
                this._model = null), this._updateModels();
            }
        }, {
            key: "_updateModels",
            value: function _updateModels() {
                this.enabledInHierarchy && this._mesh && (this._model && this._model.inited ? this._model.destroy() : this._createModel(), 
                this._model.createBoundingShape(this._mesh.minPosition, this._mesh.maxPosition), 
                this._updateModelParams(), this._model && (this._model.enabled = !0));
            }
        }, {
            key: "_createModel",
            value: function _createModel() {
                if (this.node.scene) {
                    var scene = this._getRenderScene();
                    this._model = scene.createModel(this._getModelConstructor(), this.node);
                }
            }
        }, {
            key: "_getModelConstructor",
            value: function _getModelConstructor() {
                return Model;
            }
        }, {
            key: "_updateModelParams",
            value: function _updateModelParams() {
                if (this.node._hasChanged = !0, this._mesh && this._model) for (var meshCount = this._mesh ? this._mesh.subMeshCount : 0, i = 0; i < meshCount; ++i) {
                    var material = this.getSharedMaterial(i), renderingMesh = this._mesh.renderingMesh;
                    if (renderingMesh) {
                        var subMeshData = renderingMesh.getSubmesh(i);
                        subMeshData && this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                }
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(idx, material) {
                null != this._model && this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(idx, material) {
                this._model && this._model.setSubModelMaterial(idx, material);
            }
        }, {
            key: "_onMeshChanged",
            value: function _onMeshChanged(old) {}
        }, {
            key: "_clearMaterials",
            value: function _clearMaterials() {
                if (null != this._model) for (var i = 0; i < this._model.subModelNum; ++i) this._onMaterialModified(i, null);
            }
        }, {
            key: "_getBuiltinMaterial",
            value: function _getBuiltinMaterial() {
                return builtinResMgr.get("missing-material");
            }
        }, {
            key: "_updateCastShadow",
            value: function _updateCastShadow() {
                if (this.enabledInHierarchy && this._model) if (this._shadowCastingMode === ModelShadowCastingMode.Off) for (var i = 0; i < this._model.subModelNum; ++i) {
                    this._model.getSubModel(i).castShadow = !1;
                } else if (this._shadowCastingMode === ModelShadowCastingMode.On) for (var _i = 0; _i < this._model.subModelNum; ++_i) {
                    this._model.getSubModel(_i).castShadow = !0;
                } else console.warn("ShadowCastingMode ".concat(this._shadowCastingMode, " is not supported."));
            }
        }, {
            key: "_updateReceiveShadow",
            value: function _updateReceiveShadow() {
                this.enabledInHierarchy && this._model;
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(val) {
                var old = this._mesh;
                this._mesh = val, this._onMeshChanged(old), this._updateModels();
            }
        }, {
            key: "shadowCastingMode",
            get: function get() {
                return this._shadowCastingMode;
            },
            set: function set(val) {
                this._shadowCastingMode = val, this._updateCastShadow();
            }
        }, {
            key: "receiveShadows",
            get: function get() {
                return this._receiveShadows;
            },
            set: function set(val) {
                this._receiveShadows = val, this._updateReceiveShadow();
            }
        }, {
            key: "model",
            get: function get() {
                return this._model;
            }
        } ]), ModelComponent;
    }(), _class3$b.ShadowCastingMode = ModelShadowCastingMode, _applyDecoratedDescriptor((_class2$r = _temp$v).prototype, "mesh", [ _dec4$3 ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "mesh"), _class2$r.prototype), 
    _descriptor$p = _applyDecoratedDescriptor(_class2$r.prototype, "_mesh", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$h = _applyDecoratedDescriptor(_class2$r.prototype, "_shadowCastingMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ModelShadowCastingMode.Off;
        }
    }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$r.prototype, "_receiveShadows", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$z = _class2$r)) || _class$z) || _class$z) || _class$z) || _class$z), SkinningModelComponent = (_dec$A = ccclass("cc.SkinningModelComponent"), 
    _dec2$f = executionOrder(100), _dec3$7 = menu("Components/SkinningModelComponent"), 
    _dec4$4 = property({
        type: Skeleton
    }), _dec5$2 = property({
        type: Node$1
    }), _dec6$2 = property(Skeleton), _dec7$2 = property(Node$1), _dec$A(_class$A = _dec2$f(_class$A = executeInEditMode(_class$A = _dec3$7((_applyDecoratedDescriptor((_class2$s = function(_ModelComponent) {
        function SkinningModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SkinningModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_skeleton", _descriptor$q, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$i, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(SkinningModelComponent, ModelComponent), _createClass(SkinningModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                var _this2 = this;
                this._materials.forEach(function(material, index) {
                    return material && _this2._onMaterialModified(index, material);
                });
            }
        }, {
            key: "_updateModelParams",
            value: function _updateModelParams() {
                this._bindSkeleton(), this._resetSkinningTarget(), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_updateModelParams", this).call(this);
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {
                var type = selectJointsMediumType(cc.director.root && cc.director.root.device, this._skeleton && this._skeleton.joints.length || 0), mat = this.getMaterial(index, !1) || this._getBuiltinMaterial();
                mat.recompileShaders({
                    CC_USE_SKINNING: type
                }), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_onMaterialModified", this).call(this, index, mat);
            }
        }, {
            key: "_getModelConstructor",
            value: function _getModelConstructor() {
                return SkinningModel;
            }
        }, {
            key: "_getBuiltinMaterial",
            value: function _getBuiltinMaterial() {
                return builtinResMgr.get("missing-skinning-material");
            }
        }, {
            key: "_bindSkeleton",
            value: function _bindSkeleton() {
                var _this3 = this;
                this._model && this._model.bindSkeleton(this._skeleton), this._materials.forEach(function(material, index) {
                    return material && _this3._onMaterialModified(index, material);
                });
            }
        }, {
            key: "_resetSkinningTarget",
            value: function _resetSkinningTarget() {
                this._model && this._skinningRoot && this._model.resetSkinningTarget(this._skinningRoot);
            }
        }, {
            key: "skeleton",
            get: function get$$1() {
                return this._skeleton;
            },
            set: function set(val) {
                this._skeleton = val, this._bindSkeleton(), this._resetSkinningTarget();
            }
        }, {
            key: "skinningRoot",
            get: function get$$1() {
                return this._skinningRoot;
            },
            set: function set(value) {
                this._skinningRoot = value, this._resetSkinningTarget();
            }
        }, {
            key: "model",
            get: function get$$1() {
                return this._model;
            }
        } ]), SkinningModelComponent;
    }()).prototype, "skeleton", [ _dec4$4 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "skeleton"), _class2$s.prototype), 
    _applyDecoratedDescriptor(_class2$s.prototype, "skinningRoot", [ _dec5$2 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "skinningRoot"), _class2$s.prototype), 
    _descriptor$q = _applyDecoratedDescriptor(_class2$s.prototype, "_skeleton", [ _dec6$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$i = _applyDecoratedDescriptor(_class2$s.prototype, "_skinningRoot", [ _dec7$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$A = _class2$s)) || _class$A) || _class$A) || _class$A) || _class$A), _vec2$2 = new Vec2(), AvatarUnit = (_dec$B = ccclass("cc.AvatarUnit"), 
    _dec2$g = property(Mesh), _dec3$8 = property(Skeleton), _dec4$5 = property(Node$1), 
    _dec5$3 = property(Texture2D), _dec6$3 = property({
        type: Texture2D
    }), _dec7$3 = property({
        type: SkinningModelComponent
    }), _dec$B((_descriptor$r = _applyDecoratedDescriptor((_class2$t = function() {
        function AvatarUnit() {
            _classCallCheck(this, AvatarUnit), _initializerDefineProperty(this, "mesh", _descriptor$r, this), 
            _initializerDefineProperty(this, "skeleton", _descriptor2$j, this), _initializerDefineProperty(this, "skinningRoot", _descriptor3$a, this), 
            _initializerDefineProperty(this, "_offset", _descriptor4$8, this), _initializerDefineProperty(this, "_atlasSize", _descriptor5$6, this), 
            _initializerDefineProperty(this, "_albedoMap", _descriptor6$3, this);
        }
        return _createClass(AvatarUnit, [ {
            key: "atlasSize",
            set: function set$$1(atlasSize) {
                vec2.copy(this._atlasSize, atlasSize);
            },
            get: function get$$1() {
                return this._atlasSize;
            }
        }, {
            key: "offset",
            set: function set$$1(offset) {
                vec2.copy(this._offset, offset);
            },
            get: function get$$1() {
                return this._offset;
            }
        }, {
            key: "albedoMap",
            get: function get$$1() {
                return this._albedoMap;
            },
            set: function set$$1(albedoMap) {
                this._albedoMap !== albedoMap && (this._albedoMap = albedoMap, this._albedoMap && (_vec2$2.x = this._albedoMap.width, 
                _vec2$2.y = this._albedoMap.height, this.atlasSize = _vec2$2));
            }
        }, {
            key: "source",
            set: function set$$1(comp) {
                comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.skinningRoot = comp.skinningRoot);
            },
            get: function get$$1() {
                return null;
            }
        } ]), AvatarUnit;
    }()).prototype, "mesh", [ _dec2$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$j = _applyDecoratedDescriptor(_class2$t.prototype, "skeleton", [ _dec3$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$a = _applyDecoratedDescriptor(_class2$t.prototype, "skinningRoot", [ _dec4$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$t.prototype, "_offset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(0, 0);
        }
    }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$t.prototype, "_atlasSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(256, 256);
        }
    }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$t.prototype, "_albedoMap", [ _dec5$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$t.prototype, "atlasSize", [ property ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "atlasSize"), _class2$t.prototype), 
    _applyDecoratedDescriptor(_class2$t.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "offset"), _class2$t.prototype), 
    _applyDecoratedDescriptor(_class2$t.prototype, "albedoMap", [ _dec6$3 ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "albedoMap"), _class2$t.prototype), 
    _applyDecoratedDescriptor(_class2$t.prototype, "source", [ _dec7$3 ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "source"), _class2$t.prototype), 
    _class$B = _class2$t)) || _class$B), getPrefix = function getPrefix(lca, target) {
        for (var prefix = "", cur = target; cur && cur !== lca; ) prefix = "".concat(cur.name, "/") + prefix, 
        cur = cur.parent;
        return prefix;
    }, concatPath = function concatPath(prefix, path) {
        return path ? prefix + path : prefix.slice(0, -1);
    }, AvatarModelComponent = (_dec8$1 = ccclass("cc.AvatarModelComponent"), _dec9$1 = executionOrder(100), 
    _dec10$1 = menu("Components/AvatarModelComponent"), _dec11$1 = property({
        override: !0,
        visible: !1
    }), _dec12$1 = property({
        override: !0,
        visible: !1
    }), _dec13$1 = property({
        override: !0,
        visible: !1
    }), _dec14$1 = property({
        type: Number
    }), _dec15$1 = property({
        type: String
    }), _dec16$1 = property({
        type: [ AvatarUnit ]
    }), _dec8$1(_class4$1 = _dec9$1(_class4$1 = executeInEditMode(_class4$1 = _dec10$1((_descriptor7$2 = _applyDecoratedDescriptor((_class5$1 = function(_SkinningModelCompone) {
        function AvatarModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AvatarModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AvatarModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_combinedTexSize", _descriptor7$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._combinedTex = null, _initializerDefineProperty(_this, "_albedoMapName", _descriptor8$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_avatarUnits", _descriptor9$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(AvatarModelComponent, SkinningModelComponent), _createClass(AvatarModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(AvatarModelComponent.prototype), "onLoad", this).call(this), 
                this._combinedTex = new Texture2D(), this._combinedTex.onLoaded(), this._combinedTex.setFilters(Filter.LINEAR, Filter.LINEAR), 
                this.resizeCombinedTexture(), this.combine();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._combinedTex && (this._combinedTex.destroy(), this._combinedTex = null), this._mesh && (this._mesh.destroy(), 
                this._mesh = null);
            }
        }, {
            key: "addAvatarUnit",
            value: function addAvatarUnit(unit) {
                this._avatarUnits.push(unit);
            }
        }, {
            key: "clear",
            value: function clear() {
                this._mesh && this._mesh.destroy();
            }
        }, {
            key: "bindTextures",
            value: function bindTextures() {
                if (0 < this._albedoMapName.length && 0 < this._materials.length) {
                    var mtrl = this.material;
                    mtrl && mtrl.setProperty(this._albedoMapName, this._combinedTex);
                }
            }
        }, {
            key: "combine",
            value: function combine() {
                this.combineTextures(), this.combineSkeletons(), this.combineMeshes(), this.bindTextures();
            }
        }, {
            key: "combineTextures",
            value: function combineTextures() {
                var isValid = !1, _iterator = this._avatarUnits, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    if (_ref.albedoMap) {
                        isValid = !0;
                        break;
                    }
                }
                if (isValid) {
                    var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], _iterator2 = this._avatarUnits, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var _unit = _ref2;
                        if (_unit) {
                            var offset = _unit.offset;
                            if ((isValid = 0 <= offset.x && 0 <= offset.y) && _unit.albedoMap && _unit.albedoMap.image && _unit.albedoMap.image.data) {
                                var region = new GFXBufferTextureCopy();
                                region.texOffset.x = offset.x, region.texOffset.y = offset.y, region.texExtent.width = _unit.albedoMap.image.width, 
                                region.texExtent.height = _unit.albedoMap.image.height;
                                var data = _unit.albedoMap.image.data;
                                data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                                texImageRegions.push(region)) : (texBuffers.push(data.buffer), texBufferRegions.push(region));
                            }
                        }
                    }
                    var gfxTex = this._combinedTex.getGFXTexture(), device = cc.director.root.device;
                    0 < texBuffers.length && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
                    0 < texImages.length && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
                }
            }
        }, {
            key: "combineSkeletons",
            value: function combineSkeletons() {
                var lca = null, _iterator3 = this._avatarUnits, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var unit = _ref3;
                    if (unit && unit.skinningRoot) {
                        var cur = unit.skinningRoot;
                        lca = lca ? LCA(lca, cur) : cur;
                    }
                }
                if (this._skinningRoot = lca) {
                    var skeleton = new Skeleton(), _iterator4 = this._avatarUnits, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        var _unit2 = _ref4;
                        if (_unit2 && _unit2.skeleton && _unit2.skinningRoot) for (var partial = _unit2.skeleton, prefix = getPrefix(lca, _unit2.skinningRoot), _loop = function _loop(i) {
                            var path = concatPath(prefix, partial.joints[i]);
                            if (0 <= skeleton.joints.findIndex(function(p) {
                                return p === path;
                            })) return "continue";
                            skeleton.joints.push(path), skeleton.bindposes.push(partial.bindposes[i]);
                        }, i = 0; i < partial.joints.length; i++) _loop(i);
                    }
                    var idxMap = _toConsumableArray(Array(skeleton.joints.length).keys()).sort(function(a, b) {
                        return skeleton.joints[a] > skeleton.joints[b] ? 1 : skeleton.joints[a] < skeleton.joints[b] ? -1 : 0;
                    });
                    skeleton.joints = skeleton.joints.map(function(_, idx, arr) {
                        return arr[idxMap[idx]];
                    }), skeleton.bindposes = skeleton.bindposes.map(function(_, idx, arr) {
                        return arr[idxMap[idx]];
                    }), _set(_getPrototypeOf(AvatarModelComponent.prototype), "skeleton", skeleton, this, !0);
                } else console.warn("illegal skinning roots");
            }
        }, {
            key: "combineMeshes",
            value: function combineMeshes() {
                var _this2 = this, isValid = !1, _iterator5 = this._avatarUnits, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    if (_ref5.mesh) {
                        isValid = !0;
                        break;
                    }
                }
                if (this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh(), isValid && this._skinningRoot) {
                    for (var dataView, uvOffset = 0, uvFormat = exports.GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = exports.GFXFormat.UNKNOWN, jointIndexMap = new Array(this._avatarUnits.length), avatarLen = this._avatarUnits.length, _loop2 = function _loop2(i) {
                        var unit = _this2._avatarUnits[i];
                        if (!unit || !unit.skeleton || !unit.skinningRoot) return "continue";
                        var prefix = getPrefix(_this2._skinningRoot, unit.skinningRoot);
                        jointIndexMap[i] = unit.skeleton.joints.map(function(j) {
                            var path = concatPath(prefix, j);
                            return _this2._skeleton.joints.findIndex(function(ref) {
                                return path === ref;
                            });
                        });
                    }, i = 0; i < avatarLen; i++) _loop2(i);
                    var _loop3 = function _loop3(i) {
                        var unit = _this2._avatarUnits[i];
                        if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                        var offset = unit.offset, meshData = unit.mesh.data.slice(), newMesh = new Mesh();
                        newMesh.assign(unit.mesh.struct, meshData), dataView = new DataView(meshData.buffer);
                        var _loop5 = function _loop5() {
                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) return "break";
                                _ref6 = _iterator6[_i6++];
                            } else {
                                if ((_i6 = _iterator6.next()).done) return "break";
                                _ref6 = _i6.value;
                            }
                            var bundle = _ref6;
                            uvOffset = bundle.view.offset, uvFormat = exports.GFXFormat.UNKNOWN;
                            var _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                                var _ref7;
                                if (_isArray7) {
                                    if (_i7 >= _iterator7.length) break;
                                    _ref7 = _iterator7[_i7++];
                                } else {
                                    if ((_i7 = _iterator7.next()).done) break;
                                    _ref7 = _i7.value;
                                }
                                var attr = _ref7;
                                if (0 <= attr.name.indexOf(exports.GFXAttributeName.ATTR_TEX_COORD)) {
                                    uvFormat = attr.format;
                                    break;
                                }
                                uvOffset += GFXFormatInfos[attr.format].size;
                            }
                            uvFormat && mapBuffer(dataView, function(cur, idx) {
                                var comp = 0 === idx ? "x" : "y";
                                return ((cur = function repeat$$1(n) {
                                    return n - Math.floor(n);
                                }(cur)) * unit.atlasSize[comp] + offset[comp]) / _this2._combinedTexSize;
                            }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                            var idxMap = jointIndexMap[i];
                            if (!idxMap) return "continue";
                            jointOffset = bundle.view.offset, jointFormat = exports.GFXFormat.UNKNOWN;
                            var _iterator8 = bundle.attributes, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                var _ref8;
                                if (_isArray8) {
                                    if (_i8 >= _iterator8.length) break;
                                    _ref8 = _iterator8[_i8++];
                                } else {
                                    if ((_i8 = _iterator8.next()).done) break;
                                    _ref8 = _i8.value;
                                }
                                var _attr = _ref8;
                                if (_attr.name === exports.GFXAttributeName.ATTR_JOINTS) {
                                    jointFormat = _attr.format;
                                    break;
                                }
                                jointOffset += GFXFormatInfos[_attr.format].size;
                            }
                            jointFormat && mapBuffer(dataView, function(cur) {
                                return idxMap[cur];
                            }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                        };
                        var _iterator6 = unit.mesh.struct.vertexBundles, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                        _loop4: for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            switch (_loop5()) {
                              case "break":
                                break _loop4;

                              case "continue":
                                continue;
                            }
                        }
                        _this2._mesh.merge(newMesh);
                    };
                    for (i = 0; i < avatarLen; i++) _loop3(i);
                    this._onMeshChanged(this._mesh), this._updateModels();
                }
            }
        }, {
            key: "resizeCombinedTexture",
            value: function resizeCombinedTexture() {
                this._combinedTex && (this._combinedTex.destroy(), this._combinedTex.create(this._combinedTexSize, this._combinedTexSize, PixelFormat.RGBA8888));
            }
        }, {
            key: "mesh",
            get: function get$$1() {
                return this._mesh;
            }
        }, {
            key: "skeleton",
            get: function get$$1() {
                return this._skeleton;
            }
        }, {
            key: "skinningRoot",
            get: function get$$1() {
                return this._skinningRoot;
            }
        }, {
            key: "combinedTexSize",
            get: function get$$1() {
                return this._combinedTexSize;
            },
            set: function set$$1(size) {
                this._combinedTexSize = size;
            }
        }, {
            key: "albedoMapName",
            get: function get$$1() {
                return this._albedoMapName;
            },
            set: function set$$1(name) {
                this._albedoMapName !== name && (this._albedoMapName = name);
            }
        }, {
            key: "avatarUnits",
            get: function get$$1() {
                return this._avatarUnits;
            },
            set: function set$$1(units) {
                this._avatarUnits = units;
            }
        } ]), AvatarModelComponent;
    }()).prototype, "_combinedTexSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1024;
        }
    }), _descriptor8$2 = _applyDecoratedDescriptor(_class5$1.prototype, "_albedoMapName", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor9$2 = _applyDecoratedDescriptor(_class5$1.prototype, "_avatarUnits", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class5$1.prototype, "mesh", [ _dec11$1 ], Object.getOwnPropertyDescriptor(_class5$1.prototype, "mesh"), _class5$1.prototype), 
    _applyDecoratedDescriptor(_class5$1.prototype, "skeleton", [ _dec12$1 ], Object.getOwnPropertyDescriptor(_class5$1.prototype, "skeleton"), _class5$1.prototype), 
    _applyDecoratedDescriptor(_class5$1.prototype, "skinningRoot", [ _dec13$1 ], Object.getOwnPropertyDescriptor(_class5$1.prototype, "skinningRoot"), _class5$1.prototype), 
    _applyDecoratedDescriptor(_class5$1.prototype, "combinedTexSize", [ _dec14$1 ], Object.getOwnPropertyDescriptor(_class5$1.prototype, "combinedTexSize"), _class5$1.prototype), 
    _applyDecoratedDescriptor(_class5$1.prototype, "albedoMapName", [ _dec15$1 ], Object.getOwnPropertyDescriptor(_class5$1.prototype, "albedoMapName"), _class5$1.prototype), 
    _applyDecoratedDescriptor(_class5$1.prototype, "avatarUnits", [ _dec16$1 ], Object.getOwnPropertyDescriptor(_class5$1.prototype, "avatarUnits"), _class5$1.prototype), 
    _class4$1 = _class5$1)) || _class4$1) || _class4$1) || _class4$1) || _class4$1), batch_id = {
        name: exports.GFXAttributeName.ATTR_BATCH_ID,
        format: exports.GFXFormat.R32F,
        isNormalized: !1
    }, batch_uv = {
        name: exports.GFXAttributeName.ATTR_BATCH_UV,
        format: exports.GFXFormat.RG32F,
        isNormalized: !1
    }, batch_extras_size = GFXFormatInfos[batch_id.format].size + GFXFormatInfos[batch_uv.format].size, SkinningModelUnit = (_dec$C = ccclass("cc.SkinningModelUnit"), 
    _dec2$h = property(Mesh), _dec3$9 = property(Skeleton), _dec4$6 = property(Node$1), 
    _dec5$4 = property(Material), _dec6$4 = property({
        type: SkinningModelComponent
    }), _dec$C((_descriptor$s = _applyDecoratedDescriptor((_class2$u = function() {
        function SkinningModelUnit() {
            _classCallCheck(this, SkinningModelUnit), _initializerDefineProperty(this, "mesh", _descriptor$s, this), 
            _initializerDefineProperty(this, "skeleton", _descriptor2$k, this), _initializerDefineProperty(this, "skinningRoot", _descriptor3$b, this), 
            _initializerDefineProperty(this, "material", _descriptor4$9, this), _initializerDefineProperty(this, "_offset", _descriptor5$7, this), 
            _initializerDefineProperty(this, "_size", _descriptor6$4, this);
        }
        return _createClass(SkinningModelUnit, [ {
            key: "offset",
            set: function set$$1(offset) {
                vec2.copy(this._offset, offset);
            },
            get: function get$$1() {
                return this._offset;
            }
        }, {
            key: "size",
            set: function set$$1(size) {
                vec2.copy(this._size, size);
            },
            get: function get$$1() {
                return this._size;
            }
        }, {
            key: "copyFrom",
            set: function set$$1(comp) {
                comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.skinningRoot = comp.skinningRoot, 
                this.material = comp.getSharedMaterial(0));
            },
            get: function get$$1() {
                return null;
            }
        } ]), SkinningModelUnit;
    }()).prototype, "mesh", [ _dec2$h ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$k = _applyDecoratedDescriptor(_class2$u.prototype, "skeleton", [ _dec3$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$b = _applyDecoratedDescriptor(_class2$u.prototype, "skinningRoot", [ _dec4$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$u.prototype, "material", [ _dec5$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$u.prototype, "_offset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(0, 0);
        }
    }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$u.prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(1, 1);
        }
    }), _applyDecoratedDescriptor(_class2$u.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "offset"), _class2$u.prototype), 
    _applyDecoratedDescriptor(_class2$u.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "size"), _class2$u.prototype), 
    _applyDecoratedDescriptor(_class2$u.prototype, "copyFrom", [ _dec6$4 ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "copyFrom"), _class2$u.prototype), 
    _class$C = _class2$u)) || _class$C), getPrefix$1 = function getPrefix(lca, target) {
        for (var prefix = "", cur = target; cur && cur !== lca; ) prefix = "".concat(cur.name, "/") + prefix, 
        cur = cur.parent;
        return prefix;
    }, concatPath$1 = function concatPath(prefix, path) {
        return path ? prefix + path : prefix.slice(0, -1);
    }, BatchedSkinningModelComponent = (_dec7$4 = ccclass("cc.BatchedSkinningModelComponent"), 
    _dec8$2 = executionOrder(100), _dec9$2 = menu("Components/BatchedSkinningModelComponent"), 
    _dec10$2 = property({
        type: [ String ]
    }), _dec11$2 = property({
        type: [ SkinningModelUnit ]
    }), _dec12$2 = property({
        override: !0,
        visible: !1
    }), _dec13$2 = property({
        override: !0,
        visible: !1
    }), _dec14$2 = property({
        override: !0,
        visible: !1
    }), _dec7$4(_class4$2 = _dec8$2(_class4$2 = executeInEditMode(_class4$2 = _dec9$2((_descriptor7$3 = _applyDecoratedDescriptor((_class5$2 = function(_SkinningModelCompone) {
        function BatchedSkinningModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, BatchedSkinningModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BatchedSkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "atlasSize", _descriptor7$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "batchableTextureNames", _descriptor8$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "units", _descriptor9$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._textures = {}, _this._batchMaterial = null, _this;
        }
        return _inherits(BatchedSkinningModelComponent, SkinningModelComponent), _createClass(BatchedSkinningModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._batchMaterial = this.getSharedMaterial(0), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onLoad", this).call(this), 
                this.cook();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                for (var _arr = Object.keys(this._textures), _i = 0; _i < _arr.length; _i++) {
                    var tex = _arr[_i];
                    this._textures[tex].destroy();
                }
                this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onDestroy", this).call(this);
            }
        }, {
            key: "cook",
            value: function cook() {
                this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
            }
        }, {
            key: "cookMaterials",
            value: function cookMaterials() {
                var _this2 = this, mat = this.getMaterial(0);
                if (mat && this._batchMaterial && mat.effectAsset) {
                    mat.copy(this._batchMaterial), this.resizeAtlases();
                    for (var tech = mat.effectAsset.techniques[mat.technique], _loop = function _loop(i) {
                        var pass = tech.passes[i];
                        if (!pass.properties) return "continue";
                        for (var _arr2 = Object.keys(pass.properties), _loop2 = function _loop2() {
                            var prop = _arr2[_i2];
                            if (pass.properties[prop].type >= GFXType.SAMPLER1D) {
                                var tex = null;
                                _this2.batchableTextureNames.find(function(n) {
                                    return n === prop;
                                }) ? ((tex = _this2._textures[prop]) || (tex = _this2.createTexture(prop)), _this2.cookTextures(tex, prop, i)) : _this2.units.some(function(u) {
                                    return tex = u.material && u.material.getProperty(prop, i);
                                }), tex && mat.setProperty(prop, tex, i);
                            } else {
                                var value = [], _iterator = _this2.units, _isArray = Array.isArray(_iterator), _i3 = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref;
                                    if (_isArray) {
                                        if (_i3 >= _iterator.length) break;
                                        _ref = _iterator[_i3++];
                                    } else {
                                        if ((_i3 = _iterator.next()).done) break;
                                        _ref = _i3.value;
                                    }
                                    var unit = _ref;
                                    unit.material && value.push(unit.material.getProperty(prop.slice(0, -3), i));
                                }
                                mat.setProperty(prop, value, i);
                            }
                        }, _i2 = 0; _i2 < _arr2.length; _i2++) _loop2();
                    }, i = 0; i < tech.passes.length; i++) _loop(i);
                } else console.warn("incomplete batch material!");
            }
        }, {
            key: "cookSkeletons",
            value: function cookSkeletons() {
                var lca = null, _iterator2 = this.units, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i4 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i4++];
                    } else {
                        if ((_i4 = _iterator2.next()).done) break;
                        _ref2 = _i4.value;
                    }
                    var unit = _ref2;
                    if (unit && unit.skinningRoot) {
                        var cur = unit.skinningRoot;
                        lca = lca ? LCA(lca, cur) : cur;
                    }
                }
                if (this._skinningRoot = lca) {
                    var skeleton = new Skeleton(), _iterator3 = this.units, _isArray3 = Array.isArray(_iterator3), _i5 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i5 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i5++];
                        } else {
                            if ((_i5 = _iterator3.next()).done) break;
                            _ref3 = _i5.value;
                        }
                        var _unit = _ref3;
                        if (_unit && _unit.skeleton && _unit.skinningRoot) for (var partial = _unit.skeleton, prefix = getPrefix$1(lca, _unit.skinningRoot), _loop3 = function _loop3(i) {
                            var path = concatPath$1(prefix, partial.joints[i]);
                            if (0 <= skeleton.joints.findIndex(function(p) {
                                return p === path;
                            })) return "continue";
                            skeleton.joints.push(path), skeleton.bindposes.push(partial.bindposes[i]);
                        }, i = 0; i < partial.joints.length; i++) _loop3(i);
                    }
                    var idxMap = _toConsumableArray(Array(skeleton.joints.length).keys()).sort(function(a, b) {
                        return skeleton.joints[a] > skeleton.joints[b] ? 1 : skeleton.joints[a] < skeleton.joints[b] ? -1 : 0;
                    });
                    skeleton.joints = skeleton.joints.map(function(_, idx, arr) {
                        return arr[idxMap[idx]];
                    }), skeleton.bindposes = skeleton.bindposes.map(function(_, idx, arr) {
                        return arr[idxMap[idx]];
                    }), _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", skeleton, this, !0);
                } else console.warn("illegal skinning roots");
            }
        }, {
            key: "cookMeshes",
            value: function cookMeshes() {
                var _this3 = this, isValid = !1, _iterator4 = this.units, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i6 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i6++];
                    } else {
                        if ((_i6 = _iterator4.next()).done) break;
                        _ref4 = _i6.value;
                    }
                    if (_ref4.mesh) {
                        isValid = !0;
                        break;
                    }
                }
                if (this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh(), isValid && this._skinningRoot) {
                    for (var dataView, uvOffset = 0, uvFormat = exports.GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = exports.GFXFormat.UNKNOWN, jointIndexMap = new Array(this.units.length), unitLen = this.units.length, _loop4 = function _loop4(i) {
                        var unit = _this3.units[i];
                        if (!unit || !unit.skeleton || !unit.skinningRoot) return "continue";
                        var prefix = getPrefix$1(_this3._skinningRoot, unit.skinningRoot);
                        jointIndexMap[i] = unit.skeleton.joints.map(function(j) {
                            var path = concatPath$1(prefix, j);
                            return _this3._skeleton.joints.findIndex(function(ref) {
                                return path === ref;
                            });
                        });
                    }, i = 0; i < unitLen; i++) _loop4(i);
                    var _loop5 = function _loop5(i) {
                        var unit = _this3.units[i];
                        if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                        var newMeshStruct = JSON.parse(JSON.stringify(unit.mesh.struct)), newOffset = 0, _iterator5 = newMeshStruct.vertexBundles, _isArray5 = Array.isArray(_iterator5), _i7 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref5;
                            if (_isArray5) {
                                if (_i7 >= _iterator5.length) break;
                                _ref5 = _iterator5[_i7++];
                            } else {
                                if ((_i7 = _iterator5.next()).done) break;
                                _ref5 = _i7.value;
                            }
                            var vb = _ref5;
                            vb.attributes.push(batch_id), vb.attributes.push(batch_uv), vb.view.offset = newOffset, 
                            vb.view.length += vb.view.count * batch_extras_size, vb.view.stride += batch_extras_size, 
                            newOffset += vb.view.length;
                        }
                        var _iterator6 = newMeshStruct.primitives, _isArray6 = Array.isArray(_iterator6), _i8 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i8 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i8++];
                            } else {
                                if ((_i8 = _iterator6.next()).done) break;
                                _ref6 = _i8.value;
                            }
                            var pm = _ref6;
                            pm.indexView && (pm.indexView.offset = newOffset, newOffset += pm.indexView.length), 
                            pm.geometricInfo && (newOffset = 4 * Math.ceil(newOffset / 4), pm.geometricInfo.view.offset = newOffset, 
                            newOffset += pm.geometricInfo.view.length);
                        }
                        var src = unit.mesh.data, oldOffset = 0, newMeshData = new Uint8Array(newOffset);
                        dataView = new DataView(newMeshData.buffer);
                        for (var k = 0; k < newMeshStruct.vertexBundles.length; k++) {
                            var uvs = unit.mesh.readAttribute(k, exports.GFXAttributeName.ATTR_TEX_COORD), oldView = unit.mesh.struct.vertexBundles[k].view, newView = newMeshStruct.vertexBundles[k].view, oldStride = oldView.stride, newStride = newView.stride;
                            oldOffset = oldView.offset, newOffset = newView.offset;
                            for (var j = 0; j < newView.count; j++) {
                                var srcVertex = src.subarray(oldOffset, oldOffset + oldStride);
                                newMeshData.set(srcVertex, newOffset), dataView.setFloat32(newOffset + oldStride, i, cc.sys.isLittleEndian), 
                                dataView.setFloat32(newOffset + oldStride + 4, uvs[2 * j], cc.sys.isLittleEndian), 
                                dataView.setFloat32(newOffset + oldStride + 8, uvs[2 * j + 1], cc.sys.isLittleEndian), 
                                newOffset += newStride, oldOffset += oldStride;
                            }
                        }
                        for (var _k = 0; _k < newMeshStruct.primitives.length; _k++) {
                            var oldPrimitive = unit.mesh.struct.primitives[_k], newPrimitive = newMeshStruct.primitives[_k];
                            if (oldPrimitive.indexView && newPrimitive.indexView) {
                                var _oldStride = oldPrimitive.indexView.stride, _newStride = newPrimitive.indexView.stride;
                                oldOffset = oldPrimitive.indexView.offset, newOffset = newPrimitive.indexView.offset;
                                for (var _j = 0; _j < newPrimitive.indexView.count; _j++) {
                                    var srcIndices = src.subarray(oldOffset, oldOffset + _oldStride);
                                    newMeshData.set(srcIndices, newOffset), newOffset += _newStride, oldOffset += _oldStride;
                                }
                            }
                            if (oldPrimitive.geometricInfo && newPrimitive.geometricInfo) {
                                var _oldStride2 = oldPrimitive.geometricInfo.view.stride, _newStride2 = newPrimitive.geometricInfo.view.stride;
                                oldOffset = oldPrimitive.geometricInfo.view.offset, newOffset = newPrimitive.geometricInfo.view.offset;
                                for (var _j2 = 0; _j2 < newPrimitive.geometricInfo.view.count; _j2++) {
                                    var srcPositions = src.subarray(oldOffset, oldOffset + _oldStride2);
                                    newMeshData.set(srcPositions, newOffset), newOffset += _newStride2, oldOffset += _oldStride2;
                                }
                            }
                        }
                        var newMesh = new Mesh();
                        newMesh.assign(newMeshStruct, newMeshData);
                        var offset = unit.offset, size = unit.size, _loop7 = function _loop7() {
                            if (_isArray7) {
                                if (_i9 >= _iterator7.length) return "break";
                                _ref7 = _iterator7[_i9++];
                            } else {
                                if ((_i9 = _iterator7.next()).done) return "break";
                                _ref7 = _i9.value;
                            }
                            var bundle = _ref7;
                            uvOffset = bundle.view.offset, uvFormat = exports.GFXFormat.UNKNOWN;
                            var _iterator8 = bundle.attributes, _isArray8 = Array.isArray(_iterator8), _i10 = 0;
                            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                                var _ref8;
                                if (_isArray8) {
                                    if (_i10 >= _iterator8.length) break;
                                    _ref8 = _iterator8[_i10++];
                                } else {
                                    if ((_i10 = _iterator8.next()).done) break;
                                    _ref8 = _i10.value;
                                }
                                var attr = _ref8;
                                if (attr.name === exports.GFXAttributeName.ATTR_BATCH_UV) {
                                    uvFormat = attr.format;
                                    break;
                                }
                                uvOffset += GFXFormatInfos[attr.format].size;
                            }
                            uvFormat && mapBuffer(dataView, function(cur, idx) {
                                var comp = 0 === idx ? "x" : "y";
                                return (cur = function repeat$$1(n) {
                                    return n - Math.floor(n);
                                }(cur)) * size[comp] + offset[comp];
                            }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                            var idxMap = jointIndexMap[i];
                            if (!idxMap) return "continue";
                            jointOffset = bundle.view.offset, jointFormat = exports.GFXFormat.UNKNOWN;
                            var _iterator9 = bundle.attributes, _isArray9 = Array.isArray(_iterator9), _i11 = 0;
                            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray9) {
                                    if (_i11 >= _iterator9.length) break;
                                    _ref9 = _iterator9[_i11++];
                                } else {
                                    if ((_i11 = _iterator9.next()).done) break;
                                    _ref9 = _i11.value;
                                }
                                var _attr = _ref9;
                                if (_attr.name === exports.GFXAttributeName.ATTR_JOINTS) {
                                    jointFormat = _attr.format;
                                    break;
                                }
                                jointOffset += GFXFormatInfos[_attr.format].size;
                            }
                            jointFormat && mapBuffer(dataView, function(cur) {
                                return idxMap[cur];
                            }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                        };
                        var _iterator7 = newMeshStruct.vertexBundles, _isArray7 = Array.isArray(_iterator7), _i9 = 0;
                        _loop6: for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            switch (_loop7()) {
                              case "break":
                                break _loop6;

                              case "continue":
                                continue;
                            }
                        }
                        _this3._mesh.merge(newMesh);
                    };
                    for (i = 0; i < unitLen; i++) _loop5(i);
                    this._onMeshChanged(this._mesh), this._updateModels();
                }
            }
        }, {
            key: "cookTextures",
            value: function cookTextures(target, prop, passIdx) {
                var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], _iterator10 = this.units, _isArray10 = Array.isArray(_iterator10), _i12 = 0;
                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                    var _ref10;
                    if (_isArray10) {
                        if (_i12 >= _iterator10.length) break;
                        _ref10 = _iterator10[_i12++];
                    } else {
                        if ((_i12 = _iterator10.next()).done) break;
                        _ref10 = _i12.value;
                    }
                    var unit = _ref10;
                    if (unit.material) {
                        var partial = unit.material.getProperty(prop, passIdx);
                        if (partial && partial.image && partial.image.data) {
                            var region = new GFXBufferTextureCopy();
                            region.texOffset.x = unit.offset.x * this.atlasSize, region.texOffset.y = unit.offset.y * this.atlasSize, 
                            region.texExtent.width = unit.size.x * this.atlasSize, region.texExtent.height = unit.size.y * this.atlasSize;
                            var data = partial.image.data;
                            data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                            texImageRegions.push(region)) : (texBuffers.push(data.buffer), texBufferRegions.push(region));
                        }
                    }
                }
                var gfxTex = target.getGFXTexture(), device = cc.director.root.device;
                0 < texBuffers.length && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
                0 < texImages.length && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
            }
        }, {
            key: "createTexture",
            value: function createTexture(prop) {
                var tex = new Texture2D();
                return tex.setFilters(Filter.LINEAR, Filter.LINEAR), tex.create(this.atlasSize, this.atlasSize, PixelFormat.RGBA8888), 
                tex.loaded = !0, this._textures[prop] = tex;
            }
        }, {
            key: "resizeAtlases",
            value: function resizeAtlases() {
                for (var _arr3 = Object.keys(this._textures), _i13 = 0; _i13 < _arr3.length; _i13++) {
                    var prop = _arr3[_i13];
                    this._textures[prop].create(this.atlasSize, this.atlasSize, PixelFormat.RGBA8888);
                }
            }
        }, {
            key: "mesh",
            get: function get$$1() {
                return this._mesh;
            },
            set: function set$$1(val) {
                _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", val, this, !0);
            }
        }, {
            key: "skeleton",
            get: function get$$1() {
                return this._skeleton;
            },
            set: function set$$1(val) {
                _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", val, this, !0);
            }
        }, {
            key: "skinningRoot",
            get: function get$$1() {
                return this._skinningRoot;
            },
            set: function set$$1(val) {
                _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skinningRoot", val, this, !0);
            }
        } ]), BatchedSkinningModelComponent;
    }()).prototype, "atlasSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1024;
        }
    }), _descriptor8$3 = _applyDecoratedDescriptor(_class5$2.prototype, "batchableTextureNames", [ _dec10$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor9$3 = _applyDecoratedDescriptor(_class5$2.prototype, "units", [ _dec11$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class5$2.prototype, "mesh", [ _dec12$2 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "mesh"), _class5$2.prototype), 
    _applyDecoratedDescriptor(_class5$2.prototype, "skeleton", [ _dec13$2 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "skeleton"), _class5$2.prototype), 
    _applyDecoratedDescriptor(_class5$2.prototype, "skinningRoot", [ _dec14$2 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "skinningRoot"), _class5$2.prototype), 
    _class4$2 = _class5$2)) || _class4$2) || _class4$2) || _class4$2) || _class4$2), ProjectionType = Enum({
        ORTHO: 0,
        PERSPECTIVE: 1
    }), CameraClearFlag = Enum({
        SOLID_COLOR: GFXClearFlag.ALL,
        DEPTH_ONLY: GFXClearFlag.DEPTH_STENCIL,
        DONT_CLEAR: GFXClearFlag.NONE
    }), c4_1 = color4.create(), CameraComponent = (_dec$D = ccclass("cc.CameraComponent"), 
    _dec2$i = menu("Components/CameraComponent"), _dec3$a = property({
        type: ProjectionType
    }), _dec4$7 = property({
        type: CameraClearFlag
    }), _dec$D(_class$D = _dec2$i(_class$D = executeInEditMode((_temp$z = _class3$c = function(_Component) {
        function CameraComponent() {
            var _this;
            return _classCallCheck(this, CameraComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CameraComponent).call(this)), "_projection", _descriptor$t, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_priority", _descriptor2$l, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fov", _descriptor3$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_orthoHeight", _descriptor4$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_near", _descriptor5$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_far", _descriptor6$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_color", _descriptor7$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_depth", _descriptor8$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_stencil", _descriptor9$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_clearFlags", _descriptor10$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_rect", _descriptor11$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_screenScale", _descriptor12$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_targetDisplay", _descriptor13$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._camera = null, _this;
        }
        return _inherits(CameraComponent, Component), _createClass(CameraComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneChanged, this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._camera || this._createCamera(), this._camera.enabled = !0;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._camera && (this._camera.enabled = !1);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._camera && (this._getRenderScene().destroyCamera(this._camera), this._camera = null);
            }
        }, {
            key: "screenPointToRay",
            value: function screenPointToRay(x, y, out) {
                return out || (out = ray.create()), this._camera && this._camera.screenPointToRay(out, x, y), 
                out;
            }
        }, {
            key: "worldToScreen",
            value: function worldToScreen(worldPos, out) {
                return out || (out = new Vec3()), this._camera && this._camera.worldToScreen(out, worldPos), 
                out;
            }
        }, {
            key: "screenToWorld",
            value: function screenToWorld(screenPos, out) {
                return out || (out = this.node.getWorldPosition()), this._camera && this._camera.screenToWorld(out, screenPos), 
                out;
            }
        }, {
            key: "_createCamera",
            value: function _createCamera() {
                var _this2 = this;
                if (this.node.scene) {
                    var scene = this._getRenderScene();
                    this._camera && scene.cameras.find(function(c) {
                        return c === _this2._camera;
                    }) || (this._camera = scene.createCamera({
                        name: this.node.name,
                        node: this.node,
                        projection: this._projection,
                        targetDisplay: this._targetDisplay,
                        priority: this._priority
                    }), this._camera.viewport = this._rect, this._camera.fov = toRadian(this._fov), 
                    this._camera.orthoHeight = this._orthoHeight, this._camera.nearClip = this._near, 
                    this._camera.farClip = this._far, this._camera.clearColor = color4.create(this._color.r / 255, this._color.g / 255, this._color.b / 255, this._color.a / 255), 
                    this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, 
                    this._camera.clearFlag = this._clearFlags);
                }
            }
        }, {
            key: "onSceneChanged",
            value: function onSceneChanged(scene) {
                this._camera && this._camera.scene !== scene.renderScene && (this._createCamera(), 
                this._camera.enabled = !0);
            }
        }, {
            key: "projection",
            get: function get() {
                return this._projection;
            },
            set: function set(val) {
                this._projection = val, this._camera && (this._camera.projectionType = val);
            }
        }, {
            key: "fov",
            get: function get() {
                return this._fov;
            },
            set: function set(val) {
                this._fov = val, this._camera && (this._camera.fov = toRadian(val));
            }
        }, {
            key: "orthoHeight",
            get: function get() {
                return this._orthoHeight;
            },
            set: function set(val) {
                this._orthoHeight = val, this._camera && (this._camera.orthoHeight = val);
            }
        }, {
            key: "near",
            get: function get() {
                return this._near;
            },
            set: function set(val) {
                this._near = val, this._camera && (this._camera.nearClip = val);
            }
        }, {
            key: "far",
            get: function get() {
                return this._far;
            },
            set: function set(val) {
                this._far = val, this._camera && (this._camera.farClip = val);
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                this._color.set(val), this._camera && (color4.set(c4_1, val.r / 255, val.g / 255, val.b / 255, val.a / 255), 
                this._camera.clearColor = c4_1);
            }
        }, {
            key: "depth",
            get: function get() {
                return this._depth;
            },
            set: function set(val) {
                this._depth = val, this._camera && (this._camera.clearDepth = val);
            }
        }, {
            key: "stencil",
            get: function get() {
                return this._stencil;
            },
            set: function set(val) {
                this._stencil = val, this._camera && (this._camera.clearStencil = val);
            }
        }, {
            key: "clearFlags",
            get: function get() {
                return this._clearFlags;
            },
            set: function set(val) {
                this._clearFlags = val, this._camera && (this._camera.clearFlag = val);
            }
        }, {
            key: "rect",
            get: function get() {
                return this._rect;
            },
            set: function set(val) {
                this._rect = val, this._camera && (this._camera.viewport = val);
            }
        }, {
            key: "screenScale",
            get: function get() {
                return this._screenScale;
            },
            set: function set(val) {
                this._screenScale = val, this._camera && (this._camera.screenScale = val);
            }
        }, {
            key: "targetDisplay",
            get: function get() {
                return this._targetDisplay;
            },
            set: function set(val) {
                this._targetDisplay = val, this._camera && this._camera.changeTargetDisplay(val);
            }
        } ]), CameraComponent;
    }(), _class3$c.ProjectionType = ProjectionType, _descriptor$t = _applyDecoratedDescriptor((_class2$v = _temp$z).prototype, "_projection", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ProjectionType.PERSPECTIVE;
        }
    }), _descriptor2$l = _applyDecoratedDescriptor(_class2$v.prototype, "_priority", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor3$c = _applyDecoratedDescriptor(_class2$v.prototype, "_fov", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 45;
        }
    }), _descriptor4$a = _applyDecoratedDescriptor(_class2$v.prototype, "_orthoHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 10;
        }
    }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$v.prototype, "_near", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor6$5 = _applyDecoratedDescriptor(_class2$v.prototype, "_far", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1e3;
        }
    }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$v.prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color().fromHEX("#334C78");
        }
    }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$v.prototype, "_depth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$v.prototype, "_stencil", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$v.prototype, "_clearFlags", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return CameraClearFlag.SOLID_COLOR;
        }
    }), _descriptor11$1 = _applyDecoratedDescriptor(_class2$v.prototype, "_rect", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Rect(0, 0, 1, 1);
        }
    }), _descriptor12$1 = _applyDecoratedDescriptor(_class2$v.prototype, "_screenScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor13$1 = _applyDecoratedDescriptor(_class2$v.prototype, "_targetDisplay", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$v.prototype, "projection", [ _dec3$a ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "projection"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "fov", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "fov"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "orthoHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "orthoHeight"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "near", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "near"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "far", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "far"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "color"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "depth", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "depth"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "stencil", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "stencil"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "clearFlags", [ _dec4$7 ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "clearFlags"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "rect", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "rect"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "screenScale", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "screenScale"), _class2$v.prototype), 
    _applyDecoratedDescriptor(_class2$v.prototype, "targetDisplay", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "targetDisplay"), _class2$v.prototype), 
    _class$D = _class2$v)) || _class$D) || _class$D) || _class$D);
    !function(LightType) {
        LightType[LightType.DIRECTIONAL = 0] = "DIRECTIONAL", LightType[LightType.SPHERE = 1] = "SPHERE", 
        LightType[LightType.SPOT = 2] = "SPOT", LightType[LightType.UNKNOWN = 3] = "UNKNOWN";
    }(LightType || (LightType = {}));
    var _dec$E, _dec2$j, _class$E, _class2$w, _descriptor$u, _descriptor2$m, _descriptor3$d, _class3$d, _temp$A, _dec$F, _dec2$k, _dec3$b, _class$F, _class2$x, _descriptor$v, _class$G, WebGLEXT, nt2lm = function nt2lm(size) {
        return 4 * Math.PI * Math.PI * size * size;
    }, Light = function() {
        function Light(scene, name, node) {
            _classCallCheck(this, Light), this._enabled = !0, this._color = new Vec3(1, 1, 1), 
            this._useColorTemp = !1, this._colorTemp = 6550, this._colorTempRGB = new Vec3(1, 1, 1), 
            this._scene = void 0, this._node = void 0, this._type = void 0, this._name = void 0, 
            this._scene = scene, this._name = name, this._type = LightType.UNKNOWN, this._node = node;
        }
        return _createClass(Light, [ {
            key: "enabled",
            set: function set(val) {
                this._enabled = val;
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "color",
            set: function set(color) {
                this._color.set(color);
            },
            get: function get() {
                return this._color;
            }
        }, {
            key: "useColorTemperature",
            set: function set(enable) {
                this._useColorTemp = enable;
            },
            get: function get() {
                return this._useColorTemp;
            }
        }, {
            key: "colorTemperature",
            set: function set(val) {
                this._colorTemp = val, function ColorTemperatureToRGB(rgb, kelvin) {
                    kelvin < 1e3 ? kelvin = 1e3 : 15e3 < kelvin && (kelvin = 15e3);
                    var kSqr = kelvin * kelvin, u = (.860117757 + .000154118254 * kelvin + 1.28641212e-7 * kSqr) / (1 + .000842420235 * kelvin + 7.08145163e-7 * kSqr), v = (.317398726 + 422806245e-13 * kelvin + 4.20481691e-8 * kSqr) / (1 - 289741816e-13 * kelvin + 1.61456053e-7 * kSqr), d = 2 * u - 8 * v + 4, x = 3 * u / d, y = 2 * v / d, X = 1 / y * x, Z = 1 / y * (1 - x - y);
                    rgb.x = 3.2404542 * X - 1.5371385 + -.4985314 * Z, rgb.y = -.969266 * X + 1.8760108 + .041556 * Z, 
                    rgb.z = .0556434 * X - .2040259 + 1.0572252 * Z;
                }(this._colorTempRGB, this._colorTemp);
            },
            get: function get() {
                return this._colorTemp;
            }
        }, {
            key: "colorTemperatureRGB",
            get: function get() {
                return this._colorTempRGB;
            }
        }, {
            key: "node",
            set: function set(n) {
                this._node = n;
            },
            get: function get() {
                return this._node;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        } ]), _createClass(Light, [ {
            key: "update",
            value: function update() {}
        } ]), Light;
    }(), PhotometricTerm = Enum({
        LUMINOUS_POWER: 0,
        LUMINANCE: 1
    }), LightComponent = (_dec$E = ccclass("cc.LightComponent"), _dec2$j = property({
        slide: !0,
        range: [ 1e3, 15e3, 1 ]
    }), _dec$E((_temp$A = _class3$d = function(_Component) {
        function LightComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, LightComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$u, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_useColorTemperature", _descriptor2$m, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_colorTemperature", _descriptor3$d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._type = LightType.UNKNOWN, _this._light = null, _this;
        }
        return _inherits(LightComponent, Component), _createClass(LightComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._light ? this._light.enabled = !0 : this._createLight();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._light && (this._light.enabled = !1);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._destroyLight();
            }
        }, {
            key: "_createLight",
            value: function _createLight(scene) {
                this._light && (this.color = this._color, this.useColorTemperature = this._useColorTemperature, 
                this.colorTemperature = this._colorTemperature, this._light.node = this.node, this._light.enabled = this.enabledInHierarchy);
            }
        }, {
            key: "_destroyLight",
            value: function _destroyLight(scene) {
                this._light = null;
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                this._color = val, this._light && (this._light.color.x = val.r / 255, this._light.color.y = val.g / 255, 
                this._light.color.z = val.b / 255);
            }
        }, {
            key: "useColorTemperature",
            get: function get() {
                return this._useColorTemperature;
            },
            set: function set(enable) {
                this._useColorTemperature = enable, this._light && (this._light.useColorTemperature = enable);
            }
        }, {
            key: "colorTemperature",
            get: function get() {
                return this._colorTemperature;
            },
            set: function set(val) {
                this._colorTemperature = val, this._light && (this._light.colorTemperature = val);
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ]), LightComponent;
    }(), _class3$d.Type = LightType, _class3$d.PhotometricTerm = PhotometricTerm, _descriptor$u = _applyDecoratedDescriptor((_class2$w = _temp$A).prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE;
        }
    }), _descriptor2$m = _applyDecoratedDescriptor(_class2$w.prototype, "_useColorTemperature", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$d = _applyDecoratedDescriptor(_class2$w.prototype, "_colorTemperature", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 6550;
        }
    }), _applyDecoratedDescriptor(_class2$w.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "color"), _class2$w.prototype), 
    _applyDecoratedDescriptor(_class2$w.prototype, "useColorTemperature", [ property ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "useColorTemperature"), _class2$w.prototype), 
    _applyDecoratedDescriptor(_class2$w.prototype, "colorTemperature", [ _dec2$j ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "colorTemperature"), _class2$w.prototype), 
    _class$E = _class2$w)) || _class$E), DirectionalLightComponent = (_dec$F = ccclass("cc.DirectionalLightComponent"), 
    _dec2$k = menu("Components/DirectionalLightComponent"), _dec3$b = property({
        unit: "lx"
    }), _dec$F(_class$F = _dec2$k(_class$F = executeInEditMode((_descriptor$v = _applyDecoratedDescriptor((_class2$x = function(_LightComponent) {
        function DirectionalLightComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, DirectionalLightComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(DirectionalLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_illuminance", _descriptor$v, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._type = LightType.DIRECTIONAL, _this._light = null, _this;
        }
        return _inherits(DirectionalLightComponent, LightComponent), _createClass(DirectionalLightComponent, [ {
            key: "_createLight",
            value: function _createLight(scene) {
                this.node.scene && (scene || (scene = this._getRenderScene()), scene.mainLight.node.activeInHierarchy ? console.warn("there can be only one directional(main) light.") : (this._light = scene.mainLight, 
                this.illuminance = this._illuminance, _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_createLight", this).call(this, scene)));
            }
        }, {
            key: "_destroyLight",
            value: function _destroyLight(scene) {
                this.node.scene && this._light && (this._light.enabled = !1, scene || (scene = this._getRenderScene()), 
                this._light.node = scene.defaultMainLightNode, _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_destroyLight", this).call(this, scene));
            }
        }, {
            key: "illuminance",
            get: function get$$1() {
                return this._illuminance;
            },
            set: function set(val) {
                this._illuminance = val, this._light && (this._light.illuminance = this._illuminance);
            }
        } ]), DirectionalLightComponent;
    }()).prototype, "_illuminance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 65e3;
        }
    }), _applyDecoratedDescriptor(_class2$x.prototype, "illuminance", [ _dec3$b ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "illuminance"), _class2$x.prototype), 
    _class$F = _class2$x)) || _class$F) || _class$F) || _class$F), EditorCameraComponent = ccclass("cc.EditorCameraComponent")(_class$G = function(_CameraComponent) {
        function EditorCameraComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EditorCameraComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditorCameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uiEditorCamera = null, 
            _this;
        }
        return _inherits(EditorCameraComponent, CameraComponent), _createClass(EditorCameraComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onLoad", this).call(this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onEnable", this).call(this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDisable", this).call(this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDestroy", this).call(this), 
                this._uiEditorCamera && (cc.director.root.ui.renderScene.destroyCamera(this._uiEditorCamera), 
                this._uiEditorCamera = null);
            }
        }, {
            key: "_createCamera",
            value: function _createCamera() {
                var priorCamera = this._camera;
                _get(_getPrototypeOf(EditorCameraComponent.prototype), "_createCamera", this).call(this), 
                this._camera !== priorCamera && this._camera && (this._uiEditorCamera && (cc.director.root.ui.renderScene.destroyCamera(this._uiEditorCamera), 
                this._uiEditorCamera = null), this._uiEditorCamera = cc.director.root.ui.renderScene.createCamera({
                    name: "Editor UICamera",
                    node: this._camera.node,
                    projection: this._projection,
                    targetDisplay: this._targetDisplay,
                    priority: this._priority,
                    isUI: !0,
                    flows: [ "UIFlow" ]
                }), this._uiEditorCamera.viewport = this._camera.viewport, this._uiEditorCamera.fov = this._camera.fov, 
                this._uiEditorCamera.nearClip = this._camera.nearClip, this._uiEditorCamera.farClip = this._camera.farClip, 
                this._uiEditorCamera.clearColor = this._camera.clearColor, this._uiEditorCamera.clearDepth = this._camera.clearDepth, 
                this._uiEditorCamera.clearStencil = this._camera.clearStencil, this._uiEditorCamera.clearFlag = this._camera.clearFlag);
            }
        }, {
            key: "projection",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "projection", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.projectionType = val);
            }
        }, {
            key: "fov",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "fov", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.fov = toRadian(val));
            }
        }, {
            key: "orthoHeight",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "orthoHeight", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.orthoHeight = val);
            }
        }, {
            key: "near",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "near", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.nearClip = val);
            }
        }, {
            key: "far",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "far", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.farClip = val);
            }
        }, {
            key: "color",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "color", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearColor = color4.create(val.r / 255, val.g / 255, val.b / 255, val.a / 255));
            }
        }, {
            key: "depth",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "depth", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearDepth = val);
            }
        }, {
            key: "stencil",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "stencil", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearStencil = val);
            }
        }, {
            key: "clearFlags",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "clearFlags", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.clearFlag = val);
            }
        }, {
            key: "rect",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "rect", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.viewport = val);
            }
        }, {
            key: "screenScale",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "screenScale", val, this, !0), 
                this._uiEditorCamera && (this._uiEditorCamera.screenScale = val);
            }
        }, {
            key: "targetDisplay",
            set: function set$$1(val) {
                _set(_getPrototypeOf(EditorCameraComponent.prototype), "targetDisplay", val, this, !0), 
                this._uiEditorCamera && this._uiEditorCamera.changeTargetDisplay(val);
            }
        } ]), EditorCameraComponent;
    }()) || _class$G, GFXBuffer = function(_GFXObject) {
        function GFXBuffer(device) {
            var _this;
            return _classCallCheck(this, GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBuffer).call(this, GFXObjectType.BUFFER)))._device = void 0, 
            _this._usage = GFXBufferUsageBit.NONE, _this._memUsage = GFXMemoryUsageBit.NONE, 
            _this._size = 0, _this._stride = 1, _this._count = 0, _this._device = device, _this;
        }
        return _inherits(GFXBuffer, GFXObject), _createClass(GFXBuffer, [ {
            key: "usage",
            get: function get() {
                return this._usage;
            }
        }, {
            key: "memUsage",
            get: function get() {
                return this._memUsage;
            }
        }, {
            key: "size",
            get: function get() {
                return this._size;
            }
        }, {
            key: "stride",
            get: function get() {
                return this._stride;
            }
        }, {
            key: "count",
            get: function get() {
                return this._count;
            }
        } ]), GFXBuffer;
    }(), GFXCommandBuffer = function(_GFXObject) {
        function GFXCommandBuffer(device) {
            var _this;
            return _classCallCheck(this, GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandBuffer).call(this, GFXObjectType.COMMAND_BUFFER)))._device = void 0, 
            _this._allocator = null, _this._type = GFXCommandBufferType.PRIMARY, _this._numDrawCalls = 0, 
            _this._numTris = 0, _this._device = device, _this;
        }
        return _inherits(GFXCommandBuffer, GFXObject), _createClass(GFXCommandBuffer, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "numDrawCalls",
            get: function get() {
                return this._numDrawCalls;
            }
        }, {
            key: "numTris",
            get: function get() {
                return this._numTris;
            }
        } ]), GFXCommandBuffer;
    }(), GFXFramebuffer = function(_GFXObject) {
        function GFXFramebuffer(device) {
            var _this;
            return _classCallCheck(this, GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXFramebuffer).call(this, GFXObjectType.FRAMEBUFFER)))._device = void 0, 
            _this._renderPass = null, _this._colorViews = [], _this._depthStencilView = null, 
            _this._isOffscreen = !0, _this._device = device, _this;
        }
        return _inherits(GFXFramebuffer, GFXObject), _createClass(GFXFramebuffer, [ {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        }, {
            key: "colorViews",
            get: function get() {
                return this._colorViews;
            }
        }, {
            key: "depthStencilView",
            get: function get() {
                return this._depthStencilView;
            }
        }, {
            key: "isOffscreen",
            get: function get() {
                return this._isOffscreen;
            }
        } ]), GFXFramebuffer;
    }(), GFXInputAssembler = function(_GFXObject) {
        function GFXInputAssembler(device) {
            var _this;
            return _classCallCheck(this, GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXInputAssembler).call(this, GFXObjectType.INPUT_ASSEMBLER)))._device = void 0, 
            _this._attributes = [], _this._vertexBuffers = [], _this._indexBuffer = null, _this._vertexCount = 0, 
            _this._firstVertex = 0, _this._indexCount = 0, _this._firstIndex = 0, _this._vertexOffset = 0, 
            _this._instanceCount = 0, _this._firstInstance = 0, _this._isIndirect = !1, _this._indirectBuffer = null, 
            _this._device = device, _this;
        }
        return _inherits(GFXInputAssembler, GFXObject), _createClass(GFXInputAssembler, [ {
            key: "vertexBuffers",
            get: function get() {
                return this._vertexBuffers;
            }
        }, {
            key: "indexBuffer",
            get: function get() {
                return this._indexBuffer;
            }
        }, {
            key: "attributes",
            get: function get() {
                return this._attributes;
            }
        }, {
            key: "vertexCount",
            get: function get() {
                return this._vertexCount;
            },
            set: function set(count) {
                this._vertexCount = count;
            }
        }, {
            key: "firstVertex",
            get: function get() {
                return this._firstVertex;
            },
            set: function set(first) {
                this._firstVertex = first;
            }
        }, {
            key: "indexCount",
            get: function get() {
                return this._indexCount;
            },
            set: function set(count) {
                this._indexCount = count;
            }
        }, {
            key: "firstIndex",
            get: function get() {
                return this._firstIndex;
            },
            set: function set(first) {
                this._firstIndex = first;
            }
        }, {
            key: "vertexOffset",
            get: function get() {
                return this._vertexOffset;
            },
            set: function set(offset) {
                this._vertexOffset = offset;
            }
        }, {
            key: "instanceCount",
            get: function get() {
                return this._instanceCount;
            },
            set: function set(count) {
                this._instanceCount = count;
            }
        }, {
            key: "firstInstance",
            get: function get() {
                return this._firstInstance;
            },
            set: function set(first) {
                this._firstInstance = first;
            }
        }, {
            key: "isIndirect",
            get: function get() {
                return this._isIndirect;
            }
        }, {
            key: "indirectBuffer",
            get: function get() {
                return this._indirectBuffer;
            }
        } ]), _createClass(GFXInputAssembler, [ {
            key: "getVertexBuffer",
            value: function getVertexBuffer() {
                var stream = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
                return stream < this._vertexBuffers.length ? this._vertexBuffers[stream] : null;
            }
        }, {
            key: "extractDrawInfo",
            value: function extractDrawInfo(drawInfo) {
                drawInfo.vertexCount = this._vertexCount, drawInfo.firstVertex = this._firstVertex, 
                drawInfo.indexCount = this._indexCount, drawInfo.firstIndex = this._firstIndex, 
                drawInfo.vertexOffset = this._vertexOffset, drawInfo.instanceCount = this._instanceCount, 
                drawInfo.firstInstance = this._firstInstance;
            }
        }, {
            key: "updateVertexAttr",
            value: function updateVertexAttr(vbuffer, attr, data) {
                var offset = 0, format = exports.GFXFormat.UNKNOWN, _iterator = this._attributes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var a = _ref;
                    if (a.name === attr) {
                        format = a.format;
                        break;
                    }
                    offset += GFXFormatInfos[a.format].size;
                }
                var vb = this._vertexBuffers[0];
                format && vb && (writeBuffer(new DataView(vbuffer), data, format, offset, vb.stride), 
                vb.update(vbuffer));
            }
        }, {
            key: "updateIndexBuffer",
            value: function updateIndexBuffer(ibuffer, data) {
                var count = this._indexCount, ib = this._indexBuffer;
                count && ib && (writeBuffer(new DataView(ibuffer), data, exports.GFXFormat["R".concat(8 * ib.stride, "UI")]), 
                ib.update(ibuffer), this._indexCount = data.length);
            }
        } ]), GFXInputAssembler;
    }(), GFXPipelineLayout = function(_GFXObject) {
        function GFXPipelineLayout(device) {
            var _this;
            return _classCallCheck(this, GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineLayout).call(this, GFXObjectType.PIPELINE_LAYOUT)))._device = void 0, 
            _this._pushConstantsRanges = [], _this._layouts = [], _this._device = device, _this;
        }
        return _inherits(GFXPipelineLayout, GFXObject), _createClass(GFXPipelineLayout, [ {
            key: "layouts",
            get: function get() {
                return this._layouts;
            }
        } ]), GFXPipelineLayout;
    }(), GFXQueue = function(_GFXObject) {
        function GFXQueue(device) {
            var _this;
            return _classCallCheck(this, GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXQueue).call(this, GFXObjectType.QUEUE)))._device = void 0, 
            _this._type = GFXQueueType.GRAPHICS, _this._device = device, _this;
        }
        return _inherits(GFXQueue, GFXObject), _createClass(GFXQueue, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        } ]), GFXQueue;
    }(), GFXRenderPass = function(_GFXObject) {
        function GFXRenderPass(device) {
            var _this;
            return _classCallCheck(this, GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXRenderPass).call(this, GFXObjectType.RENDER_PASS)))._device = void 0, 
            _this._colorInfos = [], _this._depthStencilInfo = null, _this._device = device, 
            _this;
        }
        return _inherits(GFXRenderPass, GFXObject), GFXRenderPass;
    }(), GFXSamplerState = function() {
        function GFXSamplerState() {
            _classCallCheck(this, GFXSamplerState), this.name = "", this.minFilter = GFXFilter.LINEAR, 
            this.magFilter = GFXFilter.LINEAR, this.mipFilter = GFXFilter.NONE, this.addressU = GFXAddress.WRAP, 
            this.addressV = GFXAddress.WRAP, this.addressW = GFXAddress.WRAP, this.maxAnisotropy = 16, 
            this.cmpFunc = GFXComparisonFunc.NEVER, this.borderColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, this.minLOD = 0, this.maxLOD = 0, this.mipLODBias = 0;
        }
        return _createClass(GFXSamplerState, [ {
            key: "compare",
            value: function compare(state) {
                return this.minFilter === state.minFilter && this.magFilter === state.magFilter && this.mipFilter === state.mipFilter && this.addressU === state.addressU && this.addressV === state.addressV && this.addressW === state.addressW && this.maxAnisotropy === state.maxAnisotropy && this.cmpFunc === state.cmpFunc && this.borderColor.r === state.borderColor.r && this.borderColor.g === state.borderColor.g && this.borderColor.b === state.borderColor.b && this.borderColor.a === state.borderColor.a && this.minLOD === state.minLOD && this.maxLOD === state.maxLOD && this.mipLODBias === state.mipLODBias;
            }
        } ]), GFXSamplerState;
    }(), GFXSampler = function(_GFXObject) {
        function GFXSampler(device) {
            var _this;
            return _classCallCheck(this, GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXSampler).call(this, GFXObjectType.SAMPLER)))._device = void 0, 
            _this._state = new GFXSamplerState(), _this._device = device, _this;
        }
        return _inherits(GFXSampler, GFXObject), _createClass(GFXSampler, [ {
            key: "state",
            get: function get() {
                return this._state;
            }
        } ]), GFXSampler;
    }(), GFXShader = function(_GFXObject) {
        function GFXShader(device) {
            var _this;
            return _classCallCheck(this, GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXShader).call(this, GFXObjectType.SHADER)))._device = void 0, 
            _this._id = void 0, _this._name = "", _this._stages = [], _this._blocks = [], _this._samplers = [], 
            _this._device = device, _this._id = device.genShaderId(), _this;
        }
        return _inherits(GFXShader, GFXObject), _createClass(GFXShader, [ {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        } ]), GFXShader;
    }(), GFXTexture = function(_GFXObject) {
        function GFXTexture(device) {
            var _this;
            return _classCallCheck(this, GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTexture).call(this, GFXObjectType.TEXTURE)))._device = void 0, 
            _this._type = GFXTextureType.TEX2D, _this._usage = GFXTextureUsageBit.NONE, _this._format = exports.GFXFormat.UNKNOWN, 
            _this._width = 0, _this._height = 0, _this._depth = 1, _this._arrayLayer = 1, _this._mipLevel = 1, 
            _this._samples = GFXSampleCount.X1, _this._flags = GFXTextureFlagBit.NONE, _this._isPowerOf2 = !1, 
            _this._size = 0, _this._buffer = null, _this._device = device, _this;
        }
        return _inherits(GFXTexture, GFXObject), _createClass(GFXTexture, [ {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "usage",
            get: function get() {
                return this._usage;
            }
        }, {
            key: "format",
            get: function get() {
                return this._format;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "depth",
            get: function get() {
                return this._depth;
            }
        }, {
            key: "arrayLayer",
            get: function get() {
                return this._arrayLayer;
            }
        }, {
            key: "mipLevel",
            get: function get() {
                return this._mipLevel;
            }
        }, {
            key: "samples",
            get: function get() {
                return this._samples;
            }
        }, {
            key: "flags",
            get: function get() {
                return this._flags;
            }
        }, {
            key: "size",
            get: function get() {
                return this._size;
            }
        }, {
            key: "buffer",
            get: function get() {
                return this._buffer;
            }
        } ]), GFXTexture;
    }(), GFXBindingLayout = function(_GFXObject) {
        function GFXBindingLayout(device) {
            var _this;
            return _classCallCheck(this, GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBindingLayout).call(this, GFXObjectType.BINDING_LAYOUT)))._device = void 0, 
            _this._bindingUnits = [], _this._isDirty = !1, _this._device = device, _this;
        }
        return _inherits(GFXBindingLayout, GFXObject), _createClass(GFXBindingLayout, [ {
            key: "bindBuffer",
            value: function bindBuffer(binding, buffer) {
                var _iterator = this._bindingUnits, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var bindingUnit = _ref;
                    if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.UNIFORM_BUFFER ? bindingUnit.buffer !== buffer && (bindingUnit.buffer = buffer, 
                    this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.UNIFORM_BUFFER."));
                }
            }
        }, {
            key: "bindSampler",
            value: function bindSampler(binding, sampler) {
                var _iterator2 = this._bindingUnits, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var bindingUnit = _ref2;
                    if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.SAMPLER ? bindingUnit.sampler !== sampler && (bindingUnit.sampler = sampler, 
                    this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
                }
            }
        }, {
            key: "bindTextureView",
            value: function bindTextureView(binding, texView) {
                var _iterator3 = this._bindingUnits, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var bindingUnit = _ref3;
                    if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.SAMPLER ? bindingUnit.texView !== texView && (bindingUnit.texView = texView, 
                    this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
                }
            }
        }, {
            key: "getBindingUnit",
            value: function getBindingUnit(binding) {
                var _iterator4 = this._bindingUnits, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var unit = _ref4;
                    if (unit.binding === binding) return unit;
                }
                return null;
            }
        } ]), GFXBindingLayout;
    }(), WebGLGFXBindingLayout = function(_GFXBindingLayout) {
        function WebGLGFXBindingLayout(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
            _this;
        }
        return _inherits(WebGLGFXBindingLayout, GFXBindingLayout), _createClass(WebGLGFXBindingLayout, [ {
            key: "gpuBindingLayout",
            get: function get() {
                return this._gpuBindingLayout;
            }
        } ]), _createClass(WebGLGFXBindingLayout, [ {
            key: "initialize",
            value: function initialize(info) {
                this._bindingUnits = new Array(info.bindings.length);
                for (var i = 0; i < info.bindings.length; ++i) {
                    var binding = info.bindings[i];
                    this._bindingUnits[i] = {
                        binding: binding.binding,
                        type: binding.type,
                        name: binding.name,
                        buffer: null,
                        texView: null,
                        sampler: null
                    };
                }
                this._gpuBindingLayout = {
                    gpuBindings: new Array(info.bindings.length)
                };
                for (var _i = 0; _i < info.bindings.length; ++_i) {
                    var _binding = info.bindings[_i];
                    this._gpuBindingLayout.gpuBindings[_i] = {
                        binding: _binding.binding,
                        type: _binding.type,
                        name: _binding.name,
                        gpuBuffer: null,
                        gpuTexView: null,
                        gpuSampler: null
                    };
                }
                return this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuBindingLayout = null, this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "update",
            value: function update() {
                if (this._isDirty && this._gpuBindingLayout) {
                    for (var i = 0; i < this._bindingUnits.length; ++i) {
                        var bindingUnit = this._bindingUnits[i];
                        switch (bindingUnit.type) {
                          case GFXBindingType.UNIFORM_BUFFER:
                            bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                            break;

                          case GFXBindingType.SAMPLER:
                            bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                            bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                        }
                    }
                    this._isDirty = !1;
                }
            }
        } ]), WebGLGFXBindingLayout;
    }(), CachedArray = function() {
        function CachedArray(length, compareFn) {
            _classCallCheck(this, CachedArray), this.array = void 0, this.length = 0, this.cache = void 0, 
            this._compareFn = void 0, this.array = new Array(length), this.cache = this.array, 
            this.length = 0, this._compareFn = void 0 !== compareFn ? compareFn : function(a, b) {
                return a - b;
            };
        }
        return _createClass(CachedArray, [ {
            key: "push",
            value: function push(item) {
                this.array[this.length++] = item;
            }
        }, {
            key: "pop",
            value: function pop() {
                return this.array[this.length--];
            }
        }, {
            key: "get",
            value: function get(idx) {
                return this.array[idx];
            }
        }, {
            key: "clear",
            value: function clear() {
                this.cache.fill(null), this.length = 0;
            }
        }, {
            key: "sort",
            value: function sort() {
                this.array.length = this.length, this.array.sort(this._compareFn);
            }
        }, {
            key: "concat",
            value: function concat(array) {
                for (var i = 0; i < array.length; ++i) this.array[this.length++] = array.array[i];
            }
        }, {
            key: "append",
            value: function append(array) {
                var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var item = _ref;
                    this.array[this.length++] = item;
                }
            }
        } ]), CachedArray;
    }();
    function CmpF32NotEuqal(a, b) {
        var c = a - b;
        return 1e-6 < c || c < -1e-6;
    }
    function GFXFormatToWebGLType(format) {
        switch (format) {
          case exports.GFXFormat.R8:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.R8SN:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.R8UI:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.R8I:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.R16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.R16UI:
            return WebGLRenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.R16I:
            return WebGLRenderingContext.SHORT;

          case exports.GFXFormat.R32F:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.R32UI:
            return WebGLRenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.R32I:
            return WebGLRenderingContext.INT;

          case exports.GFXFormat.RG8:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RG8SN:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.RG8UI:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RG8I:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.RG16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.RG16UI:
            return WebGLRenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.RG16I:
            return WebGLRenderingContext.SHORT;

          case exports.GFXFormat.RG32F:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.RG32UI:
            return WebGLRenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RG32I:
            return WebGLRenderingContext.INT;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.SRGB8:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB8SN:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.RGB8UI:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB8I:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.RGB16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.RGB16UI:
            return WebGLRenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.RGB16I:
            return WebGLRenderingContext.SHORT;

          case exports.GFXFormat.RGB32F:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.RGB32UI:
            return WebGLRenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RGB32I:
            return WebGLRenderingContext.INT;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.SRGB8_A8:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGBA8SN:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.RGBA8UI:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGBA8I:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.RGBA16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case exports.GFXFormat.RGBA16UI:
            return WebGLRenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.RGBA16I:
            return WebGLRenderingContext.SHORT;

          case exports.GFXFormat.RGBA32F:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.RGBA32UI:
            return WebGLRenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RGBA32I:
            return WebGLRenderingContext.INT;

          case exports.GFXFormat.R5G6B5:
            return WebGLRenderingContext.UNSIGNED_SHORT_5_6_5;

          case exports.GFXFormat.R11G11B10F:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.RGB5A1:
            return WebGLRenderingContext.UNSIGNED_SHORT_5_5_5_1;

          case exports.GFXFormat.RGBA4:
            return WebGLRenderingContext.UNSIGNED_SHORT_4_4_4_4;

          case exports.GFXFormat.RGB10A2:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB10A2UI:
            return WebGLRenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RGB9E5:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.D16:
          case exports.GFXFormat.D16S8:
            return WebGLRenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.D24:
            return WebGLRenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.D24S8:
            return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

          case exports.GFXFormat.D32F:
          case exports.GFXFormat.D32F_S8:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.BC1:
          case exports.GFXFormat.BC1_SRGB:
          case exports.GFXFormat.BC2:
          case exports.GFXFormat.BC2_SRGB:
          case exports.GFXFormat.BC3:
          case exports.GFXFormat.BC3_SRGB:
          case exports.GFXFormat.BC4:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.BC4_SNORM:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.BC5:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.BC5_SNORM:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.BC6H_SF16:
          case exports.GFXFormat.BC6H_UF16:
            return WebGLRenderingContext.FLOAT;

          case exports.GFXFormat.BC7:
          case exports.GFXFormat.BC7_SRGB:
          case exports.GFXFormat.ETC_RGB8:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.ETC2_RGB8_A1:
          case exports.GFXFormat.ETC2_SRGB8_A1:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.EAC_R11:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.EAC_R11SN:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.EAC_RG11:
            return WebGLRenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.EAC_RG11SN:
            return WebGLRenderingContext.BYTE;

          case exports.GFXFormat.PVRTC_RGB2:
          case exports.GFXFormat.PVRTC_RGBA2:
          case exports.GFXFormat.PVRTC_RGB4:
          case exports.GFXFormat.PVRTC_RGBA4:
          case exports.GFXFormat.PVRTC2_2BPP:
          case exports.GFXFormat.PVRTC2_4BPP:
          default:
            return WebGLRenderingContext.UNSIGNED_BYTE;
        }
    }
    function GFXFormatToWebGLInternalFormat(format) {
        switch (format) {
          case exports.GFXFormat.A8:
            return WebGLRenderingContext.ALPHA;

          case exports.GFXFormat.L8:
            return WebGLRenderingContext.LUMINANCE;

          case exports.GFXFormat.LA8:
            return WebGLRenderingContext.LUMINANCE_ALPHA;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.RGB16F:
          case exports.GFXFormat.RGB32F:
            return WebGLRenderingContext.RGB;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.RGBA16F:
          case exports.GFXFormat.RGBA32F:
            return WebGLRenderingContext.RGBA;

          case exports.GFXFormat.R5G6B5:
            return WebGLRenderingContext.RGB565;

          case exports.GFXFormat.RGB5A1:
            return WebGLRenderingContext.RGB5_A1;

          case exports.GFXFormat.RGBA4:
            return WebGLRenderingContext.RGBA4;

          case exports.GFXFormat.D16:
            return WebGLRenderingContext.DEPTH_COMPONENT16;

          case exports.GFXFormat.D16S8:
            return WebGLRenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D24:
            return WebGLRenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D24S8:
            return WebGLRenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D32F:
            return WebGLRenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D32F_S8:
            return WebGLRenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case exports.GFXFormat.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case exports.GFXFormat.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case exports.GFXFormat.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          default:
            return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
            WebGLRenderingContext.RGBA;
        }
    }
    function GFXFormatToWebGLFormat(format) {
        switch (format) {
          case exports.GFXFormat.A8:
            return WebGLRenderingContext.ALPHA;

          case exports.GFXFormat.L8:
            return WebGLRenderingContext.LUMINANCE;

          case exports.GFXFormat.LA8:
            return WebGLRenderingContext.LUMINANCE_ALPHA;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.RGB16F:
          case exports.GFXFormat.RGB32F:
            return WebGLRenderingContext.RGB;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.RGBA16F:
          case exports.GFXFormat.RGBA32F:
            return WebGLRenderingContext.RGBA;

          case exports.GFXFormat.R5G6B5:
            return WebGLRenderingContext.RGB;

          case exports.GFXFormat.RGB5A1:
          case exports.GFXFormat.RGBA4:
            return WebGLRenderingContext.RGBA;

          case exports.GFXFormat.D16:
            return WebGLRenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D16S8:
            return WebGLRenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D24:
            return WebGLRenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D24S8:
            return WebGLRenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D32F:
            return WebGLRenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D32F_S8:
            return WebGLRenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case exports.GFXFormat.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case exports.GFXFormat.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case exports.GFXFormat.ETC2_RGB8:
            return WebGLEXT.COMPRESSED_RGB8_ETC2;

          case exports.GFXFormat.ETC2_SRGB8:
            return WebGLEXT.COMPRESSED_SRGB8_ETC2;

          case exports.GFXFormat.ETC2_RGB8_A1:
            return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case exports.GFXFormat.ETC2_SRGB8_A1:
            return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case exports.GFXFormat.ETC2_RGBA8:
            return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

          case exports.GFXFormat.ETC2_SRGB8_A8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case exports.GFXFormat.EAC_R11:
            return WebGLEXT.COMPRESSED_R11_EAC;

          case exports.GFXFormat.EAC_R11SN:
            return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

          case exports.GFXFormat.EAC_RG11:
            return WebGLEXT.COMPRESSED_RG11_EAC;

          case exports.GFXFormat.EAC_RG11SN:
            return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

          case exports.GFXFormat.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          default:
            return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
            WebGLRenderingContext.RGBA;
        }
    }
    function GFXTypeToWebGLType(type) {
        switch (type) {
          case GFXType.BOOL:
            return WebGLRenderingContext.BOOL;

          case GFXType.BOOL2:
            return WebGLRenderingContext.BOOL_VEC2;

          case GFXType.BOOL3:
            return WebGLRenderingContext.BOOL_VEC3;

          case GFXType.BOOL4:
            return WebGLRenderingContext.BOOL_VEC4;

          case GFXType.INT:
            return WebGLRenderingContext.INT;

          case GFXType.INT2:
            return WebGLRenderingContext.INT_VEC2;

          case GFXType.INT3:
            return WebGLRenderingContext.INT_VEC3;

          case GFXType.INT4:
            return WebGLRenderingContext.INT_VEC4;

          case GFXType.UINT:
            return WebGLRenderingContext.UNSIGNED_INT;

          case GFXType.FLOAT:
            return WebGLRenderingContext.FLOAT;

          case GFXType.FLOAT2:
            return WebGLRenderingContext.FLOAT_VEC2;

          case GFXType.FLOAT3:
            return WebGLRenderingContext.FLOAT_VEC3;

          case GFXType.FLOAT4:
            return WebGLRenderingContext.FLOAT_VEC4;

          case GFXType.MAT2:
            return WebGLRenderingContext.FLOAT_MAT2;

          case GFXType.MAT3:
            return WebGLRenderingContext.FLOAT_MAT3;

          case GFXType.MAT4:
            return WebGLRenderingContext.FLOAT_MAT4;

          case GFXType.SAMPLER2D:
            return WebGLRenderingContext.SAMPLER_2D;

          case GFXType.SAMPLER_CUBE:
            return WebGLRenderingContext.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GL type failed."), GFXType.UNKNOWN;
        }
    }
    function WebGLTypeToGFXType(glType) {
        switch (glType) {
          case WebGLRenderingContext.BOOL:
            return GFXType.BOOL;

          case WebGLRenderingContext.BOOL_VEC2:
            return GFXType.BOOL2;

          case WebGLRenderingContext.BOOL_VEC3:
            return GFXType.BOOL3;

          case WebGLRenderingContext.BOOL_VEC4:
            return GFXType.BOOL4;

          case WebGLRenderingContext.INT:
            return GFXType.INT;

          case WebGLRenderingContext.INT_VEC2:
            return GFXType.INT2;

          case WebGLRenderingContext.INT_VEC3:
            return GFXType.INT3;

          case WebGLRenderingContext.INT_VEC4:
            return GFXType.INT4;

          case WebGLRenderingContext.UNSIGNED_INT:
            return GFXType.UINT;

          case WebGLRenderingContext.FLOAT:
            return GFXType.FLOAT;

          case WebGLRenderingContext.FLOAT_VEC2:
            return GFXType.FLOAT2;

          case WebGLRenderingContext.FLOAT_VEC3:
            return GFXType.FLOAT3;

          case WebGLRenderingContext.FLOAT_VEC4:
            return GFXType.FLOAT4;

          case WebGLRenderingContext.FLOAT_MAT2:
            return GFXType.MAT2;

          case WebGLRenderingContext.FLOAT_MAT3:
            return GFXType.MAT3;

          case WebGLRenderingContext.FLOAT_MAT4:
            return GFXType.MAT4;

          case WebGLRenderingContext.SAMPLER_2D:
            return GFXType.SAMPLER2D;

          case WebGLRenderingContext.SAMPLER_CUBE:
            return GFXType.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GFXType failed."), GFXType.UNKNOWN;
        }
    }
    function WebGLGetTypeSize(glType) {
        switch (glType) {
          case WebGLRenderingContext.BOOL:
            return 4;

          case WebGLRenderingContext.BOOL_VEC2:
            return 8;

          case WebGLRenderingContext.BOOL_VEC3:
            return 12;

          case WebGLRenderingContext.BOOL_VEC4:
            return 16;

          case WebGLRenderingContext.INT:
            return 4;

          case WebGLRenderingContext.INT_VEC2:
            return 8;

          case WebGLRenderingContext.INT_VEC3:
            return 12;

          case WebGLRenderingContext.INT_VEC4:
            return 16;

          case WebGLRenderingContext.UNSIGNED_INT:
          case WebGLRenderingContext.FLOAT:
            return 4;

          case WebGLRenderingContext.FLOAT_VEC2:
            return 8;

          case WebGLRenderingContext.FLOAT_VEC3:
            return 12;

          case WebGLRenderingContext.FLOAT_VEC4:
          case WebGLRenderingContext.FLOAT_MAT2:
            return 16;

          case WebGLRenderingContext.FLOAT_MAT3:
            return 36;

          case WebGLRenderingContext.FLOAT_MAT4:
            return 64;

          case WebGLRenderingContext.SAMPLER_2D:
          case WebGLRenderingContext.SAMPLER_CUBE:
            return 4;

          default:
            return console.error("Unsupported GLType, get type failed."), 0;
        }
    }
    function WebGLGetComponentCount(glType) {
        switch (glType) {
          case WebGLRenderingContext.FLOAT_MAT2:
            return 2;

          case WebGLRenderingContext.FLOAT_MAT3:
            return 3;

          case WebGLRenderingContext.FLOAT_MAT4:
            return 4;

          default:
            return 1;
        }
    }
    !function(WebGLEXT) {
        WebGLEXT[WebGLEXT.RGBA16F_EXT = 34842] = "RGBA16F_EXT", WebGLEXT[WebGLEXT.RGB16F_EXT = 34843] = "RGB16F_EXT", 
        WebGLEXT[WebGLEXT.RGBA32F_EXT = 34836] = "RGBA32F_EXT", WebGLEXT[WebGLEXT.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", 
        WebGLEXT[WebGLEXT.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", 
        WebGLEXT[WebGLEXT.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", 
        WebGLEXT[WebGLEXT.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", WebGLEXT[WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", 
        WebGLEXT[WebGLEXT.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", 
        WebGLEXT[WebGLEXT.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
        WebGLEXT[WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", 
        WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    }(WebGLEXT || (WebGLEXT = {}));
    var WebGLCmd, WebGLCmpFuncs = [ WebGLRenderingContext.NEVER, WebGLRenderingContext.LESS, WebGLRenderingContext.EQUAL, WebGLRenderingContext.LEQUAL, WebGLRenderingContext.GREATER, WebGLRenderingContext.NOTEQUAL, WebGLRenderingContext.GEQUAL, WebGLRenderingContext.ALWAYS ], WebGLStencilOps = [ WebGLRenderingContext.ZERO, WebGLRenderingContext.KEEP, WebGLRenderingContext.REPLACE, WebGLRenderingContext.INCR, WebGLRenderingContext.DECR, WebGLRenderingContext.INVERT, WebGLRenderingContext.INCR_WRAP, WebGLRenderingContext.DECR_WRAP ], WebGLBlendOps = [ WebGLRenderingContext.FUNC_ADD, WebGLRenderingContext.FUNC_SUBTRACT, WebGLRenderingContext.FUNC_REVERSE_SUBTRACT, WebGLRenderingContext.FUNC_ADD, WebGLRenderingContext.FUNC_ADD ], WebGLBlendFactors = [ WebGLRenderingContext.ZERO, WebGLRenderingContext.ONE, WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.DST_ALPHA, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA, WebGLRenderingContext.ONE_MINUS_DST_ALPHA, WebGLRenderingContext.SRC_COLOR, WebGLRenderingContext.DST_COLOR, WebGLRenderingContext.ONE_MINUS_SRC_COLOR, WebGLRenderingContext.ONE_MINUS_DST_COLOR, WebGLRenderingContext.SRC_ALPHA_SATURATE, WebGLRenderingContext.CONSTANT_COLOR, WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR, WebGLRenderingContext.CONSTANT_ALPHA, WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA ];
    !function(WebGLCmd) {
        WebGLCmd[WebGLCmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGLCmd[WebGLCmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
        WebGLCmd[WebGLCmd.BIND_STATES = 2] = "BIND_STATES", WebGLCmd[WebGLCmd.DRAW = 3] = "DRAW", 
        WebGLCmd[WebGLCmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGLCmd[WebGLCmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
        WebGLCmd[WebGLCmd.COUNT = 6] = "COUNT";
    }(WebGLCmd || (WebGLCmd = {}));
    var WebGLCmdObject = function WebGLCmdObject(type) {
        _classCallCheck(this, WebGLCmdObject), this.cmdType = void 0, this.refCount = 0, 
        this.cmdType = type;
    }, WebGLCmdBeginRenderPass = function(_WebGLCmdObject) {
        function WebGLCmdBeginRenderPass() {
            var _this;
            return _classCallCheck(this, WebGLCmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBeginRenderPass).call(this, WebGLCmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
            _this.renderArea = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }, _this.clearFlag = GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
            _this.clearStencil = 0, _this;
        }
        return _inherits(WebGLCmdBeginRenderPass, WebGLCmdObject), _createClass(WebGLCmdBeginRenderPass, [ {
            key: "clear",
            value: function clear() {
                this.gpuFramebuffer = null, this.clearColors = [];
            }
        } ]), WebGLCmdBeginRenderPass;
    }(), WebGLCmdBindStates = function(_WebGLCmdObject2) {
        function WebGLCmdBindStates() {
            var _this2;
            return _classCallCheck(this, WebGLCmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBindStates).call(this, WebGLCmd.BIND_STATES))).gpuPipelineState = null, 
            _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
            _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
            _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
            _this2;
        }
        return _inherits(WebGLCmdBindStates, WebGLCmdObject), _createClass(WebGLCmdBindStates, [ {
            key: "clear",
            value: function clear() {
                this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
                this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
                this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
                this.stencilCompareMask = null;
            }
        } ]), WebGLCmdBindStates;
    }(), WebGLCmdDraw = function(_WebGLCmdObject3) {
        function WebGLCmdDraw() {
            var _this3;
            return _classCallCheck(this, WebGLCmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdDraw).call(this, WebGLCmd.DRAW))).drawInfo = {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            }, _this3;
        }
        return _inherits(WebGLCmdDraw, WebGLCmdObject), _createClass(WebGLCmdDraw, [ {
            key: "clear",
            value: function clear() {}
        } ]), WebGLCmdDraw;
    }(), WebGLCmdUpdateBuffer = function(_WebGLCmdObject4) {
        function WebGLCmdUpdateBuffer() {
            var _this4;
            return _classCallCheck(this, WebGLCmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdUpdateBuffer).call(this, WebGLCmd.UPDATE_BUFFER))).gpuBuffer = null, 
            _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
        }
        return _inherits(WebGLCmdUpdateBuffer, WebGLCmdObject), _createClass(WebGLCmdUpdateBuffer, [ {
            key: "clear",
            value: function clear() {
                this.gpuBuffer = null, this.buffer = null;
            }
        } ]), WebGLCmdUpdateBuffer;
    }(), WebGLCmdCopyBufferToTexture = function(_WebGLCmdObject5) {
        function WebGLCmdCopyBufferToTexture() {
            var _this5;
            return _classCallCheck(this, WebGLCmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdCopyBufferToTexture).call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
            _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
        }
        return _inherits(WebGLCmdCopyBufferToTexture, WebGLCmdObject), _createClass(WebGLCmdCopyBufferToTexture, [ {
            key: "clear",
            value: function clear() {
                this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions = [];
            }
        } ]), WebGLCmdCopyBufferToTexture;
    }(), WebGLCmdPackage = function() {
        function WebGLCmdPackage() {
            _classCallCheck(this, WebGLCmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
            this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
            this.copyBufferToTextureCmds = new CachedArray(1);
        }
        return _createClass(WebGLCmdPackage, [ {
            key: "clearCmds",
            value: function clearCmds(allocator) {
                this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
                this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
                this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
                this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
                this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
                this.copyBufferToTextureCmds.clear()), this.cmds.clear();
            }
        } ]), WebGLCmdPackage;
    }();
    function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & GFXBufferUsageBit.UNIFORM) buffer instanceof Float32Array ? gpuBuffer.vf32.set(buffer, offset) : gpuBuffer.vf32.set(new Float32Array(buffer), offset); else if (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
            var buff = buffer, gl = device.gl, cache = device.stateCache;
            switch (gpuBuffer.glTarget) {
              case WebGLRenderingContext.ARRAY_BUFFER:
                device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer);
                break;

              case WebGLRenderingContext.ELEMENT_ARRAY_BUFFER:
                device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer);
                break;

              default:
                return void console.error("Unsupported GFXBufferType, update buffer failed.");
            }
            size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
        }
    }
    var cmdIds = new Array(WebGLCmd.COUNT);
    function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
        var gl = device.gl, cache = device.stateCache;
        cmdIds.fill(0);
        for (var glWrapS, glWrapT, glMinFilter, gpuPipelineState = null, gpuShader = null, gpuInputAssembler = null, glPrimitive = WebGLRenderingContext.TRIANGLES, i = 0; i < cmdPackage.cmds.length; ++i) {
            var cmd = cmdPackage.cmds.array[i], cmdId = cmdIds[cmd]++;
            switch (cmd) {
              case WebGLCmd.BEGIN_RENDER_PASS:
                var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
                if (cmd0.gpuFramebuffer) {
                    cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                    cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                    cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                    cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                    cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                    cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                    cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                    var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, clearCount = cmd0.clearColors.length;
                    device.WEBGL_draw_buffers || (clearCount = 1);
                    for (var j = 0; j < clearCount; ++j) {
                        var colorAttachment = curGPURenderPass.colorAttachments[j];
                        if (colorAttachment.format !== exports.GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                          case GFXLoadOp.LOAD:
                            break;

                          case GFXLoadOp.CLEAR:
                            if (cmd0.clearFlag & GFXClearFlag.COLOR) {
                                cache.bs.targets[0].blendColorMask !== GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0);
                                var clearColor = cmd0.clearColors[0];
                                gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= WebGLRenderingContext.COLOR_BUFFER_BIT;
                            }
                            break;

                          case GFXLoadOp.DISCARD:
                        }
                    }
                    if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== exports.GFXFormat.UNKNOWN) {
                        switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                          case GFXLoadOp.LOAD:
                            break;

                          case GFXLoadOp.CLEAR:
                            cmd0.clearFlag & GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                            gl.clearDepth(cmd0.clearDepth), clears |= WebGLRenderingContext.DEPTH_BUFFER_BIT);
                            break;

                          case GFXLoadOp.DISCARD:
                        }
                        if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                          case GFXLoadOp.LOAD:
                            break;

                          case GFXLoadOp.CLEAR:
                            cmd0.clearFlag & GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(WebGLRenderingContext.FRONT, 4294967295), 
                            cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(WebGLRenderingContext.BACK, 4294967295), 
                            gl.clearStencil(cmd0.clearStencil), clears |= WebGLRenderingContext.STENCIL_BUFFER_BIT);
                            break;

                          case GFXLoadOp.DISCARD:
                        }
                    }
                    if (clears && gl.clear(clears), clears & WebGLRenderingContext.COLOR_BUFFER_BIT) {
                        var colorMask = cache.bs.targets[0].blendColorMask;
                        if (colorMask !== GFXColorMask.ALL) {
                            var r = (colorMask & GFXColorMask.R) !== GFXColorMask.NONE, g = (colorMask & GFXColorMask.G) !== GFXColorMask.NONE, b = (colorMask & GFXColorMask.B) !== GFXColorMask.NONE, a = (colorMask & GFXColorMask.A) !== GFXColorMask.NONE;
                            gl.colorMask(r, g, b, a);
                        }
                    }
                    clears & WebGLRenderingContext.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), 
                    clears & WebGLRenderingContext.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(WebGLRenderingContext.FRONT, 0), 
                    cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(WebGLRenderingContext.BACK, 0));
                }
                break;

              case WebGLCmd.END_RENDER_PASS:
                break;

              case WebGLCmd.BIND_STATES:
                var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                if (cmd2.gpuPipelineState) {
                    if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                    cmd2.gpuPipelineState.gpuShader) {
                        var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                        cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram), 
                        gpuShader = cmd2.gpuPipelineState.gpuShader;
                    }
                    var rs = cmd2.gpuPipelineState.rs;
                    if (rs) {
                        if (cache.rs.cullMode !== rs.cullMode) {
                            switch (rs.cullMode) {
                              case GFXCullMode.NONE:
                                gl.disable(WebGLRenderingContext.CULL_FACE);
                                break;

                              case GFXCullMode.FRONT:
                                gl.enable(WebGLRenderingContext.CULL_FACE), gl.cullFace(WebGLRenderingContext.FRONT);
                                break;

                              case GFXCullMode.BACK:
                                gl.enable(WebGLRenderingContext.CULL_FACE), gl.cullFace(WebGLRenderingContext.BACK);
                            }
                            cache.rs.cullMode = rs.cullMode;
                        }
                        cache.rs.isFrontFaceCCW !== rs.isFrontFaceCCW && (gl.frontFace(rs.isFrontFaceCCW ? WebGLRenderingContext.CCW : WebGLRenderingContext.CW), 
                        cache.rs.isFrontFaceCCW = rs.isFrontFaceCCW), cache.rs.depthBias === rs.depthBias && cache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                        cache.rs.depthBias = rs.depthBias, cache.rs.depthBiasSlop = rs.depthBiasSlop), cache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                        cache.rs.lineWidth = rs.lineWidth);
                    }
                    var dss = cmd2.gpuPipelineState.dss;
                    dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(WebGLRenderingContext.DEPTH_TEST) : gl.disable(WebGLRenderingContext.DEPTH_TEST), 
                    cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                    cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]), 
                    cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(WebGLRenderingContext.STENCIL_TEST) : gl.disable(WebGLRenderingContext.STENCIL_TEST), 
                    cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                    cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(WebGLRenderingContext.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                    cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(WebGLRenderingContext.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]), 
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(WebGLRenderingContext.FRONT, dss.stencilWriteMaskFront), 
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(WebGLRenderingContext.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                    cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(WebGLRenderingContext.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]), 
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(WebGLRenderingContext.BACK, dss.stencilWriteMaskBack), 
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                    var bs = cmd2.gpuPipelineState.bs;
                    if (bs) {
                        cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(WebGLRenderingContext.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(WebGLRenderingContext.SAMPLE_ALPHA_TO_COVERAGE), 
                        cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                        cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                        cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                        var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                        target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(WebGLRenderingContext.BLEND) : gl.disable(WebGLRenderingContext.BLEND), 
                        target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]), 
                        target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                        target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]), 
                        target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                        target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                        target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & GFXColorMask.R) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.G) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.B) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.A) !== GFXColorMask.NONE), 
                        target0Cache.blendColorMask = target0.blendColorMask);
                    }
                }
                if (cmd2.gpuBindingLayout && gpuShader) {
                    var _iterator9 = cmd2.gpuBindingLayout.gpuBindings, _isArray9 = Array.isArray(_iterator9), _i19 = 0;
                    for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray9) {
                            if (_i19 >= _iterator9.length) break;
                            _ref9 = _iterator9[_i19++];
                        } else {
                            if ((_i19 = _iterator9.next()).done) break;
                            _ref9 = _i19.value;
                        }
                        var gpuBinding = _ref9;
                        switch (gpuBinding.type) {
                          case GFXBindingType.UNIFORM_BUFFER:
                            if (gpuBinding.gpuBuffer && gpuBinding.gpuBuffer.buffer) {
                                var glBlock = null, _iterator10 = gpuShader.glBlocks, _isArray10 = Array.isArray(_iterator10), _i20 = 0;
                                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                    var _ref10;
                                    if (_isArray10) {
                                        if (_i20 >= _iterator10.length) break;
                                        _ref10 = _iterator10[_i20++];
                                    } else {
                                        if ((_i20 = _iterator10.next()).done) break;
                                        _ref10 = _i20.value;
                                    }
                                    var block = _ref10;
                                    if (block.binding === gpuBinding.binding) {
                                        glBlock = block;
                                        break;
                                    }
                                }
                                if (glBlock && gpuBinding.gpuBuffer.vf32) {
                                    var _iterator11 = glBlock.glActiveUniforms, _isArray11 = Array.isArray(_iterator11), _i21 = 0;
                                    for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                                        var _ref11;
                                        if (_isArray11) {
                                            if (_i21 >= _iterator11.length) break;
                                            _ref11 = _iterator11[_i21++];
                                        } else {
                                            if ((_i21 = _iterator11.next()).done) break;
                                            _ref11 = _i21.value;
                                        }
                                        var glUniform = _ref11;
                                        switch (glUniform.glType) {
                                          case WebGLRenderingContext.BOOL:
                                          case WebGLRenderingContext.INT:
                                            for (var u = 0; u < glUniform.array.length; ++u) {
                                                var idx = glUniform.begin + u;
                                                if (gpuBinding.gpuBuffer.vf32[idx] !== glUniform.array[u]) {
                                                    for (var n = u, m = glUniform.begin + u; n < glUniform.array.length; ++n, ++m) glUniform.array[n] = gpuBinding.gpuBuffer.vf32[m];
                                                    gl.uniform1iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.BOOL_VEC2:
                                          case WebGLRenderingContext.INT_VEC2:
                                            for (var _u = 0; _u < glUniform.array.length; ++_u) {
                                                var _idx = glUniform.begin + _u;
                                                if (gpuBinding.gpuBuffer.vf32[_idx] !== glUniform.array[_u]) {
                                                    for (var _n = _u, _m = glUniform.begin + _u; _n < glUniform.array.length; ++_n, 
                                                    ++_m) glUniform.array[_n] = gpuBinding.gpuBuffer.vf32[_m];
                                                    gl.uniform2iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.BOOL_VEC3:
                                          case WebGLRenderingContext.INT_VEC3:
                                            for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                                                var _idx2 = glUniform.begin + _u2;
                                                if (gpuBinding.gpuBuffer.vf32[_idx2] !== glUniform.array[_u2]) {
                                                    for (var _n2 = _u2, _m2 = glUniform.begin + _u2; _n2 < glUniform.array.length; ++_n2, 
                                                    ++_m2) glUniform.array[_n2] = gpuBinding.gpuBuffer.vf32[_m2];
                                                    gl.uniform3iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.BOOL_VEC4:
                                          case WebGLRenderingContext.INT_VEC4:
                                            for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                                                var _idx3 = glUniform.begin + _u3;
                                                if (gpuBinding.gpuBuffer.vf32[_idx3] !== glUniform.array[_u3]) {
                                                    for (var _n3 = _u3, _m3 = glUniform.begin + _u3; _n3 < glUniform.array.length; ++_n3, 
                                                    ++_m3) glUniform.array[_n3] = gpuBinding.gpuBuffer.vf32[_m3];
                                                    gl.uniform4iv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT:
                                            for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                                                var _idx4 = glUniform.begin + _u4;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx4], glUniform.array[_u4])) {
                                                    for (var _n4 = _u4, _m4 = glUniform.begin + _u4; _n4 < glUniform.array.length; ++_n4, 
                                                    ++_m4) glUniform.array[_n4] = gpuBinding.gpuBuffer.vf32[_m4];
                                                    gl.uniform1fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT_VEC2:
                                            for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                                                var _idx5 = glUniform.begin + _u5;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx5], glUniform.array[_u5])) {
                                                    for (var _n5 = _u5, _m5 = glUniform.begin + _u5; _n5 < glUniform.array.length; ++_n5, 
                                                    ++_m5) glUniform.array[_n5] = gpuBinding.gpuBuffer.vf32[_m5];
                                                    gl.uniform2fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT_VEC3:
                                            for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                                                var _idx6 = glUniform.begin + _u6;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx6], glUniform.array[_u6])) {
                                                    for (var _n6 = _u6, _m6 = glUniform.begin + _u6; _n6 < glUniform.array.length; ++_n6, 
                                                    ++_m6) glUniform.array[_n6] = gpuBinding.gpuBuffer.vf32[_m6];
                                                    gl.uniform3fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT_VEC4:
                                            for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                                                var _idx7 = glUniform.begin + _u7;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx7], glUniform.array[_u7])) {
                                                    for (var _n7 = _u7, _m7 = glUniform.begin + _u7; _n7 < glUniform.array.length; ++_n7, 
                                                    ++_m7) glUniform.array[_n7] = gpuBinding.gpuBuffer.vf32[_m7];
                                                    gl.uniform4fv(glUniform.glLoc, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT_MAT2:
                                            for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                                                var _idx8 = glUniform.begin + _u8;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx8], glUniform.array[_u8])) {
                                                    for (var _n8 = _u8, _m8 = glUniform.begin + _u8; _n8 < glUniform.array.length; ++_n8, 
                                                    ++_m8) glUniform.array[_n8] = gpuBinding.gpuBuffer.vf32[_m8];
                                                    gl.uniformMatrix2fv(glUniform.glLoc, !1, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT_MAT3:
                                            for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                                                var _idx9 = glUniform.begin + _u9;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx9], glUniform.array[_u9])) {
                                                    for (var _n9 = _u9, _m9 = glUniform.begin + _u9; _n9 < glUniform.array.length; ++_n9, 
                                                    ++_m9) glUniform.array[_n9] = gpuBinding.gpuBuffer.vf32[_m9];
                                                    gl.uniformMatrix3fv(glUniform.glLoc, !1, glUniform.array);
                                                    break;
                                                }
                                            }
                                            break;

                                          case WebGLRenderingContext.FLOAT_MAT4:
                                            for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                                                var _idx10 = glUniform.begin + _u10;
                                                if (CmpF32NotEuqal(gpuBinding.gpuBuffer.vf32[_idx10], glUniform.array[_u10])) {
                                                    for (var _n10 = _u10, _m10 = glUniform.begin + _u10; _n10 < glUniform.array.length; ++_n10, 
                                                    ++_m10) glUniform.array[_n10] = gpuBinding.gpuBuffer.vf32[_m10];
                                                    gl.uniformMatrix4fv(glUniform.glLoc, !1, glUniform.array);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            break;

                          case GFXBindingType.SAMPLER:
                            if (gpuBinding.gpuSampler) {
                                var glSampler = null, _iterator12 = gpuShader.glSamplers, _isArray12 = Array.isArray(_iterator12), _i22 = 0;
                                for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                                    var _ref12;
                                    if (_isArray12) {
                                        if (_i22 >= _iterator12.length) break;
                                        _ref12 = _iterator12[_i22++];
                                    } else {
                                        if ((_i22 = _iterator12.next()).done) break;
                                        _ref12 = _i22.value;
                                    }
                                    var sampler = _ref12;
                                    if (sampler.binding === gpuBinding.binding) {
                                        glSampler = sampler;
                                        break;
                                    }
                                }
                                if (glSampler) {
                                    var _iterator13 = glSampler.units, _isArray13 = Array.isArray(_iterator13), _i23 = 0;
                                    for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                                        var _ref13;
                                        if (_isArray13) {
                                            if (_i23 >= _iterator13.length) break;
                                            _ref13 = _iterator13[_i23++];
                                        } else {
                                            if ((_i23 = _iterator13.next()).done) break;
                                            _ref13 = _i23.value;
                                        }
                                        var texUnit = _ref13, glTexUnit = null;
                                        if (gpuBinding.gpuTexView && 0 < gpuBinding.gpuTexView.gpuTexture.size) {
                                            cache.texUnit !== texUnit && (gl.activeTexture(WebGLRenderingContext.TEXTURE0 + texUnit), 
                                            cache.texUnit = texUnit);
                                            var gpuTexture = gpuBinding.gpuTexView.gpuTexture;
                                            switch (glSampler.glType) {
                                              case gl.SAMPLER_2D:
                                                (glTexUnit = cache.glTex2DUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_2D, device.nullTex2D.gpuTexture.glTexture), 
                                                glTexUnit.glTexture = gpuTexture.glTexture);
                                                break;

                                              case gl.SAMPLER_CUBE:
                                                (glTexUnit = cache.glTexCubeUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_CUBE_MAP, device.nullTexCube.gpuTexture.glTexture), 
                                                glTexUnit.glTexture = gpuTexture.glTexture);
                                                break;

                                              default:
                                                console.error("Unsupported GL Texture type.");
                                            }
                                            if (glTexUnit) {
                                                var gpuSampler = gpuBinding.gpuSampler;
                                                glWrapT = gpuTexture.isPowerOf2 ? (glWrapS = gpuSampler.glWrapS, gpuSampler.glWrapT) : (glWrapS = gl.CLAMP_TO_EDGE, 
                                                gl.CLAMP_TO_EDGE), glMinFilter = gpuTexture.isPowerOf2 ? gpuSampler.glMinFilter : gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR ? gl.LINEAR : gl.NEAREST, 
                                                gpuTexture.glWrapS !== glWrapS && (gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_WRAP_S, glWrapS), 
                                                gpuTexture.glWrapS = glWrapS), gpuTexture.glWrapT !== glWrapT && (gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_WRAP_T, glWrapT), 
                                                gpuTexture.glWrapT = glWrapT), gpuTexture.glMinFilter !== glMinFilter && (gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_MIN_FILTER, glMinFilter), 
                                                gpuTexture.glMinFilter = glMinFilter), gpuTexture.glMagFilter !== gpuSampler.glMagFilter && (gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                                                gpuTexture.glMagFilter = gpuSampler.glMagFilter);
                                            }
                                        }
                                    }
                                }
                            } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                        }
                    }
                }
                if (cmd2.gpuInputAssembler && gpuShader && gpuInputAssembler !== cmd2.gpuInputAssembler) if (gpuInputAssembler = cmd2.gpuInputAssembler, 
                device.useVAO) {
                    var vao = device.OES_vertex_array_object, glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                    if (glVAO) cache.glVAO !== glVAO && (vao.bindVertexArrayOES(glVAO), cache.glVAO = glVAO); else {
                        var _glVAO = vao.createVertexArrayOES();
                        gpuInputAssembler.glVAOs.set(gpuShader.glProgram, _glVAO), vao.bindVertexArrayOES(_glVAO), 
                        cache.glVAO = _glVAO, gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, null), gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, null), 
                        cache.glArrayBuffer = 0;
                        var glAttrib = void (cache.glElementArrayBuffer = 0), _iterator14 = gpuShader.glInputs, _isArray14 = Array.isArray(_iterator14), _i24 = 0;
                        for (_iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ;) {
                            var _ref14;
                            if (_isArray14) {
                                if (_i24 >= _iterator14.length) break;
                                _ref14 = _iterator14[_i24++];
                            } else {
                                if ((_i24 = _iterator14.next()).done) break;
                                _ref14 = _i24.value;
                            }
                            var glInput = _ref14;
                            glAttrib = null;
                            var _iterator15 = gpuInputAssembler.glAttribs, _isArray15 = Array.isArray(_iterator15), _i25 = 0;
                            for (_iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ;) {
                                var _ref15;
                                if (_isArray15) {
                                    if (_i25 >= _iterator15.length) break;
                                    _ref15 = _iterator15[_i25++];
                                } else {
                                    if ((_i25 = _iterator15.next()).done) break;
                                    _ref15 = _i25.value;
                                }
                                var attrib = _ref15;
                                if (attrib.name === glInput.name) {
                                    glAttrib = attrib;
                                    break;
                                }
                            }
                            if (glAttrib) {
                                cache.glArrayBuffer !== glAttrib.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, glAttrib.glBuffer), 
                                cache.glArrayBuffer = glAttrib.glBuffer);
                                for (var c = 0; c < glAttrib.componentCount; ++c) {
                                    var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                    gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                                }
                            }
                        }
                        var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                        gpuBuffer && cache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer);
                    }
                } else {
                    for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glCurrentAttribLocs[_a] = !1;
                    var _iterator16 = gpuShader.glInputs, _isArray16 = Array.isArray(_iterator16), _i26 = 0;
                    for (_iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ;) {
                        var _ref16;
                        if (_isArray16) {
                            if (_i26 >= _iterator16.length) break;
                            _ref16 = _iterator16[_i26++];
                        } else {
                            if ((_i26 = _iterator16.next()).done) break;
                            _ref16 = _i26.value;
                        }
                        var _glInput = _ref16, _glAttrib = null, _iterator17 = gpuInputAssembler.glAttribs, _isArray17 = Array.isArray(_iterator17), _i27 = 0;
                        for (_iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator](); ;) {
                            var _ref17;
                            if (_isArray17) {
                                if (_i27 >= _iterator17.length) break;
                                _ref17 = _iterator17[_i27++];
                            } else {
                                if ((_i27 = _iterator17.next()).done) break;
                                _ref17 = _i27.value;
                            }
                            var _attrib = _ref17;
                            if (_attrib.name === _glInput.name) {
                                _glAttrib = _attrib;
                                break;
                            }
                        }
                        if (_glAttrib) {
                            cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, _glAttrib.glBuffer), 
                            cache.glArrayBuffer = _glAttrib.glBuffer);
                            for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                                var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                                !cache.glEnabledAttribLocs[_glLoc2] && 0 <= _glLoc2 && (gl.enableVertexAttribArray(_glLoc2), 
                                cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                                gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                            }
                        }
                    }
                    var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
                    cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
                    for (var _a2 = 0; _a2 < device.maxVertexAttributes; ++_a2) cache.glEnabledAttribLocs[_a2] !== cache.glCurrentAttribLocs[_a2] && (gl.disableVertexAttribArray(_a2), 
                    cache.glEnabledAttribLocs[_a2] = !1);
                }
                if (gpuPipelineState) {
                    var _iterator18 = gpuPipelineState.dynamicStates, _isArray18 = Array.isArray(_iterator18), _i28 = 0;
                    for (_iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator](); ;) {
                        var _ref18;
                        if (_isArray18) {
                            if (_i28 >= _iterator18.length) break;
                            _ref18 = _iterator18[_i28++];
                        } else {
                            if ((_i28 = _iterator18.next()).done) break;
                            _ref18 = _i28.value;
                        }
                        switch (_ref18) {
                          case GFXDynamicState.VIEWPORT:
                            cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                            cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                            cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                            break;

                          case GFXDynamicState.SCISSOR:
                            cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                            cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                            cache.scissorRect.height = cmd2.scissor.height));
                            break;

                          case GFXDynamicState.LINE_WIDTH:
                            cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                            cache.rs.lineWidth = cmd2.lineWidth);
                            break;

                          case GFXDynamicState.DEPTH_BIAS:
                            cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                            cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                            break;

                          case GFXDynamicState.BLEND_CONSTANTS:
                            cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                            cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                            cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                            break;

                          case GFXDynamicState.STENCIL_WRITE_MASK:
                            if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                              case GFXStencilFace.FRONT:
                                cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(WebGLRenderingContext.FRONT, cmd2.stencilWriteMask.writeMask), 
                                cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                                break;

                              case GFXStencilFace.BACK:
                                cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(WebGLRenderingContext.BACK, cmd2.stencilWriteMask.writeMask), 
                                cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                                break;

                              case GFXStencilFace.ALL:
                                cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                                cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                            }
                            break;

                          case GFXDynamicState.STENCIL_COMPARE_MASK:
                            if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                              case GFXStencilFace.FRONT:
                                cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(WebGLRenderingContext.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                                break;

                              case GFXStencilFace.BACK:
                                cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(WebGLRenderingContext.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                                break;

                              case GFXStencilFace.ALL:
                                cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                                cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                            }
                        }
                    }
                }
                break;

              case WebGLCmd.DRAW:
                var cmd3 = cmdPackage.drawCmds.array[cmdId];
                if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) {
                    if (gpuInputAssembler.gpuIndirectBuffer) {
                        var _iterator19 = gpuInputAssembler.gpuIndirectBuffer.indirects, _isArray19 = Array.isArray(_iterator19), _i29 = 0;
                        for (_iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator](); ;) {
                            var _ref19;
                            if (_isArray19) {
                                if (_i29 >= _iterator19.length) break;
                                _ref19 = _iterator19[_i29++];
                            } else {
                                if ((_i29 = _iterator19.next()).done) break;
                                _ref19 = _i29.value;
                            }
                            var drawInfo = _ref19, _gpuBuffer3 = gpuInputAssembler.gpuIndexBuffer;
                            if (_gpuBuffer3 && -1 < drawInfo.indexCount) {
                                var _offset = drawInfo.firstIndex * _gpuBuffer3.stride;
                                gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                            } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                        }
                    }
                } else {
                    var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                    if (_gpuBuffer2 && 0 < cmd3.drawInfo.indexCount) {
                        var offset = cmd3.drawInfo.firstIndex * _gpuBuffer2.stride;
                        gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                    } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
                }
                break;

              case WebGLCmd.UPDATE_BUFFER:
                var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;

              case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
                var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGLCmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
            }
        }
    }
    function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        var gl = device.gl, m = 0, n = 0, w = 1, h = 1, f = 0, fmtInfo = GFXFormatInfos[gpuTexture.format], isCompressed = fmtInfo.isCompressed;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
            glTexUnit.glTexture = gpuTexture.glTexture);
            var _iterator22 = regions, _isArray22 = Array.isArray(_iterator22), _i32 = 0;
            for (_iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator](); ;) {
                var _ref22;
                if (_isArray22) {
                    if (_i32 >= _iterator22.length) break;
                    _ref22 = _iterator22[_i32++];
                } else {
                    if ((_i32 = _iterator22.next()).done) break;
                    _ref22 = _i32.value;
                }
                var region = _ref22;
                for (n = 0, w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                    var pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                    isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                    w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                }
            }
            break;

          case gl.TEXTURE_CUBE_MAP:
            var _glTexUnit4 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
            _glTexUnit4.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
            _glTexUnit4.glTexture = gpuTexture.glTexture);
            var _iterator23 = regions, _isArray23 = Array.isArray(_iterator23), _i33 = 0;
            for (_iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator](); ;) {
                var _ref23;
                if (_isArray23) {
                    if (_i33 >= _iterator23.length) break;
                    _ref23 = _iterator23[_i33++];
                } else {
                    if ((_i33 = _iterator23.next()).done) break;
                    _ref23 = _i33.value;
                }
                var _region2 = _ref23;
                n = 0;
                var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
                for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                    w = _region2.texExtent.width, h = _region2.texExtent.height;
                    var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                    for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                        var _pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                        isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                        w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                    }
                }
            }
            break;

          default:
            console.error("Unsupported GL texture type, copy buffer to texture failed.");
        }
        gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
    }
    var WebGLGFXBuffer = function(_GFXBuffer) {
        function WebGLGFXBuffer(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBuffer).call(this, device)))._gpuBuffer = null, 
            _this._uniformBuffer = null, _this._indirectBuffer = null, _this;
        }
        return _inherits(WebGLGFXBuffer, GFXBuffer), _createClass(WebGLGFXBuffer, [ {
            key: "gpuBuffer",
            get: function get() {
                return this._gpuBuffer;
            }
        } ]), _createClass(WebGLGFXBuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
                this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
                this._usage & GFXBufferUsageBit.INDIRECT ? this._indirectBuffer = {
                    drawInfos: []
                } : this._usage & GFXBufferUsageBit.UNIFORM && 0 < this._size && (this._uniformBuffer = new ArrayBuffer(this._size)), 
                this._gpuBuffer = {
                    usage: info.usage,
                    memUsage: info.memUsage,
                    size: info.size,
                    stride: this._stride,
                    buffer: null,
                    vf32: null,
                    indirects: [],
                    glTarget: 0,
                    glBuffer: null
                }, info.usage & GFXBufferUsageBit.INDIRECT ? this._gpuBuffer.indirects = this._indirectBuffer.drawInfos : this._usage & GFXBufferUsageBit.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer), 
                function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? WebGLRenderingContext.DYNAMIC_DRAW : WebGLRenderingContext.STATIC_DRAW;
                    if (gpuBuffer.usage & GFXBufferUsageBit.VERTEX) {
                        gpuBuffer.glTarget = WebGLRenderingContext.ARRAY_BUFFER;
                        var glBuffer = gl.createBuffer();
                        glBuffer && (gpuBuffer.glBuffer = glBuffer, 0 < gpuBuffer.size && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                        cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(WebGLRenderingContext.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                    } else if (gpuBuffer.usage & GFXBufferUsageBit.INDEX) {
                        gpuBuffer.glTarget = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER;
                        var _glBuffer = gl.createBuffer();
                        _glBuffer && (gpuBuffer.glBuffer = _glBuffer, 0 < gpuBuffer.size && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                        cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                    } else gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? (gpuBuffer.glTarget = WebGLRenderingContext.NONE, 
                    gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer))) : (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = WebGLRenderingContext.NONE);
                }(this._device, this._gpuBuffer), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuBuffer && (!function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
                    gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
                }(this._device, this._gpuBuffer), this._gpuBuffer = null), this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(size) {
                this._size = size, this._count = this._size / this._stride, this._uniformBuffer && (this._uniformBuffer = new ArrayBuffer(this._size)), 
                this._gpuBuffer && (this._uniformBuffer && (this._gpuBuffer.buffer = this._uniformBuffer), 
                this._gpuBuffer.size = this._size, 0 < this._size && function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? WebGLRenderingContext.DYNAMIC_DRAW : WebGLRenderingContext.STATIC_DRAW;
                    gpuBuffer.usage & GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gl.bufferData(WebGLRenderingContext.ARRAY_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(WebGLRenderingContext.ARRAY_BUFFER, null), 
                    device.stateCache.glArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gl.bufferData(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer)) : (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = WebGLRenderingContext.NONE);
                }(this._device, this._gpuBuffer));
            }
        }, {
            key: "update",
            value: function update(buffer, offset, size) {
                var buffSize;
                buffSize = void 0 !== size ? size : this._usage & GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
                WebGLCmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
            }
        } ]), WebGLGFXBuffer;
    }(), GFXCommandAllocator = function(_GFXObject) {
        function GFXCommandAllocator(device) {
            var _this;
            return _classCallCheck(this, GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandAllocator).call(this, GFXObjectType.COMMAND_ALLOCATOR)))._device = void 0, 
            _this._device = device, _this;
        }
        return _inherits(GFXCommandAllocator, GFXObject), GFXCommandAllocator;
    }(), WebGLGFXCommandPool = function() {
        function WebGLGFXCommandPool(clazz, count) {
            _classCallCheck(this, WebGLGFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
            this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
            for (var i = 0; i < count; ++i) this._frees[i] = new clazz();
            this._freeIdx = count - 1;
        }
        return _createClass(WebGLGFXCommandPool, [ {
            key: "alloc",
            value: function alloc(clazz) {
                return new clazz();
            }
        }, {
            key: "free",
            value: function free(cmd) {
                0 == --cmd.refCount && this._freeCmds.push(cmd);
            }
        }, {
            key: "freeCmds",
            value: function freeCmds(cmds) {}
        }, {
            key: "release",
            value: function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                    var cmd = this._freeCmds.array[i];
                    cmd.clear(), this._frees[++this._freeIdx] = cmd;
                }
                this._freeCmds.clear();
            }
        } ]), WebGLGFXCommandPool;
    }(), WebGLGFXCommandAllocator = function(_GFXCommandAllocator) {
        function WebGLGFXCommandAllocator(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
            _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
            _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGLGFXCommandPool(WebGLCmdBeginRenderPass, 16), 
            _this.bindStatesCmdPool = new WebGLGFXCommandPool(WebGLCmdBindStates, 16), _this.drawCmdPool = new WebGLGFXCommandPool(WebGLCmdDraw, 16), 
            _this.updateBufferCmdPool = new WebGLGFXCommandPool(WebGLCmdUpdateBuffer, 16), _this.copyBufferToTextureCmdPool = new WebGLGFXCommandPool(WebGLCmdCopyBufferToTexture, 16), 
            _this;
        }
        return _inherits(WebGLGFXCommandAllocator, GFXCommandAllocator), _createClass(WebGLGFXCommandAllocator, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "clearCmds",
            value: function clearCmds(cmdPackage) {
                cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
                cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
                cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
                cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
                cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
                cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
            }
        }, {
            key: "releaseCmds",
            value: function releaseCmds() {
                this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
                this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
            }
        } ]), WebGLGFXCommandAllocator;
    }(), WebGLGFXCommandBuffer = function(_GFXCommandBuffer) {
        function WebGLGFXCommandBuffer(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandBuffer).call(this, device))).cmdPackage = new WebGLCmdPackage(), 
            _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
            _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
            _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
            _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
            _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
        }
        return _inherits(WebGLGFXCommandBuffer, GFXCommandBuffer), _createClass(WebGLGFXCommandBuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
                this._type = info.type, this._status = GFXStatus.SUCCESS, !0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
                this._webGLAllocator = null), this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "begin",
            value: function begin() {
                this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
                this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
                this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
                this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
                this._numDrawCalls = 0, this._numTris = 0;
            }
        }, {
            key: "end",
            value: function end() {
                this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
            }
        }, {
            key: "beginRenderPass",
            value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
                var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag, 
                cmd.clearColors.length = clearColors.length;
                for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
                cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
                this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
            }
        }, {
            key: "endRenderPass",
            value: function endRenderPass() {
                this._isInRenderPass = !1;
            }
        }, {
            key: "bindPipelineState",
            value: function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;
                this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
            }
        }, {
            key: "bindBindingLayout",
            value: function bindBindingLayout(bindingLayout) {
                var gpuBindingLayout = bindingLayout.gpuBindingLayout;
                this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
            }
        }, {
            key: "bindInputAssembler",
            value: function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
            }
        }, {
            key: "setViewport",
            value: function setViewport(viewport) {
                this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
                this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
                this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
                this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                    left: viewport.left,
                    top: viewport.top,
                    width: viewport.width,
                    height: viewport.height,
                    minDepth: viewport.minDepth,
                    maxDepth: viewport.maxDepth
                }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
            }
        }, {
            key: "setScissor",
            value: function setScissor(scissor) {
                this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
                this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
                this._isStateInvalied = !0) : this._curScissor = {
                    x: scissor.x,
                    y: scissor.y,
                    width: scissor.width,
                    height: scissor.height
                };
            }
        }, {
            key: "setLineWidth",
            value: function setLineWidth(lineWidth) {
                this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
            }
        }, {
            key: "setDepthBias",
            value: function setDepthBias(depthBiasConstantFacotr, depthBiasClamp, depthBiasSlopeFactor) {
                this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFacotr && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFacotr, 
                this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
                this._isStateInvalied = !0) : (this._curDepthBias = {
                    constantFactor: depthBiasConstantFacotr,
                    clamp: depthBiasClamp,
                    slopeFactor: depthBiasSlopeFactor
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setBlendConstants",
            value: function setBlendConstants(blendConstants) {
                (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
                this._isStateInvalied = !0);
            }
        }, {
            key: "setDepthBound",
            value: function setDepthBound(minDepthBounds, maxDepthBounds) {
                this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setStencilWriteMask",
            value: function setStencilWriteMask(face, writeMask) {
                this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
                this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                    face: face,
                    writeMask: writeMask
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setStencilCompareMask",
            value: function setStencilCompareMask(face, reference, compareMask) {
                this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
                this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
                this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                    face: face,
                    reference: reference,
                    compareMask: compareMask
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "draw",
            value: function draw(inputAssembler) {
                if (this._type === GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                    this._isStateInvalied && this.bindStates();
                    var cmd = this._allocator.drawCmdPool.alloc(WebGLCmdDraw);
                    if (inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.DRAW), 
                    ++this._numDrawCalls, this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                      case WebGLRenderingContext.TRIANGLES:
                        this._numTris += inputAssembler.indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                        break;

                      case WebGLRenderingContext.TRIANGLE_STRIP:
                      case WebGLRenderingContext.TRIANGLE_FAN:
                        this._numTris += (inputAssembler.indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                    }
                } else console.error("Command 'draw' must be recorded inside a render pass.");
            }
        }, {
            key: "updateBuffer",
            value: function updateBuffer(buffer, data, offset, size) {
                if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                    var gpuBuffer = buffer.gpuBuffer;
                    if (gpuBuffer) {
                        var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);
                        if (cmd) {
                            var buffSize;
                            buffSize = void 0 !== size ? size : buffer.usage & GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                            var buff = data;
                            cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                            cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                        }
                    }
                } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
            }
        }, {
            key: "copyBufferToTexture",
            value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
                if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                    var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                    if (gpuBuffer && gpuTexture) {
                        var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);
                        cmd && (cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                        cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE));
                    }
                } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
            }
        }, {
            key: "execute",
            value: function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                    for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                        var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                        ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                    }
                    for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                        var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                        ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                    }
                    for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                        var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                        ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                    }
                    for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                        var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                        ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                    }
                    for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                        var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                        ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                    }
                    this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                    this._numTris += webGLCmdBuff._numTris;
                }
            }
        }, {
            key: "bindStates",
            value: function bindStates() {
                var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);
                bindStatesCmd && (bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
                bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
                bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
                bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
                bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
                bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
                this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES), this._isStateInvalied = !1);
            }
        }, {
            key: "webGLDevice",
            get: function get() {
                return this._device;
            }
        } ]), WebGLGFXCommandBuffer;
    }(), WebGLGFXFramebuffer = function(_GFXFramebuffer) {
        function WebGLGFXFramebuffer(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
            _this;
        }
        return _inherits(WebGLGFXFramebuffer, GFXFramebuffer), _createClass(WebGLGFXFramebuffer, [ {
            key: "gpuFramebuffer",
            get: function get() {
                return this._gpuFramebuffer;
            }
        } ]), _createClass(WebGLGFXFramebuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
                this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
                this._isOffscreen) {
                    var gpuColorViews = [];
                    if (void 0 !== info.colorViews) {
                        var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var colorView = _ref;
                            gpuColorViews.push(colorView.gpuTextureView);
                        }
                    }
                    var gpuDepthStencilView = null;
                    info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                    this._gpuFramebuffer = {
                        gpuRenderPass: info.renderPass.gpuRenderPass,
                        gpuColorViews: gpuColorViews,
                        gpuDepthStencilView: gpuDepthStencilView,
                        isOffscreen: this._isOffscreen,
                        glFramebuffer: null
                    }, function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                        if (gpuFramebuffer.isOffscreen) {
                            var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                            if (glFramebuffer) {
                                gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                                device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                                for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                    var cv = gpuFramebuffer.gpuColorViews[i];
                                    cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                    attachments.push(gl.COLOR_ATTACHMENT0 + i));
                                }
                                var dsv = gpuFramebuffer.gpuDepthStencilView;
                                if (dsv) {
                                    var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                    dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                                }
                                device.WEBGL_draw_buffers && device.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                                if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                                  case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                    break;

                                  case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                    break;

                                  case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                    break;

                                  case gl.FRAMEBUFFER_UNSUPPORTED:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                                }
                            }
                        }
                    }(this._device, this._gpuFramebuffer);
                } else this._gpuFramebuffer = {
                    gpuRenderPass: info.renderPass.gpuRenderPass,
                    gpuColorViews: [],
                    gpuDepthStencilView: null,
                    isOffscreen: info.isOffscreen,
                    glFramebuffer: null
                };
                return this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._isOffscreen && this._gpuFramebuffer && function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                    gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                    gpuFramebuffer.glFramebuffer = null);
                }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXFramebuffer;
    }(), WebGLGFXInputAssembler = function(_GFXInputAssembler) {
        function WebGLGFXInputAssembler(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
            _this;
        }
        return _inherits(WebGLGFXInputAssembler, GFXInputAssembler), _createClass(WebGLGFXInputAssembler, [ {
            key: "gpuInputAssembler",
            get: function get() {
                return this._gpuInputAssembler;
            }
        } ]), _createClass(WebGLGFXInputAssembler, [ {
            key: "initialize",
            value: function initialize(info) {
                if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
                !1;
                if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
                void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                    var vertBuff = this._vertexBuffers[0];
                    this._vertexCount = vertBuff.size / vertBuff.stride;
                }
                this._indirectBuffer = info.indirectBuffer || null;
                for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                    var vb = info.vertexBuffers[i];
                    vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
                }
                var gpuIndexBuffer = null, glIndexType = 0;
                if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
                  case 1:
                    glIndexType = WebGLRenderingContext.UNSIGNED_BYTE;
                    break;

                  case 2:
                    glIndexType = WebGLRenderingContext.UNSIGNED_SHORT;
                    break;

                  case 4:
                    glIndexType = WebGLRenderingContext.UNSIGNED_INT;
                    break;

                  default:
                    console.error("Error index buffer stride.");
                }
                var gpuIndirectBuffer = null;
                return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
                this._gpuInputAssembler = {
                    attributes: info.attributes,
                    gpuVertexBuffers: gpuVertexBuffers,
                    gpuIndexBuffer: gpuIndexBuffer,
                    gpuIndirectBuffer: gpuIndirectBuffer,
                    glAttribs: [],
                    glIndexType: glIndexType,
                    glVAOs: new Map()
                }, function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
                    gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                    for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                        var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType(attrib.format), size = GFXFormatInfos[attrib.format].size;
                        gpuInputAssembler.glAttribs[i] = {
                            name: attrib.name,
                            glBuffer: gpuBuffer.glBuffer,
                            glType: glType,
                            size: size,
                            count: GFXFormatInfos[attrib.format].count,
                            stride: gpuBuffer.stride,
                            componentCount: WebGLGetComponentCount(glType),
                            isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                            isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                            offset: offsets[stream]
                        }, offsets[stream] += size;
                    }
                }(this._device, this._gpuInputAssembler), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var webglDev = this._device;
                this._gpuInputAssembler && webglDev.useVAO && function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                    var _iterator8 = gpuInputAssembler.glVAOs, _isArray8 = Array.isArray(_iterator8), _i18 = 0;
                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray8) {
                            if (_i18 >= _iterator8.length) break;
                            _ref8 = _iterator8[_i18++];
                        } else {
                            if ((_i18 = _iterator8.next()).done) break;
                            _ref8 = _i18.value;
                        }
                        var vao = _ref8;
                        device.OES_vertex_array_object.deleteVertexArrayOES(vao[1]);
                    }
                    gpuInputAssembler.glVAOs.clear();
                }(webglDev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "extractCmdDraw",
            value: function extractCmdDraw(cmd) {
                cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
                cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
                cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
                cmd.drawInfo.firstInstance = this._firstInstance;
            }
        } ]), WebGLGFXInputAssembler;
    }(), WebGLGFXPipelineLayout = function(_GFXPipelineLayout) {
        function WebGLGFXPipelineLayout(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
            _this;
        }
        return _inherits(WebGLGFXPipelineLayout, GFXPipelineLayout), _createClass(WebGLGFXPipelineLayout, [ {
            key: "gpuPipelineLayout",
            get: function get() {
                return this._gpuPipelineLayout;
            }
        } ]), _createClass(WebGLGFXPipelineLayout, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
                this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXPipelineLayout;
    }(), WebGLPrimitives = [ WebGLRenderingContext.POINTS, WebGLRenderingContext.LINES, WebGLRenderingContext.LINE_STRIP, WebGLRenderingContext.LINE_LOOP, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.TRIANGLES, WebGLRenderingContext.TRIANGLE_STRIP, WebGLRenderingContext.TRIANGLE_FAN, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE ], WebGLGFXPipelineState = function(_GFXPipelineState) {
        function WebGLGFXPipelineState(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineState).call(this, device)))._gpuPipelineState = null, 
            _this;
        }
        return _inherits(WebGLGFXPipelineState, GFXPipelineState), _createClass(WebGLGFXPipelineState, [ {
            key: "gpuPipelineState",
            get: function get() {
                return this._gpuPipelineState;
            }
        } ]), _createClass(WebGLGFXPipelineState, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._primitive = info.primitive, this._shader = info.shader, this._is = info.is, 
                this._rs = info.rs, this._dss = info.dss, this._bs = info.bs, this._dynamicStates = info.dynamicStates || [], 
                this._layout = info.layout, this._renderPass = info.renderPass, this._gpuPipelineState = {
                    glPrimitive: WebGLPrimitives[info.primitive],
                    gpuShader: info.shader.gpuShader,
                    rs: info.rs,
                    dss: info.dss,
                    bs: info.bs,
                    dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                    gpuLayout: info.layout.gpuPipelineLayout,
                    gpuRenderPass: info.renderPass.gpuRenderPass
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuPipelineState = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXPipelineState;
    }(), WebGLGFXQueue = function(_GFXQueue) {
        function WebGLGFXQueue(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXQueue).call(this, device))).numDrawCalls = 0, 
            _this.numTris = 0, _this._isAsync = !1, _this;
        }
        return _inherits(WebGLGFXQueue, GFXQueue), _createClass(WebGLGFXQueue, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._type = info.type, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "submit",
            value: function submit(cmdBuffs, fence) {
                if (!this._isAsync) {
                    var _iterator = cmdBuffs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var cmdBuff = _ref;
                        WebGLCmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                        this.numTris += cmdBuff.numTris;
                    }
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                this.numDrawCalls = 0, this.numTris = 0;
            }
        } ]), WebGLGFXQueue;
    }(), WebGLGFXRenderPass = function(_GFXRenderPass) {
        function WebGLGFXRenderPass(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXRenderPass).call(this, device)))._gpuRenderPass = null, 
            _this;
        }
        return _inherits(WebGLGFXRenderPass, GFXRenderPass), _createClass(WebGLGFXRenderPass, [ {
            key: "gpuRenderPass",
            get: function get() {
                return this._gpuRenderPass;
            }
        } ]), _createClass(WebGLGFXRenderPass, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
                this._gpuRenderPass = {
                    colorAttachments: this._colorInfos,
                    depthStencilAttachment: this._depthStencilInfo
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuRenderPass = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXRenderPass;
    }(), WebGLWraps = [ WebGLRenderingContext.REPEAT, WebGLRenderingContext.MIRRORED_REPEAT, WebGLRenderingContext.CLAMP_TO_EDGE, WebGLRenderingContext.CLAMP_TO_EDGE ], WebGLGFXSampler = function(_GFXSampler) {
        function WebGLGFXSampler(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXSampler).call(this, device)))._gpuSampler = null, 
            _this._state = new GFXSamplerState(), _this;
        }
        return _inherits(WebGLGFXSampler, GFXSampler), _createClass(WebGLGFXSampler, [ {
            key: "gpuSampler",
            get: function get() {
                return this._gpuSampler;
            }
        } ]), _createClass(WebGLGFXSampler, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
                void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
                void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
                void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
                void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
                void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
                void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias);
                var glMinFilter = WebGLRenderingContext.NONE, glMagFilter = WebGLRenderingContext.NONE, minFilter = this._state.minFilter, magFilter = this._state.magFilter, mipFilter = this._state.mipFilter;
                glMinFilter = minFilter === GFXFilter.LINEAR || minFilter === GFXFilter.ANISOTROPIC ? mipFilter === GFXFilter.LINEAR || mipFilter === GFXFilter.ANISOTROPIC ? WebGLRenderingContext.LINEAR_MIPMAP_LINEAR : mipFilter === GFXFilter.POINT ? WebGLRenderingContext.LINEAR_MIPMAP_NEAREST : WebGLRenderingContext.LINEAR : mipFilter === GFXFilter.LINEAR || mipFilter === GFXFilter.ANISOTROPIC ? WebGLRenderingContext.NEAREST_MIPMAP_LINEAR : mipFilter === GFXFilter.POINT ? WebGLRenderingContext.NEAREST_MIPMAP_NEAREST : WebGLRenderingContext.NEAREST, 
                glMagFilter = magFilter === GFXFilter.LINEAR || magFilter === GFXFilter.ANISOTROPIC ? WebGLRenderingContext.LINEAR : WebGLRenderingContext.NEAREST;
                var glWrapS = WebGLWraps[this._state.addressU], glWrapT = WebGLWraps[this._state.addressV], glWrapR = WebGLWraps[this._state.addressW];
                return this._gpuSampler = {
                    glMinFilter: glMinFilter,
                    glMagFilter: glMagFilter,
                    glWrapS: glWrapS,
                    glWrapT: glWrapT,
                    glWrapR: glWrapR
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuSampler = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXSampler;
    }(), WebGLGFXShader = function(_GFXShader) {
        function WebGLGFXShader(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXShader).call(this, device)))._gpuShader = null, 
            _this;
        }
        return _inherits(WebGLGFXShader, GFXShader), _createClass(WebGLGFXShader, [ {
            key: "gpuShader",
            get: function get() {
                return this._gpuShader;
            }
        } ]), _createClass(WebGLGFXShader, [ {
            key: "initialize",
            value: function initialize(info) {
                this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
                void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                    name: info.name ? info.name : "",
                    blocks: void 0 !== info.blocks ? info.blocks : [],
                    samplers: void 0 !== info.samplers ? info.samplers : [],
                    gpuStages: new Array(info.stages.length),
                    glProgram: null,
                    glInputs: [],
                    glUniforms: [],
                    glBlocks: [],
                    glSamplers: []
                };
                for (var i = 0; i < info.stages.length; ++i) {
                    var stage = info.stages[i];
                    this._gpuShader.gpuStages[i] = {
                        type: stage.type,
                        source: stage.source,
                        macros: stage.macros ? stage.macros : [],
                        glShader: null
                    };
                }
                return function WebGLCmdFuncCreateShader(device, gpuShader) {
                    var gl = device.gl, _iterator = gpuShader.gpuStages, _isArray = Array.isArray(_iterator), _i7 = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i7 >= _iterator.length) break;
                            _ref = _iterator[_i7++];
                        } else {
                            if ((_i7 = _iterator.next()).done) break;
                            _ref = _i7.value;
                        }
                        var _gpuStage = _ref, glShaderType = 0, shaderTypeStr = "";
                        switch (_gpuStage.type) {
                          case GFXShaderType.VERTEX:
                            shaderTypeStr = "VertexShader", glShaderType = WebGLRenderingContext.VERTEX_SHADER;
                            break;

                          case GFXShaderType.FRAGMENT:
                            shaderTypeStr = "FragmentShader", glShaderType = WebGLRenderingContext.FRAGMENT_SHADER;
                            break;

                          default:
                            return void console.error("Unsupported GFXShaderType.");
                        }
                        var glShader = gl.createShader(glShaderType);
                        glShader && (_gpuStage.glShader = glShader, gl.shaderSource(_gpuStage.glShader, _gpuStage.source), 
                        gl.compileShader(_gpuStage.glShader), gl.getShaderParameter(_gpuStage.glShader, gl.COMPILE_STATUS) || (console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                        console.error(_gpuStage.source), console.error(gl.getShaderInfoLog(_gpuStage.glShader)), 
                        gl.deleteShader(_gpuStage.glShader), _gpuStage.glShader = null));
                    }
                    var glProgram = gl.createProgram();
                    if (glProgram) {
                        gpuShader.glProgram = glProgram;
                        var _iterator2 = gpuShader.gpuStages, _isArray2 = Array.isArray(_iterator2), _i8 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i8 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i8++];
                            } else {
                                if ((_i8 = _iterator2.next()).done) break;
                                _ref2 = _i8.value;
                            }
                            var _gpuStage2 = _ref2;
                            gl.attachShader(gpuShader.glProgram, _gpuStage2.glShader);
                        }
                        if (gl.linkProgram(gpuShader.glProgram), gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) console.info("Shader '" + gpuShader.name + "' compilation successed."); else {
                            console.error("Failed to link shader '" + gpuShader.name + "'."), console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                            var _iterator3 = gpuShader.gpuStages, _isArray3 = Array.isArray(_iterator3), _i9 = 0;
                            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref3;
                                if (_isArray3) {
                                    if (_i9 >= _iterator3.length) break;
                                    _ref3 = _iterator3[_i9++];
                                } else {
                                    if ((_i9 = _iterator3.next()).done) break;
                                    _ref3 = _i9.value;
                                }
                                var gpuStage = _ref3;
                                gpuStage.glShader && (gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                            }
                        }
                        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                        gpuShader.glInputs = new Array(activeAttribCount);
                        for (var i = 0; i < activeAttribCount; ++i) {
                            var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                            if (attribInfo) {
                                var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType(attribInfo.type), stride = WebGLGetTypeSize(attribInfo.type);
                                gpuShader.glInputs[i] = {
                                    binding: glLoc,
                                    name: varName,
                                    type: type,
                                    stride: stride,
                                    count: attribInfo.size,
                                    size: stride * attribInfo.size,
                                    glType: attribInfo.type,
                                    glLoc: glLoc
                                };
                            }
                        }
                        if (0 < gpuShader.blocks.length) {
                            gpuShader.glBlocks = new Array(gpuShader.blocks.length);
                            for (var _i10 = 0; _i10 < gpuShader.blocks.length; ++_i10) {
                                var block = gpuShader.blocks[_i10], glBlock = {
                                    binding: block.binding,
                                    name: block.name,
                                    size: 0,
                                    glUniforms: new Array(block.members.length),
                                    glActiveUniforms: [],
                                    isUniformPackage: !0
                                };
                                gpuShader.glBlocks[_i10] = glBlock;
                                for (var u = 0; u < block.members.length; ++u) {
                                    var uniform = block.members[u], glType = GFXTypeToWebGLType(uniform.type), _stride = WebGLGetTypeSize(glType), size = _stride * uniform.count, begin = glBlock.size / 4, array = new Array(size / 4);
                                    array.fill(0), glBlock.glUniforms[u] = {
                                        binding: -1,
                                        name: uniform.name,
                                        type: uniform.type,
                                        stride: _stride,
                                        count: uniform.count,
                                        size: size,
                                        offset: glBlock.size,
                                        glType: glType,
                                        glLoc: -1,
                                        array: array,
                                        begin: begin,
                                        isFirst: !0
                                    }, glBlock.size += size;
                                }
                            }
                        }
                        if (0 < gpuShader.samplers.length) {
                            gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                            for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                                var sampler = gpuShader.samplers[_i11];
                                gpuShader.glSamplers[_i11] = {
                                    binding: sampler.binding,
                                    name: sampler.name,
                                    type: sampler.type,
                                    units: [],
                                    glType: GFXTypeToWebGLType(sampler.type),
                                    glLoc: -1
                                };
                            }
                        }
                        for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i12 = 0; _i12 < activeUniformCount; ++_i12) {
                            var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i12);
                            if (uniformInfo) {
                                var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                if (_glLoc) {
                                    var _varName = void 0, _nameOffset = uniformInfo.name.indexOf("[");
                                    if (_varName = -1 !== _nameOffset ? uniformInfo.name.substr(0, _nameOffset) : uniformInfo.name, 
                                    uniformInfo.type === WebGLRenderingContext.SAMPLER_2D || uniformInfo.type === WebGLRenderingContext.SAMPLER_CUBE) {
                                        var _iterator6 = gpuShader.glSamplers, _isArray6 = Array.isArray(_iterator6), _i15 = 0;
                                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                            var _ref6;
                                            if (_isArray6) {
                                                if (_i15 >= _iterator6.length) break;
                                                _ref6 = _iterator6[_i15++];
                                            } else {
                                                if ((_i15 = _iterator6.next()).done) break;
                                                _ref6 = _i15.value;
                                            }
                                            var glSampler = _ref6;
                                            if (glSampler.name === _varName) {
                                                for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                                glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                                break;
                                            }
                                        }
                                    } else {
                                        var _iterator4 = gpuShader.glBlocks, _isArray4 = Array.isArray(_iterator4), _i13 = 0;
                                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                            var _ref4;
                                            if (_isArray4) {
                                                if (_i13 >= _iterator4.length) break;
                                                _ref4 = _iterator4[_i13++];
                                            } else {
                                                if ((_i13 = _iterator4.next()).done) break;
                                                _ref4 = _i13.value;
                                            }
                                            var _glBlock = _ref4, _iterator5 = _glBlock.glUniforms, _isArray5 = Array.isArray(_iterator5), _i14 = 0;
                                            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                                var _ref5;
                                                if (_isArray5) {
                                                    if (_i14 >= _iterator5.length) break;
                                                    _ref5 = _iterator5[_i14++];
                                                } else {
                                                    if ((_i14 = _iterator5.next()).done) break;
                                                    _ref5 = _i14.value;
                                                }
                                                var glUniform = _ref5;
                                                if (glUniform.name === _varName) {
                                                    glUniform.glLoc = _glLoc, _glBlock.glActiveUniforms.push(glUniform);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (glActiveSamplers.length) {
                            device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                            device.stateCache.glProgram = gpuShader.glProgram);
                            for (var _i16 = 0; _i16 < glActiveSamplers.length; _i16++) {
                                var _glSampler = glActiveSamplers[_i16];
                                gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                            }
                        }
                    }
                }(this._device, this._gpuShader), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuShader && (!function WebGLCmdFuncDestroyShader(device, gpuShader) {
                    var _iterator7 = gpuShader.gpuStages, _isArray7 = Array.isArray(_iterator7), _i17 = 0;
                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                        var _ref7;
                        if (_isArray7) {
                            if (_i17 >= _iterator7.length) break;
                            _ref7 = _iterator7[_i17++];
                        } else {
                            if ((_i17 = _iterator7.next()).done) break;
                            _ref7 = _i17.value;
                        }
                        var gpuStage = _ref7;
                        gpuStage.glShader && (device.gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                    }
                    gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
                }(this._device, this._gpuShader), this._gpuShader = null), this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXShader;
    }(), WebGLStateCache = function WebGLStateCache() {
        _classCallCheck(this, WebGLStateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
        this.glVAO = null, this.texUnit = 0, this.glTex2DUnits = void 0, this.glTexCubeUnits = void 0, 
        this.glRenderbuffer = null, this.glFramebuffer = null, this.viewport = void 0, this.scissorRect = void 0, 
        this.rs = void 0, this.dss = void 0, this.bs = void 0, this.glProgram = null, this.glEnabledAttribLocs = void 0, 
        this.glCurrentAttribLocs = void 0, this.glTex2DUnits = new Array(16), this.glTexCubeUnits = new Array(16), 
        this.viewport = {
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            minDepth: 0,
            maxDepth: 0
        }, this.scissorRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }, this.rs = new GFXRasterizerState(), this.dss = new GFXDepthStencilState(), this.bs = new GFXBlendState(), 
        this.glEnabledAttribLocs = new Array(16), this.glCurrentAttribLocs = new Array(16), 
        this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
        for (var i = 0; i < 16; ++i) this.glTex2DUnits[i] = {
            glTexture: null
        }, this.glTexCubeUnits[i] = {
            glTexture: null
        };
    };
    function IsPowerOf2(x) {
        return 0 < x && 0 == (x & x - 1);
    }
    var WebGLGFXTexture = function(_GFXTexture) {
        function WebGLGFXTexture(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTexture).call(this, device)))._gpuTexture = null, 
            _this;
        }
        return _inherits(WebGLGFXTexture, GFXTexture), _createClass(WebGLGFXTexture, [ {
            key: "gpuTexture",
            get: function get() {
                return this._gpuTexture;
            }
        } ]), _createClass(WebGLGFXTexture, [ {
            key: "initialize",
            value: function initialize(info) {
                var viewType;
                switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
                this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
                void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
                void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
                this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                this._flags & GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
                info.type) {
                  case GFXTextureType.TEX1D:
                    viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV1D : GFXTextureViewType.TV1D_ARRAY : GFXTextureViewType.TV1D;
                    break;

                  case GFXTextureType.TEX2D:
                    var flags = GFXTextureFlagBit.NONE;
                    info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV2D : flags & GFXTextureFlagBit.CUBEMAP ? GFXTextureViewType.CUBE : GFXTextureViewType.TV2D_ARRAY : GFXTextureViewType.TV2D;
                    break;

                  case GFXTextureType.TEX3D:
                    viewType = GFXTextureViewType.TV3D;
                    break;

                  default:
                    viewType = GFXTextureViewType.TV2D;
                }
                return this._gpuTexture = {
                    type: this._type,
                    viewType: viewType,
                    format: this._format,
                    usage: this._usage,
                    width: this._width,
                    height: this._height,
                    depth: this._depth,
                    size: this._size,
                    arrayLayer: this._arrayLayer,
                    mipLevel: this._mipLevel,
                    samples: this._samples,
                    flags: this._flags,
                    isPowerOf2: this._isPowerOf2,
                    glTarget: 0,
                    glInternelFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0
                }, function WebGLCmdFuncCreateTexture(device, gpuTexture) {
                    var gl = device.gl;
                    switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format), 
                    gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format), 
                    gpuTexture.viewType) {
                      case GFXTextureViewType.TV2D:
                        if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = WebGLRenderingContext.TEXTURE_2D, 
                        gpuTexture.samples === GFXSampleCount.X1) {
                            var glTexture = gl.createTexture();
                            if (glTexture && 0 < gpuTexture.size) {
                                gpuTexture.glTexture = glTexture;
                                var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                                glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, gpuTexture.glTexture), 
                                glTexUnit.glTexture = gpuTexture.glTexture);
                                var w = gpuTexture.width, h = gpuTexture.height;
                                if (GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                    var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                    gl.compressedTexImage2D(WebGLRenderingContext.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                } else {
                                    var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                    gl.compressedTexImage2D(WebGLRenderingContext.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                                } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(WebGLRenderingContext.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = WebGLRenderingContext.REPEAT, gpuTexture.glWrapT = WebGLRenderingContext.REPEAT) : (gpuTexture.glWrapS = WebGLRenderingContext.CLAMP_TO_EDGE, 
                                gpuTexture.glWrapT = WebGLRenderingContext.CLAMP_TO_EDGE), gpuTexture.glMinFilter = WebGLRenderingContext.LINEAR, 
                                gpuTexture.glMagFilter = WebGLRenderingContext.LINEAR, gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_WRAP_S, gpuTexture.glWrapS), 
                                gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                                gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                                gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                            }
                        }
                        break;

                      case GFXTextureViewType.CUBE:
                        gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = WebGLRenderingContext.TEXTURE_CUBE_MAP;
                        var _glTexture = gl.createTexture();
                        if (_glTexture && 0 < gpuTexture.size) {
                            gpuTexture.glTexture = _glTexture;
                            var _glTexUnit = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                            if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGLRenderingContext.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                            _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) for (var _w2 = gpuTexture.width, _h2 = gpuTexture.height, _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                                var _imgSize2 = GFXFormatSize(gpuTexture.format, _w2, _h2, 1), _view2 = new Uint8Array(_imgSize2);
                                gl.compressedTexImage2D(WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, _w2, _h2, 0, _view2), 
                                _w2 = Math.max(1, _w2 >> 1), _h2 = Math.max(1, _h2 >> 1);
                            } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                                var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                                gl.compressedTexImage2D(WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                            } else for (var f = 0; f < 6; ++f) for (var _w = gpuTexture.width, _h = gpuTexture.height, _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, _w, _h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            _w = Math.max(1, _w >> 1), _h = Math.max(1, _h >> 1);
                            gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = WebGLRenderingContext.REPEAT, gpuTexture.glWrapT = WebGLRenderingContext.REPEAT) : (gpuTexture.glWrapS = WebGLRenderingContext.CLAMP_TO_EDGE, 
                            gpuTexture.glWrapT = WebGLRenderingContext.CLAMP_TO_EDGE), gpuTexture.glMinFilter = WebGLRenderingContext.LINEAR, 
                            gpuTexture.glMagFilter = WebGLRenderingContext.LINEAR, gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_WRAP_S, gpuTexture.glWrapS), 
                            gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                            gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                            gl.texParameteri(gpuTexture.glTarget, WebGLRenderingContext.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                        }
                        break;

                      default:
                        console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                        gpuTexture.glTarget = WebGLRenderingContext.TEXTURE_2D;
                    }
                }(this._device, this._gpuTexture), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuTexture && (!function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
                    gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                    gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                    gpuTexture.glRenderbuffer = null);
                }(this._device, this._gpuTexture), this._gpuTexture = null), this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
                this._gpuTexture.size = this._size, function WebGLCmdFuncResizeTexture(device, gpuTexture) {
                    var gl = device.gl;
                    switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format), 
                    gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format), 
                    gpuTexture.viewType) {
                      case GFXTextureViewType.TV2D:
                        if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D, 
                        gpuTexture.samples === GFXSampleCount.X1) {
                            var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            if (GFXFormatInfos[gpuTexture.format].isCompressed) {
                                if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                    var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                    gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                            } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                        }
                        break;

                      case GFXTextureViewType.CUBE:
                        gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                        var _glTexUnit2 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                        if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                            if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) for (var _w4 = gpuTexture.width, _h4 = gpuTexture.height, _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                                var _imgSize4 = GFXFormatSize(gpuTexture.format, _w4, _h4, 1), _view4 = new Uint8Array(_imgSize4);
                                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, _w4, _h4, 0, _view4), 
                                _w4 = Math.max(1, _w4 >> 1), _h4 = Math.max(1, _h4 >> 1);
                            }
                        } else for (var f = 0; f < 6; ++f) for (var _w3 = gpuTexture.width, _h3 = gpuTexture.height, _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, _w3, _h3, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        _w3 = Math.max(1, _w3 >> 1), _h3 = Math.max(1, _h3 >> 1);
                        break;

                      default:
                        console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                        gpuTexture.glTarget = gl.TEXTURE_2D;
                    }
                }(this._device, this._gpuTexture)), this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXTexture;
    }(), WebGLGFXTextureView = function(_GFXTextureView) {
        function WebGLGFXTextureView(device) {
            var _this;
            return _classCallCheck(this, WebGLGFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTextureView).call(this, device)))._gpuTextureView = null, 
            _this;
        }
        return _inherits(WebGLGFXTextureView, GFXTextureView), _createClass(WebGLGFXTextureView, [ {
            key: "gpuTextureView",
            get: function get() {
                return this._gpuTextureView;
            }
        } ]), _createClass(WebGLGFXTextureView, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._texture = info.texture, this._type = info.type, this._format = info.format, 
                this._format = info.format, void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), 
                void 0 !== info.levelCount && (this._levelCount = info.levelCount), void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), 
                void 0 !== info.layerCount && (this._layerCount = info.layerCount), this._gpuTextureView = {
                    gpuTexture: info.texture.gpuTexture,
                    type: info.type,
                    format: info.format,
                    baseLevel: info.baseLevel ? info.baseLevel : 0,
                    levelCount: info.levelCount ? info.levelCount : 1
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuTextureView = null, this._texture = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGLGFXTextureView;
    }(), GFXWindow = function(_GFXObject) {
        function GFXWindow(device) {
            var _this;
            return _classCallCheck(this, GFXWindow), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXWindow).call(this, GFXObjectType.WINDOW)))._device = void 0, 
            _this._title = "", _this._left = 0, _this._top = 0, _this._width = 0, _this._height = 0, 
            _this._nativeWidth = 0, _this._nativeHeight = 0, _this._colorFmt = exports.GFXFormat.UNKNOWN, 
            _this._depthStencilFmt = exports.GFXFormat.UNKNOWN, _this._isOffscreen = !1, _this._renderPass = null, 
            _this._colorTex = null, _this._colorTexView = null, _this._depthStencilTex = null, 
            _this._depthStencilTexView = null, _this._framebuffer = null, _this._device = device, 
            _this;
        }
        return _inherits(GFXWindow, GFXObject), _createClass(GFXWindow, [ {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "colorFormat",
            get: function get() {
                return this._colorFmt;
            }
        }, {
            key: "detphStencilFormat",
            get: function get() {
                return this._depthStencilFmt;
            }
        }, {
            key: "renderPass",
            get: function get() {
                return this._renderPass;
            }
        }, {
            key: "colorTexView",
            get: function get() {
                return this._colorTexView;
            }
        }, {
            key: "depthStencilTexView",
            get: function get() {
                return this._depthStencilTexView;
            }
        }, {
            key: "framebuffer",
            get: function get() {
                return this._framebuffer;
            }
        } ]), GFXWindow;
    }(), WebGLGFXWindow = function(_GFXWindow) {
        function WebGLGFXWindow(device) {
            return _classCallCheck(this, WebGLGFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXWindow).call(this, device));
        }
        return _inherits(WebGLGFXWindow, GFXWindow), _createClass(WebGLGFXWindow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
                void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
                this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
                this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
                this._renderPass = this._device.createRenderPass({
                    colorAttachments: [ {
                        format: this._colorFmt,
                        loadOp: GFXLoadOp.CLEAR,
                        storeOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                    } ],
                    depthStencilAttachment: {
                        format: this._depthStencilFmt,
                        depthLoadOp: GFXLoadOp.CLEAR,
                        depthStoreOp: GFXStoreOp.STORE,
                        stencilLoadOp: GFXLoadOp.CLEAR,
                        stencilStoreOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                    }
                });
                var colorViews = [];
                return this._isOffscreen && (this._colorFmt !== exports.GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._colorFmt,
                    width: this._width,
                    height: this._height,
                    depth: 1,
                    arrayLayer: 1,
                    mipLevel: 1,
                    flags: GFXTextureFlagBit.NONE
                }), this._colorTexView = this._device.createTextureView({
                    texture: this._colorTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt,
                    baseLevel: 0,
                    levelCount: 1,
                    baseLayer: 0,
                    layerCount: 1
                }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== exports.GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                    format: this._depthStencilFmt,
                    width: this._width,
                    height: this._height,
                    depth: 1,
                    arrayLayer: 1,
                    mipLevel: 1,
                    flags: GFXTextureFlagBit.NONE
                }), this._depthStencilTexView = this._device.createTextureView({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt,
                    baseLevel: 0,
                    levelCount: 1,
                    baseLayer: 0,
                    layerCount: 1
                }))), this._framebuffer = this._device.createFramebuffer({
                    renderPass: this._renderPass,
                    colorViews: colorViews,
                    depthStencilView: this._depthStencilTexView,
                    isOffscreen: this._isOffscreen
                }), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
                this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
                this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
                this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
                this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
                this._colorTexView.initialize({
                    texture: this._colorTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
                this._framebuffer.initialize({
                    renderPass: this._renderPass,
                    colorViews: [ this._colorTexView ],
                    depthStencilView: this._depthStencilTexView
                })));
            }
        } ]), WebGLGFXWindow;
    }(), WebGLGFXDevice = function(_GFXDevice) {
        function WebGLGFXDevice() {
            var _this;
            return _classCallCheck(this, WebGLGFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXDevice).call(this))).stateCache = new WebGLStateCache(), 
            _this.nullTex2D = null, _this.nullTexCube = null, _this._webGLRC = null, _this._isAntialias = !0, 
            _this._isPremultipliedAlpha = !0, _this._useVAO = !1, _this._extensions = null, 
            _this._EXT_texture_filter_anisotropic = null, _this._EXT_frag_depth = null, _this._EXT_shader_texture_lod = null, 
            _this._EXT_sRGB = null, _this._OES_vertex_array_object = null, _this._EXT_color_buffer_half_float = null, 
            _this._WEBGL_color_buffer_float = null, _this._WEBGL_compressed_texture_etc1 = null, 
            _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
            _this._WEBGL_compressed_texture_astc = null, _this._WEBGL_compressed_texture_s3tc = null, 
            _this._WEBGL_compressed_texture_s3tc_srgb = null, _this._WEBGL_debug_shaders = null, 
            _this._WEBGL_draw_buffers = null, _this._WEBGL_lose_context = null, _this._WEBGL_depth_texture = null, 
            _this._WEBGL_debug_renderer_info = null, _this._OES_texture_half_float = null, _this._OES_texture_half_float_linear = null, 
            _this._OES_texture_float = null, _this._OES_texture_float_linear = null, _this._OES_standard_derivatives = null, 
            _this._OES_element_index_uint = null, _this._ANGLE_instanced_arrays = null, _this;
        }
        return _inherits(WebGLGFXDevice, GFXDevice), _createClass(WebGLGFXDevice, [ {
            key: "gl",
            get: function get() {
                return this._webGLRC;
            }
        }, {
            key: "webGLQueue",
            get: function get() {
                return this._queue;
            }
        }, {
            key: "isAntialias",
            get: function get() {
                return this._isAntialias;
            }
        }, {
            key: "isPremultipliedAlpha",
            get: function get() {
                return this._isPremultipliedAlpha;
            }
        }, {
            key: "useVAO",
            get: function get() {
                return this._useVAO;
            }
        }, {
            key: "EXT_texture_filter_anisotropic",
            get: function get() {
                return this._EXT_texture_filter_anisotropic;
            }
        }, {
            key: "EXT_frag_depth",
            get: function get() {
                return this._EXT_frag_depth;
            }
        }, {
            key: "EXT_shader_texture_lod",
            get: function get() {
                return this._EXT_shader_texture_lod;
            }
        }, {
            key: "EXT_sRGB",
            get: function get() {
                return this._EXT_sRGB;
            }
        }, {
            key: "OES_vertex_array_object",
            get: function get() {
                return this._OES_vertex_array_object;
            }
        }, {
            key: "WEBGL_color_buffer_float",
            get: function get() {
                return this._WEBGL_color_buffer_float;
            }
        }, {
            key: "WEBGL_compressed_texture_etc1",
            get: function get() {
                return this._WEBGL_compressed_texture_etc1;
            }
        }, {
            key: "WEBGL_compressed_texture_pvrtc",
            get: function get() {
                return this._WEBGL_compressed_texture_pvrtc;
            }
        }, {
            key: "WEBGL_compressed_texture_astc",
            get: function get() {
                return this._WEBGL_compressed_texture_astc;
            }
        }, {
            key: "WEBGL_compressed_texture_s3tc",
            get: function get() {
                return this._WEBGL_compressed_texture_s3tc;
            }
        }, {
            key: "WEBGL_compressed_texture_s3tc_srgb",
            get: function get() {
                return this._WEBGL_compressed_texture_s3tc_srgb;
            }
        }, {
            key: "WEBGL_debug_shaders",
            get: function get() {
                return this._WEBGL_debug_shaders;
            }
        }, {
            key: "WEBGL_draw_buffers",
            get: function get() {
                return this._WEBGL_draw_buffers;
            }
        }, {
            key: "WEBGL_lose_context",
            get: function get() {
                return this._WEBGL_lose_context;
            }
        }, {
            key: "WEBGL_depth_texture",
            get: function get() {
                return this._WEBGL_depth_texture;
            }
        }, {
            key: "WEBGL_debug_renderer_info",
            get: function get() {
                return this._WEBGL_debug_renderer_info;
            }
        }, {
            key: "OES_texture_half_float",
            get: function get() {
                return this._OES_texture_half_float;
            }
        }, {
            key: "OES_texture_half_float_linear",
            get: function get() {
                return this._OES_texture_half_float_linear;
            }
        }, {
            key: "OES_texture_float",
            get: function get() {
                return this._OES_texture_float;
            }
        }, {
            key: "OES_standard_derivatives",
            get: function get() {
                return this._OES_standard_derivatives;
            }
        }, {
            key: "OES_element_index_uint",
            get: function get() {
                return this._OES_element_index_uint;
            }
        }, {
            key: "ANGLE_instanced_arrays",
            get: function get() {
                return this._ANGLE_instanced_arrays;
            }
        } ]), _createClass(WebGLGFXDevice, [ {
            key: "initialize",
            value: function initialize(info) {
                this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
                this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
                try {
                    var webGLCtxAttribs = {
                        alpha: !0,
                        antialias: this._isAntialias,
                        depth: !0,
                        stencil: !0,
                        premultipliedAlpha: this._isPremultipliedAlpha,
                        preserveDrawingBuffer: !1,
                        powerPreference: "default",
                        failIfMajorPerformanceCaveat: !1
                    };
                    this._webGLRC = this._canvas.getContext("webgl", webGLCtxAttribs);
                } catch (err) {
                    return console.error(err), !1;
                }
                if (!this._webGLRC) return console.error("This device does not support WebGL."), 
                !1;
                this._canvas2D = document.createElement("canvas"), console.info("WebGL device initialized."), 
                this._gfxAPI = GFXAPI.WEBGL, this._deviceName = "WebGL";
                var gl = this._webGLRC;
                this._WEBGL_debug_renderer_info = gl.getExtension("WEBGL_debug_renderer_info"), 
                this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
                this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(WebGLRenderingContext.RENDERER), 
                this._vendor = gl.getParameter(WebGLRenderingContext.VENDOR)), this._version = gl.getParameter(WebGLRenderingContext.VERSION), 
                this._maxVertexAttributes = gl.getParameter(WebGLRenderingContext.MAX_VERTEX_ATTRIBS), 
                this._maxVertexUniformVectors = gl.getParameter(WebGLRenderingContext.MAX_VERTEX_UNIFORM_VECTORS), 
                this._maxFragmentUniformVectors = gl.getParameter(WebGLRenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS), 
                this._maxTextureUnits = gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_IMAGE_UNITS), 
                this._maxVertexTextureUnits = gl.getParameter(WebGLRenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
                this._depthBits = gl.getParameter(WebGLRenderingContext.DEPTH_BITS), this._stencilBits = gl.getParameter(WebGLRenderingContext.STENCIL_BITS), 
                this._devicePixelRatio = info.devicePixelRatio || 1, this._width = this._canvas.width, 
                this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
                this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = exports.GFXFormat.RGBA8, 
                24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D16S8 : this._depthStencilFmt = exports.GFXFormat.D16, 
                this._extensions = gl.getSupportedExtensions();
                var extensions = "";
                if (this._extensions) {
                    var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        extensions += _ref + " ";
                    }
                    console.debug("EXTENSIONS: " + extensions);
                }
                this._EXT_texture_filter_anisotropic = gl.getExtension("EXT_texture_filter_anisotropic"), 
                this._EXT_frag_depth = gl.getExtension("EXT_frag_depth"), this._EXT_shader_texture_lod = gl.getExtension("EXT_shader_texture_lod"), 
                this._EXT_sRGB = gl.getExtension("EXT_sRGB"), this._OES_vertex_array_object = gl.getExtension("OES_vertex_array_object"), 
                this._EXT_color_buffer_half_float = gl.getExtension("EXT_color_buffer_half_float"), 
                this._WEBGL_color_buffer_float = gl.getExtension("WEBGL_color_buffer_float"), this._WEBGL_compressed_texture_etc1 = gl.getExtension("WEBGL_compressed_texture_etc1"), 
                this._WEBGL_compressed_texture_etc = gl.getExtension("WEBGL_compressed_texture_etc"), 
                this._WEBGL_compressed_texture_pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc"), 
                this._WEBGL_compressed_texture_astc = gl.getExtension("WEBGL_compressed_texture_astc"), 
                this._WEBGL_compressed_texture_s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc"), 
                this._WEBGL_compressed_texture_s3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
                this._WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders"), this._WEBGL_draw_buffers = gl.getExtension("WEBGL_draw_buffers"), 
                this._WEBGL_lose_context = gl.getExtension("WEBGL_lose_context"), this._WEBGL_depth_texture = gl.getExtension("WEBGL_depth_texture"), 
                this._OES_texture_half_float = gl.getExtension("OES_texture_half_float"), this._OES_texture_half_float_linear = gl.getExtension("OES_texture_half_float_linear"), 
                this._OES_texture_float = gl.getExtension("OES_texture_float"), this._OES_texture_float_linear = gl.getExtension("OES_texture_float_linear"), 
                this._OES_standard_derivatives = gl.getExtension("OES_standard_derivatives"), this._OES_element_index_uint = gl.getExtension("OES_element_index_uint"), 
                this._ANGLE_instanced_arrays = gl.getExtension("ANGLE_instanced_arrays"), this._features.fill(!1), 
                this._WEBGL_color_buffer_float && (this._features[GFXFeature.COLOR_FLOAT] = !0), 
                this._EXT_color_buffer_half_float && (this._features[GFXFeature.COLOR_HALF_FLOAT] = !0), 
                this._OES_texture_float && (this._features[GFXFeature.TEXTURE_FLOAT] = !0), this._OES_texture_half_float && (this._features[GFXFeature.TEXTURE_HALF_FLOAT] = !0), 
                this._OES_texture_float_linear && (this._features[GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
                this._OES_texture_half_float_linear && (this._features[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0), 
                this._WEBGL_depth_texture && (this._features[GFXFeature.FORMAT_D24S8] = !0);
                var compressedFormat = "";
                this._WEBGL_compressed_texture_etc1 && (this._features[GFXFeature.FORMAT_ETC1] = !0, 
                compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[GFXFeature.FORMAT_ETC2] = !0, 
                compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[GFXFeature.FORMAT_DXT] = !0, 
                compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[GFXFeature.FORMAT_PVRTC] = !0, 
                compressedFormat += "pvrtc "), this._features[GFXFeature.MSAA] = !1, this._OES_vertex_array_object && (this._useVAO = !1), 
                console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
                console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
                console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
                console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("DEPTH_BITS: " + this._depthBits), 
                console.info("STENCIL_BITS: " + this._stencilBits), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
                console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
                this.initStates(gl), this._queue = this.createQueue({
                    type: GFXQueueType.GRAPHICS
                }), this._mainWindow = this.createWindow({
                    title: this._webGLRC.canvas.title,
                    left: this._webGLRC.canvas.offsetLeft,
                    top: this._webGLRC.canvas.offsetTop,
                    width: this._webGLRC.drawingBufferWidth,
                    height: this._webGLRC.drawingBufferHeight,
                    colorFmt: this._colorFmt,
                    depthStencilFmt: this._depthStencilFmt
                }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGLGFXTexture(this), 
                this.nullTex2D.initialize({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: 2,
                    height: 2,
                    flags: GFXTextureFlagBit.GEN_MIPMAP
                }), this.nullTexCube = new WebGLGFXTexture(this), this.nullTexCube.initialize({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: 2,
                    height: 2,
                    arrayLayer: 6,
                    flags: GFXTextureFlagBit.CUBEMAP | GFXTextureFlagBit.GEN_MIPMAP
                });
                var nullTexRegion = {
                    buffOffset: 0,
                    buffStride: 0,
                    buffTexHeight: 0,
                    texOffset: {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    texExtent: {
                        width: 2,
                        height: 2,
                        depth: 1
                    },
                    texSubres: {
                        baseMipLevel: 0,
                        levelCount: 1,
                        baseArrayLayer: 0,
                        layerCount: 1
                    }
                }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
                return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
                nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
                this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
                this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
                this._queue && (this._queue.destroy(), this._queue = null), this._webGLRC = null;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
                this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
            }
        }, {
            key: "createBuffer",
            value: function createBuffer(info) {
                var buffer = new WebGLGFXBuffer(this);
                return buffer.initialize(info), buffer;
            }
        }, {
            key: "createTexture",
            value: function createTexture(info) {
                var texture = new WebGLGFXTexture(this);
                return texture.initialize(info), texture;
            }
        }, {
            key: "createTextureView",
            value: function createTextureView(info) {
                var texView = new WebGLGFXTextureView(this);
                return texView.initialize(info), texView;
            }
        }, {
            key: "createSampler",
            value: function createSampler(info) {
                var sampler = new WebGLGFXSampler(this);
                return sampler.initialize(info), sampler;
            }
        }, {
            key: "createBindingLayout",
            value: function createBindingLayout(info) {
                var bindingLayout = new WebGLGFXBindingLayout(this);
                return bindingLayout.initialize(info), bindingLayout;
            }
        }, {
            key: "createShader",
            value: function createShader(info) {
                var shader = new WebGLGFXShader(this);
                return shader.initialize(info), shader;
            }
        }, {
            key: "createInputAssembler",
            value: function createInputAssembler(info) {
                var inputAssembler = new WebGLGFXInputAssembler(this);
                return inputAssembler.initialize(info), inputAssembler;
            }
        }, {
            key: "createRenderPass",
            value: function createRenderPass(info) {
                var renderPass = new WebGLGFXRenderPass(this);
                return renderPass.initialize(info), renderPass;
            }
        }, {
            key: "createFramebuffer",
            value: function createFramebuffer(info) {
                var framebuffer = new WebGLGFXFramebuffer(this);
                return framebuffer.initialize(info), framebuffer;
            }
        }, {
            key: "createPipelineLayout",
            value: function createPipelineLayout(info) {
                var pipelineLayout = new WebGLGFXPipelineLayout(this);
                return pipelineLayout.initialize(info), pipelineLayout;
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState(info) {
                var pipelineState = new WebGLGFXPipelineState(this);
                return pipelineState.initialize(info), pipelineState;
            }
        }, {
            key: "createCommandAllocator",
            value: function createCommandAllocator(info) {
                var cmdAllocator = new WebGLGFXCommandAllocator(this);
                return cmdAllocator.initialize(info), cmdAllocator;
            }
        }, {
            key: "createCommandBuffer",
            value: function createCommandBuffer(info) {
                var cmdBuff = new WebGLGFXCommandBuffer(this);
                return cmdBuff.initialize(info), cmdBuff;
            }
        }, {
            key: "createQueue",
            value: function createQueue(info) {
                var queue = new WebGLGFXQueue(this);
                return queue.initialize(info), queue;
            }
        }, {
            key: "createWindow",
            value: function createWindow(info) {
                var window = new WebGLGFXWindow(this);
                return window.initialize(info), window;
            }
        }, {
            key: "present",
            value: function present() {
                this._cmdAllocator.releaseCmds();
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
            }
        }, {
            key: "copyBuffersToTexture",
            value: function copyBuffersToTexture(buffers, texture, regions) {
                WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
            }
        }, {
            key: "copyTexImagesToTexture",
            value: function copyTexImagesToTexture(texImages, texture, regions) {
                !function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                    var gl = device.gl, m = 0, n = 0, f = 0;
                    switch (gpuTexture.glTarget) {
                      case WebGLRenderingContext.TEXTURE_2D:
                        var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, gpuTexture.glTexture), 
                        glTexUnit.glTexture = gpuTexture.glTexture);
                        var _iterator20 = regions, _isArray20 = Array.isArray(_iterator20), _i30 = 0;
                        for (_iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator](); ;) {
                            var _ref20;
                            if (_isArray20) {
                                if (_i30 >= _iterator20.length) break;
                                _ref20 = _iterator20[_i30++];
                            } else {
                                if ((_i30 = _iterator20.next()).done) break;
                                _ref20 = _i30.value;
                            }
                            var region = _ref20;
                            for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(WebGLRenderingContext.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                        }
                        break;

                      case WebGLRenderingContext.TEXTURE_CUBE_MAP:
                        var _glTexUnit3 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                        _glTexUnit3.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGLRenderingContext.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit3.glTexture = gpuTexture.glTexture);
                        var _iterator21 = regions, _isArray21 = Array.isArray(_iterator21), _i31 = 0;
                        for (_iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator](); ;) {
                            var _ref21;
                            if (_isArray21) {
                                if (_i31 >= _iterator21.length) break;
                                _ref21 = _iterator21[_i31++];
                            } else {
                                if ((_i31 = _iterator21.next()).done) break;
                                _ref21 = _i31.value;
                            }
                            var _region = _ref21, fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                            for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                                var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                                for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                            }
                        }
                        break;

                      default:
                        console.error("Unsupported GL texture type, copy buffer to texture failed.");
                    }
                    gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2 && gl.generateMipmap(gpuTexture.glTarget);
                }(this, texImages, texture.gpuTexture, regions);
            }
        }, {
            key: "copyFramebufferToBuffer",
            value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                var gl = this._webGLRC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
                this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(exports.GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                    gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, WebGLRenderingContext.RGBA, WebGLRenderingContext.UNSIGNED_BYTE, data);
                }
                this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, curFBO), 
                this.stateCache.glFramebuffer = curFBO);
            }
        }, {
            key: "blitFramebuffer",
            value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {}
        }, {
            key: "initStates",
            value: function initStates(gl) {
                gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
                gl.disable(gl.SCISSOR_TEST), gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), 
                gl.disable(gl.POLYGON_OFFSET_FILL), gl.polygonOffset(0, 0), gl.enable(gl.DEPTH_TEST), 
                gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.depthRange(0, 1), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 4294967295), 
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 4294967295), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
                gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
                gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
            }
        } ]), WebGLGFXDevice;
    }(), WebGL2GFXBindingLayout = function(_GFXBindingLayout) {
        function WebGL2GFXBindingLayout(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
            _this;
        }
        return _inherits(WebGL2GFXBindingLayout, GFXBindingLayout), _createClass(WebGL2GFXBindingLayout, [ {
            key: "gpuBindingLayout",
            get: function get() {
                return this._gpuBindingLayout;
            }
        } ]), _createClass(WebGL2GFXBindingLayout, [ {
            key: "initialize",
            value: function initialize(info) {
                this._bindingUnits = new Array(info.bindings.length);
                for (var i = 0; i < info.bindings.length; ++i) {
                    var binding = info.bindings[i];
                    this._bindingUnits[i] = {
                        binding: binding.binding,
                        type: binding.type,
                        name: binding.name,
                        buffer: null,
                        texView: null,
                        sampler: null
                    };
                }
                this._gpuBindingLayout = {
                    gpuBindings: new Array(info.bindings.length)
                };
                for (var _i = 0; _i < info.bindings.length; ++_i) {
                    var _binding = info.bindings[_i];
                    this._gpuBindingLayout.gpuBindings[_i] = {
                        binding: _binding.binding,
                        type: _binding.type,
                        name: _binding.name,
                        gpuBuffer: null,
                        gpuTexView: null,
                        gpuSampler: null
                    };
                }
                return this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuBindingLayout = null, this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "update",
            value: function update() {
                if (this._isDirty && this._gpuBindingLayout) {
                    for (var i = 0; i < this._bindingUnits.length; ++i) {
                        var bindingUnit = this._bindingUnits[i];
                        switch (bindingUnit.type) {
                          case GFXBindingType.UNIFORM_BUFFER:
                            bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                            break;

                          case GFXBindingType.SAMPLER:
                            bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                            bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                        }
                    }
                    this._isDirty = !1;
                }
            }
        } ]), WebGL2GFXBindingLayout;
    }(), WebGLWraps$1 = [ WebGLRenderingContext.REPEAT, WebGLRenderingContext.MIRRORED_REPEAT, WebGLRenderingContext.CLAMP_TO_EDGE, WebGLRenderingContext.CLAMP_TO_EDGE ], SAMPLES = [ 1, 2, 4, 8, 16, 32, 64 ], _f32v4 = new Float32Array(4);
    function GFXFormatToWebGLType$1(format, device) {
        switch (format) {
          case exports.GFXFormat.R8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.R8SN:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.R8UI:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.R8I:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.R16F:
            return WebGL2RenderingContext.HALF_FLOAT;

          case exports.GFXFormat.R16UI:
            return WebGL2RenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.R16I:
            return WebGL2RenderingContext.SHORT;

          case exports.GFXFormat.R32F:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.R32UI:
            return WebGL2RenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.R32I:
            return WebGL2RenderingContext.INT;

          case exports.GFXFormat.RG8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RG8SN:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.RG8UI:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RG8I:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.RG16F:
            return WebGL2RenderingContext.HALF_FLOAT;

          case exports.GFXFormat.RG16UI:
            return WebGL2RenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.RG16I:
            return WebGL2RenderingContext.SHORT;

          case exports.GFXFormat.RG32F:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.RG32UI:
            return WebGL2RenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RG32I:
            return WebGL2RenderingContext.INT;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.SRGB8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB8SN:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.RGB8UI:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGB8I:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.RGB16F:
            return WebGL2RenderingContext.HALF_FLOAT;

          case exports.GFXFormat.RGB16UI:
            return WebGL2RenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.RGB16I:
            return WebGL2RenderingContext.SHORT;

          case exports.GFXFormat.RGB32F:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.RGB32UI:
            return WebGL2RenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RGB32I:
            return WebGL2RenderingContext.INT;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.SRGB8_A8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGBA8SN:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.RGBA8UI:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.RGBA8I:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.RGBA16F:
            return WebGL2RenderingContext.HALF_FLOAT;

          case exports.GFXFormat.RGBA16UI:
            return WebGL2RenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.RGBA16I:
            return WebGL2RenderingContext.SHORT;

          case exports.GFXFormat.RGBA32F:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.RGBA32UI:
            return WebGL2RenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.RGBA32I:
            return WebGL2RenderingContext.INT;

          case exports.GFXFormat.R5G6B5:
            return WebGL2RenderingContext.UNSIGNED_SHORT_5_6_5;

          case exports.GFXFormat.R11G11B10F:
            return WebGL2RenderingContext.UNSIGNED_INT_10F_11F_11F_REV;

          case exports.GFXFormat.RGB5A1:
            return WebGL2RenderingContext.UNSIGNED_SHORT_5_5_5_1;

          case exports.GFXFormat.RGBA4:
            return WebGL2RenderingContext.UNSIGNED_SHORT_4_4_4_4;

          case exports.GFXFormat.RGB10A2:
          case exports.GFXFormat.RGB10A2UI:
            return WebGL2RenderingContext.UNSIGNED_INT_2_10_10_10_REV;

          case exports.GFXFormat.RGB9E5:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.D16:
          case exports.GFXFormat.D16S8:
            return WebGL2RenderingContext.UNSIGNED_SHORT;

          case exports.GFXFormat.D24:
            return WebGL2RenderingContext.UNSIGNED_INT;

          case exports.GFXFormat.D24S8:
            return WebGL2RenderingContext.UNSIGNED_INT_24_8;

          case exports.GFXFormat.D32F:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.D32F_S8:
            return WebGL2RenderingContext.FLOAT_32_UNSIGNED_INT_24_8_REV;

          case exports.GFXFormat.BC1:
          case exports.GFXFormat.BC1_SRGB:
          case exports.GFXFormat.BC2:
          case exports.GFXFormat.BC2_SRGB:
          case exports.GFXFormat.BC3:
          case exports.GFXFormat.BC3_SRGB:
          case exports.GFXFormat.BC4:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.BC4_SNORM:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.BC5:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.BC5_SNORM:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.BC6H_SF16:
          case exports.GFXFormat.BC6H_UF16:
            return WebGL2RenderingContext.FLOAT;

          case exports.GFXFormat.BC7:
          case exports.GFXFormat.BC7_SRGB:
          case exports.GFXFormat.ETC_RGB8:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.ETC2_RGB8_A1:
          case exports.GFXFormat.ETC2_SRGB8_A1:
          case exports.GFXFormat.ETC2_RGB8:
          case exports.GFXFormat.ETC2_SRGB8:
          case exports.GFXFormat.EAC_R11:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.EAC_R11SN:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.EAC_RG11:
            return WebGL2RenderingContext.UNSIGNED_BYTE;

          case exports.GFXFormat.EAC_RG11SN:
            return WebGL2RenderingContext.BYTE;

          case exports.GFXFormat.PVRTC_RGB2:
          case exports.GFXFormat.PVRTC_RGBA2:
          case exports.GFXFormat.PVRTC_RGB4:
          case exports.GFXFormat.PVRTC_RGBA4:
          case exports.GFXFormat.PVRTC2_2BPP:
          case exports.GFXFormat.PVRTC2_4BPP:
          default:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
        }
    }
    function GFXFormatToWebGLInternalFormat$1(format) {
        switch (format) {
          case exports.GFXFormat.A8:
            return WebGL2RenderingContext.ALPHA;

          case exports.GFXFormat.L8:
            return WebGL2RenderingContext.LUMINANCE;

          case exports.GFXFormat.LA8:
            return WebGL2RenderingContext.LUMINANCE_ALPHA;

          case exports.GFXFormat.R8:
            return WebGL2RenderingContext.R8;

          case exports.GFXFormat.R8SN:
            return WebGL2RenderingContext.R8_SNORM;

          case exports.GFXFormat.R8UI:
            return WebGL2RenderingContext.R8UI;

          case exports.GFXFormat.R8I:
            return WebGL2RenderingContext.R8I;

          case exports.GFXFormat.RG8:
            return WebGL2RenderingContext.RG8;

          case exports.GFXFormat.RG8SN:
            return WebGL2RenderingContext.RG8_SNORM;

          case exports.GFXFormat.RG8UI:
            return WebGL2RenderingContext.RG8UI;

          case exports.GFXFormat.RG8I:
            return WebGL2RenderingContext.RG8I;

          case exports.GFXFormat.RGB8:
            return WebGL2RenderingContext.RGB8;

          case exports.GFXFormat.RGB8SN:
            return WebGL2RenderingContext.RGB8_SNORM;

          case exports.GFXFormat.RGB8UI:
            return WebGL2RenderingContext.RGB8UI;

          case exports.GFXFormat.RGB8I:
            return WebGL2RenderingContext.RGB8I;

          case exports.GFXFormat.RGBA8:
            return WebGL2RenderingContext.RGBA8;

          case exports.GFXFormat.RGBA8SN:
            return WebGL2RenderingContext.RGBA8_SNORM;

          case exports.GFXFormat.RGBA8UI:
            return WebGL2RenderingContext.RGBA8UI;

          case exports.GFXFormat.RGBA8I:
            return WebGL2RenderingContext.RGBA8I;

          case exports.GFXFormat.R16I:
            return WebGL2RenderingContext.R16I;

          case exports.GFXFormat.R16UI:
            return WebGL2RenderingContext.R16UI;

          case exports.GFXFormat.R16F:
            return WebGL2RenderingContext.R16F;

          case exports.GFXFormat.RG16I:
            return WebGL2RenderingContext.RG16I;

          case exports.GFXFormat.RG16UI:
            return WebGL2RenderingContext.RG16UI;

          case exports.GFXFormat.RG16F:
            return WebGL2RenderingContext.RG16F;

          case exports.GFXFormat.RGB16I:
            return WebGL2RenderingContext.RGB16I;

          case exports.GFXFormat.RGB16UI:
            return WebGL2RenderingContext.RGB16UI;

          case exports.GFXFormat.RGB16F:
            return WebGL2RenderingContext.RGB16F;

          case exports.GFXFormat.RGBA16I:
            return WebGL2RenderingContext.RGBA16I;

          case exports.GFXFormat.RGBA16UI:
            return WebGL2RenderingContext.RGBA16UI;

          case exports.GFXFormat.RGBA16F:
            return WebGL2RenderingContext.RGBA16F;

          case exports.GFXFormat.R32I:
            return WebGL2RenderingContext.R32I;

          case exports.GFXFormat.R32UI:
            return WebGL2RenderingContext.R32UI;

          case exports.GFXFormat.R32F:
            return WebGL2RenderingContext.R32F;

          case exports.GFXFormat.RG32I:
            return WebGL2RenderingContext.RG32I;

          case exports.GFXFormat.RG32UI:
            return WebGL2RenderingContext.RG32UI;

          case exports.GFXFormat.RG32F:
            return WebGL2RenderingContext.RG32F;

          case exports.GFXFormat.RGB32I:
            return WebGL2RenderingContext.RGB32I;

          case exports.GFXFormat.RGB32UI:
            return WebGL2RenderingContext.RGB32UI;

          case exports.GFXFormat.RGB32F:
            return WebGL2RenderingContext.RGB32F;

          case exports.GFXFormat.RGBA32I:
            return WebGL2RenderingContext.RGBA32I;

          case exports.GFXFormat.RGBA32UI:
            return WebGL2RenderingContext.RGBA32UI;

          case exports.GFXFormat.RGBA32F:
            return WebGL2RenderingContext.RGBA32F;

          case exports.GFXFormat.R5G6B5:
            return WebGL2RenderingContext.RGB565;

          case exports.GFXFormat.RGB5A1:
            return WebGL2RenderingContext.RGB5_A1;

          case exports.GFXFormat.RGBA4:
            return WebGL2RenderingContext.RGBA4;

          case exports.GFXFormat.RGB10A2:
            return WebGL2RenderingContext.RGB10_A2;

          case exports.GFXFormat.RGB10A2UI:
            return WebGL2RenderingContext.RGB10_A2UI;

          case exports.GFXFormat.R11G11B10F:
            return WebGL2RenderingContext.R11F_G11F_B10F;

          case exports.GFXFormat.D16:
            return WebGL2RenderingContext.DEPTH_COMPONENT16;

          case exports.GFXFormat.D16S8:
            return WebGL2RenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D24:
            return WebGL2RenderingContext.DEPTH_COMPONENT24;

          case exports.GFXFormat.D24S8:
            return WebGL2RenderingContext.DEPTH24_STENCIL8;

          case exports.GFXFormat.D32F:
            return WebGL2RenderingContext.DEPTH_COMPONENT32F;

          case exports.GFXFormat.D32F_S8:
            return WebGL2RenderingContext.DEPTH32F_STENCIL8;

          case exports.GFXFormat.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case exports.GFXFormat.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case exports.GFXFormat.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case exports.GFXFormat.ETC2_RGB8:
            return WebGLEXT.COMPRESSED_RGB8_ETC2;

          case exports.GFXFormat.ETC2_SRGB8:
            return WebGLEXT.COMPRESSED_SRGB8_ETC2;

          case exports.GFXFormat.ETC2_RGB8_A1:
            return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case exports.GFXFormat.ETC2_SRGB8_A1:
            return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case exports.GFXFormat.ETC2_RGBA8:
            return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

          case exports.GFXFormat.ETC2_SRGB8_A8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case exports.GFXFormat.EAC_R11:
            return WebGLEXT.COMPRESSED_R11_EAC;

          case exports.GFXFormat.EAC_R11SN:
            return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

          case exports.GFXFormat.EAC_RG11:
            return WebGLEXT.COMPRESSED_RG11_EAC;

          case exports.GFXFormat.EAC_RG11SN:
            return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

          case exports.GFXFormat.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          default:
            return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
            WebGL2RenderingContext.RGBA;
        }
    }
    function GFXFormatToWebGLFormat$1(format) {
        switch (format) {
          case exports.GFXFormat.A8:
            return WebGL2RenderingContext.ALPHA;

          case exports.GFXFormat.L8:
            return WebGL2RenderingContext.LUMINANCE;

          case exports.GFXFormat.LA8:
            return WebGL2RenderingContext.LUMINANCE_ALPHA;

          case exports.GFXFormat.R8:
          case exports.GFXFormat.R8SN:
            return WebGL2RenderingContext.RED;

          case exports.GFXFormat.R8UI:
          case exports.GFXFormat.R8I:
            return WebGL2RenderingContext.RED;

          case exports.GFXFormat.RG8:
          case exports.GFXFormat.RG8SN:
          case exports.GFXFormat.RG8UI:
          case exports.GFXFormat.RG8I:
            return WebGL2RenderingContext.RG;

          case exports.GFXFormat.RGB8:
          case exports.GFXFormat.RGB8SN:
          case exports.GFXFormat.RGB8UI:
          case exports.GFXFormat.RGB8I:
            return WebGL2RenderingContext.RGB;

          case exports.GFXFormat.RGBA8:
          case exports.GFXFormat.RGBA8SN:
          case exports.GFXFormat.RGBA8UI:
          case exports.GFXFormat.RGBA8I:
            return WebGL2RenderingContext.RGBA;

          case exports.GFXFormat.R16UI:
          case exports.GFXFormat.R16I:
          case exports.GFXFormat.R16F:
            return WebGL2RenderingContext.RED;

          case exports.GFXFormat.RG16UI:
          case exports.GFXFormat.RG16I:
          case exports.GFXFormat.RG16F:
            return WebGL2RenderingContext.RG;

          case exports.GFXFormat.RGB16UI:
          case exports.GFXFormat.RGB16I:
          case exports.GFXFormat.RGB16F:
            return WebGL2RenderingContext.RGB;

          case exports.GFXFormat.RGBA16UI:
          case exports.GFXFormat.RGBA16I:
          case exports.GFXFormat.RGBA16F:
            return WebGL2RenderingContext.RGBA;

          case exports.GFXFormat.R32UI:
          case exports.GFXFormat.R32I:
          case exports.GFXFormat.R32F:
            return WebGL2RenderingContext.RED;

          case exports.GFXFormat.RG32UI:
          case exports.GFXFormat.RG32I:
          case exports.GFXFormat.RG32F:
            return WebGL2RenderingContext.RG;

          case exports.GFXFormat.RGB32UI:
          case exports.GFXFormat.RGB32I:
          case exports.GFXFormat.RGB32F:
            return WebGL2RenderingContext.RGB;

          case exports.GFXFormat.RGBA32UI:
          case exports.GFXFormat.RGBA32I:
          case exports.GFXFormat.RGBA32F:
          case exports.GFXFormat.RGB10A2:
            return WebGL2RenderingContext.RGBA;

          case exports.GFXFormat.R11G11B10F:
          case exports.GFXFormat.R5G6B5:
            return WebGL2RenderingContext.RGB;

          case exports.GFXFormat.RGB5A1:
          case exports.GFXFormat.RGBA4:
            return WebGL2RenderingContext.RGBA;

          case exports.GFXFormat.D16:
            return WebGL2RenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D16S8:
            return WebGL2RenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D24:
            return WebGL2RenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D24S8:
            return WebGL2RenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.D32F:
            return WebGL2RenderingContext.DEPTH_COMPONENT;

          case exports.GFXFormat.D32F_S8:
            return WebGL2RenderingContext.DEPTH_STENCIL;

          case exports.GFXFormat.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case exports.GFXFormat.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case exports.GFXFormat.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case exports.GFXFormat.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case exports.GFXFormat.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case exports.GFXFormat.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case exports.GFXFormat.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          default:
            return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
            WebGL2RenderingContext.RGBA;
        }
    }
    function GFXTypeToWebGLType$1(type) {
        switch (type) {
          case GFXType.BOOL:
            return WebGL2RenderingContext.BOOL;

          case GFXType.BOOL2:
            return WebGL2RenderingContext.BOOL_VEC2;

          case GFXType.BOOL3:
            return WebGL2RenderingContext.BOOL_VEC3;

          case GFXType.BOOL4:
            return WebGL2RenderingContext.BOOL_VEC4;

          case GFXType.INT:
            return WebGL2RenderingContext.INT;

          case GFXType.INT2:
            return WebGL2RenderingContext.INT_VEC2;

          case GFXType.INT3:
            return WebGL2RenderingContext.INT_VEC3;

          case GFXType.INT4:
            return WebGL2RenderingContext.INT_VEC4;

          case GFXType.UINT:
            return WebGL2RenderingContext.UNSIGNED_INT;

          case GFXType.FLOAT:
            return WebGL2RenderingContext.FLOAT;

          case GFXType.FLOAT2:
            return WebGL2RenderingContext.FLOAT_VEC2;

          case GFXType.FLOAT3:
            return WebGL2RenderingContext.FLOAT_VEC3;

          case GFXType.FLOAT4:
            return WebGL2RenderingContext.FLOAT_VEC4;

          case GFXType.MAT2:
            return WebGL2RenderingContext.FLOAT_MAT2;

          case GFXType.MAT2X3:
            return WebGL2RenderingContext.FLOAT_MAT2x3;

          case GFXType.MAT2X4:
            return WebGL2RenderingContext.FLOAT_MAT2x4;

          case GFXType.MAT3X2:
            return WebGL2RenderingContext.FLOAT_MAT3x2;

          case GFXType.MAT3:
            return WebGL2RenderingContext.FLOAT_MAT3;

          case GFXType.MAT3X4:
            return WebGL2RenderingContext.FLOAT_MAT3x4;

          case GFXType.MAT4X2:
            return WebGL2RenderingContext.FLOAT_MAT4x2;

          case GFXType.MAT4X3:
            return WebGL2RenderingContext.FLOAT_MAT4x3;

          case GFXType.MAT4:
            return WebGL2RenderingContext.FLOAT_MAT4;

          case GFXType.SAMPLER2D:
            return WebGL2RenderingContext.SAMPLER_2D;

          case GFXType.SAMPLER2D_ARRAY:
            return WebGL2RenderingContext.SAMPLER_2D_ARRAY;

          case GFXType.SAMPLER3D:
            return WebGL2RenderingContext.SAMPLER_3D;

          case GFXType.SAMPLER_CUBE:
            return WebGL2RenderingContext.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GL type failed."), GFXType.UNKNOWN;
        }
    }
    function WebGLTypeToGFXType$1(glType) {
        switch (glType) {
          case WebGL2RenderingContext.BOOL:
            return GFXType.BOOL;

          case WebGL2RenderingContext.BOOL_VEC2:
            return GFXType.BOOL2;

          case WebGL2RenderingContext.BOOL_VEC3:
            return GFXType.BOOL3;

          case WebGL2RenderingContext.BOOL_VEC4:
            return GFXType.BOOL4;

          case WebGL2RenderingContext.INT:
            return GFXType.INT;

          case WebGL2RenderingContext.INT_VEC2:
            return GFXType.INT2;

          case WebGL2RenderingContext.INT_VEC3:
            return GFXType.INT3;

          case WebGL2RenderingContext.INT_VEC4:
            return GFXType.INT4;

          case WebGL2RenderingContext.UNSIGNED_INT:
            return GFXType.UINT;

          case WebGL2RenderingContext.UNSIGNED_INT_VEC2:
            return GFXType.UINT2;

          case WebGL2RenderingContext.UNSIGNED_INT_VEC3:
            return GFXType.UINT3;

          case WebGL2RenderingContext.UNSIGNED_INT_VEC4:
            return GFXType.UINT4;

          case WebGL2RenderingContext.UNSIGNED_INT:
            return GFXType.UINT;

          case WebGL2RenderingContext.FLOAT:
            return GFXType.FLOAT;

          case WebGL2RenderingContext.FLOAT_VEC2:
            return GFXType.FLOAT2;

          case WebGL2RenderingContext.FLOAT_VEC3:
            return GFXType.FLOAT3;

          case WebGL2RenderingContext.FLOAT_VEC4:
            return GFXType.FLOAT4;

          case WebGL2RenderingContext.FLOAT_MAT2:
            return GFXType.MAT2;

          case WebGL2RenderingContext.FLOAT_MAT2x3:
            return GFXType.MAT2X3;

          case WebGL2RenderingContext.FLOAT_MAT2x4:
            return GFXType.MAT2X4;

          case WebGL2RenderingContext.FLOAT_MAT3x2:
            return GFXType.MAT3X2;

          case WebGL2RenderingContext.FLOAT_MAT3:
            return GFXType.MAT3;

          case WebGL2RenderingContext.FLOAT_MAT3x4:
            return GFXType.MAT3X4;

          case WebGL2RenderingContext.FLOAT_MAT4x2:
            return GFXType.MAT4X2;

          case WebGL2RenderingContext.FLOAT_MAT4x3:
            return GFXType.MAT4X3;

          case WebGL2RenderingContext.FLOAT_MAT4:
            return GFXType.MAT4;

          case WebGL2RenderingContext.SAMPLER_2D:
            return GFXType.SAMPLER2D;

          case WebGL2RenderingContext.SAMPLER_2D_ARRAY:
            return GFXType.SAMPLER2D_ARRAY;

          case WebGL2RenderingContext.SAMPLER_3D:
            return GFXType.SAMPLER3D;

          case WebGL2RenderingContext.SAMPLER_CUBE:
            return GFXType.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GFXType failed."), GFXType.UNKNOWN;
        }
    }
    function WebGLGetTypeSize$1(glType) {
        switch (glType) {
          case WebGL2RenderingContext.BOOL:
            return 4;

          case WebGL2RenderingContext.BOOL_VEC2:
            return 8;

          case WebGL2RenderingContext.BOOL_VEC3:
            return 12;

          case WebGL2RenderingContext.BOOL_VEC4:
            return 16;

          case WebGL2RenderingContext.INT:
            return 4;

          case WebGL2RenderingContext.INT_VEC2:
            return 8;

          case WebGL2RenderingContext.INT_VEC3:
            return 12;

          case WebGL2RenderingContext.INT_VEC4:
            return 16;

          case WebGL2RenderingContext.UNSIGNED_INT:
            return 4;

          case WebGL2RenderingContext.UNSIGNED_INT_VEC2:
            return 8;

          case WebGL2RenderingContext.UNSIGNED_INT_VEC3:
            return 12;

          case WebGL2RenderingContext.UNSIGNED_INT_VEC4:
            return 16;

          case WebGL2RenderingContext.FLOAT:
            return 4;

          case WebGL2RenderingContext.FLOAT_VEC2:
            return 8;

          case WebGL2RenderingContext.FLOAT_VEC3:
            return 12;

          case WebGL2RenderingContext.FLOAT_VEC4:
          case WebGL2RenderingContext.FLOAT_MAT2:
            return 16;

          case WebGL2RenderingContext.FLOAT_MAT2x3:
            return 24;

          case WebGL2RenderingContext.FLOAT_MAT2x4:
            return 32;

          case WebGL2RenderingContext.FLOAT_MAT3x2:
            return 24;

          case WebGL2RenderingContext.FLOAT_MAT3:
            return 36;

          case WebGL2RenderingContext.FLOAT_MAT3x4:
            return 48;

          case WebGL2RenderingContext.FLOAT_MAT4x2:
            return 32;

          case WebGL2RenderingContext.FLOAT_MAT4x3:
            return 48;

          case WebGL2RenderingContext.FLOAT_MAT4:
            return 64;

          case WebGL2RenderingContext.SAMPLER_2D:
          case WebGL2RenderingContext.SAMPLER_2D_ARRAY:
          case WebGL2RenderingContext.SAMPLER_2D_ARRAY_SHADOW:
          case WebGL2RenderingContext.SAMPLER_3D:
          case WebGL2RenderingContext.SAMPLER_CUBE:
          case WebGL2RenderingContext.INT_SAMPLER_2D:
          case WebGL2RenderingContext.INT_SAMPLER_2D_ARRAY:
          case WebGL2RenderingContext.INT_SAMPLER_3D:
          case WebGL2RenderingContext.INT_SAMPLER_CUBE:
          case WebGL2RenderingContext.UNSIGNED_INT_SAMPLER_2D:
          case WebGL2RenderingContext.UNSIGNED_INT_SAMPLER_2D_ARRAY:
          case WebGL2RenderingContext.UNSIGNED_INT_SAMPLER_3D:
          case WebGL2RenderingContext.UNSIGNED_INT_SAMPLER_CUBE:
            return 4;

          default:
            return console.error("Unsupported GLType, get type failed."), 0;
        }
    }
    function WebGLGetComponentCount$1(glType) {
        switch (glType) {
          case WebGL2RenderingContext.FLOAT_MAT2:
          case WebGL2RenderingContext.FLOAT_MAT2x3:
          case WebGL2RenderingContext.FLOAT_MAT2x4:
            return 2;

          case WebGL2RenderingContext.FLOAT_MAT3x2:
          case WebGL2RenderingContext.FLOAT_MAT3:
          case WebGL2RenderingContext.FLOAT_MAT3x4:
            return 3;

          case WebGL2RenderingContext.FLOAT_MAT4x2:
          case WebGL2RenderingContext.FLOAT_MAT4x3:
          case WebGL2RenderingContext.FLOAT_MAT4:
            return 4;

          default:
            return 1;
        }
    }
    var WebGL2Cmd, WebGLCmpFuncs$1 = [ WebGLRenderingContext.NEVER, WebGLRenderingContext.LESS, WebGLRenderingContext.EQUAL, WebGLRenderingContext.LEQUAL, WebGLRenderingContext.GREATER, WebGLRenderingContext.NOTEQUAL, WebGLRenderingContext.GEQUAL, WebGLRenderingContext.ALWAYS ], WebGLStencilOps$1 = [ WebGLRenderingContext.ZERO, WebGLRenderingContext.KEEP, WebGLRenderingContext.REPLACE, WebGLRenderingContext.INCR, WebGLRenderingContext.DECR, WebGLRenderingContext.INVERT, WebGLRenderingContext.INCR_WRAP, WebGLRenderingContext.DECR_WRAP ], WebGLBlendOps$1 = [ WebGLRenderingContext.FUNC_ADD, WebGLRenderingContext.FUNC_SUBTRACT, WebGLRenderingContext.FUNC_REVERSE_SUBTRACT, WebGLRenderingContext.FUNC_ADD, WebGLRenderingContext.FUNC_ADD ], WebGLBlendFactors$1 = [ WebGLRenderingContext.ZERO, WebGLRenderingContext.ONE, WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.DST_ALPHA, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA, WebGLRenderingContext.ONE_MINUS_DST_ALPHA, WebGLRenderingContext.SRC_COLOR, WebGLRenderingContext.DST_COLOR, WebGLRenderingContext.ONE_MINUS_SRC_COLOR, WebGLRenderingContext.ONE_MINUS_DST_COLOR, WebGLRenderingContext.SRC_ALPHA_SATURATE, WebGLRenderingContext.CONSTANT_COLOR, WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR, WebGLRenderingContext.CONSTANT_ALPHA, WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA ];
    !function(WebGL2Cmd) {
        WebGL2Cmd[WebGL2Cmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGL2Cmd[WebGL2Cmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
        WebGL2Cmd[WebGL2Cmd.BIND_STATES = 2] = "BIND_STATES", WebGL2Cmd[WebGL2Cmd.DRAW = 3] = "DRAW", 
        WebGL2Cmd[WebGL2Cmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGL2Cmd[WebGL2Cmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
        WebGL2Cmd[WebGL2Cmd.COUNT = 6] = "COUNT";
    }(WebGL2Cmd || (WebGL2Cmd = {}));
    var WebGL2CmdObject = function WebGL2CmdObject(type) {
        _classCallCheck(this, WebGL2CmdObject), this.cmdType = void 0, this.refCount = 0, 
        this.cmdType = type;
    }, WebGL2CmdBeginRenderPass = function(_WebGL2CmdObject) {
        function WebGL2CmdBeginRenderPass() {
            var _this;
            return _classCallCheck(this, WebGL2CmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdBeginRenderPass).call(this, WebGL2Cmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
            _this.renderArea = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }, _this.clearFlag = GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
            _this.clearStencil = 0, _this;
        }
        return _inherits(WebGL2CmdBeginRenderPass, WebGL2CmdObject), _createClass(WebGL2CmdBeginRenderPass, [ {
            key: "clear",
            value: function clear() {
                this.gpuFramebuffer = null, this.clearColors = [];
            }
        } ]), WebGL2CmdBeginRenderPass;
    }(), WebGL2CmdBindStates = function(_WebGL2CmdObject2) {
        function WebGL2CmdBindStates() {
            var _this2;
            return _classCallCheck(this, WebGL2CmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdBindStates).call(this, WebGL2Cmd.BIND_STATES))).gpuPipelineState = null, 
            _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
            _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
            _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
            _this2;
        }
        return _inherits(WebGL2CmdBindStates, WebGL2CmdObject), _createClass(WebGL2CmdBindStates, [ {
            key: "clear",
            value: function clear() {
                this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
                this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
                this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
                this.stencilCompareMask = null;
            }
        } ]), WebGL2CmdBindStates;
    }(), WebGL2CmdDraw = function(_WebGL2CmdObject3) {
        function WebGL2CmdDraw() {
            var _this3;
            return _classCallCheck(this, WebGL2CmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdDraw).call(this, WebGL2Cmd.DRAW))).drawInfo = {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            }, _this3;
        }
        return _inherits(WebGL2CmdDraw, WebGL2CmdObject), _createClass(WebGL2CmdDraw, [ {
            key: "clear",
            value: function clear() {}
        } ]), WebGL2CmdDraw;
    }(), WebGL2CmdUpdateBuffer = function(_WebGL2CmdObject4) {
        function WebGL2CmdUpdateBuffer() {
            var _this4;
            return _classCallCheck(this, WebGL2CmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdUpdateBuffer).call(this, WebGL2Cmd.UPDATE_BUFFER))).gpuBuffer = null, 
            _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
        }
        return _inherits(WebGL2CmdUpdateBuffer, WebGL2CmdObject), _createClass(WebGL2CmdUpdateBuffer, [ {
            key: "clear",
            value: function clear() {
                this.gpuBuffer = null, this.buffer = null;
            }
        } ]), WebGL2CmdUpdateBuffer;
    }(), WebGL2CmdCopyBufferToTexture = function(_WebGL2CmdObject5) {
        function WebGL2CmdCopyBufferToTexture() {
            var _this5;
            return _classCallCheck(this, WebGL2CmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdCopyBufferToTexture).call(this, WebGL2Cmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
            _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
        }
        return _inherits(WebGL2CmdCopyBufferToTexture, WebGL2CmdObject), _createClass(WebGL2CmdCopyBufferToTexture, [ {
            key: "clear",
            value: function clear() {
                this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions = [];
            }
        } ]), WebGL2CmdCopyBufferToTexture;
    }(), WebGL2CmdPackage = function() {
        function WebGL2CmdPackage() {
            _classCallCheck(this, WebGL2CmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
            this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
            this.copyBufferToTextureCmds = new CachedArray(1);
        }
        return _createClass(WebGL2CmdPackage, [ {
            key: "clearCmds",
            value: function clearCmds(allocator) {
                this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
                this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
                this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
                this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
                this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
                this.copyBufferToTextureCmds.clear()), this.cmds.clear();
            }
        } ]), WebGL2CmdPackage;
    }();
    function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
            var buff = buffer, gl = device.gl, cache = device.stateCache;
            switch (gpuBuffer.glTarget) {
              case WebGL2RenderingContext.ARRAY_BUFFER:
                cache.glVAO && (gl.bindVertexArray(null), cache.glVAO = null), cache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                cache.glArrayBuffer = gpuBuffer.glBuffer), size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                break;

              case WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER:
                cache.glVAO && (gl.bindVertexArray(null), cache.glVAO = null), cache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                cache.glElementArrayBuffer = gpuBuffer.glBuffer), size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                break;

              case WebGL2RenderingContext.UNIFORM_BUFFER:
                var buf;
                cache.glUniformBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                cache.glUniformBuffer = gpuBuffer.glBuffer), size === (buf = buffer instanceof Float32Array ? buffer : new Float32Array(buffer, 0, size / 4)).byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buf) : gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                break;

              default:
                return void console.error("Unsupported GFXBufferType, update buffer failed.");
            }
        }
    }
    var cmdIds$1 = new Array(WebGL2Cmd.COUNT);
    function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
        var gl = device.gl, cache = device.stateCache;
        cmdIds$1.fill(0);
        for (var gpuPipelineState = null, gpuShader = null, gpuInputAssembler = null, glPrimitive = WebGL2RenderingContext.TRIANGLES, i = 0; i < cmdPackage.cmds.length; ++i) {
            var cmd = cmdPackage.cmds.array[i], cmdId = cmdIds$1[cmd]++;
            switch (cmd) {
              case WebGL2Cmd.BEGIN_RENDER_PASS:
                var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
                if (cmd0.gpuFramebuffer) {
                    cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                    cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                    cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                    cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                    cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                    cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                    cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                    for (var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, invalidateAttachments = [], j = 0; j < cmd0.clearColors.length; ++j) {
                        var colorAttachment = curGPURenderPass.colorAttachments[j];
                        if (colorAttachment.format !== exports.GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                          case GFXLoadOp.LOAD:
                            break;

                          case GFXLoadOp.CLEAR:
                            if (cmd0.clearFlag & GFXClearFlag.COLOR) if (cache.bs.targets[0].blendColorMask !== GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0), 
                            cmd0.gpuFramebuffer.isOffscreen) _f32v4[0] = cmd0.clearColors[j].r, _f32v4[1] = cmd0.clearColors[j].g, 
                            _f32v4[2] = cmd0.clearColors[j].b, _f32v4[3] = cmd0.clearColors[j].a, gl.clearBufferfv(gl.COLOR, j, _f32v4); else {
                                var clearColor = cmd0.clearColors[0];
                                gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= WebGL2RenderingContext.COLOR_BUFFER_BIT;
                            }
                            break;

                          case GFXLoadOp.DISCARD:
                            invalidateAttachments.push(WebGL2RenderingContext.COLOR_ATTACHMENT0 + j);
                        }
                    }
                    if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== exports.GFXFormat.UNKNOWN) {
                        switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                          case GFXLoadOp.LOAD:
                            break;

                          case GFXLoadOp.CLEAR:
                            cmd0.clearFlag & GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                            gl.clearDepth(cmd0.clearDepth), clears |= WebGL2RenderingContext.DEPTH_BUFFER_BIT);
                            break;

                          case GFXLoadOp.DISCARD:
                            invalidateAttachments.push(WebGL2RenderingContext.DEPTH_ATTACHMENT);
                        }
                        if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                          case GFXLoadOp.LOAD:
                            break;

                          case GFXLoadOp.CLEAR:
                            cmd0.clearFlag & GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(WebGL2RenderingContext.FRONT, 4294967295), 
                            cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(WebGL2RenderingContext.BACK, 4294967295), 
                            gl.clearStencil(cmd0.clearStencil), clears |= WebGL2RenderingContext.STENCIL_BUFFER_BIT);
                            break;

                          case GFXLoadOp.DISCARD:
                            invalidateAttachments.push(WebGL2RenderingContext.STENCIL_ATTACHMENT);
                        }
                    }
                    if (invalidateAttachments.length && gl.invalidateFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, invalidateAttachments), 
                    clears && gl.clear(clears), clears & WebGL2RenderingContext.COLOR_BUFFER_BIT) {
                        var colorMask = cache.bs.targets[0].blendColorMask;
                        if (colorMask !== GFXColorMask.ALL) {
                            var r = (colorMask & GFXColorMask.R) !== GFXColorMask.NONE, g = (colorMask & GFXColorMask.G) !== GFXColorMask.NONE, b = (colorMask & GFXColorMask.B) !== GFXColorMask.NONE, a = (colorMask & GFXColorMask.A) !== GFXColorMask.NONE;
                            gl.colorMask(r, g, b, a);
                        }
                    }
                    clears & WebGL2RenderingContext.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), 
                    clears & WebGL2RenderingContext.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(WebGL2RenderingContext.FRONT, 0), 
                    cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(WebGL2RenderingContext.BACK, 0));
                }
                break;

              case WebGL2Cmd.END_RENDER_PASS:
                break;

              case WebGL2Cmd.BIND_STATES:
                var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                if (cmd2.gpuPipelineState) {
                    if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                    cmd2.gpuPipelineState.gpuShader) {
                        var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                        cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram), 
                        gpuShader = cmd2.gpuPipelineState.gpuShader;
                    }
                    var rs = cmd2.gpuPipelineState.rs;
                    if (rs) {
                        if (cache.rs.cullMode !== rs.cullMode) {
                            switch (rs.cullMode) {
                              case GFXCullMode.NONE:
                                gl.disable(WebGL2RenderingContext.CULL_FACE);
                                break;

                              case GFXCullMode.FRONT:
                                gl.enable(WebGL2RenderingContext.CULL_FACE), gl.cullFace(WebGL2RenderingContext.FRONT);
                                break;

                              case GFXCullMode.BACK:
                                gl.enable(WebGL2RenderingContext.CULL_FACE), gl.cullFace(WebGL2RenderingContext.BACK);
                            }
                            device.stateCache.rs.cullMode = rs.cullMode;
                        }
                        device.stateCache.rs.isFrontFaceCCW !== rs.isFrontFaceCCW && (gl.frontFace(rs.isFrontFaceCCW ? WebGL2RenderingContext.CCW : WebGL2RenderingContext.CW), 
                        device.stateCache.rs.isFrontFaceCCW = rs.isFrontFaceCCW), device.stateCache.rs.depthBias === rs.depthBias && device.stateCache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                        device.stateCache.rs.depthBias = rs.depthBias, device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop), 
                        device.stateCache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                        device.stateCache.rs.lineWidth = rs.lineWidth);
                    }
                    var dss = cmd2.gpuPipelineState.dss;
                    dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(WebGL2RenderingContext.DEPTH_TEST) : gl.disable(WebGL2RenderingContext.DEPTH_TEST), 
                    cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                    cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]), 
                    cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(WebGL2RenderingContext.STENCIL_TEST) : gl.disable(WebGL2RenderingContext.STENCIL_TEST), 
                    cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                    cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(WebGL2RenderingContext.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                    cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(WebGL2RenderingContext.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]), 
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(WebGL2RenderingContext.FRONT, dss.stencilWriteMaskFront), 
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(WebGL2RenderingContext.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                    cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(WebGL2RenderingContext.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]), 
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(WebGL2RenderingContext.BACK, dss.stencilWriteMaskBack), 
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                    var bs = cmd2.gpuPipelineState.bs;
                    if (bs) {
                        cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(WebGL2RenderingContext.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(WebGL2RenderingContext.SAMPLE_ALPHA_TO_COVERAGE), 
                        cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                        cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                        cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                        var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                        target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(WebGL2RenderingContext.BLEND) : gl.disable(WebGL2RenderingContext.BLEND), 
                        target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]), 
                        target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                        target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]), 
                        target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                        target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                        target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & GFXColorMask.R) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.G) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.B) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.A) !== GFXColorMask.NONE), 
                        target0Cache.blendColorMask = target0.blendColorMask);
                    }
                }
                if (cmd2.gpuBindingLayout && gpuShader) {
                    var _iterator8 = cmd2.gpuBindingLayout.gpuBindings, _isArray8 = Array.isArray(_iterator8), _i17 = 0;
                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray8) {
                            if (_i17 >= _iterator8.length) break;
                            _ref8 = _iterator8[_i17++];
                        } else {
                            if ((_i17 = _iterator8.next()).done) break;
                            _ref8 = _i17.value;
                        }
                        var gpuBinding = _ref8;
                        switch (gpuBinding.type) {
                          case GFXBindingType.UNIFORM_BUFFER:
                            if (gpuBinding.gpuBuffer) {
                                var _iterator9 = gpuShader.glBlocks, _isArray9 = Array.isArray(_iterator9), _i18 = 0;
                                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                    var _ref9;
                                    if (_isArray9) {
                                        if (_i18 >= _iterator9.length) break;
                                        _ref9 = _iterator9[_i18++];
                                    } else {
                                        if ((_i18 = _iterator9.next()).done) break;
                                        _ref9 = _i18.value;
                                    }
                                    var glBlock = _ref9;
                                    if (glBlock.binding === gpuBinding.binding) {
                                        cache.glBindUBOs[glBlock.binding] !== gpuBinding.gpuBuffer.glBuffer && (gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.binding, gpuBinding.gpuBuffer.glBuffer), 
                                        cache.glBindUBOs[glBlock.binding] = gpuBinding.gpuBuffer.glBuffer, cache.glUniformBuffer = gpuBinding.gpuBuffer.glBuffer);
                                        break;
                                    }
                                }
                            }
                            break;

                          case GFXBindingType.SAMPLER:
                            if (gpuBinding.gpuSampler) {
                                var glSampler = null, _iterator10 = gpuShader.glSamplers, _isArray10 = Array.isArray(_iterator10), _i19 = 0;
                                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                    var _ref10;
                                    if (_isArray10) {
                                        if (_i19 >= _iterator10.length) break;
                                        _ref10 = _iterator10[_i19++];
                                    } else {
                                        if ((_i19 = _iterator10.next()).done) break;
                                        _ref10 = _i19.value;
                                    }
                                    var sampler = _ref10;
                                    if (sampler.binding === gpuBinding.binding) {
                                        glSampler = sampler;
                                        break;
                                    }
                                }
                                if (glSampler) {
                                    var _iterator11 = glSampler.units, _isArray11 = Array.isArray(_iterator11), _i20 = 0;
                                    for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                                        var _ref11;
                                        if (_isArray11) {
                                            if (_i20 >= _iterator11.length) break;
                                            _ref11 = _iterator11[_i20++];
                                        } else {
                                            if ((_i20 = _iterator11.next()).done) break;
                                            _ref11 = _i20.value;
                                        }
                                        var texUnit = _ref11, glTexUnit = null;
                                        if (gpuBinding.gpuTexView && 0 < gpuBinding.gpuTexView.gpuTexture.size) {
                                            cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), cache.texUnit = texUnit);
                                            var gpuTexture = gpuBinding.gpuTexView.gpuTexture;
                                            switch (glSampler.glType) {
                                              case gl.SAMPLER_2D:
                                                (glTexUnit = cache.glTex2DUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_2D, device.nullTex2D.gpuTexture.glTexture), 
                                                glTexUnit.glTexture = gpuTexture.glTexture);
                                                break;

                                              case gl.SAMPLER_CUBE:
                                                (glTexUnit = cache.glTexCubeUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_CUBE_MAP, device.nullTexCube.gpuTexture.glTexture), 
                                                glTexUnit.glTexture = gpuTexture.glTexture);
                                                break;

                                              default:
                                                console.error("Unsupported GL Texture type.");
                                            }
                                            var gpuSampler = gpuBinding.gpuSampler;
                                            cache.glSamplerUnits[texUnit] !== gpuSampler.glSampler && (gl.bindSampler(texUnit, gpuSampler.glSampler), 
                                            cache.glSamplerUnits[texUnit] = gpuSampler.glSampler);
                                        }
                                    }
                                }
                            } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                        }
                    }
                }
                if (cmd2.gpuInputAssembler && gpuShader && gpuInputAssembler !== cmd2.gpuInputAssembler) {
                    var glVAO = (gpuInputAssembler = cmd2.gpuInputAssembler).glVAOs.get(gpuShader.glProgram);
                    if (glVAO) cache.glVAO !== glVAO && (gl.bindVertexArray(glVAO), cache.glVAO = glVAO); else {
                        var _glVAO = gl.createVertexArray();
                        gpuInputAssembler.glVAOs.set(gpuShader.glProgram, _glVAO), gl.bindVertexArray(_glVAO), 
                        cache.glVAO = _glVAO, gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                        cache.glArrayBuffer = 0;
                        var glAttrib = void (cache.glElementArrayBuffer = 0), _iterator12 = gpuShader.glInputs, _isArray12 = Array.isArray(_iterator12), _i21 = 0;
                        for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                            var _ref12;
                            if (_isArray12) {
                                if (_i21 >= _iterator12.length) break;
                                _ref12 = _iterator12[_i21++];
                            } else {
                                if ((_i21 = _iterator12.next()).done) break;
                                _ref12 = _i21.value;
                            }
                            var glInput = _ref12;
                            glAttrib = null;
                            var _iterator13 = gpuInputAssembler.glAttribs, _isArray13 = Array.isArray(_iterator13), _i22 = 0;
                            for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                                var _ref13;
                                if (_isArray13) {
                                    if (_i22 >= _iterator13.length) break;
                                    _ref13 = _iterator13[_i22++];
                                } else {
                                    if ((_i22 = _iterator13.next()).done) break;
                                    _ref13 = _i22.value;
                                }
                                var attrib = _ref13;
                                if (attrib.name === glInput.name) {
                                    glAttrib = attrib;
                                    break;
                                }
                            }
                            if (glAttrib) {
                                cache.glArrayBuffer !== glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer), 
                                cache.glArrayBuffer = glAttrib.glBuffer);
                                for (var c = 0; c < glAttrib.componentCount; ++c) {
                                    var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                    gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset), 
                                    gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                                }
                            }
                        }
                        var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                        gpuBuffer && cache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer);
                    }
                }
                if (gpuPipelineState) {
                    var _iterator14 = gpuPipelineState.dynamicStates, _isArray14 = Array.isArray(_iterator14), _i23 = 0;
                    for (_iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ;) {
                        var _ref14;
                        if (_isArray14) {
                            if (_i23 >= _iterator14.length) break;
                            _ref14 = _iterator14[_i23++];
                        } else {
                            if ((_i23 = _iterator14.next()).done) break;
                            _ref14 = _i23.value;
                        }
                        switch (_ref14) {
                          case GFXDynamicState.VIEWPORT:
                            cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                            cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                            cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                            break;

                          case GFXDynamicState.SCISSOR:
                            cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                            cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                            cache.scissorRect.height = cmd2.scissor.height));
                            break;

                          case GFXDynamicState.LINE_WIDTH:
                            cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                            cache.rs.lineWidth = cmd2.lineWidth);
                            break;

                          case GFXDynamicState.DEPTH_BIAS:
                            cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                            cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                            break;

                          case GFXDynamicState.BLEND_CONSTANTS:
                            cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                            cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                            cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                            break;

                          case GFXDynamicState.STENCIL_WRITE_MASK:
                            if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                              case GFXStencilFace.FRONT:
                                cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(WebGL2RenderingContext.FRONT, cmd2.stencilWriteMask.writeMask), 
                                cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                                break;

                              case GFXStencilFace.BACK:
                                cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(WebGL2RenderingContext.BACK, cmd2.stencilWriteMask.writeMask), 
                                cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                                break;

                              case GFXStencilFace.ALL:
                                cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                                cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                            }
                            break;

                          case GFXDynamicState.STENCIL_COMPARE_MASK:
                            if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                              case GFXStencilFace.FRONT:
                                cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(WebGL2RenderingContext.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                                break;

                              case GFXStencilFace.BACK:
                                cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(WebGL2RenderingContext.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                                break;

                              case GFXStencilFace.ALL:
                                cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs$1[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                                cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                                cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                            }
                        }
                    }
                }
                break;

              case WebGL2Cmd.DRAW:
                var cmd3 = cmdPackage.drawCmds.array[cmdId];
                if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) {
                    if (gpuInputAssembler.gpuIndirectBuffer) {
                        var _iterator15 = gpuInputAssembler.gpuIndirectBuffer.indirects, _isArray15 = Array.isArray(_iterator15), _i24 = 0;
                        for (_iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ;) {
                            var _ref15;
                            if (_isArray15) {
                                if (_i24 >= _iterator15.length) break;
                                _ref15 = _iterator15[_i24++];
                            } else {
                                if ((_i24 = _iterator15.next()).done) break;
                                _ref15 = _i24.value;
                            }
                            var drawInfo = _ref15, _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                            if (_gpuBuffer2 && -1 < drawInfo.indexCount) {
                                var _offset = drawInfo.firstIndex * _gpuBuffer2.stride;
                                gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                            } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                        }
                    }
                } else {
                    var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    if (_gpuBuffer && 0 < cmd3.drawInfo.indexCount) {
                        var offset = cmd3.drawInfo.firstIndex * _gpuBuffer.stride;
                        gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                    } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
                }
                break;

              case WebGL2Cmd.UPDATE_BUFFER:
                var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;

              case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
                var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGL2CmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
            }
        }
    }
    function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        var gl = device.gl, m = 0, n = 0, w = 1, h = 1, f = 0, fmtInfo = GFXFormatInfos[gpuTexture.format], isCompressed = fmtInfo.isCompressed;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
            glTexUnit.glTexture = gpuTexture.glTexture);
            var _iterator18 = regions, _isArray18 = Array.isArray(_iterator18), _i27 = 0;
            for (_iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator](); ;) {
                var _ref18;
                if (_isArray18) {
                    if (_i27 >= _iterator18.length) break;
                    _ref18 = _iterator18[_i27++];
                } else {
                    if ((_i27 = _iterator18.next()).done) break;
                    _ref18 = _i27.value;
                }
                var region = _ref18;
                for (n = 0, w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                    var pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                    isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                    w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                }
            }
            break;

          case gl.TEXTURE_CUBE_MAP:
            var _glTexUnit4 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
            _glTexUnit4.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
            _glTexUnit4.glTexture = gpuTexture.glTexture);
            var _iterator19 = regions, _isArray19 = Array.isArray(_iterator19), _i28 = 0;
            for (_iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator](); ;) {
                var _ref19;
                if (_isArray19) {
                    if (_i28 >= _iterator19.length) break;
                    _ref19 = _iterator19[_i28++];
                } else {
                    if ((_i28 = _iterator19.next()).done) break;
                    _ref19 = _i28.value;
                }
                var _region2 = _ref19;
                n = 0;
                var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
                for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                    w = _region2.texExtent.width, h = _region2.texExtent.height;
                    var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                    for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                        var _pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                        isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                        w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                    }
                }
            }
            break;

          default:
            console.error("Unsupported GL texture type, copy buffer to texture failed.");
        }
        gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
    }
    var WebGL2GFXBuffer = function(_GFXBuffer) {
        function WebGL2GFXBuffer(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXBuffer).call(this, device)))._gpuBuffer = null, 
            _this._indirectBuffer = null, _this;
        }
        return _inherits(WebGL2GFXBuffer, GFXBuffer), _createClass(WebGL2GFXBuffer, [ {
            key: "gpuBuffer",
            get: function get() {
                return this._gpuBuffer;
            }
        } ]), _createClass(WebGL2GFXBuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
                this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
                this._usage & GFXBufferUsageBit.INDIRECT && (this._indirectBuffer = {
                    drawInfos: []
                }), this._gpuBuffer = {
                    usage: info.usage,
                    memUsage: info.memUsage,
                    size: info.size,
                    stride: this._stride,
                    buffer: null,
                    vf32: null,
                    indirects: [],
                    glTarget: 0,
                    glBuffer: null
                }, info.usage & GFXBufferUsageBit.INDIRECT && (this._gpuBuffer.indirects = this._indirectBuffer.drawInfos), 
                function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? WebGL2RenderingContext.DYNAMIC_DRAW : WebGL2RenderingContext.STATIC_DRAW;
                    if (gpuBuffer.usage & GFXBufferUsageBit.VERTEX) {
                        gpuBuffer.glTarget = WebGL2RenderingContext.ARRAY_BUFFER;
                        var glBuffer = gl.createBuffer();
                        glBuffer && (gpuBuffer.glBuffer = glBuffer, 0 < gpuBuffer.size && (cache.glVAO && (gl.bindVertexArray(null), 
                        cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                    } else if (gpuBuffer.usage & GFXBufferUsageBit.INDEX) {
                        gpuBuffer.glTarget = WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER;
                        var _glBuffer = gl.createBuffer();
                        _glBuffer && (gpuBuffer.glBuffer = _glBuffer, 0 < gpuBuffer.size && (cache.glVAO && (gl.bindVertexArray(null), 
                        cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                    } else if (gpuBuffer.usage & GFXBufferUsageBit.UNIFORM) {
                        gpuBuffer.glTarget = WebGL2RenderingContext.UNIFORM_BUFFER;
                        var _glBuffer2 = gl.createBuffer();
                        _glBuffer2 && 0 < gpuBuffer.size && (gpuBuffer.glBuffer = _glBuffer2, device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                        device.stateCache.glUniformBuffer = gpuBuffer.glBuffer), gl.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, gpuBuffer.size, glUsage), 
                        gl.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, null), device.stateCache.glUniformBuffer = null);
                    } else gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = WebGL2RenderingContext.NONE;
                }(this._device, this._gpuBuffer), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuBuffer && (!function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
                    gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
                }(this._device, this._gpuBuffer), this._gpuBuffer = null), this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(size) {
                this._size = size, this._count = this._size / this._stride, this._gpuBuffer && (this._gpuBuffer.size = this._size, 
                0 < this._size && function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? WebGL2RenderingContext.DYNAMIC_DRAW : WebGL2RenderingContext.STATIC_DRAW;
                    gpuBuffer.usage & GFXBufferUsageBit.VERTEX ? (cache.glVAO && (gl.bindVertexArray(null), 
                    cache.glVAO = null), cache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gl.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null), 
                    cache.glArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDEX ? (cache.glVAO && (gl.bindVertexArray(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gl.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                    gl.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, null), 
                    device.stateCache.glUniformBuffer = null) : (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = WebGL2RenderingContext.NONE);
                }(this._device, this._gpuBuffer));
            }
        }, {
            key: "update",
            value: function update(buffer, offset, size) {
                var buffSize;
                buffSize = void 0 !== size ? size : this._usage & GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
                WebGL2CmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
            }
        } ]), WebGL2GFXBuffer;
    }(), WebGL2GFXCommandPool = function() {
        function WebGL2GFXCommandPool(clazz, count) {
            _classCallCheck(this, WebGL2GFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
            this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
            for (var i = 0; i < count; ++i) this._frees[i] = new clazz();
            this._freeIdx = count - 1;
        }
        return _createClass(WebGL2GFXCommandPool, [ {
            key: "alloc",
            value: function alloc(clazz) {
                return new clazz();
            }
        }, {
            key: "free",
            value: function free(cmd) {
                0 == --cmd.refCount && this._freeCmds.push(cmd);
            }
        }, {
            key: "freeCmds",
            value: function freeCmds(cmds) {}
        }, {
            key: "release",
            value: function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                    var cmd = this._freeCmds.array[i];
                    cmd.clear(), this._frees[++this._freeIdx] = cmd;
                }
                this._freeCmds.clear();
            }
        } ]), WebGL2GFXCommandPool;
    }(), WebGL2GFXCommandAllocator = function(_GFXCommandAllocator) {
        function WebGL2GFXCommandAllocator(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
            _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
            _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGL2GFXCommandPool(WebGL2CmdBeginRenderPass, 16), 
            _this.bindStatesCmdPool = new WebGL2GFXCommandPool(WebGL2CmdBindStates, 16), _this.drawCmdPool = new WebGL2GFXCommandPool(WebGL2CmdDraw, 16), 
            _this.updateBufferCmdPool = new WebGL2GFXCommandPool(WebGL2CmdUpdateBuffer, 16), 
            _this.copyBufferToTextureCmdPool = new WebGL2GFXCommandPool(WebGL2CmdCopyBufferToTexture, 16), 
            _this;
        }
        return _inherits(WebGL2GFXCommandAllocator, GFXCommandAllocator), _createClass(WebGL2GFXCommandAllocator, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "clearCmds",
            value: function clearCmds(cmdPackage) {
                cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
                cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
                cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
                cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
                cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
                cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
            }
        }, {
            key: "releaseCmds",
            value: function releaseCmds() {
                this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
                this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
            }
        } ]), WebGL2GFXCommandAllocator;
    }(), WebGL2GFXCommandBuffer = function(_GFXCommandBuffer) {
        function WebGL2GFXCommandBuffer(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXCommandBuffer).call(this, device))).cmdPackage = new WebGL2CmdPackage(), 
            _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
            _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
            _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
            _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
            _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
        }
        return _inherits(WebGL2GFXCommandBuffer, GFXCommandBuffer), _createClass(WebGL2GFXCommandBuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
                this._type = info.type, this._status = GFXStatus.SUCCESS, !0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
                this._webGLAllocator = null), this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "begin",
            value: function begin() {
                this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
                this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
                this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
                this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
                this._numDrawCalls = 0, this._numTris = 0;
            }
        }, {
            key: "end",
            value: function end() {
                this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
            }
        }, {
            key: "beginRenderPass",
            value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
                var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag;
                for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
                cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
                this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
            }
        }, {
            key: "endRenderPass",
            value: function endRenderPass() {
                this._isInRenderPass = !1;
            }
        }, {
            key: "bindPipelineState",
            value: function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;
                this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
            }
        }, {
            key: "bindBindingLayout",
            value: function bindBindingLayout(bindingLayout) {
                var gpuBindingLayout = bindingLayout.gpuBindingLayout;
                this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
            }
        }, {
            key: "bindInputAssembler",
            value: function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
            }
        }, {
            key: "setViewport",
            value: function setViewport(viewport) {
                this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
                this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
                this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
                this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                    left: viewport.left,
                    top: viewport.top,
                    width: viewport.width,
                    height: viewport.height,
                    minDepth: viewport.minDepth,
                    maxDepth: viewport.maxDepth
                }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
            }
        }, {
            key: "setScissor",
            value: function setScissor(scissor) {
                this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
                this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
                this._isStateInvalied = !0) : this._curScissor = {
                    x: scissor.x,
                    y: scissor.y,
                    width: scissor.width,
                    height: scissor.height
                };
            }
        }, {
            key: "setLineWidth",
            value: function setLineWidth(lineWidth) {
                this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
            }
        }, {
            key: "setDepthBias",
            value: function setDepthBias(depthBiasConstantFacotr, depthBiasClamp, depthBiasSlopeFactor) {
                this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFacotr && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFacotr, 
                this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
                this._isStateInvalied = !0) : (this._curDepthBias = {
                    constantFactor: depthBiasConstantFacotr,
                    clamp: depthBiasClamp,
                    slopeFactor: depthBiasSlopeFactor
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setBlendConstants",
            value: function setBlendConstants(blendConstants) {
                (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
                this._isStateInvalied = !0);
            }
        }, {
            key: "setDepthBound",
            value: function setDepthBound(minDepthBounds, maxDepthBounds) {
                this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setStencilWriteMask",
            value: function setStencilWriteMask(face, writeMask) {
                this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
                this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                    face: face,
                    writeMask: writeMask
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "setStencilCompareMask",
            value: function setStencilCompareMask(face, reference, compareMask) {
                this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
                this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
                this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                    face: face,
                    reference: reference,
                    compareMask: compareMask
                }, this._isStateInvalied = !0);
            }
        }, {
            key: "draw",
            value: function draw(inputAssembler) {
                if (this._type === GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                    this._isStateInvalied && this.bindStates();
                    var cmd = this._allocator.drawCmdPool.alloc(WebGL2CmdDraw);
                    if (inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.DRAW), 
                    ++this._numDrawCalls, this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                      case WebGL2RenderingContext.TRIANGLES:
                        this._numTris += inputAssembler.indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                        break;

                      case WebGL2RenderingContext.TRIANGLE_STRIP:
                      case WebGL2RenderingContext.TRIANGLE_FAN:
                        this._numTris += (inputAssembler.indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                    }
                } else console.error("Command 'draw' must be recorded inside a render pass.");
            }
        }, {
            key: "updateBuffer",
            value: function updateBuffer(buffer, data, offset, size) {
                if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                    var gpuBuffer = buffer.gpuBuffer;
                    if (gpuBuffer) {
                        var buffSize, cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);
                        buffSize = void 0 !== size ? size : buffer.usage & GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                        var buff = data;
                        cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                        cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
                    }
                } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
            }
        }, {
            key: "copyBufferToTexture",
            value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
                if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                    var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                    if (gpuBuffer && gpuTexture) {
                        var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);
                        cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                        cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                    }
                } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
            }
        }, {
            key: "execute",
            value: function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                    for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                        var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                        ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                    }
                    for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                        var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                        ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                    }
                    for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                        var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                        ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                    }
                    for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                        var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                        ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                    }
                    for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                        var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                        ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                    }
                    this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                    this._numTris += webGLCmdBuff._numTris;
                }
            }
        }, {
            key: "bindStates",
            value: function bindStates() {
                var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);
                bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
                bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
                bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
                bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
                bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
                bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
                this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES), this._isStateInvalied = !1;
            }
        }, {
            key: "webGLDevice",
            get: function get() {
                return this._device;
            }
        } ]), WebGL2GFXCommandBuffer;
    }(), WebGL2GFXFramebuffer = function(_GFXFramebuffer) {
        function WebGL2GFXFramebuffer(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
            _this;
        }
        return _inherits(WebGL2GFXFramebuffer, GFXFramebuffer), _createClass(WebGL2GFXFramebuffer, [ {
            key: "gpuFramebuffer",
            get: function get() {
                return this._gpuFramebuffer;
            }
        } ]), _createClass(WebGL2GFXFramebuffer, [ {
            key: "initialize",
            value: function initialize(info) {
                if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
                this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
                this._isOffscreen) {
                    var gpuColorViews = [];
                    if (void 0 !== info.colorViews) {
                        var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var colorView = _ref;
                            gpuColorViews.push(colorView.gpuTextureView);
                        }
                    }
                    var gpuDepthStencilView = null;
                    info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                    this._gpuFramebuffer = {
                        gpuRenderPass: info.renderPass.gpuRenderPass,
                        gpuColorViews: gpuColorViews,
                        gpuDepthStencilView: gpuDepthStencilView,
                        isOffscreen: this._isOffscreen,
                        glFramebuffer: null
                    }, function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                        if (gpuFramebuffer.isOffscreen) {
                            var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                            if (glFramebuffer) {
                                gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                                device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                                for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                    var cv = gpuFramebuffer.gpuColorViews[i];
                                    cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                    attachments.push(gl.COLOR_ATTACHMENT0 + i));
                                }
                                var dsv = gpuFramebuffer.gpuDepthStencilView;
                                if (dsv) {
                                    var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                    dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                                }
                                gl.drawBuffers(attachments);
                                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                                if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                                  case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                    break;

                                  case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                    break;

                                  case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                    break;

                                  case gl.FRAMEBUFFER_UNSUPPORTED:
                                    console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                                }
                            }
                        }
                    }(this._device, this._gpuFramebuffer);
                } else this._gpuFramebuffer = {
                    gpuRenderPass: info.renderPass.gpuRenderPass,
                    gpuColorViews: [],
                    gpuDepthStencilView: null,
                    isOffscreen: info.isOffscreen,
                    glFramebuffer: null
                };
                return this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._isOffscreen && this._gpuFramebuffer && function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                    gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                    gpuFramebuffer.glFramebuffer = null);
                }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXFramebuffer;
    }(), WebGL2GFXInputAssembler = function(_GFXInputAssembler) {
        function WebGL2GFXInputAssembler(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
            _this;
        }
        return _inherits(WebGL2GFXInputAssembler, GFXInputAssembler), _createClass(WebGL2GFXInputAssembler, [ {
            key: "gpuInputAssembler",
            get: function get() {
                return this._gpuInputAssembler;
            }
        } ]), _createClass(WebGL2GFXInputAssembler, [ {
            key: "initialize",
            value: function initialize(info) {
                if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
                !1;
                if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
                void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                    var vertBuff = this._vertexBuffers[0];
                    this._vertexCount = vertBuff.size / vertBuff.stride;
                }
                this._indirectBuffer = info.indirectBuffer || null;
                for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                    var vb = info.vertexBuffers[i];
                    vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
                }
                var gpuIndexBuffer = null, glIndexType = 0;
                if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
                  case 1:
                    glIndexType = WebGLRenderingContext.UNSIGNED_BYTE;
                    break;

                  case 2:
                    glIndexType = WebGLRenderingContext.UNSIGNED_SHORT;
                    break;

                  case 4:
                    glIndexType = WebGLRenderingContext.UNSIGNED_INT;
                    break;

                  default:
                    console.error("Illegal index buffer stride.");
                }
                var gpuIndirectBuffer = null;
                return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
                this._gpuInputAssembler = {
                    attributes: info.attributes,
                    gpuVertexBuffers: gpuVertexBuffers,
                    gpuIndexBuffer: gpuIndexBuffer,
                    gpuIndirectBuffer: gpuIndirectBuffer,
                    glAttribs: [],
                    glIndexType: glIndexType,
                    glVAOs: new Map()
                }, function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
                    gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                    for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                        var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType$1(attrib.format), size = GFXFormatInfos[attrib.format].size;
                        gpuInputAssembler.glAttribs[i] = {
                            name: attrib.name,
                            glBuffer: gpuBuffer.glBuffer,
                            glType: glType,
                            size: size,
                            count: GFXFormatInfos[attrib.format].count,
                            stride: gpuBuffer.stride,
                            componentCount: WebGLGetComponentCount$1(glType),
                            isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                            isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                            offset: offsets[stream]
                        }, offsets[stream] += size;
                    }
                }(this._device, this._gpuInputAssembler), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var webgl2Dev = this._device;
                this._gpuInputAssembler && webgl2Dev.useVAO && function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                    var _iterator7 = gpuInputAssembler.glVAOs, _isArray7 = Array.isArray(_iterator7), _i16 = 0;
                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                        var _ref7;
                        if (_isArray7) {
                            if (_i16 >= _iterator7.length) break;
                            _ref7 = _iterator7[_i16++];
                        } else {
                            if ((_i16 = _iterator7.next()).done) break;
                            _ref7 = _i16.value;
                        }
                        var vao = _ref7;
                        device.gl.deleteVertexArray(vao[1]);
                    }
                    gpuInputAssembler.glVAOs.clear();
                }(webgl2Dev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "extractCmdDraw",
            value: function extractCmdDraw(cmd) {
                cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
                cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
                cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
                cmd.drawInfo.firstInstance = this._firstInstance;
            }
        } ]), WebGL2GFXInputAssembler;
    }(), WebGL2GFXPipelineLayout = function(_GFXPipelineLayout) {
        function WebGL2GFXPipelineLayout(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
            _this;
        }
        return _inherits(WebGL2GFXPipelineLayout, GFXPipelineLayout), _createClass(WebGL2GFXPipelineLayout, [ {
            key: "gpuPipelineLayout",
            get: function get() {
                return this._gpuPipelineLayout;
            }
        } ]), _createClass(WebGL2GFXPipelineLayout, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
                this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXPipelineLayout;
    }(), WebGLPrimitives$1 = [ WebGLRenderingContext.POINTS, WebGLRenderingContext.LINES, WebGLRenderingContext.LINE_STRIP, WebGLRenderingContext.LINE_LOOP, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.TRIANGLES, WebGLRenderingContext.TRIANGLE_STRIP, WebGLRenderingContext.TRIANGLE_FAN, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE, WebGLRenderingContext.NONE ], WebGL2GFXPipelineState = function(_GFXPipelineState) {
        function WebGL2GFXPipelineState(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXPipelineState).call(this, device)))._gpuPipelineState = null, 
            _this;
        }
        return _inherits(WebGL2GFXPipelineState, GFXPipelineState), _createClass(WebGL2GFXPipelineState, [ {
            key: "gpuPipelineState",
            get: function get() {
                return this._gpuPipelineState;
            }
        } ]), _createClass(WebGL2GFXPipelineState, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._primitive = info.primitive, this._shader = info.shader, this._is = info.is, 
                this._rs = info.rs, this._dss = info.dss, this._bs = info.bs, this._dynamicStates = info.dynamicStates || [], 
                this._layout = info.layout, this._renderPass = info.renderPass, this._gpuPipelineState = {
                    glPrimitive: WebGLPrimitives$1[info.primitive],
                    gpuShader: info.shader.gpuShader,
                    rs: info.rs,
                    dss: info.dss,
                    bs: info.bs,
                    dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                    gpuLayout: info.layout.gpuPipelineLayout,
                    gpuRenderPass: info.renderPass.gpuRenderPass
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuPipelineState = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXPipelineState;
    }(), WebGL2GFXQueue = function(_GFXQueue) {
        function WebGL2GFXQueue(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXQueue).call(this, device))).numDrawCalls = 0, 
            _this.numTris = 0, _this._isAsync = !1, _this;
        }
        return _inherits(WebGL2GFXQueue, GFXQueue), _createClass(WebGL2GFXQueue, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._type = info.type, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "submit",
            value: function submit(cmdBuffs, fence) {
                if (!this._isAsync) {
                    var _iterator = cmdBuffs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var cmdBuff = _ref;
                        WebGL2CmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                        this.numTris += cmdBuff.numTris;
                    }
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                this.numDrawCalls = 0, this.numTris = 0;
            }
        } ]), WebGL2GFXQueue;
    }(), WebGL2GFXRenderPass = function(_GFXRenderPass) {
        function WebGL2GFXRenderPass(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXRenderPass).call(this, device)))._gpuRenderPass = null, 
            _this;
        }
        return _inherits(WebGL2GFXRenderPass, GFXRenderPass), _createClass(WebGL2GFXRenderPass, [ {
            key: "gpuRenderPass",
            get: function get() {
                return this._gpuRenderPass;
            }
        } ]), _createClass(WebGL2GFXRenderPass, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
                this._gpuRenderPass = {
                    colorAttachments: this._colorInfos,
                    depthStencilAttachment: this._depthStencilInfo
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuRenderPass = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXRenderPass;
    }(), WebGL2GFXSampler = function(_GFXSampler) {
        function WebGL2GFXSampler(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXSampler).call(this, device)))._gpuSampler = null, 
            _this._state = new GFXSamplerState(), _this;
        }
        return _inherits(WebGL2GFXSampler, GFXSampler), _createClass(WebGL2GFXSampler, [ {
            key: "gpuSampler",
            get: function get() {
                return this._gpuSampler;
            }
        } ]), _createClass(WebGL2GFXSampler, [ {
            key: "initialize",
            value: function initialize(info) {
                return void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
                void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
                void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
                void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
                void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
                void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
                void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias), this._gpuSampler = {
                    glSampler: null,
                    minFilter: this._state.minFilter,
                    magFilter: this._state.magFilter,
                    mipFilter: this._state.mipFilter,
                    addressU: this._state.addressU,
                    addressV: this._state.addressV,
                    addressW: this._state.addressW,
                    minLOD: this._state.minLOD,
                    maxLOD: this._state.maxLOD,
                    glMinFilter: WebGL2RenderingContext.NONE,
                    glMagFilter: WebGL2RenderingContext.NONE,
                    glWrapS: WebGL2RenderingContext.NONE,
                    glWrapT: WebGL2RenderingContext.NONE,
                    glWrapR: WebGL2RenderingContext.NONE
                }, function WebGL2CmdFuncCreateSampler(device, gpuSampler) {
                    var gl = device.gl, glSampler = gl.createSampler();
                    glSampler && (gpuSampler.minFilter === GFXFilter.LINEAR || gpuSampler.minFilter === GFXFilter.ANISOTROPIC ? gpuSampler.mipFilter === GFXFilter.LINEAR || gpuSampler.mipFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMinFilter = WebGLRenderingContext.LINEAR_MIPMAP_LINEAR : gpuSampler.mipFilter === GFXFilter.POINT ? gpuSampler.glMinFilter = WebGLRenderingContext.LINEAR_MIPMAP_NEAREST : gpuSampler.glMinFilter = WebGLRenderingContext.LINEAR : gpuSampler.mipFilter === GFXFilter.LINEAR || gpuSampler.mipFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMinFilter = WebGLRenderingContext.NEAREST_MIPMAP_LINEAR : gpuSampler.mipFilter === GFXFilter.POINT ? gpuSampler.glMinFilter = WebGLRenderingContext.NEAREST_MIPMAP_NEAREST : gpuSampler.glMinFilter = WebGLRenderingContext.NEAREST, 
                    gpuSampler.magFilter === GFXFilter.LINEAR || gpuSampler.magFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMagFilter = WebGLRenderingContext.LINEAR : gpuSampler.glMagFilter = WebGLRenderingContext.NEAREST, 
                    gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU], gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV], 
                    gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW], gpuSampler.glSampler = glSampler, 
                    gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gpuSampler.glMinFilter), 
                    gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                    gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gpuSampler.glWrapS), gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gpuSampler.glWrapT), 
                    gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, gpuSampler.glWrapR), gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, gpuSampler.minLOD), 
                    gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, gpuSampler.maxLOD));
                }(this._device, this._gpuSampler), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuSampler && (!function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
                    gpuSampler.glSampler && (device.gl.deleteSampler(gpuSampler.glSampler), gpuSampler.glSampler = null);
                }(this._device, this._gpuSampler), this._gpuSampler = null), this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXSampler;
    }(), WebGL2GFXShader = function(_GFXShader) {
        function WebGL2GFXShader(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXShader).call(this, device)))._gpuShader = null, 
            _this;
        }
        return _inherits(WebGL2GFXShader, GFXShader), _createClass(WebGL2GFXShader, [ {
            key: "gpuShader",
            get: function get() {
                return this._gpuShader;
            }
        } ]), _createClass(WebGL2GFXShader, [ {
            key: "initialize",
            value: function initialize(info) {
                this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
                void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                    name: info.name ? info.name : "",
                    blocks: void 0 !== info.blocks ? info.blocks : [],
                    samplers: void 0 !== info.samplers ? info.samplers : [],
                    gpuStages: new Array(info.stages.length),
                    glProgram: null,
                    glInputs: [],
                    glUniforms: [],
                    glBlocks: [],
                    glSamplers: []
                };
                for (var i = 0; i < info.stages.length; ++i) {
                    var stage = info.stages[i];
                    this._gpuShader.gpuStages[i] = {
                        type: stage.type,
                        source: stage.source,
                        macros: stage.macros ? stage.macros : [],
                        glShader: null
                    };
                }
                return function WebGL2CmdFuncCreateShader(device, gpuShader) {
                    var gl = device.gl, _iterator = gpuShader.gpuStages, _isArray = Array.isArray(_iterator), _i7 = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i7 >= _iterator.length) break;
                            _ref = _iterator[_i7++];
                        } else {
                            if ((_i7 = _iterator.next()).done) break;
                            _ref = _i7.value;
                        }
                        var _gpuStage = _ref, glShaderType = 0, shaderTypeStr = "";
                        switch (_gpuStage.type) {
                          case GFXShaderType.VERTEX:
                            shaderTypeStr = "VertexShader", glShaderType = WebGL2RenderingContext.VERTEX_SHADER;
                            break;

                          case GFXShaderType.FRAGMENT:
                            shaderTypeStr = "FragmentShader", glShaderType = WebGL2RenderingContext.FRAGMENT_SHADER;
                            break;

                          default:
                            return void console.error("Unsupported GFXShaderType.");
                        }
                        var glShader = gl.createShader(glShaderType);
                        glShader && (_gpuStage.glShader = glShader, gl.shaderSource(_gpuStage.glShader, _gpuStage.source), 
                        gl.compileShader(_gpuStage.glShader), gl.getShaderParameter(_gpuStage.glShader, gl.COMPILE_STATUS) || (console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                        console.error(_gpuStage.source), console.error(gl.getShaderInfoLog(_gpuStage.glShader)), 
                        gl.deleteShader(_gpuStage.glShader), _gpuStage.glShader = null));
                    }
                    var glProgram = gl.createProgram();
                    if (glProgram) {
                        gpuShader.glProgram = glProgram;
                        var _iterator2 = gpuShader.gpuStages, _isArray2 = Array.isArray(_iterator2), _i8 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i8 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i8++];
                            } else {
                                if ((_i8 = _iterator2.next()).done) break;
                                _ref2 = _i8.value;
                            }
                            var _gpuStage2 = _ref2;
                            gl.attachShader(gpuShader.glProgram, _gpuStage2.glShader);
                        }
                        if (gl.linkProgram(gpuShader.glProgram), gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) console.info("Shader '" + gpuShader.name + "' compilation successed."); else {
                            console.error("Failed to link shader '" + gpuShader.name + "'."), console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                            var _iterator3 = gpuShader.gpuStages, _isArray3 = Array.isArray(_iterator3), _i9 = 0;
                            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref3;
                                if (_isArray3) {
                                    if (_i9 >= _iterator3.length) break;
                                    _ref3 = _iterator3[_i9++];
                                } else {
                                    if ((_i9 = _iterator3.next()).done) break;
                                    _ref3 = _i9.value;
                                }
                                var gpuStage = _ref3;
                                gpuStage.glShader && (gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                            }
                        }
                        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                        gpuShader.glInputs = new Array(activeAttribCount);
                        for (var i = 0; i < activeAttribCount; ++i) {
                            var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                            if (attribInfo) {
                                var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType$1(attribInfo.type), stride = WebGLGetTypeSize$1(attribInfo.type);
                                gpuShader.glInputs[i] = {
                                    binding: glLoc,
                                    name: varName,
                                    type: type,
                                    stride: stride,
                                    count: attribInfo.size,
                                    size: stride * attribInfo.size,
                                    glType: attribInfo.type,
                                    glLoc: glLoc
                                };
                            }
                        }
                        var blockName, blockIdx, blockSize, blockBinding, blockUniformCount, uIndices, indices, glUniformSizes, glUniformOffsets, glUniformInfo, activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
                        if (activeBlockCount) {
                            gpuShader.glBlocks = new Array(activeBlockCount);
                            for (var b = 0; b < activeBlockCount; ++b) {
                                var _nameOffset = (blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b)).indexOf("[");
                                -1 !== _nameOffset && (blockName = blockName.substr(0, _nameOffset)), blockBinding = -1;
                                var _iterator4 = gpuShader.blocks, _isArray4 = Array.isArray(_iterator4), _i10 = 0;
                                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                    var _ref4;
                                    if (_isArray4) {
                                        if (_i10 >= _iterator4.length) break;
                                        _ref4 = _iterator4[_i10++];
                                    } else {
                                        if ((_i10 = _iterator4.next()).done) break;
                                        _ref4 = _i10.value;
                                    }
                                    var block = _ref4;
                                    if (block.name === blockName) {
                                        blockBinding = block.binding;
                                        break;
                                    }
                                }
                                if (0 <= blockBinding) {
                                    blockIdx = b, blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE), 
                                    blockUniformCount = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS), 
                                    gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, blockBinding);
                                    var glBlock = {
                                        binding: blockBinding,
                                        idx: blockIdx,
                                        name: blockName,
                                        size: blockSize,
                                        glUniforms: new Array(blockUniformCount),
                                        glActiveUniforms: [],
                                        isUniformPackage: !1
                                    };
                                    gpuShader.glBlocks[b] = glBlock, uIndices = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES), 
                                    indices = new Array(uIndices.length);
                                    for (var n = 0; n < uIndices.length; ++n) indices[n] = uIndices[n];
                                    glUniformSizes = gl.getActiveUniforms(gpuShader.glProgram, indices, gl.UNIFORM_SIZE), 
                                    glUniformOffsets = gl.getActiveUniforms(gpuShader.glProgram, indices, gl.UNIFORM_OFFSET);
                                    for (var u = 0; u < blockUniformCount; ++u) if (glUniformInfo = gl.getActiveUniform(gpuShader.glProgram, uIndices[u])) {
                                        var _stride = WebGLGetTypeSize$1(glUniformInfo.type), size = glUniformSizes[u] * _stride, begin = glUniformOffsets[u] / 4, array = new Array(size / 4);
                                        array.fill(0), glBlock.glUniforms[u] = {
                                            binding: -1,
                                            name: glUniformInfo.name,
                                            type: WebGLTypeToGFXType$1(glUniformInfo.type),
                                            stride: _stride,
                                            count: glUniformInfo.size,
                                            size: size,
                                            offset: glUniformOffsets[u],
                                            glType: glUniformInfo.type,
                                            glLoc: -1,
                                            array: array,
                                            begin: begin,
                                            isFirst: !0
                                        };
                                    }
                                }
                            }
                        }
                        if (0 < gpuShader.samplers.length) {
                            gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                            for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                                var sampler = gpuShader.samplers[_i11];
                                gpuShader.glSamplers[_i11] = {
                                    binding: sampler.binding,
                                    name: sampler.name,
                                    type: sampler.type,
                                    units: [],
                                    glType: GFXTypeToWebGLType$1(sampler.type),
                                    glLoc: -1
                                };
                            }
                        }
                        for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i12 = 0; _i12 < activeUniformCount; ++_i12) {
                            var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i12);
                            if (uniformInfo) {
                                var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                if (_glLoc) {
                                    var _varName = void 0, _nameOffset2 = uniformInfo.name.indexOf("[");
                                    if (_varName = -1 !== _nameOffset2 ? uniformInfo.name.substr(0, _nameOffset2) : uniformInfo.name, 
                                    uniformInfo.type === WebGL2RenderingContext.SAMPLER_2D || uniformInfo.type === WebGL2RenderingContext.SAMPLER_CUBE) {
                                        var _iterator5 = gpuShader.glSamplers, _isArray5 = Array.isArray(_iterator5), _i13 = 0;
                                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                            var _ref5;
                                            if (_isArray5) {
                                                if (_i13 >= _iterator5.length) break;
                                                _ref5 = _iterator5[_i13++];
                                            } else {
                                                if ((_i13 = _iterator5.next()).done) break;
                                                _ref5 = _i13.value;
                                            }
                                            var glSampler = _ref5;
                                            if (glSampler.name === _varName) {
                                                for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                                glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (glActiveSamplers.length) {
                            device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                            device.stateCache.glProgram = gpuShader.glProgram);
                            for (var _i14 = 0; _i14 < glActiveSamplers.length; _i14++) {
                                var _glSampler = glActiveSamplers[_i14];
                                gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                            }
                        }
                    }
                }(this._device, this._gpuShader), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuShader && (!function WebGL2CmdFuncDestroyShader(device, gpuShader) {
                    var _iterator6 = gpuShader.gpuStages, _isArray6 = Array.isArray(_iterator6), _i15 = 0;
                    for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray6) {
                            if (_i15 >= _iterator6.length) break;
                            _ref6 = _iterator6[_i15++];
                        } else {
                            if ((_i15 = _iterator6.next()).done) break;
                            _ref6 = _i15.value;
                        }
                        var gpuStage = _ref6;
                        gpuStage.glShader && (device.gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                    }
                    gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
                }(this._device, this._gpuShader), this._gpuShader = null), this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXShader;
    }(), WebGL2StateCache = function WebGL2StateCache() {
        _classCallCheck(this, WebGL2StateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
        this.glUniformBuffer = null, this.glBindUBOs = void 0, this.glVAO = null, this.texUnit = 0, 
        this.glTex2DUnits = void 0, this.glTexCubeUnits = void 0, this.glSamplerUnits = void 0, 
        this.glRenderbuffer = null, this.glFramebuffer = null, this.glReadFramebuffer = null, 
        this.viewport = void 0, this.scissorRect = void 0, this.rs = void 0, this.dss = void 0, 
        this.bs = void 0, this.glProgram = null, this.glEnabledAttribLocs = void 0, this.glCurrentAttribLocs = void 0, 
        this.glBindUBOs = new Array(24), this.glBindUBOs.fill(null), this.glTex2DUnits = new Array(16), 
        this.glTexCubeUnits = new Array(16), this.glSamplerUnits = new Array(16), this.glSamplerUnits.fill(null), 
        this.viewport = {
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            minDepth: 0,
            maxDepth: 0
        }, this.scissorRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }, this.rs = new GFXRasterizerState(), this.dss = new GFXDepthStencilState(), this.bs = new GFXBlendState(), 
        this.glEnabledAttribLocs = new Array(16), this.glCurrentAttribLocs = new Array(16), 
        this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
        for (var i = 0; i < 16; ++i) this.glTex2DUnits[i] = {
            glTexture: null
        }, this.glTexCubeUnits[i] = {
            glTexture: null
        };
    };
    function IsPowerOf2$1(x) {
        return 0 < x && 0 == (x & x - 1);
    }
    var WebGL2GFXTexture = function(_GFXTexture) {
        function WebGL2GFXTexture(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXTexture).call(this, device)))._gpuTexture = null, 
            _this;
        }
        return _inherits(WebGL2GFXTexture, GFXTexture), _createClass(WebGL2GFXTexture, [ {
            key: "gpuTexture",
            get: function get() {
                return this._gpuTexture;
            }
        } ]), _createClass(WebGL2GFXTexture, [ {
            key: "initialize",
            value: function initialize(info) {
                var viewType;
                switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
                this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
                void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
                void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
                this._isPowerOf2 = IsPowerOf2$1(this._width) && IsPowerOf2$1(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                this._flags & GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
                info.type) {
                  case GFXTextureType.TEX1D:
                    viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV1D : GFXTextureViewType.TV1D_ARRAY : GFXTextureViewType.TV1D;
                    break;

                  case GFXTextureType.TEX2D:
                    var flags = GFXTextureFlagBit.NONE;
                    info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV2D : flags & GFXTextureFlagBit.CUBEMAP ? GFXTextureViewType.CUBE : GFXTextureViewType.TV2D_ARRAY : GFXTextureViewType.TV2D;
                    break;

                  case GFXTextureType.TEX3D:
                    viewType = GFXTextureViewType.TV3D;
                    break;

                  default:
                    viewType = GFXTextureViewType.TV2D;
                }
                return this._gpuTexture = {
                    type: this._type,
                    viewType: viewType,
                    format: this._format,
                    usage: this._usage,
                    width: this._width,
                    height: this._height,
                    depth: this._depth,
                    size: this._size,
                    arrayLayer: this._arrayLayer,
                    mipLevel: this._mipLevel,
                    samples: this._samples,
                    flags: this._flags,
                    isPowerOf2: this._isPowerOf2,
                    glTarget: 0,
                    glInternelFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0
                }, function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
                    var gl = device.gl;
                    switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format), 
                    gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format), gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format), 
                    gpuTexture.viewType) {
                      case GFXTextureViewType.TV2D:
                        if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = WebGL2RenderingContext.TEXTURE_2D, 
                        gpuTexture.samples === GFXSampleCount.X1) {
                            var glTexture = gl.createTexture();
                            if (glTexture && 0 < gpuTexture.size) {
                                gpuTexture.glTexture = glTexture;
                                var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                                glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, gpuTexture.glTexture), 
                                glTexUnit.glTexture = gpuTexture.glTexture);
                                var w = gpuTexture.width, h = gpuTexture.height;
                                if (GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                    var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                    gl.compressedTexImage2D(WebGL2RenderingContext.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                } else {
                                    var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                    gl.compressedTexImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                                } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(WebGL2RenderingContext.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                        } else {
                            var glRenderbuffer = gl.createRenderbuffer();
                            glRenderbuffer && 0 < gpuTexture.size && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                            device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(WebGL2RenderingContext.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                            device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternelFmt, gpuTexture.width, gpuTexture.height));
                        }
                        break;

                      case GFXTextureViewType.CUBE:
                        gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = WebGL2RenderingContext.TEXTURE_CUBE_MAP;
                        var _glTexture = gl.createTexture();
                        if (_glTexture && 0 < gpuTexture.size) {
                            gpuTexture.glTexture = _glTexture;
                            var _glTexUnit = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                            if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGL2RenderingContext.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                            _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) for (var _w2 = gpuTexture.width, _h2 = gpuTexture.height, _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                                var _imgSize2 = GFXFormatSize(gpuTexture.format, _w2, _h2, 1), _view2 = new Uint8Array(_imgSize2);
                                gl.compressedTexImage2D(WebGL2RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, _w2, _h2, 0, _view2), 
                                _w2 = Math.max(1, _w2 >> 1), _h2 = Math.max(1, _h2 >> 1);
                            } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                                var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                                gl.compressedTexImage2D(WebGL2RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                            } else for (var f = 0; f < 6; ++f) for (var _w = gpuTexture.width, _h = gpuTexture.height, _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(WebGL2RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, _w, _h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            _w = Math.max(1, _w >> 1), _h = Math.max(1, _h >> 1);
                        }
                        break;

                      default:
                        console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                        gpuTexture.glTarget = WebGL2RenderingContext.TEXTURE_2D;
                    }
                }(this._device, this._gpuTexture), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuTexture && (!function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
                    gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                    gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                    gpuTexture.glRenderbuffer = null);
                }(this._device, this._gpuTexture), this._gpuTexture = null), this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
                this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
                this._gpuTexture.size = this._size, function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
                    var gl = device.gl;
                    switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format), 
                    gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format), gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format), 
                    gpuTexture.viewType) {
                      case GFXTextureViewType.TV2D:
                        if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = WebGL2RenderingContext.TEXTURE_2D, 
                        gpuTexture.samples === GFXSampleCount.X1) {
                            var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            if (GFXFormatInfos[gpuTexture.format].isCompressed) {
                                if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                    var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                    gl.compressedTexImage2D(WebGL2RenderingContext.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                    w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                                }
                            } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(WebGL2RenderingContext.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                        } else {
                            var glRenderbuffer = gl.createRenderbuffer();
                            glRenderbuffer && 0 < gpuTexture.size && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                            device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(WebGL2RenderingContext.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                            device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternelFmt, gpuTexture.width, gpuTexture.height));
                        }
                        break;

                      case GFXTextureViewType.CUBE:
                        gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = WebGL2RenderingContext.TEXTURE_CUBE_MAP;
                        var _glTexUnit2 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                        if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGL2RenderingContext.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                            if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) for (var _w4 = gpuTexture.width, _h4 = gpuTexture.height, _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                                var _imgSize4 = GFXFormatSize(gpuTexture.format, _w4, _h4, 1), _view4 = new Uint8Array(_imgSize4);
                                gl.compressedTexImage2D(WebGL2RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, _w4, _h4, 0, _view4), 
                                _w4 = Math.max(1, _w4 >> 1), _h4 = Math.max(1, _h4 >> 1);
                            }
                        } else for (var f = 0; f < 6; ++f) for (var _w3 = gpuTexture.width, _h3 = gpuTexture.height, _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(WebGL2RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, _w3, _h3, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        _w3 = Math.max(1, _w3 >> 1), _h3 = Math.max(1, _h3 >> 1);
                        break;

                      default:
                        console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                        gpuTexture.glTarget = WebGL2RenderingContext.TEXTURE_2D;
                    }
                }(this._device, this._gpuTexture)), this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXTexture;
    }(), WebGL2GFXTextureView = function(_GFXTextureView) {
        function WebGL2GFXTextureView(device) {
            var _this;
            return _classCallCheck(this, WebGL2GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXTextureView).call(this, device)))._gpuTextureView = null, 
            _this;
        }
        return _inherits(WebGL2GFXTextureView, GFXTextureView), _createClass(WebGL2GFXTextureView, [ {
            key: "gpuTextureView",
            get: function get() {
                return this._gpuTextureView;
            }
        } ]), _createClass(WebGL2GFXTextureView, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._texture = info.texture, this._type = info.type, this._format = info.format, 
                this._format = info.format, void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), 
                void 0 !== info.levelCount && (this._levelCount = info.levelCount), void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), 
                void 0 !== info.layerCount && (this._layerCount = info.layerCount), this._gpuTextureView = {
                    gpuTexture: info.texture.gpuTexture,
                    type: info.type,
                    format: info.format,
                    baseLevel: info.baseLevel ? info.baseLevel : 0,
                    levelCount: info.levelCount ? info.levelCount : 1
                }, this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._gpuTextureView = null, this._texture = null, this._status = GFXStatus.UNREADY;
            }
        } ]), WebGL2GFXTextureView;
    }(), WebGL2GFXWindow = function(_GFXWindow) {
        function WebGL2GFXWindow(device) {
            return _classCallCheck(this, WebGL2GFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXWindow).call(this, device));
        }
        return _inherits(WebGL2GFXWindow, GFXWindow), _createClass(WebGL2GFXWindow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
                void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
                this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
                this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
                this._renderPass = this._device.createRenderPass({
                    colorAttachments: [ {
                        format: this._colorFmt,
                        loadOp: GFXLoadOp.CLEAR,
                        storeOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                    } ],
                    depthStencilAttachment: {
                        format: this._depthStencilFmt,
                        depthLoadOp: GFXLoadOp.CLEAR,
                        depthStoreOp: GFXStoreOp.STORE,
                        stencilLoadOp: GFXLoadOp.CLEAR,
                        stencilStoreOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                    }
                });
                var colorViews = [];
                return this._isOffscreen && (this._colorFmt !== exports.GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._colorFmt,
                    width: this._width,
                    height: this._height,
                    depth: 1,
                    arrayLayer: 1,
                    mipLevel: 1,
                    flags: GFXTextureFlagBit.NONE
                }), this._colorTexView = this._device.createTextureView({
                    texture: this._colorTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt,
                    baseLevel: 0,
                    levelCount: 1,
                    baseLayer: 0,
                    layerCount: 1
                }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== exports.GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                    format: this._depthStencilFmt,
                    width: this._width,
                    height: this._height,
                    depth: 1,
                    arrayLayer: 1,
                    mipLevel: 1,
                    flags: GFXTextureFlagBit.NONE
                }), this._depthStencilTexView = this._device.createTextureView({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt,
                    baseLevel: 0,
                    levelCount: 1,
                    baseLayer: 0,
                    layerCount: 1
                }))), this._framebuffer = this._device.createFramebuffer({
                    renderPass: this._renderPass,
                    colorViews: colorViews,
                    depthStencilView: this._depthStencilTexView,
                    isOffscreen: this._isOffscreen
                }), this._status = GFXStatus.SUCCESS, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
                this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
                this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
                this._status = GFXStatus.UNREADY;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
                this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
                this._colorTexView.initialize({
                    texture: this._colorTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
                this._framebuffer.initialize({
                    renderPass: this._renderPass,
                    colorViews: [ this._colorTexView ],
                    depthStencilView: this._depthStencilTexView
                })));
            }
        } ]), WebGL2GFXWindow;
    }(), WebGL2GFXDevice = function(_GFXDevice) {
        function WebGL2GFXDevice() {
            var _this;
            return _classCallCheck(this, WebGL2GFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXDevice).call(this))).stateCache = new WebGL2StateCache(), 
            _this.nullTex2D = null, _this.nullTexCube = null, _this._webGL2RC = null, _this._isAntialias = !0, 
            _this._isPremultipliedAlpha = !0, _this._useVAO = !0, _this._extensions = null, 
            _this._EXT_texture_filter_anisotropic = null, _this._OES_texture_float_linear = null, 
            _this._OES_texture_half_float_linear = null, _this._EXT_color_buffer_float = null, 
            _this._EXT_disjoint_timer_query_webgl2 = null, _this._WEBGL_compressed_texture_etc1 = null, 
            _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
            _this._WEBGL_compressed_texture_s3tc = null, _this._WEBGL_compressed_texture_s3tc_srgb = null, 
            _this._WEBGL_debug_renderer_info = null, _this._WEBGL_texture_storage_multisample = null, 
            _this._WEBGL_debug_shaders = null, _this._WEBGL_lose_context = null, _this;
        }
        return _inherits(WebGL2GFXDevice, GFXDevice), _createClass(WebGL2GFXDevice, [ {
            key: "gl",
            get: function get() {
                return this._webGL2RC;
            }
        }, {
            key: "isAntialias",
            get: function get() {
                return this._isAntialias;
            }
        }, {
            key: "isPremultipliedAlpha",
            get: function get() {
                return this._isPremultipliedAlpha;
            }
        }, {
            key: "useVAO",
            get: function get() {
                return this._useVAO;
            }
        }, {
            key: "EXT_texture_filter_anisotropic",
            get: function get() {
                return this._EXT_texture_filter_anisotropic;
            }
        }, {
            key: "OES_texture_float_linear",
            get: function get() {
                return this._OES_texture_float_linear;
            }
        }, {
            key: "EXT_color_buffer_float",
            get: function get() {
                return this._EXT_color_buffer_float;
            }
        }, {
            key: "EXT_disjoint_timer_query_webgl2",
            get: function get() {
                return this._EXT_disjoint_timer_query_webgl2;
            }
        }, {
            key: "WEBGL_compressed_texture_etc1",
            get: function get() {
                return this._WEBGL_compressed_texture_etc1;
            }
        }, {
            key: "WEBGL_compressed_texture_etc",
            get: function get() {
                return this._WEBGL_compressed_texture_etc;
            }
        }, {
            key: "WEBGL_compressed_texture_pvrtc",
            get: function get() {
                return this._WEBGL_compressed_texture_pvrtc;
            }
        }, {
            key: "WEBGL_compressed_texture_s3tc",
            get: function get() {
                return this._WEBGL_compressed_texture_s3tc;
            }
        }, {
            key: "WEBGL_compressed_texture_s3tc_srgb",
            get: function get() {
                return this._WEBGL_compressed_texture_s3tc_srgb;
            }
        } ]), _createClass(WebGL2GFXDevice, [ {
            key: "initialize",
            value: function initialize(info) {
                this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
                this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
                try {
                    var webGLCtxAttribs = {
                        alpha: !0,
                        antialias: this._isAntialias,
                        depth: !0,
                        stencil: !0,
                        premultipliedAlpha: this._isPremultipliedAlpha,
                        preserveDrawingBuffer: !1,
                        powerPreference: "default",
                        failIfMajorPerformanceCaveat: !1
                    };
                    this._webGL2RC = this._canvas.getContext("webgl2", webGLCtxAttribs);
                } catch (err) {
                    return console.error(err), !1;
                }
                if (!this._webGL2RC) return console.error("This device does not support WebGL2."), 
                !1;
                this._canvas2D = document.createElement("canvas"), console.info("WebGL2 device initialized."), 
                this._gfxAPI = GFXAPI.WEBGL2, this._deviceName = "WebGL2";
                var gl = this._webGL2RC;
                this._WEBGL_debug_renderer_info = gl.getExtension("WEBGL_debug_renderer_info"), 
                this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
                this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(WebGL2RenderingContext.RENDERER), 
                this._vendor = gl.getParameter(WebGL2RenderingContext.VENDOR)), this._version = gl.getParameter(WebGL2RenderingContext.VERSION), 
                this._maxVertexAttributes = gl.getParameter(WebGL2RenderingContext.MAX_VERTEX_ATTRIBS), 
                this._maxVertexUniformVectors = gl.getParameter(WebGL2RenderingContext.MAX_VERTEX_UNIFORM_VECTORS), 
                this._maxFragmentUniformVectors = gl.getParameter(WebGL2RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS), 
                this._maxTextureUnits = gl.getParameter(WebGL2RenderingContext.MAX_TEXTURE_IMAGE_UNITS), 
                this._maxVertexTextureUnits = gl.getParameter(WebGL2RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
                this._maxUniformBufferBindings = gl.getParameter(WebGL2RenderingContext.MAX_UNIFORM_BUFFER_BINDINGS), 
                this._maxUniformBlockSize = gl.getParameter(WebGL2RenderingContext.MAX_UNIFORM_BLOCK_SIZE), 
                this._depthBits = gl.getParameter(WebGL2RenderingContext.DEPTH_BITS), this._stencilBits = gl.getParameter(WebGL2RenderingContext.STENCIL_BITS), 
                this._devicePixelRatio = info.devicePixelRatio || 1, this._width = this._canvas.width, 
                this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
                this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = exports.GFXFormat.RGBA8, 
                32 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D32F_S8 : this._depthStencilFmt = exports.GFXFormat.D32F : 24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D16S8 : this._depthStencilFmt = exports.GFXFormat.D16, 
                this._extensions = gl.getSupportedExtensions();
                var extensions = "";
                if (this._extensions) {
                    var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        extensions += _ref + " ";
                    }
                    console.debug("EXTENSIONS: " + extensions);
                }
                this._EXT_texture_filter_anisotropic = gl.getExtension("EXT_texture_filter_anisotropic"), 
                this._EXT_color_buffer_float = gl.getExtension("EXT_color_buffer_float"), this._EXT_disjoint_timer_query_webgl2 = gl.getExtension("EXT_disjoint_timer_query_webgl2"), 
                this._OES_texture_float_linear = gl.getExtension("OES_texture_float_linear"), this._OES_texture_half_float_linear = gl.getExtension("OES_texture_half_float_linear"), 
                this._WEBGL_compressed_texture_etc1 = gl.getExtension("WEBGL_compressed_texture_etc1"), 
                this._WEBGL_compressed_texture_etc = gl.getExtension("WEBGL_compressed_texture_etc"), 
                this._WEBGL_compressed_texture_pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc"), 
                this._WEBGL_compressed_texture_s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc"), 
                this._WEBGL_compressed_texture_s3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
                this._WEBGL_texture_storage_multisample = gl.getExtension("WEBGL_texture_storage_multisample"), 
                this._WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders"), this._WEBGL_lose_context = gl.getExtension("WEBGL_lose_context"), 
                this._features.fill(!1), this._features[GFXFeature.TEXTURE_FLOAT] = !0, this._features[GFXFeature.TEXTURE_HALF_FLOAT] = !0, 
                this._features[GFXFeature.FORMAT_R11G11B10F] = !0, this._features[GFXFeature.FORMAT_D24S8] = !0, 
                this._features[GFXFeature.FORMAT_ETC2] = !0, this._features[GFXFeature.MSAA] = !0, 
                this._EXT_color_buffer_float && (this._features[GFXFeature.COLOR_FLOAT] = !0, this._features[GFXFeature.COLOR_HALF_FLOAT] = !0), 
                this._OES_texture_float_linear && (this._features[GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
                this._OES_texture_half_float_linear && (this._features[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0);
                var compressedFormat = "";
                this._WEBGL_compressed_texture_etc1 && (this._features[GFXFeature.FORMAT_ETC1] = !0, 
                compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[GFXFeature.FORMAT_ETC2] = !0, 
                compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[GFXFeature.FORMAT_DXT] = !0, 
                compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[GFXFeature.FORMAT_PVRTC] = !0, 
                compressedFormat += "pvrtc "), console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
                console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
                console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
                console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("MAX_UNIFORM_BUFFER_BINDINGS: " + this._maxUniformBufferBindings), 
                console.info("DEPTH_BITS: " + this._depthBits), console.info("STENCIL_BITS: " + this._stencilBits), 
                this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
                console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
                this.initStates(gl), this._queue = this.createQueue({
                    type: GFXQueueType.GRAPHICS
                }), this._mainWindow = this.createWindow({
                    title: this._webGL2RC.canvas.title,
                    left: this._webGL2RC.canvas.offsetLeft,
                    top: this._webGL2RC.canvas.offsetTop,
                    width: this._webGL2RC.drawingBufferWidth,
                    height: this._webGL2RC.drawingBufferHeight,
                    colorFmt: this._colorFmt,
                    depthStencilFmt: this._depthStencilFmt
                }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGL2GFXTexture(this), 
                this.nullTex2D.initialize({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: 2,
                    height: 2,
                    flags: GFXTextureFlagBit.GEN_MIPMAP
                }), this.nullTexCube = new WebGL2GFXTexture(this), this.nullTexCube.initialize({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: 2,
                    height: 2,
                    arrayLayer: 6,
                    flags: GFXTextureFlagBit.CUBEMAP | GFXTextureFlagBit.GEN_MIPMAP
                });
                var nullTexRegion = {
                    buffOffset: 0,
                    buffStride: 0,
                    buffTexHeight: 0,
                    texOffset: {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    texExtent: {
                        width: 2,
                        height: 2,
                        depth: 1
                    },
                    texSubres: {
                        baseMipLevel: 0,
                        levelCount: 1,
                        baseArrayLayer: 0,
                        layerCount: 1
                    }
                }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
                return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
                nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
                !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
                this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
                this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
                this._queue && (this._queue.destroy(), this._queue = null), this._webGL2RC = null;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
                this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
            }
        }, {
            key: "createBuffer",
            value: function createBuffer(info) {
                var buffer = new WebGL2GFXBuffer(this);
                return buffer.initialize(info), buffer;
            }
        }, {
            key: "createTexture",
            value: function createTexture(info) {
                var texture = new WebGL2GFXTexture(this);
                return texture.initialize(info), texture;
            }
        }, {
            key: "createTextureView",
            value: function createTextureView(info) {
                var texView = new WebGL2GFXTextureView(this);
                return texView.initialize(info), texView;
            }
        }, {
            key: "createSampler",
            value: function createSampler(info) {
                var sampler = new WebGL2GFXSampler(this);
                return sampler.initialize(info), sampler;
            }
        }, {
            key: "createBindingLayout",
            value: function createBindingLayout(info) {
                var bindingLayout = new WebGL2GFXBindingLayout(this);
                return bindingLayout.initialize(info), bindingLayout;
            }
        }, {
            key: "createShader",
            value: function createShader(info) {
                var shader = new WebGL2GFXShader(this);
                return shader.initialize(info), shader;
            }
        }, {
            key: "createInputAssembler",
            value: function createInputAssembler(info) {
                var inputAssembler = new WebGL2GFXInputAssembler(this);
                return inputAssembler.initialize(info), inputAssembler;
            }
        }, {
            key: "createRenderPass",
            value: function createRenderPass(info) {
                var renderPass = new WebGL2GFXRenderPass(this);
                return renderPass.initialize(info), renderPass;
            }
        }, {
            key: "createFramebuffer",
            value: function createFramebuffer(info) {
                var framebuffer = new WebGL2GFXFramebuffer(this);
                return framebuffer.initialize(info), framebuffer;
            }
        }, {
            key: "createPipelineLayout",
            value: function createPipelineLayout(info) {
                var pipelineLayout = new WebGL2GFXPipelineLayout(this);
                return pipelineLayout.initialize(info), pipelineLayout;
            }
        }, {
            key: "createPipelineState",
            value: function createPipelineState(info) {
                var pipelineState = new WebGL2GFXPipelineState(this);
                return pipelineState.initialize(info), pipelineState;
            }
        }, {
            key: "createCommandAllocator",
            value: function createCommandAllocator(info) {
                var cmdAllocator = new WebGL2GFXCommandAllocator(this);
                return cmdAllocator.initialize(info), cmdAllocator;
            }
        }, {
            key: "createCommandBuffer",
            value: function createCommandBuffer(info) {
                var cmdBuff = new WebGL2GFXCommandBuffer(this);
                return cmdBuff.initialize(info), cmdBuff;
            }
        }, {
            key: "createQueue",
            value: function createQueue(info) {
                var queue = new WebGL2GFXQueue(this);
                return queue.initialize(info), queue;
            }
        }, {
            key: "createWindow",
            value: function createWindow(info) {
                var window = new WebGL2GFXWindow(this);
                return window.initialize(info), window;
            }
        }, {
            key: "present",
            value: function present() {
                this._cmdAllocator.releaseCmds();
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
            }
        }, {
            key: "copyBuffersToTexture",
            value: function copyBuffersToTexture(buffers, texture, regions) {
                WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
            }
        }, {
            key: "copyTexImagesToTexture",
            value: function copyTexImagesToTexture(texImages, texture, regions) {
                !function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                    var gl = device.gl, m = 0, n = 0, f = 0;
                    switch (gpuTexture.glTarget) {
                      case WebGL2RenderingContext.TEXTURE_2D:
                        var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, gpuTexture.glTexture), 
                        glTexUnit.glTexture = gpuTexture.glTexture);
                        var _iterator16 = regions, _isArray16 = Array.isArray(_iterator16), _i25 = 0;
                        for (_iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ;) {
                            var _ref16;
                            if (_isArray16) {
                                if (_i25 >= _iterator16.length) break;
                                _ref16 = _iterator16[_i25++];
                            } else {
                                if ((_i25 = _iterator16.next()).done) break;
                                _ref16 = _i25.value;
                            }
                            var region = _ref16;
                            for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(WebGL2RenderingContext.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                        }
                        break;

                      case WebGL2RenderingContext.TEXTURE_CUBE_MAP:
                        var _glTexUnit3 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                        _glTexUnit3.glTexture !== gpuTexture.glTexture && (gl.bindTexture(WebGL2RenderingContext.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit3.glTexture = gpuTexture.glTexture);
                        var _iterator17 = regions, _isArray17 = Array.isArray(_iterator17), _i26 = 0;
                        for (_iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator](); ;) {
                            var _ref17;
                            if (_isArray17) {
                                if (_i26 >= _iterator17.length) break;
                                _ref17 = _iterator17[_i26++];
                            } else {
                                if ((_i26 = _iterator17.next()).done) break;
                                _ref17 = _i26.value;
                            }
                            var _region = _ref17, fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                            for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                                var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                                for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(WebGL2RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                            }
                        }
                        break;

                      default:
                        console.error("Unsupported GL texture type, copy buffer to texture failed.");
                    }
                    gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
                }(this, texImages, texture.gpuTexture, regions);
            }
        }, {
            key: "copyFramebufferToBuffer",
            value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                var gl = this._webGL2RC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
                this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(exports.GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                    gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, data);
                }
                this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, curFBO), 
                this.stateCache.glFramebuffer = curFBO);
            }
        }, {
            key: "blitFramebuffer",
            value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {
                !function WebGL2CmdFuncBlitFramebuffer(device, src, dst, srcRect, dstRect, filter) {
                    var gl = device.gl;
                    device.stateCache.glReadFramebuffer !== src.glFramebuffer && (gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src.glFramebuffer), 
                    device.stateCache.glReadFramebuffer = src.glFramebuffer);
                    var rebindFBO = dst.glFramebuffer !== device.stateCache.glFramebuffer;
                    rebindFBO && gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst.glFramebuffer);
                    var mask = 0;
                    0 < src.gpuColorViews.length && (mask |= gl.COLOR_BUFFER_BIT), src.gpuDepthStencilView && (mask |= gl.DEPTH_BUFFER_BIT, 
                    GFXFormatInfos[src.gpuDepthStencilView.format].hasStencil && (mask |= gl.STENCIL_BUFFER_BIT));
                    var glFilter = filter === GFXFilter.LINEAR || filter === GFXFilter.ANISOTROPIC ? gl.LINEAR : gl.NEAREST;
                    gl.blitFramebuffer(srcRect.x, srcRect.y, srcRect.x + srcRect.width, srcRect.y + srcRect.height, dstRect.x, dstRect.y, dstRect.x + dstRect.width, dstRect.y + dstRect.height, mask, glFilter), 
                    rebindFBO && gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }(this, src.gpuFramebuffer, dst.gpuFramebuffer, srcRect, dstRect, filter);
            }
        }, {
            key: "initStates",
            value: function initStates(gl) {
                gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
                gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), gl.polygonOffset(0, 0), 
                gl.enable(gl.DEPTH_TEST), gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 4294967295), 
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 4294967295), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
                gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
                gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
            }
        } ]), WebGL2GFXDevice;
    }();
    cc.GFXDevice = GFXDevice, cc.GFXBuffer = GFXBuffer, cc.GFXTexture = GFXTexture, 
    cc.GFXTextureView = GFXTextureView, cc.GFXSampler = GFXSampler, cc.GFXShader = GFXShader, 
    cc.GFXInputAssembler = GFXInputAssembler, cc.GFXRenderPass = GFXRenderPass, cc.GFXFramebuffer = GFXFramebuffer, 
    cc.GFXPipelineLayout = GFXPipelineLayout, cc.GFXPipelineState = GFXPipelineState, 
    cc.GFXCommandBuffer = GFXCommandBuffer, cc.GFXQueue = GFXQueue, cc.WebGLGFXDevice = WebGLGFXDevice, 
    cc.WebGL2GFXDevice = WebGL2GFXDevice, Object.assign(cc, GFXDefines);
    var RenderQueue, PassStage, CameraProjection, CameraAperture, CameraISO, CameraShutter, _stageOffset = 0, _name2stageID = {}, config_addStage = function addStage(name) {
        if (void 0 === _name2stageID[name]) {
            var stageID = 1 << _stageOffset;
            _name2stageID[name] = stageID, _stageOffset += 1;
        }
    };
    !function(RenderQueue) {
        RenderQueue[RenderQueue.OPAQUE = 0] = "OPAQUE", RenderQueue[RenderQueue.TRANSPARENT = 1] = "TRANSPARENT", 
        RenderQueue[RenderQueue.OVERLAY = 2] = "OVERLAY";
    }(RenderQueue || (RenderQueue = {})), function(PassStage) {
        PassStage[PassStage.DEFAULT = 1] = "DEFAULT", PassStage[PassStage.FORWARD = 2] = "FORWARD", 
        PassStage[PassStage.SHADOWCAST = 4] = "SHADOWCAST";
    }(PassStage || (PassStage = {})), function(CameraProjection) {
        CameraProjection[CameraProjection.ORTHO = 0] = "ORTHO", CameraProjection[CameraProjection.PERSPECTIVE = 1] = "PERSPECTIVE";
    }(CameraProjection || (CameraProjection = {})), function(CameraAperture) {
        CameraAperture[CameraAperture.F1_8 = 0] = "F1_8", CameraAperture[CameraAperture.F2_0 = 1] = "F2_0", 
        CameraAperture[CameraAperture.F2_2 = 2] = "F2_2", CameraAperture[CameraAperture.F2_5 = 3] = "F2_5", 
        CameraAperture[CameraAperture.F2_8 = 4] = "F2_8", CameraAperture[CameraAperture.F3_2 = 5] = "F3_2", 
        CameraAperture[CameraAperture.F3_5 = 6] = "F3_5", CameraAperture[CameraAperture.F4_0 = 7] = "F4_0", 
        CameraAperture[CameraAperture.F4_5 = 8] = "F4_5", CameraAperture[CameraAperture.F5_0 = 9] = "F5_0", 
        CameraAperture[CameraAperture.F5_6 = 10] = "F5_6", CameraAperture[CameraAperture.F6_3 = 11] = "F6_3", 
        CameraAperture[CameraAperture.F7_1 = 12] = "F7_1", CameraAperture[CameraAperture.F8_0 = 13] = "F8_0", 
        CameraAperture[CameraAperture.F9_0 = 14] = "F9_0", CameraAperture[CameraAperture.F10_0 = 15] = "F10_0", 
        CameraAperture[CameraAperture.F11_0 = 16] = "F11_0", CameraAperture[CameraAperture.F13_0 = 17] = "F13_0", 
        CameraAperture[CameraAperture.F14_0 = 18] = "F14_0", CameraAperture[CameraAperture.F16_0 = 19] = "F16_0", 
        CameraAperture[CameraAperture.F18_0 = 20] = "F18_0", CameraAperture[CameraAperture.F20_0 = 21] = "F20_0", 
        CameraAperture[CameraAperture.F22_0 = 22] = "F22_0";
    }(CameraAperture || (CameraAperture = {})), function(CameraISO) {
        CameraISO[CameraISO.ISO100 = 0] = "ISO100", CameraISO[CameraISO.ISO200 = 1] = "ISO200", 
        CameraISO[CameraISO.ISO400 = 2] = "ISO400", CameraISO[CameraISO.ISO800 = 3] = "ISO800";
    }(CameraISO || (CameraISO = {})), function(CameraShutter) {
        CameraShutter[CameraShutter.D1 = 0] = "D1", CameraShutter[CameraShutter.D2 = 1] = "D2", 
        CameraShutter[CameraShutter.D4 = 2] = "D4", CameraShutter[CameraShutter.D8 = 3] = "D8", 
        CameraShutter[CameraShutter.D15 = 4] = "D15", CameraShutter[CameraShutter.D30 = 5] = "D30", 
        CameraShutter[CameraShutter.D60 = 6] = "D60", CameraShutter[CameraShutter.D125 = 7] = "D125", 
        CameraShutter[CameraShutter.D250 = 8] = "D250", CameraShutter[CameraShutter.D500 = 9] = "D500", 
        CameraShutter[CameraShutter.D1000 = 10] = "D1000", CameraShutter[CameraShutter.D2000 = 11] = "D2000", 
        CameraShutter[CameraShutter.D4000 = 12] = "D4000";
    }(CameraShutter || (CameraShutter = {}));
    var FSTOPS = [ 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22 ], SHUTERS = [ 1, .5, .25, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 25e-5 ], ISOS = [ 100, 200, 400, 800 ], v_a = cc.v3(), v_b = cc.v3(), _tempMat1 = cc.mat4(), _tempMat2 = cc.mat4(), Camera = function() {
        function Camera(scene, info) {
            _classCallCheck(this, Camera), this._scene = void 0, this._name = void 0, this._enabled = !1, 
            this._proj = void 0, this._isWindowSize = !0, this._width = void 0, this._height = void 0, 
            this._screenScale = void 0, this._aspect = void 0, this._orthoHeight = 10, this._fov = toRadian(45), 
            this._nearClip = .1, this._farClip = 1e3, this._clearStencil = 0, this._clearDepth = 1, 
            this._clearFlag = GFXClearFlag.NONE, this._clearColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, this._viewport = new Rect(0, 0, 1, 1), this._isProjDirty = !0, this._matView = new Mat4(), 
            this._matProj = new Mat4(), this._matViewProj = new Mat4(), this._matViewProjInv = new Mat4(), 
            this._frustum = new frustum(), this._forward = new Vec3(), this._position = new Vec3(), 
            this._node = null, this._view = void 0, this._visibility = 0, this._priority = 0, 
            this._aperture = CameraAperture.F16_0, this._apertureValue = void 0, this._shutter = CameraShutter.D125, 
            this._shutterValue = 0, this._iso = CameraISO.ISO100, this._isoValue = 0, this._ec = 0, 
            this._exposure = 0, this._scene = scene, this._name = info.name, this._node = info.node, 
            this._proj = info.projection, this._priority = info.priority || 0, this._apertureValue = FSTOPS[this._aperture], 
            this._shutterValue = SHUTERS[this._shutter], this._isoValue = ISOS[this._iso], this.updateExposure(), 
            this._aspect = this._width = this._height = this._screenScale = 1;
            var isUI = void 0 !== info.isUI && info.isUI;
            this._view = this._scene.root.createView({
                camera: this,
                name: this._name,
                priority: this._priority,
                isUI: isUI,
                flows: info.flows
            }), this.changeTargetDisplay(info.targetDisplay), console.log("Create Camera: " + this._name + " " + this._width + " x " + this._height);
        }
        return _createClass(Camera, [ {
            key: "destroy",
            value: function destroy() {
                this._scene.root.destroyView(this._view);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._width = width, this._height = height, this._aspect = this._width / this._height, 
                this._isProjDirty = !0;
            }
        }, {
            key: "setFixedSize",
            value: function setFixedSize(width, height) {
                this._width = width, this._height = height, this._aspect = this._width / this._height, 
                this._isWindowSize = !1;
            }
        }, {
            key: "update",
            value: function update() {
                if (this._node) {
                    if (this._node.hasChanged && (mat4.invert(this._matView, this.node.worldMatrix), 
                    this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, 
                    this._node.getWorldPosition(this._position)), this._isProjDirty) if (this._proj === CameraProjection.PERSPECTIVE) mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip); else {
                        var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                        mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip);
                    }
                    (this._node.hasChanged || this._isProjDirty) && (mat4.multiply(this._matViewProj, this._matProj, this._matView), 
                    mat4.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv)), 
                    this._isProjDirty = !1;
                }
            }
        }, {
            key: "getSplitFrustum",
            value: function getSplitFrustum(out, nearClip, farClip) {
                if (this._node) {
                    if (nearClip = Math.max(nearClip, this._nearClip), farClip = Math.min(farClip, this._farClip), 
                    mat4.invert(this._matView, this.node.worldMatrix), this._proj === CameraProjection.PERSPECTIVE) mat4.perspective(_tempMat1, this._fov, this._aspect, nearClip, farClip); else {
                        var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                        mat4.ortho(_tempMat1, -x, x, -y, y, nearClip, farClip);
                    }
                    mat4.multiply(_tempMat2, _tempMat1, this._matView), mat4.invert(_tempMat1, _tempMat2), 
                    out.update(_tempMat2, _tempMat1);
                }
            }
        }, {
            key: "changeTargetDisplay",
            value: function changeTargetDisplay(val) {
                var scene = this._scene, win = scene.root.windows[val] || scene.root.mainWindow;
                win && (this._width = win.width, this._height = win.height, this._view.window = win), 
                this._aspect = this._width / this._height;
            }
        }, {
            key: "screenPointToRay",
            value: function screenPointToRay(out, x, y) {
                var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                return vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1), vec3.transformMat4(v_a, v_a, this._matViewProjInv), 
                this._proj === CameraProjection.PERSPECTIVE ? this._node && this._node.getWorldPosition(v_b) : (vec3.set(v_b, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1), 
                vec3.transformMat4(v_b, v_b, this._matViewProjInv)), ray.fromPoints(out, v_b, v_a);
            }
        }, {
            key: "screenToWorld",
            value: function screenToWorld(out, screenPos) {
                var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                return this._proj === CameraProjection.PERSPECTIVE ? (vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1), 
                vec3.transformMat4(out, out, this._matViewProjInv), this._node && this._node.getWorldPosition(v_a), 
                vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z))) : (vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 2 * screenPos.z - 1), 
                vec3.transformMat4(out, out, this.matViewProjInv)), out;
            }
        }, {
            key: "worldToScreen",
            value: function worldToScreen(out, worldPos) {
                var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
                return vec3.transformMat4(out, worldPos, this.matViewProj), out.x = cx + .5 * (out.x + 1) * cw, 
                out.y = cy + .5 * (out.y + 1) * ch, out.z = .5 * out.z + .5, out;
            }
        }, {
            key: "updateExposure",
            value: function updateExposure() {
                var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
                this._exposure = .833333 / Math.pow(2, ev100);
            }
        }, {
            key: "screenScale",
            set: function set(val) {
                this._screenScale = val;
            },
            get: function get() {
                return this._screenScale;
            }
        }, {
            key: "enabled",
            set: function set(val) {
                this._enabled = val, this._view.enable(val);
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "view",
            get: function get() {
                return this._view;
            }
        }, {
            key: "node",
            set: function set(val) {
                this._node = val;
            },
            get: function get() {
                return this._node;
            }
        }, {
            key: "isWindowSize",
            get: function get() {
                return this._isWindowSize;
            }
        }, {
            key: "orthoHeight",
            set: function set(val) {
                this._orthoHeight = val, this._isProjDirty = !0;
            },
            get: function get() {
                return this._orthoHeight;
            }
        }, {
            key: "projectionType",
            set: function set(val) {
                this._proj = val, this._isProjDirty = !0;
            },
            get: function get() {
                return this._proj;
            }
        }, {
            key: "viewport",
            set: function set(v) {
                this._viewport = v;
            },
            get: function get() {
                return this._viewport;
            }
        }, {
            key: "fov",
            set: function set(fov) {
                this._fov = fov, this._isProjDirty = !0;
            },
            get: function get() {
                return this._fov;
            }
        }, {
            key: "nearClip",
            set: function set(nearClip) {
                this._nearClip = nearClip, this._isProjDirty = !0;
            },
            get: function get() {
                return this._nearClip;
            }
        }, {
            key: "farClip",
            set: function set(farClip) {
                this._farClip = farClip, this._isProjDirty = !0;
            },
            get: function get() {
                return this._farClip;
            }
        }, {
            key: "clearColor",
            set: function set(val) {
                color4.copy(this._clearColor, val);
            },
            get: function get() {
                return this._clearColor;
            }
        }, {
            key: "clearDepth",
            set: function set(val) {
                this._clearDepth = val;
            },
            get: function get() {
                return this._clearDepth;
            }
        }, {
            key: "clearStencil",
            set: function set(val) {
                this._clearStencil = val;
            },
            get: function get() {
                return this._clearStencil;
            }
        }, {
            key: "clearFlag",
            set: function set(val) {
                this._clearFlag = val;
            },
            get: function get() {
                return this._clearFlag;
            }
        }, {
            key: "scene",
            get: function get() {
                return this._scene;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "aspect",
            get: function get() {
                return this._aspect;
            }
        }, {
            key: "matView",
            get: function get() {
                return this._matView;
            }
        }, {
            key: "matProj",
            get: function get() {
                return this._matProj;
            }
        }, {
            key: "matViewProj",
            get: function get() {
                return this._matViewProj;
            }
        }, {
            key: "matViewProjInv",
            get: function get() {
                return this._matViewProjInv;
            }
        }, {
            key: "frustum",
            get: function get() {
                return this._frustum;
            }
        }, {
            key: "forward",
            get: function get() {
                return this._forward;
            }
        }, {
            key: "position",
            get: function get() {
                return this._position;
            }
        }, {
            key: "visibility",
            set: function set(vis) {
                this._visibility = vis, this._view.visibility = vis;
            },
            get: function get() {
                return this._visibility;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._view.priority;
            },
            set: function set(val) {
                this._priority = val, this._view.priority = this._priority;
            }
        }, {
            key: "aperture",
            set: function set(val) {
                this._aperture = val, this._apertureValue = FSTOPS[this._aperture], this.updateExposure();
            },
            get: function get() {
                return this._aperture;
            }
        }, {
            key: "apertureValue",
            get: function get() {
                return this._apertureValue;
            }
        }, {
            key: "shutter",
            set: function set(val) {
                this._shutter = val, this._shutterValue = SHUTERS[this._shutter], this.updateExposure();
            },
            get: function get() {
                return this._shutter;
            }
        }, {
            key: "shutterValue",
            get: function get() {
                return this._shutterValue;
            }
        }, {
            key: "iso",
            set: function set(val) {
                this._iso = val, this._isoValue = ISOS[this._iso], this.updateExposure();
            },
            get: function get() {
                return this._iso;
            }
        }, {
            key: "isoValue",
            get: function get() {
                return this._isoValue;
            }
        }, {
            key: "ec",
            set: function set(val) {
                this._ec = val;
            },
            get: function get() {
                return this._ec;
            }
        }, {
            key: "exposure",
            get: function get() {
                return this._exposure;
            }
        } ]), Camera;
    }(), ParticleBatchModel = function(_Model) {
        function ParticleBatchModel(scene, node) {
            var _this;
            return _classCallCheck(this, ParticleBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleBatchModel).call(this, scene, node)))._capacity = void 0, 
            _this._vertAttrs = void 0, _this._vertSize = void 0, _this._vBuffer = void 0, _this._vertAttrsFloatCount = void 0, 
            _this._vdataF32 = void 0, _this._vdataUint32 = void 0, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
            _this._subMeshData = void 0, _this._mesh = void 0, _this._vertCount = 0, _this._indexCount = 0, 
            _this._type = "particle-batch", _this._capacity = 0, _this._vertAttrs = null, _this._vertSize = 0, 
            _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, _this._vdataUint32 = null, 
            _this._iaInfo = {
                drawInfos: [ {
                    vertexCount: 0,
                    firstVertex: 0,
                    indexCount: 0,
                    firstIndex: 0,
                    vertexOffset: 0,
                    instanceCount: 0,
                    firstInstance: 0
                } ]
            }, _this._iaInfoBuffer = _this._device.createBuffer({
                usage: GFXBufferUsageBit.INDIRECT,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 56,
                stride: 1
            }), _this._subMeshData = null, _this._mesh = null, _this;
        }
        return _inherits(ParticleBatchModel, Model), _createClass(ParticleBatchModel, [ {
            key: "setCapacity",
            value: function setCapacity(capacity) {
                var capChanged = this._capacity !== capacity;
                this._capacity = capacity, this._inited && capChanged && this._recreateBuffer();
            }
        }, {
            key: "setVertexAttributes",
            value: function setVertexAttributes(mesh, attrs) {
                if (this._mesh !== mesh || this._vertAttrs !== attrs) {
                    this._mesh = mesh, this._vertAttrs = attrs, this._vertSize = 0;
                    var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var a = _ref;
                        a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                    }
                    this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                    this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer), 
                    this._inited = !0;
                }
            }
        }, {
            key: "_recreateBuffer",
            value: function _recreateBuffer() {
                this._vBuffer = this._createSubMeshData(), this.getSubModel(0).updateCommandBuffer(), 
                this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
            }
        }, {
            key: "_createSubMeshData",
            value: function _createSubMeshData() {
                this._subMeshData && this.destroySubMeshData(), this._vertCount = 4, this._indexCount = 6, 
                this._mesh && (this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count, 
                this._indexCount = this._mesh.struct.primitives[0].indexView.count);
                var vertexBuffer = this._device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: this._vertSize * this._capacity * this._vertCount,
                    stride: this._vertSize
                }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                if (this._mesh) {
                    var vIdx = this._vertAttrs.findIndex(function(val) {
                        return val.name === exports.GFXAttributeName.ATTR_TEX_COORD2;
                    }), vOffset = this._vertAttrs[vIdx++].offset;
                    if (this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_POSITION, vBuffer, this._vertSize, vOffset), 
                    vOffset = this._vertAttrs[vIdx++].offset, this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_NORMAL, vBuffer, this._vertSize, vOffset), 
                    vOffset = this._vertAttrs[this._vertAttrs.findIndex(function(val) {
                        return val.name === exports.GFXAttributeName.ATTR_TEX_COORD;
                    })].offset, this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_TEX_COORD, vBuffer, this._vertSize, vOffset), 
                    vOffset = this._vertAttrs[vIdx++].offset, !this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_COLOR, vBuffer, this._vertSize, vOffset)) for (var vb = new Uint32Array(vBuffer), iVertex = 0; iVertex < this._vertCount; ++iVertex) vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = cc.Color.WHITE._val;
                    for (var vbFloatArray = new Float32Array(vBuffer), i = 1; i < this._capacity; i++) vbFloatArray.copyWithin(i * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
                }
                vertexBuffer.update(vBuffer);
                var indices = new Uint16Array(this._capacity * this._indexCount);
                if (this._mesh) {
                    this._mesh.copyIndices(0, indices);
                    for (var _i2 = 1; _i2 < this._capacity; _i2++) for (var j = 0; j < this._indexCount; j++) indices[_i2 * this._indexCount + j] = indices[j] + _i2 * this._vertCount;
                } else for (var dst = 0, _i3 = 0; _i3 < this._capacity; ++_i3) {
                    var baseIdx = 4 * _i3;
                    indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                    indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
                }
                var indexBuffer = this._device.createBuffer({
                    usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                });
                return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
                this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount, this._iaInfoBuffer.update(this._iaInfo), 
                this._subMeshData = {
                    vertexBuffers: [ vertexBuffer ],
                    indexBuffer: indexBuffer,
                    indirectBuffer: this._iaInfoBuffer,
                    attributes: this._vertAttrs,
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST
                }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
            }
        }, {
            key: "setSubModelMaterial",
            value: function setSubModelMaterial(idx, mat) {
                this.initLocalBindings(mat), _get(_getPrototypeOf(ParticleBatchModel.prototype), "setSubModelMaterial", this).call(this, idx, mat);
            }
        }, {
            key: "addParticleVertexData",
            value: function addParticleVertexData(index, pvdata) {
                if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
                    var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                    this._vdataF32[_offset++] = pvdata[0].x, this._vdataF32[_offset++] = pvdata[0].y, 
                    this._vdataF32[_offset++] = pvdata[0].z, _offset += 2, this._vdataF32[_offset++] = index, 
                    this._vdataF32[_offset++] = pvdata[2].x, this._vdataF32[_offset++] = pvdata[2].y, 
                    this._vdataUint32[_offset++] = pvdata[3];
                } else {
                    var offset = index * this._vertAttrsFloatCount;
                    this._vdataF32[offset++] = pvdata[0].x, this._vdataF32[offset++] = pvdata[0].y, 
                    this._vdataF32[offset++] = pvdata[0].z, this._vdataF32[offset++] = pvdata[1].x, 
                    this._vdataF32[offset++] = pvdata[1].y, this._vdataF32[offset++] = pvdata[1].z, 
                    this._vdataF32[offset++] = pvdata[2].x, this._vdataF32[offset++] = pvdata[2].y, 
                    this._vdataUint32[offset++] = pvdata[3], pvdata[4] && (this._vdataF32[offset++] = pvdata[4].x, 
                    this._vdataF32[offset++] = pvdata[4].y, this._vdataF32[offset++] = pvdata[4].z);
                }
            }
        }, {
            key: "updateIA",
            value: function updateIA(count) {
                this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
                this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
            }
        }, {
            key: "clear",
            value: function clear() {
                this.getSubModel(0).inputAssembler.indexCount = 0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(ParticleBatchModel.prototype), "destroy", this).call(this), 
                this._vBuffer = null, this._vdataF32 = null, this._subMeshData && this.destroySubMeshData(), 
                this._iaInfoBuffer.destroy(), this._subMeshData = null;
            }
        }, {
            key: "destroySubMeshData",
            value: function destroySubMeshData() {
                var _iterator2 = this._subMeshData.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i4 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i4++];
                    } else {
                        if ((_i4 = _iterator2.next()).done) break;
                        _ref2 = _i4.value;
                    }
                    _ref2.destroy();
                }
                this._subMeshData.indexBuffer.destroy();
            }
        } ]), ParticleBatchModel;
    }(), addStage = config_addStage;
    cc.samplerLib = samplerLib;
    var _dec$H, _dec2$l, _class$H, _class2$y, _descriptor$w, _descriptor2$n, _descriptor3$e, _descriptor4$b, _descriptor5$9, _dec$I, _dec2$m, _class$I, _class2$z, _descriptor$x, _dec3$c, _dec4$8, _dec5$5, _dec6$5, _class4$3, _class5$3, _descriptor2$o, _descriptor3$f, renderer = Object.freeze({
        addStage: addStage,
        samplerLib: samplerLib,
        createIA: function createIA(device, data) {
            if (!data.positions) return console.error("The data must have positions field"), 
            null;
            for (var verts = [], vcount = data.positions.length / 3, i = 0; i < vcount; ++i) verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]), 
            data.normals && verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]), 
            data.uvs && verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]), data.colors && verts.push(data.colors[3 * i], data.uvs[3 * i + 1], data.colors[3 * i + 2]);
            var vfmt = [];
            vfmt.push({
                name: exports.GFXAttributeName.ATTR_POSITION,
                format: exports.GFXFormat.RGB32F
            }), data.normals && vfmt.push({
                name: exports.GFXAttributeName.ATTR_NORMAL,
                format: exports.GFXFormat.RGB32F
            }), data.uvs && vfmt.push({
                name: exports.GFXAttributeName.ATTR_TEX_COORD,
                format: exports.GFXFormat.RG32F
            }), data.colors && vfmt.push({
                name: exports.GFXAttributeName.ATTR_COLOR,
                format: exports.GFXFormat.RGB32F
            });
            var vb = device.createBuffer({
                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 4 * verts.length,
                stride: 4 * verts.length / vcount
            });
            vb.update(new Float32Array(verts));
            var ib = device.createBuffer({
                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 2 * data.indices.length,
                stride: 2
            });
            return ib.update(new Uint16Array(data.indices)), device.createInputAssembler({
                attributes: vfmt,
                vertexBuffers: [ vb ],
                indexBuffer: ib
            });
        },
        get RenderQueue() {
            return RenderQueue;
        },
        get PassStage() {
            return PassStage;
        },
        Pass: Pass,
        programLib: programLib,
        Light: Light,
        Camera: Camera,
        Model: Model,
        ParticleBatchModel: ParticleBatchModel,
        SkinningModel: SkinningModel
    }), EventHandler = (_dec$H = ccclass("cc.ClickEvent"), _dec2$l = property(cc.Node), 
    _dec$H((_applyDecoratedDescriptor((_class2$y = function() {
        function EventHandler() {
            _classCallCheck(this, EventHandler), _initializerDefineProperty(this, "target", _descriptor$w, this), 
            _initializerDefineProperty(this, "component", _descriptor2$n, this), _initializerDefineProperty(this, "_componentId", _descriptor3$e, this), 
            _initializerDefineProperty(this, "handler", _descriptor4$b, this), _initializerDefineProperty(this, "customEventData", _descriptor5$9, this);
        }
        return _createClass(EventHandler, [ {
            key: "emit",
            value: function emit(params) {
                var target = this.target;
                if (cc.isValid(target)) {
                    this._genCompIdIfNeeded();
                    var compType = cc.js._getClassById(this._componentId), comp = target.getComponent(compType);
                    if (cc.isValid(comp)) {
                        var handler = comp[this.handler];
                        "function" == typeof handler && (null != this.customEventData && "" !== this.customEventData && (params = params.slice()).push(this.customEventData), 
                        handler.apply(comp, params));
                    }
                }
            }
        }, {
            key: "_compName2Id",
            value: function _compName2Id(compName) {
                var comp = cc.js.getClassByName(compName);
                return cc.js._getClassId(comp);
            }
        }, {
            key: "_compId2Name",
            value: function _compId2Name(compId) {
                var comp = cc.js._getClassById(compId);
                return cc.js.getClassName(comp);
            }
        }, {
            key: "_genCompIdIfNeeded",
            value: function _genCompIdIfNeeded() {
                this._componentId || (this._componentName = this.component, this.component = "");
            }
        }, {
            key: "_componentName",
            get: function get() {
                return this._genCompIdIfNeeded(), this._compId2Name(this._componentId);
            },
            set: function set(value) {
                this._componentId = this._compName2Id(value);
            }
        } ], [ {
            key: "emitEvents",
            value: function emitEvents(events) {
                for (var _len = arguments.length, args = new Array(1 < _len ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                for (var i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    event instanceof EventHandler && event.emit(args);
                }
            }
        } ]), EventHandler;
    }()).prototype, "_componentName", [ property ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "_componentName"), _class2$y.prototype), 
    _descriptor$w = _applyDecoratedDescriptor(_class2$y.prototype, "target", [ _dec2$l ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$n = _applyDecoratedDescriptor(_class2$y.prototype, "component", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor3$e = _applyDecoratedDescriptor(_class2$y.prototype, "_componentId", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor4$b = _applyDecoratedDescriptor(_class2$y.prototype, "handler", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$y.prototype, "customEventData", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$H = _class2$y)) || _class$H);
    cc.Component.EventHandler = EventHandler;
    var MissingClass$1 = (_dec$I = ccclass("cc.MissingClass"), _dec2$m = property({
        visible: !1,
        editorOnly: !0
    }), _dec$I((_descriptor$x = _applyDecoratedDescriptor((_class2$z = function MissingClass() {
        _classCallCheck(this, MissingClass), _initializerDefineProperty(this, "_$erialized", _descriptor$x, this);
    }).prototype, "_$erialized", [ _dec2$m ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$I = _class2$z)) || _class$I), MissingScript = (_dec3$c = ccclass("cc.MissingScript"), 
    _dec4$8 = inspector("packages://inspector/inspectors/comps/missing-script.js"), 
    _dec5$5 = property({
        serializable: !1
    }), _dec6$5 = property({
        visible: !1,
        editorOnly: !0
    }), _dec3$c(_class4$3 = _dec4$8((_descriptor2$o = _applyDecoratedDescriptor((_class5$3 = function(_Component) {
        function MissingScript() {
            var _this;
            return _classCallCheck(this, MissingScript), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MissingScript).call(this)), "compiled", _descriptor2$o, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_$erialized", _descriptor3$f, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(MissingScript, Component), _createClass(MissingScript, null, [ {
            key: "safeFindClass",
            value: function safeFindClass(id, data) {
                var cls = _getClassById(id);
                return cls || (id ? (cc.deserialize.reportMissingClass(id), MissingScript.getMissingWrapper(id, data)) : null);
            }
        }, {
            key: "getMissingWrapper",
            value: function getMissingWrapper(id, data) {
                return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass$1;
            }
        } ]), _createClass(MissingScript, [ {
            key: "onLoad",
            value: function onLoad() {
                cc.warnID(4600, this.node.name);
            }
        } ]), MissingScript;
    }()).prototype, "compiled", [ _dec5$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$f = _applyDecoratedDescriptor(_class5$3.prototype, "_$erialized", [ _dec6$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class4$3 = _class5$3)) || _class4$3) || _class4$3);
    function quadIn(k) {
        return k * k;
    }
    function quadOut(k) {
        return k * (2 - k);
    }
    function cubicIn(k) {
        return k * k * k;
    }
    function cubicOut(k) {
        return --k * k * k + 1;
    }
    function quartIn(k) {
        return k * k * k * k;
    }
    function quartOut(k) {
        return 1 - --k * k * k * k;
    }
    function quintIn(k) {
        return k * k * k * k * k;
    }
    function quintOut(k) {
        return --k * k * k * k * k + 1;
    }
    function sineIn(k) {
        return 1 - Math.cos(k * Math.PI / 2);
    }
    function sineOut(k) {
        return Math.sin(k * Math.PI / 2);
    }
    function expoIn(k) {
        return 0 === k ? 0 : Math.pow(1024, k - 1);
    }
    function expoOut(k) {
        return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
    }
    function circIn(k) {
        return 1 - Math.sqrt(1 - k * k);
    }
    function circOut(k) {
        return Math.sqrt(1 - --k * k);
    }
    function backIn(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    }
    function backOut(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    }
    function bounceIn(k) {
        return 1 - bounceOut(1 - k);
    }
    function bounceOut(k) {
        return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
    }
    cc._MissingScript = MissingScript;
    var quadOutIn = _makeOutIn(quadIn, quadOut), cubicOutIn = _makeOutIn(cubicIn, cubicOut), quartOutIn = _makeOutIn(quartIn, quartOut), quintOutIn = _makeOutIn(quintIn, quintOut), sineOutIn = _makeOutIn(sineIn, sineOut), expoOutIn = _makeOutIn(expoIn, expoOut), circOutIn = _makeOutIn(circIn, circOut), backOutIn = _makeOutIn(backIn, backOut), bounceOutIn = _makeOutIn(bounceIn, bounceOut);
    function _makeOutIn(fnIn, fnOut) {
        return function(k) {
            return k < .5 ? fnOut(2 * k) / 2 : fnIn(2 * k - 1) / 2 + .5;
        };
    }
    var easing = Object.freeze({
        constant: function constant() {
            return 0;
        },
        linear: function linear(k) {
            return k;
        },
        quadIn: quadIn,
        quadOut: quadOut,
        quadInOut: function quadInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
        },
        cubicIn: cubicIn,
        cubicOut: cubicOut,
        cubicInOut: function cubicInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
        },
        quartIn: quartIn,
        quartOut: quartOut,
        quartInOut: function quartInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
        },
        quintIn: quintIn,
        quintOut: quintOut,
        quintInOut: function quintInOut(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
        },
        sineIn: sineIn,
        sineOut: sineOut,
        sineInOut: function sineInOut(k) {
            return .5 * (1 - Math.cos(Math.PI * k));
        },
        expoIn: expoIn,
        expoOut: expoOut,
        expoInOut: function expoInOut(k) {
            return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
        },
        circIn: circIn,
        circOut: circOut,
        circInOut: function circInOut(k) {
            return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
        elasticIn: function elasticIn(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (s = !a || a < 1 ? (a = 1, .1) : .4 * Math.asin(1 / a) / (2 * Math.PI), 
            -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
        },
        elasticOut: function elasticOut(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (s = !a || a < 1 ? (a = 1, .1) : .4 * Math.asin(1 / a) / (2 * Math.PI), 
            a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
        },
        elasticInOut: function elasticInOut(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (s = !a || a < 1 ? (a = 1, .1) : .4 * Math.asin(1 / a) / (2 * Math.PI), 
            (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * .5 + 1);
        },
        backIn: backIn,
        backOut: backOut,
        backInOut: function backInOut(k) {
            var s = 2.5949095;
            return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
        bounceIn: bounceIn,
        bounceOut: bounceOut,
        bounceInOut: function bounceInOut(k) {
            return k < .5 ? .5 * bounceIn(2 * k) : .5 * bounceOut(2 * k - 1) + .5;
        },
        smooth: function smooth(k) {
            return k <= 0 ? 0 : 1 <= k ? 1 : k * k * (3 - 2 * k);
        },
        fade: function fade(k) {
            return k <= 0 ? 0 : 1 <= k ? 1 : k * k * k * (k * (6 * k - 15) + 10);
        },
        quadOutIn: quadOutIn,
        cubicOutIn: cubicOutIn,
        quartOutIn: quartOutIn,
        quintOutIn: quintOutIn,
        sineOutIn: sineOutIn,
        expoOutIn: expoOutIn,
        circOutIn: circOutIn,
        backOutIn: backOutIn,
        bounceOutIn: bounceOutIn
    });
    function bezier(C1, C2, C3, C4, t) {
        var t1 = 1 - t;
        return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
    }
    var cos = Math.cos, acos = Math.acos, max$2 = Math.max, tau = 2 * Math.PI, sqrt = Math.sqrt;
    function crt(v) {
        return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
    }
    function bezierByTime(controlPoints, x) {
        var percent = function cardano(curve, x) {
            var u1, x1, x2, x3, pa = x - 0, pb = x - curve[0], pa3 = 3 * pa, pb3 = 3 * pb, pc3 = 3 * (x - curve[2]), rd = 1 / (-pa + pb3 - pc3 + (x - 1)), a = (pa3 - 6 * pb + pc3) * rd, a3 = a * (1 / 3), b = (-pa3 + pb3) * rd, p = 1 / 3 * (3 * b - a * a), p3 = p * (1 / 3), q = (2 * a * a * a - 9 * a * b + pa * rd * 27) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
            if (discriminant < 0) {
                var mp3 = 1 / 3 * -p, r = sqrt(mp3 * mp3 * mp3), t = -q / (2 * r), phi = acos(t < -1 ? -1 : 1 < t ? 1 : t), t1 = 2 * crt(r);
                return x1 = t1 * cos(phi * (1 / 3)) - a3, x2 = t1 * cos((phi + tau) * (1 / 3)) - a3, 
                x3 = t1 * cos((phi + 2 * tau) * (1 / 3)) - a3, 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x1, x2, x3) : max$2(x1, x2) : 0 <= x3 && x3 <= 1 ? max$2(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x2, x3) : x2 : x3;
            }
            if (0 === discriminant) return x2 = -(u1 = q2 < 0 ? crt(-q2) : -crt(q2)) - a3, 0 <= (x1 = 2 * u1 - a3) && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max$2(x1, x2) : x1 : x2;
            var sd = sqrt(discriminant);
            return x1 = (u1 = crt(-q2 + sd)) - crt(q2 + sd) - a3;
        }(controlPoints, x), t1 = 1 - percent;
        return 0 * t1 * t1 * t1 + 3 * controlPoints[1] * percent * t1 * t1 + 3 * controlPoints[3] * percent * percent * t1 + 1 * percent * percent * percent;
    }
    var WrapModeMask, WrapMode$2, EPSILON$1 = 1e-6;
    function binarySearchEpsilon(array, value) {
        for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
            var test = array[m];
            if (value + EPSILON$1 < test) h = m - 1; else {
                if (!(test < value - EPSILON$1)) return m;
                l = m + 1;
            }
        }
        return ~l;
    }
    function additive3D(value, weight, propertyBlendState) {
        return propertyBlendState.value || (propertyBlendState.value = new Vec3()), 0 === propertyBlendState.weight && vec3.zero(propertyBlendState.value), 
        0 === weight ? propertyBlendState.value : 1 === weight ? vec3.copy(propertyBlendState.value, value) : vec3.scaleAndAdd(propertyBlendState.value, propertyBlendState.value, value, weight);
    }
    function additiveQuat(value, weight, propertyBlendState) {
        if (propertyBlendState.value || (propertyBlendState.value = new Quat()), 0 === propertyBlendState.weight && quat.identity(propertyBlendState.value), 
        0 === weight) return propertyBlendState.value;
        if (1 === weight) return quat.copy(propertyBlendState.value, value);
        var t = weight / (propertyBlendState.weight + weight);
        return quat.slerp(propertyBlendState.value, propertyBlendState.value, value, t);
    }
    !function(WrapModeMask) {
        WrapModeMask[WrapModeMask.Loop = 2] = "Loop", WrapModeMask[WrapModeMask.ShouldWrap = 4] = "ShouldWrap", 
        WrapModeMask[WrapModeMask.PingPong = 22] = "PingPong", WrapModeMask[WrapModeMask.Reverse = 36] = "Reverse";
    }(WrapModeMask || (WrapModeMask = {})), function(WrapMode) {
        WrapMode[WrapMode.Default = 0] = "Default", WrapMode[WrapMode.Normal = 1] = "Normal", 
        WrapMode[WrapMode.Reverse = WrapModeMask.Reverse] = "Reverse", WrapMode[WrapMode.Loop = WrapModeMask.Loop] = "Loop", 
        WrapMode[WrapMode.LoopReverse = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse", 
        WrapMode[WrapMode.PingPong = WrapModeMask.PingPong] = "PingPong", WrapMode[WrapMode.PingPongReverse = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
    }(WrapMode$2 || (WrapMode$2 = {})), ccenum(WrapMode$2);
    var _class$J, _class2$A, _descriptor$y, _descriptor2$p, _descriptor3$g, _class3$e, _temp$F, WrappedInfo = function() {
        function WrappedInfo(info) {
            _classCallCheck(this, WrappedInfo), this.ratio = 0, this.time = 0, this.direction = 1, 
            this.stopped = !0, this.iterations = 0, this.frameIndex = void 0, info && this.set(info);
        }
        return _createClass(WrappedInfo, [ {
            key: "set",
            value: function set(info) {
                this.ratio = info.ratio, this.time = info.time, this.direction = info.direction, 
                this.stopped = info.stopped, this.iterations = info.iterations, this.frameIndex = info.frameIndex;
            }
        } ]), WrappedInfo;
    }();
    var RatioSampler = function() {
        function RatioSampler(ratios) {
            var currRatioDif, lastRatioDif;
            _classCallCheck(this, RatioSampler), this.ratios = void 0;
            for (var canOptimize = !(this._findRatio = void 0), i = 1, l = (this.ratios = ratios).length; i < l; i++) if (currRatioDif = ratios[i] - ratios[i - 1], 
            1 === i) lastRatioDif = currRatioDif; else if (1e-6 < Math.abs(currRatioDif - lastRatioDif)) {
                canOptimize = !1;
                break;
            }
            this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
        }
        return _createClass(RatioSampler, [ {
            key: "sample",
            value: function sample(ratio) {
                return this._findRatio(this.ratios, ratio);
            }
        } ]), RatioSampler;
    }(), AnimCurve = ccclass("cc.AnimCurve")((_temp$F = _class3$e = function() {
        function AnimCurve(propertyCurveData, propertyName, duration, isNode) {
            _classCallCheck(this, AnimCurve), _initializerDefineProperty(this, "types", _descriptor$y, this), 
            _initializerDefineProperty(this, "type", _descriptor2$p, this), this._blendFunction = void 0, 
            _initializerDefineProperty(this, "_values", _descriptor3$g, this), this._lerp = void 0, 
            this._stepfiedValues = void 0, this._duration = void 0, this._duration = duration, 
            this._values = propertyCurveData.values;
            var getCurveType = function getCurveType(easingMethod) {
                return "string" == typeof easingMethod ? easingMethod : Array.isArray(easingMethod) ? easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3] ? AnimCurve.Linear : AnimCurve.Bezier(easingMethod) : AnimCurve.Linear;
            };
            void 0 !== propertyCurveData.easingMethod ? this.type = getCurveType(propertyCurveData.easingMethod) : void 0 !== propertyCurveData.easingMethods ? this.types = propertyCurveData.easingMethods.map(getCurveType) : this.type = null;
            var firstValue = propertyCurveData.values[0];
            if ((void 0 === propertyCurveData.interpolate || propertyCurveData.interpolate) && (this._lerp = selectLerpFx(firstValue)), 
            isNode) switch (propertyName) {
              case "position":
              case "scale":
                this._blendFunction = additive3D;
                break;

              case "rotation":
                this._blendFunction = additiveQuat;
            }
        }
        return _createClass(AnimCurve, null, [ {
            key: "Bezier",
            value: function Bezier(controlPoints) {
                return controlPoints;
            }
        } ]), _createClass(AnimCurve, [ {
            key: "hasLerp",
            value: function hasLerp() {
                return !!this._lerp;
            }
        }, {
            key: "valueAt",
            value: function valueAt(index) {
                var value = this._values[index];
                return value && value.getNoLerp ? value.getNoLerp() : value;
            }
        }, {
            key: "valueBetween",
            value: function valueBetween(ratio, from, fromRatio, to, toRatio) {
                if (!this._lerp) return this.valueAt(from);
                var type = this.types ? this.types[from] : this.type, dRatio = toRatio - fromRatio, ratioBetweenFrames = (ratio - fromRatio) / dRatio;
                type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
                var fromVal = this._values[from], toVal = this._values[to];
                return this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
            }
        }, {
            key: "empty",
            value: function empty() {
                return 0 === this._values.length;
            }
        } ]), AnimCurve;
    }(), _class3$e.Linear = null, _descriptor$y = _applyDecoratedDescriptor((_class2$A = _temp$F).prototype, "types", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {}
    }), _descriptor2$p = _applyDecoratedDescriptor(_class2$A.prototype, "type", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$g = _applyDecoratedDescriptor(_class2$A.prototype, "_values", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _class$J = _class2$A)) || _class$J, EventInfo = function() {
        function EventInfo() {
            _classCallCheck(this, EventInfo), this.events = [];
        }
        return _createClass(EventInfo, [ {
            key: "add",
            value: function add(func, params) {
                this.events.push({
                    func: func || "",
                    params: params || []
                });
            }
        } ]), EventInfo;
    }();
    function computeRatioByType(ratio, type) {
        if ("string" == typeof type) {
            var func = easing[type];
            func ? ratio = func(ratio) : errorID(3906, type);
        } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
        return ratio;
    }
    function quickFindIndex(ratios, ratio) {
        var length = ratios.length - 1;
        if (0 === length) return 0;
        var start = ratios[0];
        if (ratio < start) return 0;
        var end = ratios[length];
        if (end < ratio) return length;
        var index = (ratio = (ratio - start) / (end - start)) / (1 / length), floorIndex = 0 | index;
        return index - floorIndex < 1e-6 ? floorIndex : floorIndex + 1 - index < 1e-6 ? floorIndex + 1 : ~(floorIndex + 1);
    }
    var selectLerpFx = function() {
        function callLerpable(from, to, t, dt) {
            return from.lerp(to, t, dt);
        }
        var lerpNumber = lerp;
        return function(value) {
            if (null !== value) {
                if ("number" == typeof value) return lerpNumber;
                if ("object" === _typeof(value) && value.constructor) {
                    if (value instanceof ValueType) return function makeValueTypeLerpFx(constructor) {
                        var tempValue = new constructor();
                        return function(from, to, ratio) {
                            return from.lerp(to, ratio, tempValue);
                        };
                    }(value.constructor);
                    if (value.constructor === Number) return lerpNumber;
                    if (function isLerpable(object) {
                        return "function" == typeof object.lerp;
                    }(value)) return callLerpable;
                }
            }
        };
    }(), Curve = function() {
        function Curve() {
            var points = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [];
            _classCallCheck(this, Curve), this.points = points, this.beziers = [], this.ratios = [], 
            this.progresses = [], this.length = 0, this.computeBeziers();
        }
        return _createClass(Curve, [ {
            key: "computeBeziers",
            value: function computeBeziers() {
                this.beziers.length = 0, this.ratios.length = 0, this.progresses.length = 0, this.length = 0;
                for (var i = 1; i < this.points.length; i++) {
                    var startPoint = this.points[i - 1], endPoint = this.points[i], _bezier = new Bezier();
                    _bezier.start = startPoint.pos, _bezier.startCtrlPoint = startPoint.out, _bezier.end = endPoint.pos, 
                    _bezier.endCtrlPoint = endPoint.in, this.beziers.push(_bezier), this.length += _bezier.getLength();
                }
                for (var current = 0, _i = 0; _i < this.beziers.length; _i++) {
                    var _bezier2 = this.beziers[_i];
                    this.ratios[_i] = _bezier2.getLength() / this.length, this.progresses[_i] = current += this.ratios[_i];
                }
                return this.beziers;
            }
        } ]), Curve;
    }(), Bezier = function() {
        function Bezier() {
            _classCallCheck(this, Bezier), this.start = new Vec2(), this.end = new Vec2(), this.startCtrlPoint = new Vec2(), 
            this.endCtrlPoint = new Vec2(), this.__arcLengthDivisions = void 0, this.cacheArcLengths = void 0;
        }
        return _createClass(Bezier, [ {
            key: "getPointAt",
            value: function getPointAt(u) {
                var t = this.getUtoTmapping(u);
                return this.getPoint(t);
            }
        }, {
            key: "getPoint",
            value: function getPoint(t) {
                var x = bezier(this.start.x, this.startCtrlPoint.x, this.endCtrlPoint.x, this.end.x, t), y = bezier(this.start.y, this.startCtrlPoint.y, this.endCtrlPoint.y, this.end.y, t);
                return new Vec2(x, y);
            }
        }, {
            key: "getLength",
            value: function getLength() {
                var lengths = this.getLengths();
                return lengths[lengths.length - 1];
            }
        }, {
            key: "getLengths",
            value: function getLengths(divisions) {
                if (divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), 
                this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1) return this.cacheArcLengths;
                var current, p, cache = [], last = this.getPoint(0), vector = new Vec2(), sum = 0;
                for (cache.push(0), p = 1; p <= divisions; p++) current = this.getPoint(p / divisions), 
                vector.x = last.x - current.x, vector.y = last.y - current.y, sum += vector.mag(), 
                cache.push(sum), last = current;
                return this.cacheArcLengths = cache;
            }
        }, {
            key: "getUtoTmapping",
            value: function getUtoTmapping(u, distance) {
                var targetArcLength, arcLengths = this.getLengths(), i = 0, il = arcLengths.length;
                targetArcLength = distance || u * arcLengths[il - 1];
                for (var comparison, low = 0, high = il - 1; low <= high; ) if ((comparison = arcLengths[i = Math.floor(low + (high - low) / 2)] - targetArcLength) < 0) low = i + 1; else {
                    if (!(0 < comparison)) {
                        high = i;
                        break;
                    }
                    high = i - 1;
                }
                if (arcLengths[i = high] === targetArcLength) return i / (il - 1);
                var lengthBefore = arcLengths[i];
                return (i + (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) / (il - 1);
            }
        } ]), Bezier;
    }();
    function checkMotionPath(motionPath) {
        if (!Array.isArray(motionPath)) return !1;
        for (var i = 0, l = motionPath.length; i < l; i++) {
            var controls = motionPath[i];
            if (!Array.isArray(controls) || 6 !== controls.length) return !1;
        }
        return !0;
    }
    var _dec$K, _dec2$n, _class$K, _class2$B, _descriptor$z, _descriptor2$q, _descriptor3$h, _descriptor4$c, _descriptor5$a, _descriptor6$6, _descriptor7$5, _descriptor8$5, _class3$f, _temp$G;
    var AnimationClip = (_dec$K = ccclass("cc.AnimationClip"), _dec2$n = property({
        visible: !1
    }), _dec$K((_temp$G = _class3$f = function(_Asset) {
        function AnimationClip() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, AnimationClip);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "sample", _descriptor$z, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "speed", _descriptor2$q, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "wrapMode", _descriptor3$h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "curveDatas", _descriptor4$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "events", _descriptor5$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_duration", _descriptor6$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_keys", _descriptor7$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._ratioSamplers = [], _this._propertyCurves = void 0, _this._runtimeEvents = void 0, 
            _this.frameRate = 0, _initializerDefineProperty(_this, "_stepness", _descriptor8$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(AnimationClip, Asset), _createClass(AnimationClip, [ {
            key: "onLoad",
            value: function onLoad() {
                this.duration = this._duration, this.speed = this.speed, this.wrapMode = this.wrapMode, 
                this.frameRate = this.sample;
            }
        }, {
            key: "updateCurveDatas",
            value: function updateCurveDatas() {
                delete this._propertyCurves;
            }
        }, {
            key: "updateEventDatas",
            value: function updateEventDatas() {
                delete this._runtimeEvents;
            }
        }, {
            key: "getEventGroupIndexAtRatio",
            value: function getEventGroupIndexAtRatio(ratio) {
                return this._runtimeEvents || this._createRuntimeEvents(), function binarySearchEpsilon$1(array, value) {
                    for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                        var test = array[m];
                        if (value + 1e-6 < test) h = m - 1; else {
                            if (!(test < value - 1e-6)) return m;
                            l = m + 1;
                        }
                    }
                    return ~l;
                }(this._runtimeEvents.ratios, ratio);
            }
        }, {
            key: "hasEvents",
            value: function hasEvents() {
                return 0 !== this.events.length;
            }
        }, {
            key: "_createPropertyCurves",
            value: function _createPropertyCurves() {
                var _this2 = this;
                this._ratioSamplers = this._keys.map(function(keys) {
                    return new RatioSampler(keys.map(function(key) {
                        return key / _this2._duration;
                    }));
                }), this._propertyCurves = [];
                for (var _arr = Object.keys(this.curveDatas), _i = 0; _i < _arr.length; _i++) {
                    var curveTargetPath = _arr[_i], nodeData = this.curveDatas[curveTargetPath];
                    if (nodeData.props) for (var _arr2 = Object.keys(nodeData.props), _i2 = 0; _i2 < _arr2.length; _i2++) {
                        var nodePropertyName = _arr2[_i2], propertyCurveData = nodeData.props[nodePropertyName];
                        this._propertyCurves.push({
                            path: curveTargetPath,
                            propertyName: nodePropertyName,
                            curve: new AnimCurve(propertyCurveData, nodePropertyName, this._duration, !0),
                            sampler: 0 <= propertyCurveData.keys ? this._ratioSamplers[propertyCurveData.keys] : null
                        });
                    }
                    if (nodeData.comps) for (var _arr3 = Object.keys(nodeData.comps), _i3 = 0; _i3 < _arr3.length; _i3++) for (var _componentName = _arr3[_i3], componentData = nodeData.comps[_componentName], _arr4 = Object.keys(componentData), _i4 = 0; _i4 < _arr4.length; _i4++) {
                        var componentPropertyName = _arr4[_i4], _propertyCurveData = componentData[componentPropertyName];
                        this._propertyCurves.push({
                            path: curveTargetPath,
                            component: _componentName,
                            propertyName: componentPropertyName,
                            curve: new AnimCurve(_propertyCurveData, componentPropertyName, this._duration, !1),
                            sampler: 0 <= _propertyCurveData.keys ? this._ratioSamplers[_propertyCurveData.keys] : null
                        });
                    }
                }
                this._applyStepness();
            }
        }, {
            key: "_createRuntimeEvents",
            value: function _createRuntimeEvents() {
                var _this3 = this;
                var ratios = [], eventGroups = [], _loop = function _loop() {
                    if (_isArray) {
                        if (_i5 >= _iterator.length) return "break";
                        _ref = _iterator[_i5++];
                    } else {
                        if ((_i5 = _iterator.next()).done) return "break";
                        _ref = _i5.value;
                    }
                    var eventData = _ref, ratio = eventData.frame / _this3._duration, i = ratios.findIndex(function(r) {
                        return r === ratio;
                    });
                    i < 0 && (i = ratios.length, ratios.push(ratio), eventGroups.push({
                        events: []
                    })), eventGroups[i].events.push({
                        functionName: eventData.func,
                        parameters: eventData.params
                    });
                }, _iterator = this.events.sort(function(a, b) {
                    return a.frame - b.frame;
                }), _isArray = Array.isArray(_iterator), _i5 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if ("break" === _loop()) break;
                }
                this._runtimeEvents = {
                    ratios: ratios,
                    eventGroups: eventGroups
                };
            }
        }, {
            key: "_applyStepness",
            value: function _applyStepness() {
                this._propertyCurves;
            }
        }, {
            key: "duration",
            get: function get() {
                return this._duration;
            },
            set: function set(value) {
                this._duration = value;
            }
        }, {
            key: "keys",
            get: function get() {
                return this._keys;
            },
            set: function set(value) {
                this._keys = value;
            }
        }, {
            key: "propertyCurves",
            get: function get() {
                return this._propertyCurves || this._createPropertyCurves(), this._propertyCurves;
            }
        }, {
            key: "eventGroups",
            get: function get() {
                return this._runtimeEvents || this._createRuntimeEvents(), this._runtimeEvents.eventGroups;
            }
        }, {
            key: "stepness",
            get: function get() {
                return this._stepness;
            },
            set: function set(value) {
                this._stepness = value, this._applyStepness();
            }
        } ], [ {
            key: "createWithSpriteFrames",
            value: function createWithSpriteFrames(spriteFrames, sample) {
                if (!Array.isArray(spriteFrames)) return errorID(3905), null;
                var clip = new AnimationClip();
                clip.sample = sample || clip.sample, clip.duration = spriteFrames.length / clip.sample;
                for (var step = 1 / clip.sample, keys = new Array(spriteFrames.length), values = new Array(keys.length), i = 0; i < spriteFrames.length; i++) keys[i] = i * step, 
                values[i] = spriteFrames[i];
                return clip.keys = [ keys ], clip.curveDatas = {
                    "/": {
                        comps: {
                            "cc.Sprite": {
                                spriteFrame: {
                                    keys: 0,
                                    values: values
                                }
                            }
                        }
                    }
                }, clip;
            }
        } ]), AnimationClip;
    }(), _class3$f.WrapMode = WrapMode$2, _descriptor$z = _applyDecoratedDescriptor((_class2$B = _temp$G).prototype, "sample", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 60;
        }
    }), _descriptor2$q = _applyDecoratedDescriptor(_class2$B.prototype, "speed", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor3$h = _applyDecoratedDescriptor(_class2$B.prototype, "wrapMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return WrapMode$2.Normal;
        }
    }), _descriptor4$c = _applyDecoratedDescriptor(_class2$B.prototype, "curveDatas", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return {};
        }
    }), _descriptor5$a = _applyDecoratedDescriptor(_class2$B.prototype, "events", [ _dec2$n ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor6$6 = _applyDecoratedDescriptor(_class2$B.prototype, "_duration", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$B.prototype, "_keys", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$B.prototype, "_stepness", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$K = _class2$B)) || _class$K);
    cc.AnimationClip = AnimationClip;
    var _class$L, AnimationBlendState = function() {
        function AnimationBlendState() {
            _classCallCheck(this, AnimationBlendState), this._blendTargets = [];
        }
        return _createClass(AnimationBlendState, [ {
            key: "refPropertyBlendTarget",
            value: function refPropertyBlendTarget(target, propertyName) {
                var targetState = this._blendTargets.find(function(x) {
                    return x.target === target;
                });
                targetState || (targetState = {
                    target: target,
                    properties: []
                }, this._blendTargets.push(targetState));
                var propertyStates = targetState.properties, propertyState = propertyStates.find(function(p) {
                    return p.name === propertyName;
                });
                return propertyState || (propertyState = {
                    name: propertyName,
                    weight: 0,
                    value: void 0,
                    refCount: 0
                }, propertyStates.push(propertyState)), ++propertyState.refCount, propertyState;
            }
        }, {
            key: "derefPropertyBlendTarget",
            value: function derefPropertyBlendTarget(target, propertyName) {
                var iTargetState = this._blendTargets.findIndex(function(x) {
                    return x.target === target;
                });
                if (!(iTargetState < 0)) {
                    var propertyStates = this._blendTargets[iTargetState].properties, iPropertyState = propertyStates.findIndex(function(p) {
                        return p.name === propertyName;
                    });
                    if (!(iPropertyState < 0)) {
                        var propertyState = propertyStates[iPropertyState];
                        --propertyState.refCount, 0 < propertyState.refCount || (2 <= propertyStates.length ? propertyStates.splice(iPropertyState, 1) : this._blendTargets.splice(iTargetState, 1));
                    }
                }
            }
        }, {
            key: "apply",
            value: function apply() {
                var _iterator = this._blendTargets, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var targetState = _ref, _target = targetState.target, _iterator2 = targetState.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var p = _ref2;
                        0 !== p.weight && (_target[p.name] = p.value);
                    }
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                var _iterator3 = this._blendTargets, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _iterator4 = _ref3.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        _ref4.weight = 0;
                    }
                }
            }
        } ]), AnimationBlendState;
    }(), AnimationManager = ccclass(_class$L = function() {
        function AnimationManager() {
            _classCallCheck(this, AnimationManager), this._anims = new MutableForwardIterator([]), 
            this._delayEvents = [], this._blendState = new AnimationBlendState(), this._crossFades = [], 
            cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        }
        return _createClass(AnimationManager, [ {
            key: "addCrossFade",
            value: function addCrossFade(crossFade) {
                this._crossFades.push(crossFade);
            }
        }, {
            key: "removeCrossFade",
            value: function removeCrossFade(crossFade) {
                remove(this._crossFades, crossFade);
            }
        }, {
            key: "update",
            value: function update(dt) {
                var _iterator = this._crossFades, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.update(dt);
                }
                this._blendState.clear();
                var iterator = this._anims, array = iterator.array;
                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                    var anim = array[iterator.i];
                    anim.isPlaying && !anim.isPaused && anim.update(dt);
                }
                this._blendState.apply();
                for (var events = this._delayEvents, i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    event.target[event.func].apply(event.target, event.args);
                }
                events.length = 0;
            }
        }, {
            key: "destruct",
            value: function destruct() {}
        }, {
            key: "addAnimation",
            value: function addAnimation(anim) {
                -1 === this._anims.array.indexOf(anim) && (anim.attachToBlendState(this._blendState), 
                this._anims.push(anim));
            }
        }, {
            key: "removeAnimation",
            value: function removeAnimation(anim) {
                var index = this._anims.array.indexOf(anim);
                0 <= index ? (anim.detachFromBlendState(this._blendState), this._anims.fastRemoveAt(index)) : errorID(3907);
            }
        }, {
            key: "pushDelayEvent",
            value: function pushDelayEvent(target, func, args) {
                this._delayEvents.push({
                    target: target,
                    func: func,
                    args: args
                });
            }
        }, {
            key: "blendState",
            get: function get() {
                return this._blendState;
            }
        } ]), AnimationManager;
    }()) || _class$L;
    cc.AnimationManager = AnimationManager;
    var Playable = function() {
        function Playable() {
            _classCallCheck(this, Playable), this._isPlaying = !1, this._isPaused = !1, this._stepOnce = !1;
        }
        return _createClass(Playable, [ {
            key: "play",
            value: function play() {
                this._isPlaying ? this._isPaused ? (this._isPaused = !1, this.onResume()) : this.onError(getError(3912)) : (this._isPlaying = !0, 
                this.onPlay());
            }
        }, {
            key: "stop",
            value: function stop() {
                this._isPlaying && (this._isPlaying = !1, this.onStop(), this._isPaused = !1);
            }
        }, {
            key: "pause",
            value: function pause() {
                this._isPlaying && !this._isPaused && (this._isPaused = !0, this.onPause());
            }
        }, {
            key: "resume",
            value: function resume() {
                this._isPlaying && this._isPaused && (this._isPaused = !1, this.onResume());
            }
        }, {
            key: "step",
            value: function step() {
                this.pause(), this._stepOnce = !0, this._isPlaying || this.play();
            }
        }, {
            key: "update",
            value: function update(deltaTime) {}
        }, {
            key: "onPlay",
            value: function onPlay() {}
        }, {
            key: "onPause",
            value: function onPause() {}
        }, {
            key: "onResume",
            value: function onResume() {}
        }, {
            key: "onStop",
            value: function onStop() {}
        }, {
            key: "onError",
            value: function onError(message) {}
        }, {
            key: "isPlaying",
            get: function get() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function get() {
                return this._isPaused;
            }
        } ]), Playable;
    }();
    var _class$M, _descriptor$A, _descriptor2$r, _descriptor3$i, _class4$4, AnimationState = function(_Playable) {
        function AnimationState(clip, name) {
            var _this;
            return _classCallCheck(this, AnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationState).call(this))).duration = 1, 
            _this.speed = 1, _this.time = 0, _this.weight = 0, _this.frameRate = 0, _this._lastframeEventOn = !1, 
            _this._wrapMode = WrapMode$2.Normal, _this._repeatCount = 1, _this._currentFramePlayed = !1, 
            _this._delay = 0, _this._delayTime = 0, _this._wrappedInfo = new WrappedInfo(), 
            _this._lastWrapInfo = null, _this._lastWrapInfoEvent = null, _this._process = _this.process, 
            _this._target = null, _this._targetNode = null, _this._clip = void 0, _this._name = void 0, 
            _this._lastIterations = void 0, _this._samplerSharedGroups = [], _this._curveLoaded = !1, 
            _this._ignoreIndex = -1, _this._clip = clip, _this._name = name || clip && clip.name, 
            _this;
        }
        return _inherits(AnimationState, Playable), _createClass(AnimationState, [ {
            key: "clip",
            get: function get() {
                return this._clip;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "length",
            get: function get() {
                return this.duration;
            }
        }, {
            key: "wrapMode",
            get: function get() {
                return this._wrapMode;
            },
            set: function set(value) {
                this._wrapMode = value, this.time = 0, value & WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
            }
        }, {
            key: "repeatCount",
            get: function get() {
                return this._repeatCount;
            },
            set: function set(value) {
                this._repeatCount = value;
                var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap, reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
                this._process = value !== 1 / 0 || shouldWrap || reverse ? this.process : this.simpleProcess;
            }
        }, {
            key: "delay",
            get: function get() {
                return this._delay;
            },
            set: function set(value) {
                this._delayTime = this._delay = value;
            }
        } ]), _createClass(AnimationState, [ {
            key: "initialize",
            value: function initialize(root) {
                var _this2 = this;
                this._curveLoaded = !0, this._samplerSharedGroups.length = 0, this._targetNode = root;
                var clip = this._clip;
                this.duration = clip.duration, this.speed = clip.speed, this.wrapMode = clip.wrapMode, 
                this.frameRate = clip.sample, (this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
                var _loop2 = function _loop2() {
                    if (_isArray) {
                        if (_i >= _iterator.length) return "break";
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) return "break";
                        _ref = _i.value;
                    }
                    var propertyCurve = _ref, targetNode = root.getChildByPath(propertyCurve.path);
                    if (!targetNode) return console.warn("Target animation node referenced by path ".concat(propertyCurve.path, " is not found(from ").concat(root.name, ").")), 
                    "continue";
                    var target = targetNode;
                    if (propertyCurve.component) {
                        var targetComponent = targetNode.getComponent(propertyCurve.component);
                        if (!targetComponent) return "continue";
                        target = targetComponent;
                    }
                    var samplerSharedGroup = _this2._samplerSharedGroups.find(function(value) {
                        return value.sampler === propertyCurve.sampler;
                    });
                    samplerSharedGroup || (samplerSharedGroup = function makeSamplerSharedGroup(sampler) {
                        return {
                            sampler: sampler,
                            curves: [],
                            samplerResultCache: {
                                from: 0,
                                fromRatio: 0,
                                to: 0,
                                toRatio: 0
                            }
                        };
                    }(propertyCurve.sampler), _this2._samplerSharedGroups.push(samplerSharedGroup)), 
                    samplerSharedGroup.curves.push({
                        target: target,
                        propertyName: propertyCurve.propertyName,
                        curve: propertyCurve.curve,
                        blendTarget: null
                    });
                };
                var _iterator = clip.propertyCurves, _isArray = Array.isArray(_iterator), _i = 0;
                _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    switch (_loop2()) {
                      case "break":
                        break _loop;

                      case "continue":
                        continue;
                    }
                }
            }
        }, {
            key: "_emit",
            value: function _emit(type, state) {
                this._target && this._target.isValid && this._target.emit(type, type, state);
            }
        }, {
            key: "emit",
            value: function emit() {
                for (var args = new Array(arguments.length), i = 0, l = args.length; i < l; i++) args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
                this._target.on(type, callback, target)) : null;
            }
        }, {
            key: "once",
            value: function once(type, callback, target) {
                var _this3 = this;
                return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
                this._target.once(type, function(event) {
                    callback.call(target, event), _this3._lastframeEventOn = !1;
                })) : null;
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                this._target && this._target.isValid && ("lastframe" === type && (this._target.hasEventListener(type) || (this._lastframeEventOn = !1)), 
                this._target.off(type, callback, target));
            }
        }, {
            key: "_setEventTarget",
            value: function _setEventTarget(target) {
                this._target = target;
            }
        }, {
            key: "setTime",
            value: function setTime(time) {
                this._currentFramePlayed = !1, this.time = time || 0, this._lastWrapInfoEvent = null, 
                this._ignoreIndex = -1;
                var info = this.getWrappedInfo(time, this._wrappedInfo), direction = info.direction, frameIndex = this._clip.getEventGroupIndexAtRatio(info.ratio);
                frameIndex < 0 && (frameIndex = ~frameIndex - 1, direction < 0 && (frameIndex += 1), 
                this._ignoreIndex = frameIndex);
            }
        }, {
            key: "update",
            value: function update(delta) {
                0 < this._delayTime && (this._delayTime -= delta, 0 < this._delayTime) || (this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = !0, 
                this._process());
            }
        }, {
            key: "_needReverse",
            value: function _needReverse(currentIterations) {
                var wrapMode = this.wrapMode, needReverse = !1;
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong && (currentIterations - (0 | currentIterations) == 0 && 0 < currentIterations && (currentIterations -= 1), 
                1 & currentIterations && (needReverse = !needReverse));
                return (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needReverse = !needReverse), 
                needReverse;
            }
        }, {
            key: "getWrappedInfo",
            value: function getWrappedInfo(time, info) {
                info = info || new WrappedInfo();
                var stopped = !1, duration = this.duration, repeatCount = this.repeatCount, currentIterations = 0 < time ? time / duration : -time / duration;
                if (repeatCount <= currentIterations) {
                    stopped = !0;
                    var tempRatio = (currentIterations = repeatCount) - (0 | repeatCount);
                    0 === tempRatio && (tempRatio = 1), time = tempRatio * duration * (0 < time ? 1 : -1);
                }
                if (duration < time) {
                    var tempTime = time % duration;
                    time = 0 === tempTime ? duration : tempTime;
                } else time < 0 && 0 !== (time %= duration) && (time += duration);
                var needReverse = !1, shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
                shouldWrap && (needReverse = this._needReverse(currentIterations));
                var direction = needReverse ? -1 : 1;
                return this.speed < 0 && (direction *= -1), shouldWrap && needReverse && (time = duration - time), 
                info.ratio = time / duration, info.time = time, info.direction = direction, info.stopped = stopped, 
                info.iterations = currentIterations, info;
            }
        }, {
            key: "sample",
            value: function sample() {
                var info = this.getWrappedInfo(this.time, this._wrappedInfo);
                return this._sampleCurves(info.ratio), this._sampleEvents(info), info;
            }
        }, {
            key: "process",
            value: function process() {
                var lastInfo, info = this.sample();
                this._lastframeEventOn && (lastInfo = this._lastWrapInfo ? this._lastWrapInfo : this._lastWrapInfo = new WrappedInfo(info), 
                1 < this.repeatCount && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit("lastframe", this), 
                lastInfo.set(info));
                info.stopped && (this.stop(), this.emit("finished", this));
            }
        }, {
            key: "simpleProcess",
            value: function simpleProcess() {
                var time = this.time, duration = this.duration;
                duration < time ? 0 === (time %= duration) && (time = duration) : time < 0 && 0 !== (time %= duration) && (time += duration);
                var ratio = time / duration;
                this._sampleCurves(ratio), this._clip.hasEvents() && this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo)), 
                this._lastframeEventOn && (void 0 === this._lastIterations && (this._lastIterations = ratio), 
                (0 < this.time && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit("lastframe", this), 
                this._lastIterations = ratio);
            }
        }, {
            key: "attachToBlendState",
            value: function attachToBlendState(blendState) {
                var _iterator2 = this._samplerSharedGroups, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _iterator3 = _ref2.curves, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var curveInstance = _ref3;
                        curveInstance.blendTarget = blendState.refPropertyBlendTarget(curveInstance.target, curveInstance.propertyName);
                    }
                }
            }
        }, {
            key: "detachFromBlendState",
            value: function detachFromBlendState(blendState) {
                var _iterator4 = this._samplerSharedGroups, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var _iterator5 = _ref4.curves, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        var curveInstance = _ref5;
                        curveInstance.blendTarget = null, blendState.derefPropertyBlendTarget(curveInstance.target, curveInstance.propertyName);
                    }
                }
            }
        }, {
            key: "cache",
            value: function cache(frames) {}
        }, {
            key: "onPlay",
            value: function onPlay() {
                this.setTime(0), this._delayTime = this._delay, cc.director.getAnimationManager().addAnimation(this), 
                this.emit("play", this);
            }
        }, {
            key: "onStop",
            value: function onStop() {
                this.isPaused || cc.director.getAnimationManager().removeAnimation(this), this.emit("stop", this);
            }
        }, {
            key: "onResume",
            value: function onResume() {
                cc.director.getAnimationManager().addAnimation(this), this.emit("resume", this);
            }
        }, {
            key: "onPause",
            value: function onPause() {
                cc.director.getAnimationManager().removeAnimation(this), this.emit("pause", this);
            }
        }, {
            key: "_sampleCurves",
            value: function _sampleCurves(ratio) {
                var _iterator6 = this._samplerSharedGroups, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    var samplerSharedGroup = _ref6, _sampler = samplerSharedGroup.sampler, _samplerResultCache = samplerSharedGroup.samplerResultCache, index = 0, lerpRequired = !1;
                    _sampler ? (index = _sampler.sample(ratio)) < 0 && ((index = ~index) <= 0 ? index = 0 : index >= _sampler.ratios.length ? index = _sampler.ratios.length - 1 : (lerpRequired = !0, 
                    _samplerResultCache.from = index - 1, _samplerResultCache.fromRatio = _sampler.ratios[_samplerResultCache.from], 
                    _samplerResultCache.to = index, _samplerResultCache.toRatio = _sampler.ratios[_samplerResultCache.to])) : index = 0;
                    var _iterator7 = samplerSharedGroup.curves, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                    for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                        var _ref7;
                        if (_isArray7) {
                            if (_i7 >= _iterator7.length) break;
                            _ref7 = _iterator7[_i7++];
                        } else {
                            if ((_i7 = _iterator7.next()).done) break;
                            _ref7 = _i7.value;
                        }
                        var curveInstace = _ref7, _curve = curveInstace.curve, _blendTarget = curveInstace.blendTarget, _target = curveInstace.target, _propertyName = curveInstace.propertyName;
                        if (!_curve.empty()) {
                            var value = void 0;
                            if (value = lerpRequired ? _curve.valueBetween(ratio, _samplerResultCache.from, _samplerResultCache.fromRatio, _samplerResultCache.to, _samplerResultCache.toRatio) : _curve.valueAt(index), 
                            !_curve._blendFunction || !_blendTarget || _blendTarget.refCount <= 1) _target[_propertyName] = value; else {
                                var weight = this.weight;
                                _blendTarget.value = _curve._blendFunction(value, weight, _blendTarget), _blendTarget.weight += weight;
                            }
                        }
                    }
                }
            }
        }, {
            key: "_sampleEvents",
            value: function _sampleEvents(wrapInfo) {
                var direction = wrapInfo.direction, eventIndex = this._clip.getEventGroupIndexAtRatio(wrapInfo.ratio);
                if (eventIndex < 0 && (eventIndex = ~eventIndex - 1, direction < 0 && (eventIndex += 1)), 
                this._ignoreIndex !== eventIndex && (this._ignoreIndex = -1), wrapInfo.frameIndex = eventIndex, 
                !this._lastWrapInfoEvent) return this._fireEvent(eventIndex), void (this._lastWrapInfoEvent = new WrappedInfo(wrapInfo));
                var wrapMode = this.wrapMode, currentIterations = wrapIterations(wrapInfo.iterations), lastWrappedInfo = this._lastWrapInfoEvent, lastIterations = wrapIterations(lastWrappedInfo.iterations), lastIndex = lastWrappedInfo.frameIndex, lastDirection = lastWrappedInfo.direction, interationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
                if (lastIndex === eventIndex && interationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== eventIndex || interationsChanged) {
                    direction = lastDirection;
                    do {
                        if (lastIndex !== eventIndex) {
                            if (-1 === direction && 0 === lastIndex && 0 < eventIndex ? ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length, 
                            lastIterations++) : 1 === direction && lastIndex === length - 1 && eventIndex < length - 1 && ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1, 
                            lastIterations++), lastIndex === eventIndex) break;
                            if (currentIterations < lastIterations) break;
                        }
                        lastIndex += direction, cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
                    } while (lastIndex !== eventIndex && -1 < lastIndex && lastIndex < length);
                }
                this._lastWrapInfoEvent.set(wrapInfo);
            }
        }, {
            key: "_fireEvent",
            value: function _fireEvent(index) {
                if (this._targetNode && this._targetNode.isValid) {
                    var eventGroups = this._clip.eventGroups;
                    if (!(index < 0 || index >= eventGroups.length || this._ignoreIndex === index)) {
                        var eventGroup = eventGroups[index], components = this._targetNode.components, _iterator8 = eventGroup.events, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                        for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                            var _ref8;
                            if (_isArray8) {
                                if (_i8 >= _iterator8.length) break;
                                _ref8 = _iterator8[_i8++];
                            } else {
                                if ((_i8 = _iterator8.next()).done) break;
                                _ref8 = _i8.value;
                            }
                            var event = _ref8, functionName = event.functionName, _iterator9 = components, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray9) {
                                    if (_i9 >= _iterator9.length) break;
                                    _ref9 = _iterator9[_i9++];
                                } else {
                                    if ((_i9 = _iterator9.next()).done) break;
                                    _ref9 = _i9.value;
                                }
                                var component = _ref9, fx = component[functionName];
                                "function" == typeof fx && fx.apply(component, event.parameters);
                            }
                        }
                    }
                }
            }
        }, {
            key: "curveLoaded",
            get: function get() {
                return this._curveLoaded;
            }
        } ]), AnimationState;
    }();
    function wrapIterations(iterations) {
        return iterations - (0 | iterations) == 0 && (iterations -= 1), 0 | iterations;
    }
    cc.AnimationState = AnimationState;
    var CubicSplineValueBase = (_descriptor$A = _applyDecoratedDescriptor((_class$M = function() {
        function CubicSplineValueBase(dataPoint, inTangent, outTangent) {
            _classCallCheck(this, CubicSplineValueBase), _initializerDefineProperty(this, "dataPoint", _descriptor$A, this), 
            _initializerDefineProperty(this, "inTangent", _descriptor2$r, this), _initializerDefineProperty(this, "outTangent", _descriptor3$i, this), 
            this.dataPoint = dataPoint, this.inTangent = inTangent, this.outTangent = outTangent;
        }
        return _createClass(CubicSplineValueBase, [ {
            key: "getNoLerp",
            value: function getNoLerp() {
                return this.dataPoint;
            }
        }, {
            key: "lerp",
            value: function lerp$$1(to, t, dt) {
                return this.dataPoint;
            }
        } ]), CubicSplineValueBase;
    }()).prototype, "dataPoint", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: null
    }), _descriptor2$r = _applyDecoratedDescriptor(_class$M.prototype, "inTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: null
    }), _descriptor3$i = _applyDecoratedDescriptor(_class$M.prototype, "outTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: null
    }), _class$M);
    function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
        var _class3, tempValue = new constructorX(), m0 = new constructorX(), m1 = new constructorX();
        return ccclass(name)(_class3 = function(_CubicSplineValueBase) {
            function CubicSplineValueClass() {
                return _classCallCheck(this, CubicSplineValueClass), _possibleConstructorReturn(this, _getPrototypeOf(CubicSplineValueClass).apply(this, arguments));
            }
            return _inherits(CubicSplineValueClass, CubicSplineValueBase), _createClass(CubicSplineValueClass, [ {
                key: "lerp",
                value: function lerp$$1(to, t, dt) {
                    var p0 = this.dataPoint, p1 = to.dataPoint;
                    m0 = scaleFx(m0, this.outTangent, dt), m1 = scaleFx(m1, to.inTangent, dt);
                    var t_3 = t * t * t, t_2 = t * t, f_1 = t_3 - 2 * t_2 + t, f_2 = -2 * t_3 + 3 * t_2, f_3 = t_3 - t_2;
                    return tempValue = scaleFx(tempValue, p0, 2 * t_3 - 3 * t_2 + 1), tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1), 
                    tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2), tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
                }
            } ]), CubicSplineValueClass;
        }()) || _class3;
    }
    var CubicSplineVec2Value = makeCubicSplineValueConstructor("cc.CubicSplineVec2Value", Vec2, vec2.scale, vec2.scaleAndAdd);
    cc.CubicSplineVec2Value = CubicSplineVec2Value;
    var CubicSplineVec3Value = makeCubicSplineValueConstructor("cc.CubicSplineVec3Value", Vec3, vec3.scale, vec3.scaleAndAdd);
    cc.CubicSplineVec3Value = CubicSplineVec3Value;
    var CubicSplineVec4Value = makeCubicSplineValueConstructor("cc.CubicSplineVec4Value", Vec4, vec4.scale, vec4.scaleAndAdd);
    cc.CubicSplineVec4Value = CubicSplineVec4Value;
    var CubicSplineQuatValue = makeCubicSplineValueConstructor("cc.CubicSplineQuatValue", Quat, quat.scale, quat.scaleAndAdd);
    cc.CubicSplineQuatValue = CubicSplineQuatValue;
    var CubicSplineNumberValue = ccclass("cc.CubicSplineNumberValue")(_class4$4 = function(_CubicSplineValueBase2) {
        function CubicSplineNumberValue() {
            return _classCallCheck(this, CubicSplineNumberValue), _possibleConstructorReturn(this, _getPrototypeOf(CubicSplineNumberValue).apply(this, arguments));
        }
        return _inherits(CubicSplineNumberValue, CubicSplineValueBase), _createClass(CubicSplineNumberValue, [ {
            key: "lerp",
            value: function lerp$$1(to, t, dt) {
                var p0 = this.dataPoint, p1 = to.dataPoint, t_3 = t * t * t, t_2 = t * t;
                return p0 * (2 * t_3 - 3 * t_2 + 1) + this.outTangent * dt * (t_3 - 2 * t_2 + t) + p1 * (-2 * t_3 + 3 * t_2) + to.inTangent * dt * (t_3 - t_2);
            }
        } ]), CubicSplineNumberValue;
    }()) || _class4$4;
    cc.CubicSplineNumberValue = CubicSplineNumberValue;
    var _dec$L, _dec2$p, _dec3$d, _dec4$9, _dec5$6, _dec6$6, _class$N, _class2$C, _descriptor$B, _descriptor2$s, _descriptor3$j, _class3$g, _temp$J, EventType, CrossFade = function(_Playable) {
        function CrossFade() {
            var _this;
            return _classCallCheck(this, CrossFade), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this)))._fadings = [], 
            _this._unshiftDefault(), _this;
        }
        return _inherits(CrossFade, Playable), _createClass(CrossFade, [ {
            key: "update",
            value: function update(deltaTime) {
                if (this.isPlaying && !this.isPaused) for (var absoluteWeight = 1, i = 0; i < this._fadings.length; ++i) {
                    if (0 === absoluteWeight) {
                        for (var j = i; j < this._fadings.length; ++j) {
                            var follingFading = this._fadings[j];
                            follingFading.state && this._directStopState(follingFading.state);
                        }
                        this._fadings.splice(i);
                        break;
                    }
                    var fading = this._fadings[i];
                    fading.easeTime += deltaTime;
                    var relativeWeight = clamp01(fading.easeTime / fading.easeDuration), weight = relativeWeight * absoluteWeight;
                    absoluteWeight *= 1 - relativeWeight, fading.state && (fading.state.weight = weight);
                }
            }
        }, {
            key: "crossFade",
            value: function crossFade(state, duration) {
                var es = removeIf(this._fadings, function(animation) {
                    return animation.state === state;
                });
                void 0 === es && (es = {
                    easeDuration: duration,
                    easeTime: 0,
                    state: state
                }), this._fadings.unshift(es), state && this._directPlayState(state);
            }
        }, {
            key: "onPause",
            value: function onPause() {
                _get(_getPrototypeOf(CrossFade.prototype), "onPause", this).call(this);
                var _iterator = this._fadings, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var fading = _ref;
                    fading.state && fading.state.pause();
                }
            }
        }, {
            key: "onResume",
            value: function onResume() {
                _get(_getPrototypeOf(CrossFade.prototype), "onResume", this).call(this);
                var _iterator2 = this._fadings, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var fading = _ref2;
                    fading.state && fading.state.resume();
                }
            }
        }, {
            key: "onStop",
            value: function onStop() {
                _get(_getPrototypeOf(CrossFade.prototype), "onStop", this).call(this);
                var currentFading = this._fadings[0];
                currentFading.state && (currentFading.state.weight = 1);
                var _iterator3 = this._fadings, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var fading = _ref3;
                    fading.state && this._directStopState(fading.state);
                }
                this._fadings.splice(1, this._fadings.length - 1);
            }
        }, {
            key: "clear",
            value: function clear() {
                this.stop(), this._fadings.length = 0, this._unshiftDefault();
            }
        }, {
            key: "_unshiftDefault",
            value: function _unshiftDefault() {
                this._fadings.unshift({
                    state: null,
                    easeDuration: Number.POSITIVE_INFINITY,
                    easeTime: 0
                });
            }
        }, {
            key: "_directStopState",
            value: function _directStopState(state) {
                state.stop();
            }
        }, {
            key: "_directPlayState",
            value: function _directPlayState(state) {
                state.weight = 1, state.play();
            }
        } ]), CrossFade;
    }();
    !function(EventType) {
        EventType.PLAY = "play", EventType.STOP = "stop", EventType.PAUSE = "pause", EventType.RESUME = "resume", 
        EventType.LASTFRAME = "lastframe", EventType.FINISHED = "finished";
    }(EventType || (EventType = {})), ccenum(EventType);
    var _dec$M, _dec2$q, _dec3$e, _dec4$a, _class$O, _class2$D, _descriptor$C, _descriptor2$t, _descriptor3$k, _descriptor4$d, AnimationComponent = (_dec$L = ccclass("cc.AnimationComponent"), 
    _dec2$p = executionOrder(99), _dec3$d = menu("Components/AnimationComponent"), _dec4$9 = property({
        type: [ AnimationClip ]
    }), _dec5$6 = property({
        type: AnimationClip
    }), _dec6$6 = property({
        type: [ AnimationClip ]
    }), _dec$L(_class$N = _dec2$p(_class$N = executeInEditMode(_class$N = _dec3$d((_temp$J = _class3$g = function(_Component) {
        function AnimationComponent() {
            var _this;
            return _classCallCheck(this, AnimationComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationComponent).call(this)), "playOnLoad", _descriptor$B, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._callbackTable = createMap(!0), _this._crossFade = new CrossFade(), _this._nameToState = createMap(!0), 
            _initializerDefineProperty(_this, "_clips", _descriptor2$s, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_defaultClip", _descriptor3$j, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._currentPlaying = _this._crossFade, _this;
        }
        return _inherits(AnimationComponent, Component), _createClass(AnimationComponent, [ {
            key: "clips",
            get: function get$$1() {
                return this._clips;
            },
            set: function set(value$$1) {
                var _this2 = this;
                this._crossFade && this._crossFade.clear();
                var _iterator = this._clips, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var clip = _ref;
                    clip && this._removeStateOfAutomaticClip(clip);
                }
                var _iterator2 = value$$1, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _clip = _ref2;
                    _clip && this.createState(_clip);
                }
                var newDefaultClip = value$$1.find(function(clip) {
                    return equalClips(clip, _this2._defaultClip);
                });
                this._defaultClip = newDefaultClip || null, this._clips = value$$1;
            }
        }, {
            key: "defaultClip",
            get: function get$$1() {
                return this._defaultClip;
            },
            set: function set(value$$1) {
                (this._defaultClip = value$$1) && (0 <= this._clips.findIndex(function(clip) {
                    return equalClips(clip, value$$1);
                }) || (this._clips.push(value$$1), this.createState(value$$1)));
            }
        }, {
            key: "currentPlaying",
            get: function get$$1() {
                return this._currentPlaying;
            }
        } ]), _createClass(AnimationComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this.clips = this._clips;
            }
        }, {
            key: "start",
            value: function start() {
                for (var _arr = Object.keys(this._nameToState), _i3 = 0; _i3 < _arr.length; _i3++) {
                    var stateName = _arr[_i3];
                    this._nameToState[stateName].initialize(this.node);
                }
                cc.director.getAnimationManager().addCrossFade(this._crossFade), this._crossFade.play(), 
                this.playOnLoad && this._defaultClip && this.crossFade(this._defaultClip.name, 0);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._crossFade && this._crossFade.resume();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._crossFade && this._crossFade.pause();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._crossFade && (this._crossFade.stop(), cc.director.getAnimationManager().removeCrossFade(this._crossFade), 
                this._crossFade.stop());
            }
        }, {
            key: "play",
            value: function play(name) {
                var startTime = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!name) {
                    if (!this._defaultClip) return null;
                    name = this._defaultClip.name;
                }
                var state = this._nameToState[name];
                return state && (this._currentPlaying.stop(), (this._currentPlaying = state).setTime(startTime), 
                state.play()), state;
            }
        }, {
            key: "crossFade",
            value: function crossFade(name) {
                var duration = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .3, state = this._nameToState[name];
                state && (this._currentPlaying !== this._crossFade && this._currentPlaying.stop(), 
                this._currentPlaying = this._crossFade, this._crossFade.crossFade(state, duration));
            }
        }, {
            key: "getAnimationState",
            value: function getAnimationState(name) {
                return this.getState(name);
            }
        }, {
            key: "getState",
            value: function getState(name) {
                var state = this._nameToState[name];
                return state && !state.curveLoaded && state.initialize(this.node), state || null;
            }
        }, {
            key: "createState",
            value: function createState(clip, name) {
                return name = name || clip.name, this.removeState(name), this._doCreateState(clip, name);
            }
        }, {
            key: "removeState",
            value: function removeState(name) {
                var state = this._nameToState[name];
                state && (state.stop(), delete this._nameToState[name]);
            }
        }, {
            key: "addClip",
            value: function addClip(clip, name) {
                return contains(this._clips, clip) || this._clips.push(clip), this.createState(clip, name);
            }
        }, {
            key: "removeClip",
            value: function removeClip(clip, force) {
                for (var state, _arr2 = Object.keys(this._nameToState), _i4 = 0; _i4 < _arr2.length; _i4++) {
                    var _name = _arr2[_i4];
                    if ((state = this._nameToState[_name]).clip === clip) break;
                }
                if (clip === this._defaultClip) {
                    if (!force) return void warnID(3902);
                    this._defaultClip = null;
                }
                if (state && state.isPlaying) {
                    if (!force) return void warnID(3903);
                    state.stop();
                }
                this._clips = this._clips.filter(function(item) {
                    return item !== clip;
                }), state && delete this._nameToState[state.name];
            }
        }, {
            key: "on",
            value: function on(type, callback, target) {
                var ret = EventTarget.prototype.on.call(this, type, callback, target);
                if ("lastframe" === type) for (var _arr3 = Object.keys(this._nameToState), _i5 = 0; _i5 < _arr3.length; _i5++) {
                    var stateName = _arr3[_i5];
                    this._nameToState[stateName]._lastframeEventOn = !0;
                }
                return ret;
            }
        }, {
            key: "off",
            value: function off(type, callback, target) {
                if ("lastframe" === type) for (var nameToState = this._nameToState, _arr4 = Object.keys(nameToState), _i6 = 0; _i6 < _arr4.length; _i6++) {
                    nameToState[_arr4[_i6]]._lastframeEventOn = !1;
                }
                EventTarget.prototype.off.call(this, type, callback, target);
            }
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {}
        }, {
            key: "once",
            value: function once(type, callback, target) {}
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {}
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback, target) {
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {}
        }, {
            key: "emit",
            value: function emit(key) {}
        }, {
            key: "_getStateByNameOrDefaultClip",
            value: function _getStateByNameOrDefaultClip(name) {
                if (!name) {
                    if (!this._defaultClip) return null;
                    name = this._defaultClip.name;
                }
                var state = this._nameToState[name];
                return state || null;
            }
        }, {
            key: "_removeStateOfAutomaticClip",
            value: function _removeStateOfAutomaticClip(clip) {
                var state = this._nameToState[name];
                state && equalClips(clip, state.clip) && (state.stop(), delete this._nameToState[name]);
            }
        }, {
            key: "_doCreateState",
            value: function _doCreateState(clip, name) {
                var state = new AnimationState(clip, name);
                return state._setEventTarget(this), this.node && state.initialize(this.node), this._nameToState[state.name] = state;
            }
        } ]), AnimationComponent;
    }(), _class3$g.EventType = EventType, _applyDecoratedDescriptor((_class2$C = _temp$J).prototype, "clips", [ _dec4$9 ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "clips"), _class2$C.prototype), 
    _applyDecoratedDescriptor(_class2$C.prototype, "defaultClip", [ _dec5$6 ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "defaultClip"), _class2$C.prototype), 
    _descriptor$B = _applyDecoratedDescriptor(_class2$C.prototype, "playOnLoad", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$s = _applyDecoratedDescriptor(_class2$C.prototype, "_clips", [ _dec6$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$j = _applyDecoratedDescriptor(_class2$C.prototype, "_defaultClip", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$N = _class2$C)) || _class$N) || _class$N) || _class$N) || _class$N), _AnimationComponent$p = AnimationComponent.prototype, on = _AnimationComponent$p.on, off = _AnimationComponent$p.off;
    function equalClips(clip1, clip2) {
        return clip1 === clip2 || !(!clip1 || !clip2 || clip1.name !== clip2.name && clip1._uuid !== clip2._uuid);
    }
    applyMixins(AnimationComponent, [ CallbacksInvoker, EventTarget ]), AnimationComponent.prototype.on = on, 
    AnimationComponent.prototype.off = off, cc.AnimationComponent = AnimationComponent;
    var _dec$N, _dec2$r, _dec3$f, _dec4$b, _dec5$7, _class$P, _class2$E, _descriptor$D, _descriptor2$u, _descriptor3$l, _descriptor4$e, _descriptor5$b, _descriptor6$7, _descriptor7$6, _descriptor8$6, _class3$h, _temp$L, _class$Q, _class2$F, _descriptor$E, _descriptor2$v, _class4$5, _class5$4, _descriptor3$m, _descriptor4$f, _class7$1, _class8$1, _descriptor5$c, _descriptor6$8, _descriptor7$7, _class9, _temp3$1, _dec$P, _dec2$t, _dec3$h, _dec4$c, _dec5$8, _dec6$7, _class$R, _class2$G, _descriptor$F, _descriptor2$w, _descriptor3$n, _descriptor4$g, _descriptor5$d, _descriptor6$9, _descriptor7$8, _class3$i, _temp$N, _dec$Q, _dec2$u, _dec3$i, _dec4$d, _dec5$9, _dec6$8, _dec7$5, _dec8$3, _dec9$3, _dec10$3, _dec11$3, _dec12$3, _dec13$3, _class$S, _class2$H, _descriptor$G, _descriptor2$x, _descriptor3$o, _descriptor4$h, _descriptor5$e, _descriptor6$a, _descriptor7$9, _dec$R, _dec2$v, _dec3$j, _class$T, _class2$I, _descriptor$H, _descriptor2$y, _dec$S, _dec2$w, _dec3$k, _dec4$e, _dec5$a, _dec6$9, _class$U, _class2$J, _descriptor$I, _descriptor2$z, _descriptor3$p, _descriptor4$i, _descriptor5$f, BillboardComponent = (_dec$M = ccclass("cc.BillboardComponent"), 
    _dec2$q = menu("Components/BillboardComponent"), _dec3$e = property({
        type: Texture2D
    }), _dec4$a = property({
        type: Texture2D
    }), _dec$M(_class$O = _dec2$q(_class$O = executeInEditMode((_descriptor$C = _applyDecoratedDescriptor((_class2$D = function(_Component) {
        function BillboardComponent() {
            var _this;
            return _classCallCheck(this, BillboardComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BillboardComponent).call(this)), "_texture", _descriptor$C, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_height", _descriptor2$t, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_width", _descriptor3$k, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_rotation", _descriptor4$d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._model = null, _this._mesh = null, _this._material = null, _this._uniform = cc.v4(1, 1, 0, 0), 
            _this;
        }
        return _inherits(BillboardComponent, Component), _createClass(BillboardComponent, [ {
            key: "texture",
            get: function get() {
                return this._texture;
            },
            set: function set(val) {
                this._texture = val, this._material && this._material.setProperty("mainTexture", val);
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            },
            set: function set(val) {
                this._height = val, this._material && (this._uniform.y = val, this._material.setProperty("cc_size_rotation", this._uniform));
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(val) {
                this._width = val, this._material && (this._uniform.x = val, this._material.setProperty("cc_size_rotation", this._uniform));
            }
        }, {
            key: "rotation",
            get: function get() {
                return Math.round(100 * toDegree(this._rotation)) / 100;
            },
            set: function set(val) {
                this._rotation = toRadian(val), this._material && (this._uniform.z = this._rotation, 
                this._material.setProperty("cc_size_rotation", this._uniform));
            }
        } ]), _createClass(BillboardComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._model || this.createModel(), this._model.enabled = !0, this.width = this._width, 
                this.height = this._height, this.rotation = this.rotation, this.texture = this.texture;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._model && (this._model.enabled = !1);
            }
        }, {
            key: "createModel",
            value: function createModel() {
                this._mesh = createMesh({
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST,
                    positions: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
                    uvs: [ 0, 0, 1, 0, 0, 1, 1, 1 ],
                    colors: [ Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a ],
                    attributes: [ {
                        name: exports.GFXAttributeName.ATTR_POSITION,
                        format: exports.GFXFormat.RGB32F
                    }, {
                        name: exports.GFXAttributeName.ATTR_TEX_COORD,
                        format: exports.GFXFormat.RG32F
                    }, {
                        name: exports.GFXAttributeName.ATTR_COLOR,
                        format: exports.GFXFormat.RGBA8UI,
                        isNormalized: !0
                    } ],
                    indices: [ 0, 1, 2, 1, 2, 3 ]
                }, void 0, {
                    calculateBounds: !1
                }), this._model = this._getRenderScene().createModel(Model, this.node), null == this._material && (this._material = new Material(), 
                this._material.copy(builtinResMgr.get("default-billboard-material"))), this._model.initSubModel(0, this._mesh.getSubMesh(0), this._material);
            }
        } ]), BillboardComponent;
    }()).prototype, "_texture", [ _dec3$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$D.prototype, "texture", [ _dec4$a ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "texture"), _class2$D.prototype), 
    _descriptor2$t = _applyDecoratedDescriptor(_class2$D.prototype, "_height", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$D.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "height"), _class2$D.prototype), 
    _descriptor3$k = _applyDecoratedDescriptor(_class2$D.prototype, "_width", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$D.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "width"), _class2$D.prototype), 
    _descriptor4$d = _applyDecoratedDescriptor(_class2$D.prototype, "_rotation", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$D.prototype, "rotation", [ property ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "rotation"), _class2$D.prototype), 
    _class$O = _class2$D)) || _class$O) || _class$O) || _class$O), _vertex_attrs = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGBA32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    } ], _temp_v1 = cc.v3(), _temp_v2 = cc.v3(), LineModel = function(_Model) {
        function LineModel(scene, node) {
            var _this;
            return _classCallCheck(this, LineModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LineModel).call(this, scene, node)))._capacity = void 0, 
            _this._vertSize = void 0, _this._vBuffer = void 0, _this._vertAttrsFloatCount = void 0, 
            _this._vdataF32 = void 0, _this._vdataUint32 = void 0, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
            _this._subMeshData = void 0, _this._vertCount = 0, _this._indexCount = 0, _this._capacity = 100, 
            _this._iaInfo = {
                drawInfos: [ {
                    vertexCount: 0,
                    firstVertex: 0,
                    indexCount: 0,
                    firstIndex: 0,
                    vertexOffset: 0,
                    instanceCount: 0,
                    firstInstance: 0
                } ]
            }, _this._iaInfoBuffer = _this._device.createBuffer({
                usage: GFXBufferUsageBit.INDIRECT,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 56,
                stride: 1
            }), _this;
        }
        return _inherits(LineModel, Model), _createClass(LineModel, [ {
            key: "setCapacity",
            value: function setCapacity(capacity) {
                this._capacity = capacity, this.createBuffer();
            }
        }, {
            key: "createBuffer",
            value: function createBuffer() {
                for (var _i = this._vertSize = 0; _i < _vertex_attrs.length; _i++) {
                    var a = _vertex_attrs[_i];
                    a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                }
                this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
            }
        }, {
            key: "_createSubMeshData",
            value: function _createSubMeshData() {
                this._subMeshData && this.destroySubMeshData(), this._vertCount = 2, this._indexCount = 6;
                var vertexBuffer = this._device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: this._vertSize * this._capacity * this._vertCount,
                    stride: this._vertSize
                }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                vertexBuffer.update(vBuffer);
                for (var indices = new Uint16Array((this._capacity - 1) * this._indexCount), dst = 0, i = 0; i < this._capacity - 1; ++i) {
                    var baseIdx = 2 * i;
                    indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                    indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
                }
                var indexBuffer = this._device.createBuffer({
                    usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                });
                return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
                this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount, 
                this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                    vertexBuffers: [ vertexBuffer ],
                    indexBuffer: indexBuffer,
                    indirectBuffer: this._iaInfoBuffer,
                    attributes: _vertex_attrs,
                    primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST
                }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
            }
        }, {
            key: "addLineVertexData",
            value: function addLineVertexData(positions, width, color) {
                if (1 < positions.length) {
                    var offset = 0;
                    vec3.subtract(_temp_v1, positions[1], positions[0]), this._vdataF32[offset++] = positions[0].x, 
                    this._vdataF32[offset++] = positions[0].y, this._vdataF32[offset++] = positions[0].z, 
                    this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(0, 1), this._vdataF32[offset++] = 0, 
                    this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                    this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val, 
                    this._vdataF32[offset++] = positions[0].x, this._vdataF32[offset++] = positions[0].y, 
                    this._vdataF32[offset++] = positions[0].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(0, 1), 
                    this._vdataF32[offset++] = 0, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, 
                    this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                    for (var i = 1; i < positions.length - 1; i++) {
                        vec3.subtract(_temp_v1, positions[i - 1], positions[i]), vec3.subtract(_temp_v2, positions[i + 1], positions[i]), 
                        vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                        var seg = i / positions.length;
                        this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                        this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                        this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v2.x, 
                        this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val, 
                        this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                        this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                        this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v2.x, 
                        this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                    }
                    vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]), 
                    this._vdataF32[offset++] = positions[positions.length - 1].x, this._vdataF32[offset++] = positions[positions.length - 1].y, 
                    this._vdataF32[offset++] = positions[positions.length - 1].z, this._vdataF32[offset++] = 0, 
                    this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, this._vdataF32[offset++] = 0, 
                    this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, 
                    this._vdataUint32[offset++] = color.evaluate(1, 1)._val, this._vdataF32[offset++] = positions[positions.length - 1].x, 
                    this._vdataF32[offset++] = positions[positions.length - 1].y, this._vdataF32[offset++] = positions[positions.length - 1].z, 
                    this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, 
                    this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                    this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                }
                this.updateIA(Math.max(0, positions.length - 1));
            }
        }, {
            key: "updateIA",
            value: function updateIA(count) {
                this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
                this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
            }
        }, {
            key: "destroySubMeshData",
            value: function destroySubMeshData() {
                var _iterator = this._subMeshData.vertexBuffers, _isArray = Array.isArray(_iterator), _i2 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i2 >= _iterator.length) break;
                        _ref = _iterator[_i2++];
                    } else {
                        if ((_i2 = _iterator.next()).done) break;
                        _ref = _i2.value;
                    }
                    _ref.destroy();
                }
                this._subMeshData.indexBuffer.destroy();
            }
        } ]), LineModel;
    }(), Mode = Enum({
        Constant: 0,
        Curve: 1,
        TwoCurves: 2,
        TwoConstants: 3
    }), CurveRange = (_dec$N = ccclass("cc.CurveRange"), _dec2$r = property({
        type: Mode
    }), _dec3$f = property({
        type: AnimationCurve
    }), _dec4$b = property({
        type: AnimationCurve
    }), _dec5$7 = property({
        type: AnimationCurve
    }), _dec$N((_temp$L = _class3$h = function() {
        function CurveRange() {
            _classCallCheck(this, CurveRange), _initializerDefineProperty(this, "mode", _descriptor$D, this), 
            _initializerDefineProperty(this, "curve", _descriptor2$u, this), _initializerDefineProperty(this, "curveMin", _descriptor3$l, this), 
            _initializerDefineProperty(this, "curveMax", _descriptor4$e, this), _initializerDefineProperty(this, "constant", _descriptor5$b, this), 
            _initializerDefineProperty(this, "constantMin", _descriptor6$7, this), _initializerDefineProperty(this, "constantMax", _descriptor7$6, this), 
            _initializerDefineProperty(this, "multiplier", _descriptor8$6, this);
        }
        return _createClass(CurveRange, [ {
            key: "evaluate",
            value: function evaluate(time, rndRatio) {
                switch (this.mode) {
                  case Mode.Constant:
                    return this.constant;

                  case Mode.Curve:
                    return this.curve.evaluate(time) * this.multiplier;

                  case Mode.TwoCurves:
                    return lerp(this.curveMin.evaluate(time), this.curveMax.evaluate(time), rndRatio) * this.multiplier;

                  case Mode.TwoConstants:
                    return lerp(this.constantMin, this.constantMax, rndRatio);
                }
            }
        }, {
            key: "getMax",
            value: function getMax() {
                switch (this.mode) {
                  case Mode.Constant:
                    return this.constant;

                  case Mode.Curve:
                    return this.multiplier;

                  case Mode.TwoConstants:
                    return this.constantMax;

                  case Mode.TwoCurves:
                    return this.multiplier;
                }
                return 0;
            }
        } ]), CurveRange;
    }(), _class3$h.Mode = Mode, _descriptor$D = _applyDecoratedDescriptor((_class2$E = _temp$L).prototype, "mode", [ _dec2$r ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode.Constant;
        }
    }), _descriptor2$u = _applyDecoratedDescriptor(_class2$E.prototype, "curve", [ _dec3$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AnimationCurve();
        }
    }), _descriptor3$l = _applyDecoratedDescriptor(_class2$E.prototype, "curveMin", [ _dec4$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AnimationCurve();
        }
    }), _descriptor4$e = _applyDecoratedDescriptor(_class2$E.prototype, "curveMax", [ _dec5$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new AnimationCurve();
        }
    }), _descriptor5$b = _applyDecoratedDescriptor(_class2$E.prototype, "constant", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$E.prototype, "constantMin", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$E.prototype, "constantMax", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$E.prototype, "multiplier", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class$P = _class2$E)) || _class$P), Mode$1 = Enum({
        Blend: 0,
        Fixed: 1
    }), Gradient = (ccclass("cc.ColorKey")((_descriptor$E = _applyDecoratedDescriptor((_class2$F = function ColorKey() {
        _classCallCheck(this, ColorKey), _initializerDefineProperty(this, "color", _descriptor$E, this), 
        _initializerDefineProperty(this, "time", _descriptor2$v, this);
    }).prototype, "color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.Color.WHITE;
        }
    }), _descriptor2$v = _applyDecoratedDescriptor(_class2$F.prototype, "time", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$Q = _class2$F)), ccclass("cc.AlphaKey")((_descriptor3$m = _applyDecoratedDescriptor((_class5$4 = function AlphaKey() {
        _classCallCheck(this, AlphaKey), _initializerDefineProperty(this, "alpha", _descriptor3$m, this), 
        _initializerDefineProperty(this, "time", _descriptor4$f, this);
    }).prototype, "alpha", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$f = _applyDecoratedDescriptor(_class5$4.prototype, "time", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class4$5 = _class5$4)), ccclass("cc.Gradient")((_temp3$1 = _class9 = function() {
        function Gradient() {
            _classCallCheck(this, Gradient), _initializerDefineProperty(this, "colorKeys", _descriptor5$c, this), 
            _initializerDefineProperty(this, "alphaKeys", _descriptor6$8, this), _initializerDefineProperty(this, "mode", _descriptor7$7, this), 
            this._color = void 0, this._color = cc.Color.WHITE;
        }
        return _createClass(Gradient, [ {
            key: "setKeys",
            value: function setKeys(colorKeys, alphaKeys) {
                this.colorKeys = colorKeys, this.alphaKeys = alphaKeys;
            }
        }, {
            key: "sortKeys",
            value: function sortKeys() {
                1 < this.colorKeys.length && this.colorKeys.sort(function(a, b) {
                    return a.time - b.time;
                }), 1 < this.alphaKeys.length && this.alphaKeys.sort(function(a, b) {
                    return a.time - b.time;
                });
            }
        }, {
            key: "getRGB",
            value: function getRGB(time) {
                if (!(1 < this.colorKeys.length)) return 1 === this.colorKeys.length ? this._color.set(this.colorKeys[0].color) : (this._color.r = 255, 
                this._color.g = 255, this._color.b = 255, this._color.a = 255), this._color;
                time = repeat(time, 1);
                for (var i = 1; i < this.colorKeys.length; ++i) {
                    var preTime = this.colorKeys[i - 1].time, curTime = this.colorKeys[i].time;
                    if (preTime <= time && time < curTime) {
                        if (this.mode === Mode$1.Fixed) return this.colorKeys[i].color;
                        var factor = (time - preTime) / (curTime - preTime);
                        return this.colorKeys[i - 1].color.lerp(this.colorKeys[i].color, factor, this._color), 
                        this._color;
                    }
                }
                var lastIndex = this.colorKeys.length - 1;
                time < this.colorKeys[0].time ? Color.BLACK.lerp(this.colorKeys[0].color, time / this.colorKeys[0].time, this._color) : time > this.colorKeys[lastIndex].time && this.colorKeys[lastIndex].color.lerp(Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time), this._color);
            }
        }, {
            key: "getAlpha",
            value: function getAlpha(time) {
                if (!(1 < this.alphaKeys.length)) return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
                time = repeat(time, 1);
                for (var i = 1; i < this.alphaKeys.length; ++i) {
                    var preTime = this.alphaKeys[i - 1].time, curTime = this.alphaKeys[i].time;
                    if (preTime <= time && time < curTime) {
                        if (this.mode === Mode$1.Fixed) return this.alphaKeys[i].alpha;
                        var factor = (time - preTime) / (curTime - preTime);
                        return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                    }
                }
                var lastIndex = this.alphaKeys.length - 1;
                return time < this.alphaKeys[0].time ? lerp(255, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time) : time > this.alphaKeys[lastIndex].time ? lerp(this.alphaKeys[lastIndex].alpha, 255, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time)) : void 0;
            }
        }, {
            key: "evaluate",
            value: function evaluate(time) {
                return this.getRGB(time), this._color.a = this.getAlpha(time), this._color;
            }
        }, {
            key: "randomColor",
            value: function randomColor() {
                var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)], a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
                return this._color.r = c.color.r, this._color.g = c.color.g, this._color.b = c.color.b, 
                this._color.a = a.alpha, this._color;
            }
        } ]), Gradient;
    }(), _class9.Mode = Mode$1, _descriptor5$c = _applyDecoratedDescriptor((_class8$1 = _temp3$1).prototype, "colorKeys", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Array();
        }
    }), _descriptor6$8 = _applyDecoratedDescriptor(_class8$1.prototype, "alphaKeys", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Array();
        }
    }), _descriptor7$7 = _applyDecoratedDescriptor(_class8$1.prototype, "mode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$1.Blend;
        }
    }), _class7$1 = _class8$1)) || _class7$1), Mode$2 = Enum({
        Color: 0,
        Gradient: 1,
        TwoColors: 2,
        TwoGradients: 3,
        RandomColor: 4
    }), GradientRange = (_dec$P = ccclass("cc.GradientRange"), _dec2$t = property({
        type: Mode$2
    }), _dec3$h = property({
        type: Mode$2
    }), _dec4$c = property({
        type: Gradient
    }), _dec5$8 = property({
        type: Gradient
    }), _dec6$7 = property({
        type: Gradient
    }), _dec$P((_temp$N = _class3$i = function() {
        function GradientRange() {
            _classCallCheck(this, GradientRange), _initializerDefineProperty(this, "_mode", _descriptor$F, this), 
            _initializerDefineProperty(this, "color", _descriptor2$w, this), _initializerDefineProperty(this, "colorMin", _descriptor3$n, this), 
            _initializerDefineProperty(this, "colorMax", _descriptor4$g, this), _initializerDefineProperty(this, "gradient", _descriptor5$d, this), 
            _initializerDefineProperty(this, "gradientMin", _descriptor6$9, this), _initializerDefineProperty(this, "gradientMax", _descriptor7$8, this);
        }
        return _createClass(GradientRange, [ {
            key: "evaluate",
            value: function evaluate(time, rndRatio) {
                switch (this.mode) {
                  case Mode$2.Color:
                    return this.color;

                  case Mode$2.TwoColors:
                    return this.colorMin.lerp(this.colorMax, rndRatio, this.color), this.color;

                  case Mode$2.RandomColor:
                    return this.gradient.randomColor();

                  case Mode$2.Gradient:
                    return this.gradient.evaluate(time);

                  case Mode$2.TwoGradients:
                    return this.colorMin = this.gradientMin.evaluate(time), this.colorMax = this.gradientMax.evaluate(time), 
                    this.colorMin.lerp(this.colorMax, rndRatio, this.color), this.color;
                }
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(m) {
                this._mode = m;
            }
        } ]), GradientRange;
    }(), _class3$i.Mode = Mode$2, _descriptor$F = _applyDecoratedDescriptor((_class2$G = _temp$N).prototype, "_mode", [ _dec2$t ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$2.Color;
        }
    }), _applyDecoratedDescriptor(_class2$G.prototype, "mode", [ _dec3$h ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "mode"), _class2$G.prototype), 
    _descriptor2$w = _applyDecoratedDescriptor(_class2$G.prototype, "color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.Color.WHITE;
        }
    }), _descriptor3$n = _applyDecoratedDescriptor(_class2$G.prototype, "colorMin", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.Color.WHITE;
        }
    }), _descriptor4$g = _applyDecoratedDescriptor(_class2$G.prototype, "colorMax", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.Color.WHITE;
        }
    }), _descriptor5$d = _applyDecoratedDescriptor(_class2$G.prototype, "gradient", [ _dec4$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Gradient();
        }
    }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$G.prototype, "gradientMin", [ _dec5$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Gradient();
        }
    }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$G.prototype, "gradientMax", [ _dec6$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Gradient();
        }
    }), _class$R = _class2$G)) || _class$R), define$1 = {
        CC_USE_WORLD_SPACE: !1
    }, LineComponent = (_dec$Q = ccclass("cc.LineComponent"), _dec2$u = menu("Components/LineComponent"), 
    _dec3$i = property({
        type: Texture2D
    }), _dec4$d = property({
        type: Texture2D,
        displayOrder: 0
    }), _dec5$9 = property({
        displayOrder: 1
    }), _dec6$8 = property({
        type: [ Vec3 ]
    }), _dec7$5 = property({
        type: [ Vec3 ],
        displayOrder: 2
    }), _dec8$3 = property({
        type: CurveRange
    }), _dec9$3 = property({
        type: CurveRange,
        displayOrder: 3
    }), _dec10$3 = property({
        type: Vec2,
        displayOrder: 4
    }), _dec11$3 = property({
        type: Vec2,
        displayOrder: 5
    }), _dec12$3 = property({
        type: GradientRange
    }), _dec13$3 = property({
        type: GradientRange,
        displayOrder: 6
    }), _dec$Q(_class$S = _dec2$u(_class$S = executeInEditMode((_descriptor$G = _applyDecoratedDescriptor((_class2$H = function(_Component) {
        function LineComponent() {
            var _this;
            return _classCallCheck(this, LineComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LineComponent).call(this)), "_texture", _descriptor$G, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._material = null, _initializerDefineProperty(_this, "_worldSpace", _descriptor2$x, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_positions", _descriptor3$o, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_width", _descriptor4$h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_tile", _descriptor5$e, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_offset", _descriptor6$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_color", _descriptor7$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._model = null, _this._tile_offset = cc.v4(), _this;
        }
        return _inherits(LineComponent, Component), _createClass(LineComponent, [ {
            key: "texture",
            get: function get() {
                return this._texture;
            },
            set: function set(val) {
                this._texture = val, this._material && this._material.setProperty("mainTexture", val);
            }
        }, {
            key: "worldSpace",
            get: function get() {
                return this._worldSpace;
            },
            set: function set(val) {
                this._worldSpace = val, this._material && (define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
                this._material.recompileShaders(define$1), this._model && this._model.setSubModelMaterial(0, this._material));
            }
        }, {
            key: "positions",
            get: function get() {
                return this._positions;
            },
            set: function set(val) {
                this._positions = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(val) {
                this._width = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        }, {
            key: "tile",
            get: function get() {
                return this._tile;
            },
            set: function set(val) {
                this._tile.set(val), this._material && (this._tile_offset.x = this._tile.x, this._tile_offset.y = this._tile.y, 
                this._material.setProperty("mainTiling_Offset", this._tile_offset));
            }
        }, {
            key: "offset",
            get: function get() {
                return this._offset;
            },
            set: function set(val) {
                this._offset.set(val), this._material && (this._tile_offset.z = this._offset.x, 
                this._tile_offset.w = this._offset.y, this._material.setProperty("mainTiling_Offset", this._tile_offset));
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(val) {
                this._color = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        } ]), _createClass(LineComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._model || (this._model = this._getRenderScene().createModel(LineModel, this.node), 
                this._model.setCapacity(100), null == this._material && (this._material = new Material(), 
                this._material.copy(builtinResMgr.get("default-trail-material")), define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
                this._material.recompileShaders(define$1)), this._model.setSubModelMaterial(0, this._material)), 
                this._model.enabled = !0, this.texture = this.texture, this.tile = this._tile, this.offset = this._offset, 
                this._model.addLineVertexData(this._positions, this._width, this._color);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._model && (this._model.enabled = !1);
            }
        } ]), LineComponent;
    }()).prototype, "_texture", [ _dec3$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "texture", [ _dec4$d ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "texture"), _class2$H.prototype), 
    _descriptor2$x = _applyDecoratedDescriptor(_class2$H.prototype, "_worldSpace", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "worldSpace", [ _dec5$9 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "worldSpace"), _class2$H.prototype), 
    _descriptor3$o = _applyDecoratedDescriptor(_class2$H.prototype, "_positions", [ _dec6$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "positions", [ _dec7$5 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "positions"), _class2$H.prototype), 
    _descriptor4$h = _applyDecoratedDescriptor(_class2$H.prototype, "_width", [ _dec8$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "width", [ _dec9$3 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "width"), _class2$H.prototype), 
    _descriptor5$e = _applyDecoratedDescriptor(_class2$H.prototype, "_tile", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.v2(1, 1);
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "tile", [ _dec10$3 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "tile"), _class2$H.prototype), 
    _descriptor6$a = _applyDecoratedDescriptor(_class2$H.prototype, "_offset", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.v2(0, 0);
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "offset", [ _dec11$3 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "offset"), _class2$H.prototype), 
    _descriptor7$9 = _applyDecoratedDescriptor(_class2$H.prototype, "_color", [ _dec12$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange();
        }
    }), _applyDecoratedDescriptor(_class2$H.prototype, "color", [ _dec13$3 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "color"), _class2$H.prototype), 
    _class$S = _class2$H)) || _class$S) || _class$S) || _class$S), ColorOvertimeModule = (_dec$R = ccclass("cc.ColorOvertimeModule"), 
    _dec2$v = property({
        displayOrder: 0
    }), _dec3$j = property({
        type: GradientRange,
        displayOrder: 1
    }), _dec$R((_descriptor$H = _applyDecoratedDescriptor((_class2$I = function() {
        function ColorOvertimeModule() {
            _classCallCheck(this, ColorOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$H, this), 
            _initializerDefineProperty(this, "color", _descriptor2$y, this);
        }
        return _createClass(ColorOvertimeModule, [ {
            key: "animate",
            value: function animate(particle) {
                this.enable && particle.startColor.mul(this.color.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 91041)), particle.color);
            }
        } ]), ColorOvertimeModule;
    }()).prototype, "enable", [ _dec2$v ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$y = _applyDecoratedDescriptor(_class2$I.prototype, "color", [ _dec3$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange();
        }
    }), _class$T = _class2$I)) || _class$T), Space = Enum({
        World: 0,
        Local: 1
    }), RenderMode = Enum({
        Billboard: 0,
        StrecthedBillboard: 1,
        HorizontalBillboard: 2,
        VerticalBillboard: 3,
        Mesh: 4
    }), ShapeType = Enum({
        Box: 0,
        Circle: 1,
        Cone: 2,
        Sphere: 3,
        Hemisphere: 4
    }), EmitLocation = Enum({
        Base: 0,
        Edge: 1,
        Shell: 2,
        Volume: 3
    }), ArcMode = Enum({
        Random: 0,
        Loop: 1,
        PingPong: 2
    }), TrailMode = Enum({
        Particles: 0,
        Ribbon: 1
    }), TextureMode = Enum({
        Stretch: 0,
        Repeat: 1
    }), particleEmitZAxis = vec3.create(0, 0, -1);
    function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
        return moduleSpace !== systemSpace ? (systemSpace === Space.World || mat4.invert(worldTransform, worldTransform), 
        mat4.getRotation(outQuat, worldTransform), !0) : (quat.set(outQuat, 0, 0, 0, 1), 
        !1);
    }
    function fixedAngleUnitVector2(out, theta) {
        vec2.set(out, Math.cos(theta), Math.sin(theta));
    }
    function randomUnitVector(out) {
        var z = randomRange(-1, 1), a = randomRange(0, 2 * Math.PI), r = Math.sqrt(1 - z * z), x = r * Math.cos(a), y = r * Math.sin(a);
        vec3.set(out, x, y, z);
    }
    function randomPointBetweenSphere(out, minRadius, maxRadius) {
        randomUnitVector(out), vec3.scale(out, out, minRadius + (maxRadius - minRadius) * random());
    }
    function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
        fixedAngleUnitVector2(out, theta), out.z = 0, vec3.scale(out, out, minRadius + (maxRadius - minRadius) * random());
    }
    function randomSortArray(arr) {
        for (var i = 0; i < arr.length; i++) {
            var transpose = i + randomRangeInt(0, arr.length - i), val = arr[transpose];
            arr[transpose] = arr[i], arr[i] = val;
        }
    }
    function randomSign() {
        var sgn = randomRange(-1, 1);
        return 0 === sgn && sgn++, sign(sgn);
    }
    var _dec$T, _dec2$x, _dec3$l, _dec4$f, _dec5$b, _dec6$a, _dec7$6, _dec8$4, _dec9$4, _class$V, _class2$K, _descriptor$J, _descriptor2$A, _descriptor3$q, _descriptor4$j, _descriptor5$g, _descriptor6$b, _descriptor7$a, _descriptor8$7, _dec$U, _dec2$y, _dec3$m, _dec4$g, _dec5$c, _dec6$b, _class$W, _class2$L, _descriptor$K, _descriptor2$B, _descriptor3$r, _descriptor4$k, _descriptor5$h, _temp_v3 = cc.v3(), ForceOvertimeModule = (_dec$S = ccclass("cc.ForceOvertimeModule"), 
    _dec2$w = property({
        displayOrder: 0
    }), _dec3$k = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 2
    }), _dec4$e = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 3
    }), _dec5$a = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 4
    }), _dec6$9 = property({
        type: Space,
        displayOrder: 1
    }), _dec$S((_descriptor$I = _applyDecoratedDescriptor((_class2$J = function() {
        function ForceOvertimeModule() {
            _classCallCheck(this, ForceOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$I, this), 
            _initializerDefineProperty(this, "x", _descriptor2$z, this), _initializerDefineProperty(this, "y", _descriptor3$p, this), 
            _initializerDefineProperty(this, "z", _descriptor4$i, this), _initializerDefineProperty(this, "space", _descriptor5$f, this), 
            this.randomized = !1, this.rotation = void 0, this.needTransform = void 0, this.rotation = quat.create(), 
            this.needTransform = !1;
        }
        return _createClass(ForceOvertimeModule, [ {
            key: "update",
            value: function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
            }
        }, {
            key: "animate",
            value: function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, force = vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)));
                this.needTransform && vec3.transformQuat(force, force, this.rotation), vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
            }
        } ]), ForceOvertimeModule;
    }()).prototype, "enable", [ _dec2$w ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$z = _applyDecoratedDescriptor(_class2$J.prototype, "x", [ _dec3$k ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor3$p = _applyDecoratedDescriptor(_class2$J.prototype, "y", [ _dec4$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor4$i = _applyDecoratedDescriptor(_class2$J.prototype, "z", [ _dec5$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor5$f = _applyDecoratedDescriptor(_class2$J.prototype, "space", [ _dec6$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$U = _class2$J)) || _class$U), _temp_v3$1 = cc.v3(), LimitVelocityOvertimeModule = (_dec$T = ccclass("cc.LimitVelocityOvertimeModule"), 
    _dec2$x = property({
        displayOrder: 0
    }), _dec3$l = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 4
    }), _dec4$f = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 5
    }), _dec5$b = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 6
    }), _dec6$a = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 3
    }), _dec7$6 = property({
        displayOrder: 7
    }), _dec8$4 = property({
        displayOrder: 2
    }), _dec9$4 = property({
        type: Space,
        displayOrder: 1
    }), _dec$T((_descriptor$J = _applyDecoratedDescriptor((_class2$K = function() {
        function LimitVelocityOvertimeModule() {
            _classCallCheck(this, LimitVelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$J, this), 
            _initializerDefineProperty(this, "limitX", _descriptor2$A, this), _initializerDefineProperty(this, "limitY", _descriptor3$q, this), 
            _initializerDefineProperty(this, "limitZ", _descriptor4$j, this), _initializerDefineProperty(this, "limit", _descriptor5$g, this), 
            _initializerDefineProperty(this, "dampen", _descriptor6$b, this), _initializerDefineProperty(this, "separateAxes", _descriptor7$a, this), 
            _initializerDefineProperty(this, "space", _descriptor8$7, this), this.drag = null, 
            this.multiplyDragByParticleSize = !1, this.multiplyDragByParticleVelocity = !1;
        }
        return _createClass(LimitVelocityOvertimeModule, [ {
            key: "animate",
            value: function animate(p) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, dampedVel = _temp_v3$1;
                this.separateAxes ? vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen)) : (vec3.normalize(dampedVel, p.ultimateVelocity), 
                vec3.scale(dampedVel, dampedVel, dampenBeyondLimit(vec3.magnitude(p.ultimateVelocity), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen))), 
                vec3.copy(p.ultimateVelocity, dampedVel);
            }
        } ]), LimitVelocityOvertimeModule;
    }()).prototype, "enable", [ _dec2$x ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$A = _applyDecoratedDescriptor(_class2$K.prototype, "limitX", [ _dec3$l ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor3$q = _applyDecoratedDescriptor(_class2$K.prototype, "limitY", [ _dec4$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor4$j = _applyDecoratedDescriptor(_class2$K.prototype, "limitZ", [ _dec5$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor5$g = _applyDecoratedDescriptor(_class2$K.prototype, "limit", [ _dec6$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor6$b = _applyDecoratedDescriptor(_class2$K.prototype, "dampen", [ _dec7$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 3;
        }
    }), _descriptor7$a = _applyDecoratedDescriptor(_class2$K.prototype, "separateAxes", [ _dec8$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$K.prototype, "space", [ _dec9$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$V = _class2$K)) || _class$V);
    function dampenBeyondLimit(vel, limit, dampen) {
        var sgn = Math.sign(vel), abs$$1 = Math.abs(vel);
        return limit < abs$$1 && (abs$$1 = lerp(abs$$1, limit, dampen)), abs$$1 * sgn;
    }
    var _dec$V, _dec2$z, _dec3$n, _dec4$h, _dec5$d, _dec6$c, _dec7$7, _class$X, _class2$M, _descriptor$L, _descriptor2$C, _descriptor3$s, _descriptor4$l, _descriptor5$i, _descriptor6$c, _dec$W, _dec2$A, _dec3$o, _dec4$i, _dec5$e, _dec6$d, _dec7$8, _dec8$5, _dec9$5, _dec10$4, _dec11$4, _dec12$4, _class$Y, _class2$N, _descriptor$M, _descriptor2$D, _descriptor3$t, _descriptor4$m, _descriptor5$j, _descriptor6$d, _descriptor7$b, _descriptor8$8, _descriptor9$5, _descriptor10$3, _descriptor11$2, _descriptor12$2, _descriptor13$2, _dec$X, _dec2$B, _dec3$p, _dec4$j, _dec5$f, _dec6$e, _dec7$9, _class$Z, _class2$O, _descriptor$N, _descriptor2$E, _descriptor3$u, _descriptor4$n, _descriptor5$k, _descriptor6$e, _dec$Y, _dec2$C, _class$_, _class2$P, _descriptor$O, _descriptor2$F, _descriptor3$v, _descriptor4$o, _descriptor5$l, _descriptor6$f, _dec$Z, _dec2$D, _dec3$q, _dec4$k, _dec5$g, _dec6$f, _dec7$a, _dec8$6, _dec9$6, _dec10$5, _dec11$5, _dec12$5, _dec13$4, _dec14$3, _dec15$2, _dec16$2, _dec17$1, _dec18$1, _dec19, _dec20, _class$10, _class2$Q, _descriptor$P, _descriptor2$G, _descriptor3$w, _descriptor4$p, _descriptor5$m, _descriptor6$g, _descriptor7$c, _descriptor8$9, _descriptor9$6, _descriptor10$4, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, RotationOvertimeModule = (_dec$U = ccclass("cc.RotationOvertimeModule"), 
    _dec2$y = property({
        displayOrder: 0
    }), _dec3$m = property({
        displayOrder: 1
    }), _dec4$g = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 2
    }), _dec5$c = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 3
    }), _dec6$b = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 4
    }), _dec$U((_descriptor$K = _applyDecoratedDescriptor((_class2$L = function() {
        function RotationOvertimeModule() {
            _classCallCheck(this, RotationOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$K, this), 
            _initializerDefineProperty(this, "_separateAxes", _descriptor2$B, this), _initializerDefineProperty(this, "x", _descriptor3$r, this), 
            _initializerDefineProperty(this, "y", _descriptor4$k, this), _initializerDefineProperty(this, "z", _descriptor5$h, this);
        }
        return _createClass(RotationOvertimeModule, [ {
            key: "separateAxes",
            get: function get() {
                return this._separateAxes;
            },
            set: function set(val) {
                val ? console.error("rotation overtime separateAxes is not supported!") : this._separateAxes = val;
            }
        } ]), _createClass(RotationOvertimeModule, [ {
            key: "animate",
            value: function animate(p, dt) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                this._separateAxes || (p.rotation.x += this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 125292)) * dt);
            }
        } ]), RotationOvertimeModule;
    }()).prototype, "enable", [ _dec2$y ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$B = _applyDecoratedDescriptor(_class2$L.prototype, "_separateAxes", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$L.prototype, "separateAxes", [ _dec3$m ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "separateAxes"), _class2$L.prototype), 
    _descriptor3$r = _applyDecoratedDescriptor(_class2$L.prototype, "x", [ _dec4$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor4$k = _applyDecoratedDescriptor(_class2$L.prototype, "y", [ _dec5$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor5$h = _applyDecoratedDescriptor(_class2$L.prototype, "z", [ _dec6$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _class$W = _class2$L)) || _class$W), SizeOvertimeModule = (_dec$V = ccclass("cc.SizeOvertimeModule"), 
    _dec2$z = property({
        displayOrder: 0
    }), _dec3$n = property({
        displayOrder: 1
    }), _dec4$h = property({
        type: CurveRange,
        displayOrder: 2
    }), _dec5$d = property({
        type: CurveRange,
        displayOrder: 3
    }), _dec6$c = property({
        type: CurveRange,
        displayOrder: 4
    }), _dec7$7 = property({
        type: CurveRange,
        displayOrder: 5
    }), _dec$V((_descriptor$L = _applyDecoratedDescriptor((_class2$M = function() {
        function SizeOvertimeModule() {
            _classCallCheck(this, SizeOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$L, this), 
            _initializerDefineProperty(this, "separateAxes", _descriptor2$C, this), _initializerDefineProperty(this, "size", _descriptor3$s, this), 
            _initializerDefineProperty(this, "x", _descriptor4$l, this), _initializerDefineProperty(this, "y", _descriptor5$i, this), 
            _initializerDefineProperty(this, "z", _descriptor6$c, this);
        }
        return _createClass(SizeOvertimeModule, [ {
            key: "animate",
            value: function animate(particle) {
                this.separateAxes || vec3.scale(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 39825)));
            }
        } ]), SizeOvertimeModule;
    }()).prototype, "enable", [ _dec2$z ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$C = _applyDecoratedDescriptor(_class2$M.prototype, "separateAxes", [ _dec3$n ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor3$s = _applyDecoratedDescriptor(_class2$M.prototype, "size", [ _dec4$h ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor4$l = _applyDecoratedDescriptor(_class2$M.prototype, "x", [ _dec5$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor5$i = _applyDecoratedDescriptor(_class2$M.prototype, "y", [ _dec6$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor6$c = _applyDecoratedDescriptor(_class2$M.prototype, "z", [ _dec7$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _class$X = _class2$M)) || _class$X), Mode$3 = Enum({
        Grid: 0,
        Sprites: 1
    }), Animation = Enum({
        WholeSheet: 0,
        SingleRow: 1
    }), TextureAnimationModule = (_dec$W = ccclass("cc.TextureAnimationModule"), _dec2$A = property({
        displayOrder: 0
    }), _dec3$o = property({
        type: Mode$3
    }), _dec4$i = property({
        type: Mode$3,
        displayOrder: 1
    }), _dec5$e = property({
        displayOrder: 2
    }), _dec6$d = property({
        displayOrder: 3
    }), _dec7$8 = property({
        type: Animation,
        displayOrder: 4
    }), _dec8$5 = property({
        type: CurveRange,
        displayOrder: 7
    }), _dec9$5 = property({
        type: CurveRange,
        displayOrder: 8
    }), _dec10$4 = property({
        displayOrder: 9
    }), _dec11$4 = property({
        displayOrder: 5
    }), _dec12$4 = property({
        displayOrder: 6
    }), _dec$W((_descriptor$M = _applyDecoratedDescriptor((_class2$N = function() {
        function TextureAnimationModule() {
            _classCallCheck(this, TextureAnimationModule), _initializerDefineProperty(this, "_enable", _descriptor$M, this), 
            _initializerDefineProperty(this, "_mode", _descriptor2$D, this), _initializerDefineProperty(this, "numTilesX", _descriptor3$t, this), 
            _initializerDefineProperty(this, "numTilesY", _descriptor4$m, this), _initializerDefineProperty(this, "animation", _descriptor5$j, this), 
            _initializerDefineProperty(this, "frameOverTime", _descriptor6$d, this), _initializerDefineProperty(this, "startFrame", _descriptor7$b, this), 
            _initializerDefineProperty(this, "cycleCount", _descriptor8$8, this), _initializerDefineProperty(this, "_flipU", _descriptor9$5, this), 
            _initializerDefineProperty(this, "_flipV", _descriptor10$3, this), _initializerDefineProperty(this, "_uvChannelMask", _descriptor11$2, this), 
            _initializerDefineProperty(this, "randomRow", _descriptor12$2, this), _initializerDefineProperty(this, "rowIndex", _descriptor13$2, this), 
            this.ps = null;
        }
        return _createClass(TextureAnimationModule, [ {
            key: "onInit",
            value: function onInit(ps) {
                this.ps = ps;
            }
        }, {
            key: "animate",
            value: function animate(p) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) / (this.numTilesX * this.numTilesY);
                if (this.animation === Animation.WholeSheet) p.frameIndex = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1); else if (this.animation === Animation.SingleRow) {
                    var rowLength = 1 / this.numTilesY;
                    if (this.randomRow) {
                        var f = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1), from = Math.floor(Math.random() * this.numTilesY) * rowLength, to = from + rowLength;
                        p.frameIndex = lerp(from, to, f);
                    } else {
                        var _from = this.rowIndex * rowLength, _to = _from + rowLength;
                        p.frameIndex = lerp(_from, _to, repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1));
                    }
                }
            }
        }, {
            key: "enable",
            get: function get() {
                return this._enable;
            },
            set: function set(val) {
                this._enable = val, this.ps.renderer._updateMaterialParams();
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(val) {
                val !== Mode$3.Sprites || console.error("particle texture animation's sprites is not supported!");
            }
        }, {
            key: "flipU",
            get: function get() {
                return this._flipU;
            },
            set: function set(val) {
                console.error("particle texture animation's flipU is not supported!");
            }
        }, {
            key: "flipV",
            get: function get() {
                return this._flipV;
            },
            set: function set(val) {
                console.error("particle texture animation's flipV is not supported!");
            }
        }, {
            key: "uvChannelMask",
            get: function get() {
                return this._uvChannelMask;
            },
            set: function set(val) {
                console.error("particle texture animation's uvChannelMask is not supported!");
            }
        } ]), TextureAnimationModule;
    }()).prototype, "_enable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$N.prototype, "enable", [ _dec2$A ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "enable"), _class2$N.prototype), 
    _descriptor2$D = _applyDecoratedDescriptor(_class2$N.prototype, "_mode", [ _dec3$o ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$3.Grid;
        }
    }), _applyDecoratedDescriptor(_class2$N.prototype, "mode", [ _dec4$i ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "mode"), _class2$N.prototype), 
    _descriptor3$t = _applyDecoratedDescriptor(_class2$N.prototype, "numTilesX", [ _dec5$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor4$m = _applyDecoratedDescriptor(_class2$N.prototype, "numTilesY", [ _dec6$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor5$j = _applyDecoratedDescriptor(_class2$N.prototype, "animation", [ _dec7$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Animation.WholeSheet;
        }
    }), _descriptor6$d = _applyDecoratedDescriptor(_class2$N.prototype, "frameOverTime", [ _dec8$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor7$b = _applyDecoratedDescriptor(_class2$N.prototype, "startFrame", [ _dec9$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$N.prototype, "cycleCount", [ _dec10$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$N.prototype, "_flipU", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$N.prototype, "_flipV", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$N.prototype, "_uvChannelMask", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return -1;
        }
    }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$N.prototype, "randomRow", [ _dec11$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$N.prototype, "rowIndex", [ _dec12$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$Y = _class2$N)) || _class$Y), _temp_v3$2 = cc.v3(), VelocityOvertimeModule = (_dec$X = ccclass("cc.VelocityOvertimeModule"), 
    _dec2$B = property({
        displayOrder: 0
    }), _dec3$p = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 2
    }), _dec4$j = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 3
    }), _dec5$f = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 4
    }), _dec6$e = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 5
    }), _dec7$9 = property({
        type: Space,
        displayOrder: 1
    }), _dec$X((_descriptor$N = _applyDecoratedDescriptor((_class2$O = function() {
        function VelocityOvertimeModule() {
            _classCallCheck(this, VelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$N, this), 
            _initializerDefineProperty(this, "x", _descriptor2$E, this), _initializerDefineProperty(this, "y", _descriptor3$u, this), 
            _initializerDefineProperty(this, "z", _descriptor4$n, this), _initializerDefineProperty(this, "speedModifier", _descriptor5$k, this), 
            _initializerDefineProperty(this, "space", _descriptor6$e, this), this.rotation = void 0, 
            this.needTransform = void 0, this.rotation = quat.create(), this.speedModifier.constant = 1, 
            this.needTransform = !1;
        }
        return _createClass(VelocityOvertimeModule, [ {
            key: "update",
            value: function update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
            }
        }, {
            key: "animate",
            value: function animate(p) {
                var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, vel = vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 197866)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 197866)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 197866)));
                this.needTransform && vec3.transformQuat(vel, vel, this.rotation), vec3.add(p.animatedVelocity, p.animatedVelocity, vel), 
                vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity), vec3.scale(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + 197866)));
            }
        } ]), VelocityOvertimeModule;
    }()).prototype, "enable", [ _dec2$B ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$E = _applyDecoratedDescriptor(_class2$O.prototype, "x", [ _dec3$p ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor3$u = _applyDecoratedDescriptor(_class2$O.prototype, "y", [ _dec4$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor4$n = _applyDecoratedDescriptor(_class2$O.prototype, "z", [ _dec5$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor5$k = _applyDecoratedDescriptor(_class2$O.prototype, "speedModifier", [ _dec6$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor6$e = _applyDecoratedDescriptor(_class2$O.prototype, "space", [ _dec7$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$Z = _class2$O)) || _class$Z), Burst = (_dec$Y = ccclass("cc.Burst"), 
    _dec2$C = property({
        type: CurveRange
    }), _dec$Y((_descriptor$O = _applyDecoratedDescriptor((_class2$P = function() {
        function Burst() {
            _classCallCheck(this, Burst), _initializerDefineProperty(this, "_time", _descriptor$O, this), 
            _initializerDefineProperty(this, "minCount", _descriptor2$F, this), _initializerDefineProperty(this, "maxCount", _descriptor3$v, this), 
            _initializerDefineProperty(this, "_repeatCount", _descriptor4$o, this), _initializerDefineProperty(this, "repeatInterval", _descriptor5$l, this), 
            _initializerDefineProperty(this, "count", _descriptor6$f, this), this._remainingCount = void 0, 
            this._curTime = void 0, this._remainingCount = 1, this._curTime = 0;
        }
        return _createClass(Burst, [ {
            key: "time",
            get: function get() {
                return this._time;
            },
            set: function set(val) {
                this._time = val, this._curTime = val;
            }
        }, {
            key: "repeatCount",
            get: function get() {
                return this._repeatCount;
            },
            set: function set(val) {
                this._repeatCount = val, this._remainingCount = val;
            }
        } ]), _createClass(Burst, [ {
            key: "update",
            value: function update(psys, dt) {
                if (0 === this._remainingCount && (this._remainingCount = this._repeatCount, this._curTime = this._time), 
                0 < this._remainingCount) {
                    var preFrameTime = repeat(psys._time - psys.startDelay.evaluate(), psys.duration) - dt;
                    preFrameTime = 0 < preFrameTime ? preFrameTime : 0;
                    var curFrameTime = repeat(psys.time - psys.startDelay.evaluate(), psys.duration);
                    this._curTime >= preFrameTime && this._curTime < curFrameTime && (psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime)), 
                    this._curTime += this.repeatInterval, --this._remainingCount);
                }
            }
        }, {
            key: "getMaxCount",
            value: function getMaxCount(psys) {
                return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
            }
        } ]), Burst;
    }()).prototype, "_time", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$P.prototype, "time", [ property ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "time"), _class2$P.prototype), 
    _descriptor2$F = _applyDecoratedDescriptor(_class2$P.prototype, "minCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 30;
        }
    }), _descriptor3$v = _applyDecoratedDescriptor(_class2$P.prototype, "maxCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 30;
        }
    }), _descriptor4$o = _applyDecoratedDescriptor(_class2$P.prototype, "_repeatCount", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$P.prototype, "repeatCount", [ property ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "repeatCount"), _class2$P.prototype), 
    _descriptor5$l = _applyDecoratedDescriptor(_class2$P.prototype, "repeatInterval", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor6$f = _applyDecoratedDescriptor(_class2$P.prototype, "count", [ _dec2$C ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _class$_ = _class2$P)) || _class$_), _intermediVec = vec3.create(0, 0, 0), _intermediArr = new Array(), _unitBoxExtent = vec3.create(.5, .5, .5), ShapeModule = (_dec$Z = ccclass("cc.ShapeModule"), 
    _dec2$D = property({
        displayOrder: 0
    }), _dec3$q = property({
        type: ShapeType,
        displayOrder: 1
    }), _dec4$k = property({
        type: EmitLocation,
        displayOrder: 2
    }), _dec5$g = property({
        displayOrder: 12
    }), _dec6$f = property({
        displayOrder: 13
    }), _dec7$a = property({
        displayOrder: 14
    }), _dec8$6 = property({
        displayOrder: 15
    }), _dec9$6 = property({
        displayOrder: 16
    }), _dec10$5 = property({
        displayOrder: 17
    }), _dec11$5 = property({
        displayOrder: 18
    }), _dec12$5 = property({
        displayOrder: 3
    }), _dec13$4 = property({
        displayOrder: 4
    }), _dec14$3 = property({
        displayOrder: 6
    }), _dec15$2 = property({
        type: ArcMode,
        displayOrder: 7
    }), _dec16$2 = property({
        displayOrder: 0
    }), _dec17$1 = property({
        type: CurveRange,
        displayOrder: 9
    }), _dec18$1 = property({
        displayOrder: 5
    }), _dec19 = property({
        displayOrder: 10
    }), _dec20 = property({
        displayOrder: 11
    }), _dec$Z((_descriptor$P = _applyDecoratedDescriptor((_class2$Q = function() {
        function ShapeModule() {
            _classCallCheck(this, ShapeModule), _initializerDefineProperty(this, "enable", _descriptor$P, this), 
            _initializerDefineProperty(this, "shapeType", _descriptor2$G, this), _initializerDefineProperty(this, "emitFrom", _descriptor3$w, this), 
            _initializerDefineProperty(this, "_position", _descriptor4$p, this), _initializerDefineProperty(this, "_rotation", _descriptor5$m, this), 
            _initializerDefineProperty(this, "_scale", _descriptor6$g, this), _initializerDefineProperty(this, "alignToDirection", _descriptor7$c, this), 
            _initializerDefineProperty(this, "randomDirectionAmount", _descriptor8$9, this), 
            _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor9$6, this), 
            _initializerDefineProperty(this, "randomPositionAmount", _descriptor10$4, this), 
            _initializerDefineProperty(this, "radius", _descriptor11$3, this), _initializerDefineProperty(this, "radiusThickness", _descriptor12$3, this), 
            _initializerDefineProperty(this, "_arc", _descriptor13$3, this), _initializerDefineProperty(this, "arcMode", _descriptor14, this), 
            _initializerDefineProperty(this, "arcSpread", _descriptor15, this), _initializerDefineProperty(this, "arcSpeed", _descriptor16, this), 
            _initializerDefineProperty(this, "_angle", _descriptor17, this), _initializerDefineProperty(this, "length", _descriptor18, this), 
            _initializerDefineProperty(this, "boxThickness", _descriptor19, this), this.mat = void 0, 
            this.quat = void 0, this.particleSystem = void 0, this.lastTime = void 0, this.totalAngle = void 0, 
            this.mat = mat4.create(), this.quat = quat.create(), this.particleSystem = null, 
            this.lastTime = 0, this.totalAngle = 0;
        }
        return _createClass(ShapeModule, [ {
            key: "position",
            get: function get() {
                return this._position;
            },
            set: function set(val) {
                this._position = val, this.constructMat();
            }
        }, {
            key: "rotation",
            get: function get() {
                return this._rotation;
            },
            set: function set(val) {
                this._rotation = val, this.constructMat();
            }
        }, {
            key: "scale",
            get: function get() {
                return this._scale;
            },
            set: function set(val) {
                this._scale = val, this.constructMat();
            }
        }, {
            key: "arc",
            get: function get() {
                return toDegree(this._arc);
            },
            set: function set(val) {
                this._arc = toRadian(val);
            }
        }, {
            key: "angle",
            get: function get() {
                return Math.round(100 * toDegree(this._angle)) / 100;
            },
            set: function set(val) {
                this._angle = toRadian(val);
            }
        } ]), _createClass(ShapeModule, [ {
            key: "onInit",
            value: function onInit(ps) {
                this.constructMat(), this.particleSystem = ps, this.lastTime = this.particleSystem._time, 
                this.totalAngle = 0;
            }
        }, {
            key: "constructMat",
            value: function constructMat() {
                quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z), 
                mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
            }
        }, {
            key: "emit",
            value: function emit(p) {
                switch (this.shapeType) {
                  case ShapeType.Box:
                    !function boxEmit(emitFrom, boxThickness, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Volume:
                            !function randomPointInCube(out, extents) {
                                vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
                            }(pos, _unitBoxExtent);
                            break;

                          case EmitLocation.Shell:
                            _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                            _intermediArr.push(randomRange(-.5, .5)), _intermediArr.push(.5 * randomSign()), 
                            randomSortArray(_intermediArr), applyBoxThickness(_intermediArr, boxThickness), 
                            vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                            break;

                          case EmitLocation.Edge:
                            _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                            _intermediArr.push(.5 * randomSign()), _intermediArr.push(.5 * randomSign()), randomSortArray(_intermediArr), 
                            applyBoxThickness(_intermediArr, boxThickness), vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for box emitter.");
                        }
                        vec3.copy(dir, particleEmitZAxis);
                    }(this.emitFrom, this.boxThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Circle:
                    !function circleEmit(radius, radiusThickness, theta, pos, dir) {
                        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                        vec3.normalize(dir, pos);
                    }(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                    break;

                  case ShapeType.Cone:
                    !function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Base:
                            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                            vec2.scale(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, vec3.normalize(dir, dir), 
                            pos.z = 0;
                            break;

                          case EmitLocation.Shell:
                            fixedAngleUnitVector2(pos, theta), vec2.scale(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle), 
                            vec3.normalize(dir, dir), vec2.scale(pos, pos, radius), pos.z = 0;
                            break;

                          case EmitLocation.Volume:
                            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                            vec2.scale(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, vec3.normalize(dir, dir), 
                            pos.z = 0, vec3.add(pos, pos, vec3.scale(_intermediVec, dir, length * random() / -dir.z));
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for cone emitter.");
                        }
                    }(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                    break;

                  case ShapeType.Sphere:
                    !function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Volume:
                            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), vec3.copy(dir, pos), 
                            vec3.normalize(dir, dir);
                            break;

                          case EmitLocation.Shell:
                            randomUnitVector(pos), vec3.scale(pos, pos, radius), vec3.copy(dir, pos);
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for sphere emitter.");
                        }
                    }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Hemisphere:
                    !function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                        switch (emitFrom) {
                          case EmitLocation.Volume:
                            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), 0 < pos.z && (pos.z *= -1), 
                            vec3.copy(dir, pos), vec3.normalize(dir, dir);
                            break;

                          case EmitLocation.Shell:
                            randomUnitVector(pos), vec3.scale(pos, pos, radius), pos.z < 0 && (pos.z *= -1), 
                            vec3.copy(dir, pos);
                            break;

                          default:
                            console.warn(emitFrom + " is not supported for hemisphere emitter.");
                        }
                    }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  default:
                    console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
                }
                if (0 < this.randomPositionAmount && (p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
                p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
                p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount)), 
                vec3.transformQuat(p.velocity, p.velocity, this.quat), vec3.transformMat4(p.position, p.position, this.mat), 
                0 < this.sphericalDirectionAmount) {
                    var sphericalVel = vec3.normalize(_intermediVec, p.position);
                    vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
                }
                this.lastTime = this.particleSystem._time;
            }
        }, {
            key: "generateArcAngle",
            value: function generateArcAngle() {
                if (this.arcMode === ArcMode.Random) return randomRange(0, this._arc);
                var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
                switch (this.totalAngle = angle, 0 !== this.arcSpread && (angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread), 
                this.arcMode) {
                  case ArcMode.Loop:
                    return repeat(angle, this._arc);

                  case ArcMode.PingPong:
                    return pingPong(angle, this._arc);
                }
            }
        } ]), ShapeModule;
    }()).prototype, "enable", [ _dec2$D ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$G = _applyDecoratedDescriptor(_class2$Q.prototype, "shapeType", [ _dec3$q ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ShapeType.Box;
        }
    }), _descriptor3$w = _applyDecoratedDescriptor(_class2$Q.prototype, "emitFrom", [ _dec4$k ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return EmitLocation.Volume;
        }
    }), _descriptor4$p = _applyDecoratedDescriptor(_class2$Q.prototype, "_position", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _applyDecoratedDescriptor(_class2$Q.prototype, "position", [ _dec5$g ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "position"), _class2$Q.prototype), 
    _descriptor5$m = _applyDecoratedDescriptor(_class2$Q.prototype, "_rotation", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _applyDecoratedDescriptor(_class2$Q.prototype, "rotation", [ _dec6$f ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "rotation"), _class2$Q.prototype), 
    _descriptor6$g = _applyDecoratedDescriptor(_class2$Q.prototype, "_scale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(1, 1, 1);
        }
    }), _applyDecoratedDescriptor(_class2$Q.prototype, "scale", [ _dec7$a ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "scale"), _class2$Q.prototype), 
    _descriptor7$c = _applyDecoratedDescriptor(_class2$Q.prototype, "alignToDirection", [ _dec8$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$Q.prototype, "randomDirectionAmount", [ _dec9$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$Q.prototype, "sphericalDirectionAmount", [ _dec10$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$Q.prototype, "randomPositionAmount", [ _dec11$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$Q.prototype, "radius", [ _dec12$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$Q.prototype, "radiusThickness", [ _dec13$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$Q.prototype, "_arc", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return toRadian(360);
        }
    }), _applyDecoratedDescriptor(_class2$Q.prototype, "arc", [ _dec14$3 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "arc"), _class2$Q.prototype), 
    _descriptor14 = _applyDecoratedDescriptor(_class2$Q.prototype, "arcMode", [ _dec15$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ArcMode.Random;
        }
    }), _descriptor15 = _applyDecoratedDescriptor(_class2$Q.prototype, "arcSpread", [ _dec16$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 8;
        }
    }), _descriptor16 = _applyDecoratedDescriptor(_class2$Q.prototype, "arcSpeed", [ _dec17$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor17 = _applyDecoratedDescriptor(_class2$Q.prototype, "_angle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return toRadian(25);
        }
    }), _applyDecoratedDescriptor(_class2$Q.prototype, "angle", [ _dec18$1 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "angle"), _class2$Q.prototype), 
    _descriptor18 = _applyDecoratedDescriptor(_class2$Q.prototype, "length", [ _dec19 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor19 = _applyDecoratedDescriptor(_class2$Q.prototype, "boxThickness", [ _dec20 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _class$10 = _class2$Q)) || _class$10);
    function applyBoxThickness(pos, thickness) {
        0 < thickness.x && (pos[0] += .5 * randomRange(-thickness.x, thickness.x), pos[0] = clamp(pos[0], -.5, .5)), 
        0 < thickness.y && (pos[1] += .5 * randomRange(-thickness.y, thickness.y), pos[1] = clamp(pos[1], -.5, .5)), 
        0 < thickness.z && (pos[2] += .5 * randomRange(-thickness.z, thickness.z), pos[2] = clamp(pos[2], -.5, .5));
    }
    var _dec$_, _dec2$E, _dec3$r, _dec4$l, _dec5$h, _dec6$g, _dec7$b, _dec8$7, _dec9$7, _dec10$6, _dec11$6, _class$11, _class2$R, _descriptor$Q, _descriptor2$H, _descriptor3$x, _descriptor4$q, _dec$10, _dec2$F, _dec3$s, _dec4$m, _dec5$i, _dec6$h, _dec7$c, _dec8$8, _dec9$8, _dec10$7, _dec11$7, _dec12$6, _dec13$5, _dec14$4, _dec15$3, _class$12, _class2$S, _descriptor$R, _descriptor2$I, _descriptor3$y, _descriptor4$r, _descriptor5$n, _descriptor6$h, _descriptor7$d, _descriptor8$a, _descriptor9$7, _descriptor10$5, _descriptor11$4, _descriptor12$4, _descriptor13$4, Particle = function Particle(particleSystem) {
        _classCallCheck(this, Particle), this.particleSystem = void 0, this.position = void 0, 
        this.velocity = void 0, this.animatedVelocity = void 0, this.ultimateVelocity = void 0, 
        this.angularVelocity = void 0, this.axisOfRotation = void 0, this.rotation = void 0, 
        this.startSize = void 0, this.size = void 0, this.startColor = void 0, this.color = cc.Color.WHITE, 
        this.randomSeed = void 0, this.remainingLifetime = void 0, this.startLifetime = void 0, 
        this.emitAccumulator0 = void 0, this.emitAccumulator1 = void 0, this.frameIndex = void 0, 
        this.particleSystem = particleSystem, this.position = vec3.create(0, 0, 0), this.velocity = vec3.create(0, 0, 0), 
        this.animatedVelocity = vec3.create(0, 0, 0), this.ultimateVelocity = vec3.create(0, 0, 0), 
        this.angularVelocity = vec3.create(0, 0, 0), this.axisOfRotation = vec3.create(0, 0, 0), 
        this.rotation = vec3.create(0, 0, 0), this.startSize = vec3.create(0, 0, 0), this.size = vec3.create(0, 0, 0), 
        this.startColor = cc.Color.WHITE, this.color = cc.Color.WHITE, this.randomSeed = 0, 
        this.remainingLifetime = 0, this.startLifetime = 0, this.emitAccumulator0 = 0, this.emitAccumulator1 = 0, 
        this.frameIndex = 0;
    }, _tempAttribUV = vec3.create(), _tempAttribUV0 = vec2.create(), _tempWorldTrans = (vec4.create(), 
    mat4.create()), _uvs = [ 0, 0, 1, 0, 0, 1, 1, 1 ], _vertex_attrs$1 = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    } ], _vertex_attrs_stretch = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR1,
        format: exports.GFXFormat.RGB32F
    } ], _vertex_attrs_mesh = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD1,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD2,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_NORMAL,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR1,
        format: exports.GFXFormat.RGBA8,
        isNormalized: !0
    } ], ParticleSystemRenderer = (_dec$_ = ccclass("cc.ParticleSystemRenderer"), _dec2$E = property({
        type: RenderMode,
        displayOrder: 0
    }), _dec3$r = property({
        displayOrder: 1
    }), _dec4$l = property({
        displayOrder: 2
    }), _dec5$h = property({
        type: RenderMode,
        displayOrder: 3
    }), _dec6$g = property({
        displayOrder: 4
    }), _dec7$b = property({
        displayOrder: 5
    }), _dec8$7 = property({
        displayOrder: 6
    }), _dec9$7 = property({
        type: Mesh,
        displayOrder: 7
    }), _dec10$6 = property({
        type: Material,
        displayOrder: 8
    }), _dec11$6 = property({
        type: Material,
        displayOrder: 9
    }), _dec$_((_applyDecoratedDescriptor((_class2$R = function() {
        function ParticleSystemRenderer() {
            _classCallCheck(this, ParticleSystemRenderer), _initializerDefineProperty(this, "_renderMode", _descriptor$Q, this), 
            _initializerDefineProperty(this, "_velocityScale", _descriptor2$H, this), _initializerDefineProperty(this, "_lengthScale", _descriptor3$x, this), 
            _initializerDefineProperty(this, "_mesh", _descriptor4$q, this), this._defines = void 0, 
            this._trailDefines = void 0, this._model = void 0, this.frameTile_velLenScale = void 0, 
            this._node_scale = void 0, this.attrs = void 0, this._vertAttrs = void 0, this.particleSystem = void 0, 
            this._particles = null, this._defaultMat = null, this._defaultTrailMat = null, this._model = null, 
            this.frameTile_velLenScale = cc.v4(1, 1, 0, 0), this._node_scale = cc.v4(), this.attrs = new Array(5), 
            this._defines = {
                CC_USE_WORLD_SPACE: !0,
                CC_USE_BILLBOARD: !0,
                CC_USE_STRETCHED_BILLBOARD: !1,
                CC_USE_HORIZONTAL_BILLBOARD: !1,
                CC_USE_VERTICAL_BILLBOARD: !1
            }, this._trailDefines = {
                CC_USE_WORLD_SPACE: !0
            };
        }
        return _createClass(ParticleSystemRenderer, [ {
            key: "renderMode",
            get: function get() {
                return this._renderMode;
            },
            set: function set(val) {
                this._renderMode !== val && (this._renderMode = val, this._setVertexAttrib(), this._updateModel(), 
                this._updateMaterialParams());
            }
        }, {
            key: "velocityScale",
            get: function get() {
                return this._velocityScale;
            },
            set: function set(val) {
                this._velocityScale = val, this._updateMaterialParams();
            }
        }, {
            key: "lengthScale",
            get: function get() {
                return this._lengthScale;
            },
            set: function set(val) {
                this._lengthScale = val, this._updateMaterialParams();
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(val) {
                this._mesh = val, this._model && this._model.setVertexAttributes(this._renderMode === RenderMode.Mesh ? this._mesh : null, this._vertAttrs);
            }
        }, {
            key: "particleMaterial",
            get: function get() {
                return this.particleSystem.getMaterial(0, !1);
            },
            set: function set(val) {
                this.particleSystem.setMaterial(val, 0);
            }
        }, {
            key: "trailMaterial",
            get: function get() {
                return this.particleSystem.getMaterial(1, !1);
            },
            set: function set(val) {
                this.particleSystem.setMaterial(val, 1);
            }
        } ]), _createClass(ParticleSystemRenderer, [ {
            key: "onInit",
            value: function onInit(ps) {
                var _this = this;
                this.particleSystem = ps.node.getComponent("cc.ParticleSystemComponent"), this._particles = new RecyclePool(function() {
                    return new Particle(_this);
                }, 16), this._setVertexAttrib(), this.onEnable();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.particleSystem && (null == this._model && (this._model = this.particleSystem._getRenderScene().createModel(ParticleBatchModel, this.particleSystem.node)), 
                this._model.inited || (this._model.setCapacity(this.particleSystem.capacity), this._model.node = this.particleSystem.node), 
                this._model.enabled = this.particleSystem.enabledInHierarchy, this._updateModel(), 
                this._updateMaterialParams(), this._updateTrailMaterial());
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._model && (this._model.enabled = this.particleSystem.enabledInHierarchy);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.particleSystem._getRenderScene().destroyModel(this._model), this._model = null;
            }
        }, {
            key: "clear",
            value: function clear() {
                this._particles.reset(), this._updateRenderData();
            }
        }, {
            key: "_getFreeParticle",
            value: function _getFreeParticle() {
                return this._particles.length >= this.particleSystem.capacity ? null : this._particles.add();
            }
        }, {
            key: "_setNewParticle",
            value: function _setNewParticle(p) {}
        }, {
            key: "_updateParticles",
            value: function _updateParticles(dt) {
                switch (this.particleSystem.node.getWorldMatrix(_tempWorldTrans), this.particleSystem.scaleSpace) {
                  case Space.Local:
                    this.particleSystem.node.getScale(this._node_scale);
                    break;

                  case Space.World:
                    this.particleSystem.node.getWorldScale(this._node_scale);
                }
                (this.particleSystem.sharedMaterial ? this.particleMaterial : this._defaultMat).setProperty("scale", this._node_scale), 
                this.particleSystem.velocityOvertimeModule.enable && this.particleSystem.velocityOvertimeModule.update(this.particleSystem._simulationSpace, _tempWorldTrans), 
                this.particleSystem.forceOvertimeModule.enable && this.particleSystem.forceOvertimeModule.update(this.particleSystem._simulationSpace, _tempWorldTrans), 
                this.particleSystem.trailModule.enable && this.particleSystem.trailModule.update();
                for (var i = 0; i < this._particles.length; ++i) {
                    var p = this._particles.data[i];
                    p.remainingLifetime -= dt, vec3.set(p.animatedVelocity, 0, 0, 0), p.remainingLifetime < 0 ? (this.particleSystem.trailModule.enable && this.particleSystem.trailModule.removeParticle(p), 
                    this._particles.removeAt(i), --i) : (p.velocity.y -= 9.8 * this.particleSystem.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed) * dt, 
                    this.particleSystem.sizeOvertimeModule.enable && this.particleSystem.sizeOvertimeModule.animate(p), 
                    this.particleSystem.colorOverLifetimeModule.enable && this.particleSystem.colorOverLifetimeModule.animate(p), 
                    this.particleSystem.forceOvertimeModule.enable && this.particleSystem.forceOvertimeModule.animate(p, dt), 
                    this.particleSystem.velocityOvertimeModule.enable && this.particleSystem.velocityOvertimeModule.animate(p), 
                    this.particleSystem.limitVelocityOvertimeModule.enable && this.particleSystem.limitVelocityOvertimeModule.animate(p), 
                    this.particleSystem.rotationOvertimeModule.enable && this.particleSystem.rotationOvertimeModule.animate(p, dt), 
                    this.particleSystem.textureAnimationModule.enable && this.particleSystem.textureAnimationModule.animate(p), 
                    vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt), this.particleSystem.trailModule.enable && this.particleSystem.trailModule.animate(p, dt));
                }
                return this._particles.length;
            }
        }, {
            key: "_updateRenderData",
            value: function _updateRenderData() {
                for (var idx = 0, uploadVel = this._renderMode === RenderMode.StrecthedBillboard, i = 0; i < this._particles.length; ++i) {
                    var p = this._particles.data[i], fi = 0;
                    this.particleSystem.textureAnimationModule.enable && (fi = p.frameIndex), idx = 4 * i;
                    var attrNum = 0;
                    if (this._renderMode !== RenderMode.Mesh) for (var j = 0; j < 4; ++j) attrNum = 0, 
                    this.attrs[attrNum++] = p.position, _tempAttribUV.x = _uvs[2 * j], _tempAttribUV.y = _uvs[2 * j + 1], 
                    _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, _tempAttribUV0.x = p.size.x, 
                    _tempAttribUV0.y = p.rotation.x, this.attrs[attrNum++] = _tempAttribUV0, this.attrs[attrNum++] = p.color._val, 
                    this.attrs[attrNum++] = uploadVel ? p.ultimateVelocity : null, this._model.addParticleVertexData(idx++, this.attrs); else attrNum = 0, 
                    this.attrs[attrNum++] = p.position, _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, 
                    _tempAttribUV0.x = p.size.x, _tempAttribUV0.y = p.rotation.x, this.attrs[attrNum++] = _tempAttribUV0, 
                    this.attrs[attrNum++] = p.color._val, this._model.addParticleVertexData(i, this.attrs);
                }
                this._model.updateIA(this._particles.length);
            }
        }, {
            key: "updateShaderUniform",
            value: function updateShaderUniform() {}
        }, {
            key: "getParticleCount",
            value: function getParticleCount() {
                return this._particles.length;
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {
                0 === index ? (this._updateMaterialParams(), this._updateModel()) : this._updateTrailMaterial();
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(index, material) {
                this._model && 0 === index && this._model.setSubModelMaterial(0, material), this.particleSystem.trailModule._trailModel && 1 === index && this.particleSystem.trailModule._trailModel.setSubModelMaterial(0, material);
            }
        }, {
            key: "_setVertexAttrib",
            value: function _setVertexAttrib() {
                switch (this._renderMode) {
                  case RenderMode.StrecthedBillboard:
                    this._vertAttrs = _vertex_attrs_stretch.slice();
                    break;

                  case RenderMode.Mesh:
                    this._vertAttrs = _vertex_attrs_mesh.slice();
                    break;

                  default:
                    this._vertAttrs = _vertex_attrs$1.slice();
                }
            }
        }, {
            key: "_updateMaterialParams",
            value: function _updateMaterialParams() {
                if (this.particleSystem) {
                    null != this.particleSystem.sharedMaterial && -1 === this.particleSystem.sharedMaterial._effectAsset._name.indexOf("particle") && this.particleSystem.setMaterial(null, 0, !1), 
                    null == this.particleSystem.sharedMaterial && null == this._defaultMat && (this._defaultMat = Material.getInstantiatedMaterial(builtinResMgr.get("default-particle-material"), this.particleSystem, !0));
                    var mat = this.particleSystem.sharedMaterial ? this.particleMaterial : this._defaultMat;
                    this.particleSystem._simulationSpace === Space.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1, 
                    this._renderMode === RenderMode.Billboard ? (this._defines.CC_USE_BILLBOARD = !0, 
                    this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                    this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode.StrecthedBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                    this._defines.CC_USE_STRETCHED_BILLBOARD = !0, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                    this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1, this.frameTile_velLenScale.z = this._velocityScale, 
                    this.frameTile_velLenScale.w = this._lengthScale) : this._renderMode === RenderMode.HorizontalBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                    this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !0, 
                    this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode.VerticalBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                    this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                    this._defines.CC_USE_VERTICAL_BILLBOARD = !0, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode.Mesh ? (this._defines.CC_USE_BILLBOARD = !1, 
                    this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                    this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !0) : console.warn("particle system renderMode ".concat(this._renderMode, " not support.")), 
                    mat.recompileShaders(this._defines), this.particleSystem.textureAnimationModule.enable ? mat.setProperty("frameTile_velLenScale", vec2.set(this.frameTile_velLenScale, this.particleSystem.textureAnimationModule.numTilesX, this.particleSystem.textureAnimationModule.numTilesY)) : mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale), 
                    this._model && this._model.setSubModelMaterial(0, this.particleSystem.sharedMaterial || this._defaultMat);
                }
            }
        }, {
            key: "_updateTrailMaterial",
            value: function _updateTrailMaterial() {
                if (this.particleSystem.trailModule.enable) {
                    this.particleSystem._simulationSpace === Space.World || this.particleSystem.trailModule.space === Space.World ? this._trailDefines.CC_USE_WORLD_SPACE = !0 : this._trailDefines.CC_USE_WORLD_SPACE = !1;
                    var mat = this.trailMaterial;
                    null === mat && null === this._defaultTrailMat && (this._defaultTrailMat = Material.getInstantiatedMaterial(builtinResMgr.get("default-trail-material"), this.particleSystem, !0)), 
                    null === mat && (mat = this._defaultTrailMat), mat.recompileShaders(this._trailDefines), 
                    this.particleSystem.trailModule._updateMaterial();
                }
            }
        }, {
            key: "_updateModel",
            value: function _updateModel() {
                this._model && this._model.setVertexAttributes(this._renderMode === RenderMode.Mesh ? this._mesh : null, this._vertAttrs);
            }
        } ]), ParticleSystemRenderer;
    }()).prototype, "renderMode", [ _dec2$E ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "renderMode"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "velocityScale", [ _dec3$r ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "velocityScale"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "lengthScale", [ _dec4$l ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "lengthScale"), _class2$R.prototype), 
    _descriptor$Q = _applyDecoratedDescriptor(_class2$R.prototype, "_renderMode", [ _dec5$h ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return RenderMode.Billboard;
        }
    }), _descriptor2$H = _applyDecoratedDescriptor(_class2$R.prototype, "_velocityScale", [ _dec6$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor3$x = _applyDecoratedDescriptor(_class2$R.prototype, "_lengthScale", [ _dec7$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$q = _applyDecoratedDescriptor(_class2$R.prototype, "_mesh", [ _dec8$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _applyDecoratedDescriptor(_class2$R.prototype, "mesh", [ _dec9$7 ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "mesh"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "particleMaterial", [ _dec10$6 ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "particleMaterial"), _class2$R.prototype), 
    _applyDecoratedDescriptor(_class2$R.prototype, "trailMaterial", [ _dec11$6 ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "trailMaterial"), _class2$R.prototype), 
    _class$11 = _class2$R)) || _class$11);
    Object.assign(ParticleSystemRenderer, {
        uv: _uvs
    });
    var _dec$11, _dec2$G, _dec3$t, _dec4$n, _dec5$j, _dec6$i, _dec7$d, _dec8$9, _dec9$9, _dec10$8, _dec11$8, _dec12$7, _dec13$6, _dec14$5, _dec15$4, _dec16$3, _dec17$2, _dec18$2, _dec19$1, _dec20$1, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class$13, _class2$T, _descriptor$S, _descriptor2$J, _descriptor3$z, _descriptor4$s, _descriptor5$o, _descriptor6$i, _descriptor7$e, _descriptor8$b, _descriptor9$8, _descriptor10$6, _descriptor11$5, _descriptor12$5, _descriptor13$5, _descriptor14$1, _descriptor15$1, _descriptor16$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _temp_trailEle = {
        position: cc.v3(),
        velocity: cc.v3()
    }, _temp_quat = cc.quat(), _temp_xform = cc.mat4(), _temp_vec3 = cc.v3(), _temp_vec3_1 = cc.v3(), _temp_color = cc.color(), TrailSegment = function() {
        function TrailSegment(maxTrailElementNum) {
            for (_classCallCheck(this, TrailSegment), this.start = void 0, this.end = void 0, 
            this.trailElements = void 0, this.start = -1, this.end = -1, this.trailElements = []; maxTrailElementNum--; ) this.trailElements.push({
                position: cc.v3(),
                lifetime: 0,
                width: 0,
                velocity: cc.v3(),
                color: cc.color()
            });
        }
        return _createClass(TrailSegment, [ {
            key: "getElement",
            value: function getElement(idx) {
                return -1 === this.start ? null : (idx < 0 && (idx = (idx + this.trailElements.length) % this.trailElements.length), 
                idx >= this.trailElements.length && (idx %= this.trailElements.length), this.trailElements[idx]);
            }
        }, {
            key: "addElement",
            value: function addElement() {
                if (0 === this.trailElements.length) return null;
                if (-1 === this.start) return this.start = 0, this.end = 1, this.trailElements[0];
                this.start === this.end && (this.start++, this.start %= this.trailElements.length);
                var newEleLoc = this.end++;
                return this.end %= this.trailElements.length, this.trailElements[newEleLoc];
            }
        }, {
            key: "iterateElement",
            value: function iterateElement(target, f, p, dt) {
                for (var end = this.start >= this.end ? this.end + this.trailElements.length : this.end, i = this.start; i < end; i++) f(target, this.trailElements[i % this.trailElements.length], p, dt) && (this.start++, 
                this.start %= this.trailElements.length);
                this.start === end && (this.start = -1, this.end = -1);
            }
        }, {
            key: "count",
            value: function count() {
                return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.start = -1, this.end = -1;
            }
        } ]), TrailSegment;
    }(), TrailModule = (_dec$10 = ccclass("cc.TrailModule"), _dec2$F = property({
        displayOrder: 0
    }), _dec3$s = property({
        type: TrailMode,
        displayOrder: 1
    }), _dec4$m = property({
        displayOrder: 2
    }), _dec5$i = property({
        type: CurveRange,
        displayOrder: 3
    }), _dec6$h = property({
        displayOrder: 5
    }), _dec7$c = property({
        type: Space
    }), _dec8$8 = property({
        type: Space,
        displayOrder: 6
    }), _dec9$8 = property({
        displayOrder: 7
    }), _dec10$7 = property({
        type: TextureMode,
        displayOrder: 8
    }), _dec11$7 = property({
        displayOrder: 9
    }), _dec12$6 = property({
        type: CurveRange,
        displayOrder: 10
    }), _dec13$5 = property({
        displayOrder: 11
    }), _dec14$4 = property({
        type: GradientRange,
        displayOrder: 12
    }), _dec15$3 = property({
        type: GradientRange,
        displayOrder: 13
    }), _dec$10((_applyDecoratedDescriptor((_class2$S = function() {
        function TrailModule() {
            _classCallCheck(this, TrailModule), _initializerDefineProperty(this, "_enable", _descriptor$R, this), 
            _initializerDefineProperty(this, "mode", _descriptor2$I, this), _initializerDefineProperty(this, "ratio", _descriptor3$y, this), 
            _initializerDefineProperty(this, "lifeTime", _descriptor4$r, this), _initializerDefineProperty(this, "_minParticleDistance", _descriptor5$n, this), 
            _initializerDefineProperty(this, "_space", _descriptor6$h, this), _initializerDefineProperty(this, "existWithParticles", _descriptor7$d, this), 
            _initializerDefineProperty(this, "textureMode", _descriptor8$a, this), _initializerDefineProperty(this, "widthFromParticle", _descriptor9$7, this), 
            _initializerDefineProperty(this, "widthRatio", _descriptor10$5, this), _initializerDefineProperty(this, "colorFromParticle", _descriptor11$4, this), 
            _initializerDefineProperty(this, "colorOverTrail", _descriptor12$4, this), _initializerDefineProperty(this, "colorOvertime", _descriptor13$4, this), 
            this._particleSystem = void 0, this._minSquaredDistance = 0, this._vertSize = void 0, 
            this._trailNum = 0, this._trailLifetime = 0, this.vbOffset = 0, this.ibOffset = 0, 
            this._trailSegments = void 0, this._particleTrail = void 0, this._trailModel = null, 
            this._iaInfo = void 0, this._iaInfoBuffer = void 0, this._subMeshData = null, this._vertAttrs = void 0, 
            this._vbF32 = void 0, this._vbUint32 = void 0, this._iBuffer = void 0, this._needTransform = void 0, 
            this._defaultMat = null, this._iaInfo = {
                drawInfos: [ {
                    vertexCount: 0,
                    firstVertex: 0,
                    indexCount: 0,
                    firstIndex: 0,
                    vertexOffset: 0,
                    instanceCount: 0,
                    firstInstance: 0
                } ]
            }, this._vertAttrs = [ {
                name: exports.GFXAttributeName.ATTR_POSITION,
                format: exports.GFXFormat.RGB32F
            }, {
                name: exports.GFXAttributeName.ATTR_TEX_COORD,
                format: exports.GFXFormat.RGBA32F
            }, {
                name: exports.GFXAttributeName.ATTR_TEX_COORD1,
                format: exports.GFXFormat.RGB32F
            }, {
                name: exports.GFXAttributeName.ATTR_COLOR,
                format: exports.GFXFormat.RGBA8,
                isNormalized: !0
            } ], this._vertSize = 0;
            var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var a = _ref;
                this._vertSize += GFXFormatInfos[a.format].size;
            }
            this._particleTrail = new Map();
        }
        return _createClass(TrailModule, [ {
            key: "enable",
            get: function get() {
                return this._enable;
            },
            set: function set(val) {
                val && !this._trailModel && this._createModel(), val && !this._enable && (this._enable = val, 
                this._particleSystem.renderer._updateTrailMaterial()), this._enable = val, this._trailModel && (this._trailModel.enabled = val);
            }
        }, {
            key: "minParticleDistance",
            get: function get() {
                return this._minParticleDistance;
            },
            set: function set(val) {
                this._minParticleDistance = val, this._minSquaredDistance = val * val;
            }
        }, {
            key: "space",
            get: function get() {
                return this._space;
            },
            set: function set(val) {
                this._space = val, this._particleSystem.renderer._updateTrailMaterial();
            }
        } ]), _createClass(TrailModule, [ {
            key: "init",
            value: function init(ps) {
                var _this = this, burstCount = 0, _iterator2 = (this._particleSystem = ps).bursts, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    burstCount += _ref2.getMaxCount(ps);
                }
                this._trailNum = Math.ceil(ps.startLifetime.getMax() * this.lifeTime.getMax() * 60 * (ps.rateOverTime.getMax() * ps.duration + burstCount)), 
                this._trailSegments = new Pool$1(function() {
                    return new TrailSegment(Math.ceil(ps.startLifetime.getMax() * _this.lifeTime.getMax() * 60));
                }, Math.ceil(ps.rateOverTime.getMax() * ps.duration)), this._enable && (this.enable = this._enable, 
                this._updateMaterial());
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._enable && this._trailModel && (this._trailModel.enabled = !0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._enable && this._trailModel && (this._trailModel.enabled = !1);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._trailModel && (this._particleSystem._getRenderScene().destroyModel(this._trailModel), 
                this._trailModel = null);
            }
        }, {
            key: "clear",
            value: function clear() {
                if (this.enable) {
                    for (var trailIter = this._particleTrail.values(), trail = trailIter.next(); !trail.done; ) trail.value.clear(), 
                    trail = trailIter.next();
                    this._particleTrail.clear(), this.updateRenderData();
                }
            }
        }, {
            key: "_createModel",
            value: function _createModel() {
                if (!this._trailModel) {
                    var device = cc.director.root.device, vertexBuffer = device.createBuffer({
                        usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: this._vertSize * (this._trailNum + 1) * 2,
                        stride: this._vertSize
                    }), vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                    this._vbF32 = new Float32Array(vBuffer), this._vbUint32 = new Uint32Array(vBuffer), 
                    vertexBuffer.update(vBuffer);
                    var indexBuffer = device.createBuffer({
                        usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: 6 * this._trailNum * Uint16Array.BYTES_PER_ELEMENT,
                        stride: Uint16Array.BYTES_PER_ELEMENT
                    });
                    this._iBuffer = new Uint16Array(6 * this._trailNum), indexBuffer.update(this._iBuffer), 
                    this._iaInfoBuffer = device.createBuffer({
                        usage: GFXBufferUsageBit.INDIRECT,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: 56,
                        stride: 1
                    }), this._iaInfo.drawInfos[0].vertexCount = 2 * (this._trailNum + 1), this._iaInfo.drawInfos[0].indexCount = 6 * this._trailNum, 
                    this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                        vertexBuffers: [ vertexBuffer ],
                        indexBuffer: indexBuffer,
                        indirectBuffer: this._iaInfoBuffer,
                        attributes: this._vertAttrs,
                        primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST
                    }, this._trailModel = this._particleSystem._getRenderScene().createModel(Model, this._particleSystem.node), 
                    this._trailModel.setSubModelMesh(0, this._subMeshData), this._trailModel.enabled = !0;
                }
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial() {
                if (this._particleSystem) {
                    var mat = this._particleSystem.renderer.trailMaterial;
                    mat ? this._trailModel.setSubModelMaterial(0, mat) : this._trailModel.setSubModelMaterial(0, this._particleSystem.renderer._defaultTrailMat);
                }
            }
        }, {
            key: "update",
            value: function update() {
                this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1), this.space === Space.World && this._particleSystem._simulationSpace === Space.Local ? (this._needTransform = !0, 
                this._particleSystem.node.getWorldMatrix(_temp_xform), this._particleSystem.node.getWorldRotation(_temp_quat)) : this._needTransform = !1;
            }
        }, {
            key: "animate",
            value: function animate(p, scaledDt) {
                var trail = this._particleTrail.get(p);
                trail || (trail = this._trailSegments.alloc(), this._particleTrail.set(p, trail));
                var lastSeg = trail.getElement(trail.end - 1);
                if (this._needTransform ? vec3.transformMat4(_temp_vec3, p.position, _temp_xform) : vec3.copy(_temp_vec3, p.position), 
                !(lastSeg && (trail.iterateElement(this, this._updateTrailElement, p, scaledDt), 
                vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance)) && (lastSeg = trail.addElement())) {
                    vec3.copy(lastSeg.position, _temp_vec3), lastSeg.lifetime = 0, this.widthFromParticle ? lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1) : lastSeg.width = this.widthRatio.evaluate(0, 1);
                    var trailNum = trail.count();
                    if (2 === trailNum) {
                        var lastSecondTrail = trail.getElement(trail.end - 2);
                        vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                    } else if (2 < trailNum) {
                        var _lastSecondTrail = trail.getElement(trail.end - 2), lastThirdTrail = trail.getElement(trail.end - 3);
                        vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position), vec3.subtract(_temp_vec3_1, lastSeg.position, _lastSecondTrail.position), 
                        vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);
                    }
                    this.colorFromParticle ? lastSeg.color.set(p.color) : lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                }
            }
        }, {
            key: "_updateTrailElement",
            value: function _updateTrailElement(module, trailEle, p, dt) {
                return trailEle.lifetime += dt, module.colorFromParticle ? p.color.mul(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1), trailEle.color) : trailEle.color.set(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1)), 
                module.widthFromParticle ? trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1) : trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1), 
                trailEle.lifetime > module._trailLifetime;
            }
        }, {
            key: "removeParticle",
            value: function removeParticle(p) {
                var trail = this._particleTrail.get(p);
                trail && (trail.clear(), this._trailSegments.free(trail), this._particleTrail.delete(p));
            }
        }, {
            key: "updateRenderData",
            value: function updateRenderData() {
                this.vbOffset = 0, this.ibOffset = 0;
                var _iterator3 = this._particleTrail.keys(), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var p = _ref3, trailSeg = this._particleTrail.get(p);
                    if (-1 !== trailSeg.start) {
                        var indexOffset = 4 * this.vbOffset / this._vertSize, end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end, trailNum = end - trailSeg.start, textCoordSeg = 1 / trailNum, startSegEle = trailSeg.trailElements[trailSeg.start];
                        this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 0, 0, 4);
                        for (var i = trailSeg.start + 1; i < end; i++) {
                            var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length], j = i - trailSeg.start;
                            this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, j * textCoordSeg, j, 5);
                        }
                        if (this._needTransform ? vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform) : vec3.copy(_temp_trailEle.position, p.position), 
                        1 === trailNum) {
                            var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                            vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x, 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y, 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z, 
                            this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x, this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y, 
                            this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z, vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);
                        } else if (2 < trailNum) {
                            var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1), lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                            vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position), 
                            vec3.subtract(_temp_vec3_1, _temp_trailEle.position, _lastSecondTrail2.position), 
                            vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1, _temp_vec3), this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = _lastSecondTrail2.velocity.x, 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = _lastSecondTrail2.velocity.y, 
                            this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = _lastSecondTrail2.velocity.z, 
                            this._vbF32[this.vbOffset - 4] = _lastSecondTrail2.velocity.x, this._vbF32[this.vbOffset - 3] = _lastSecondTrail2.velocity.y, 
                            this._vbF32[this.vbOffset - 2] = _lastSecondTrail2.velocity.z, vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position);
                        }
                        _temp_trailEle.width = p.size.x, _temp_trailEle.color = p.color, this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 1, trailNum, 1);
                    }
                }
                this.updateIA(this.ibOffset);
            }
        }, {
            key: "_fillVertexBuffer",
            value: function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
                this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
                this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 0, 
                this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
                this._vbF32[this.vbOffset++] = 0, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
                trailSeg.color.mul(colorModifer, _temp_color), this._vbUint32[this.vbOffset++] = _temp_color._val, 
                this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
                this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 1, 
                this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
                this._vbF32[this.vbOffset++] = 1, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
                this._vbUint32[this.vbOffset++] = _temp_color._val, 1 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
                this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1), 
                4 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
                this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2);
            }
        }, {
            key: "updateIA",
            value: function updateIA(count) {
                this._trailModel.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vbF32), 
                this._trailModel.getSubModel(0).inputAssembler.indexBuffer.update(this._iBuffer), 
                this._trailModel.getSubModel(0).inputAssembler.indexCount = count, this._trailModel.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), 
                this._iaInfoBuffer.update(this._iaInfo);
            }
        } ]), TrailModule;
    }()).prototype, "enable", [ _dec2$F ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "enable"), _class2$S.prototype), 
    _descriptor$R = _applyDecoratedDescriptor(_class2$S.prototype, "_enable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$I = _applyDecoratedDescriptor(_class2$S.prototype, "mode", [ _dec3$s ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return TrailMode.Particles;
        }
    }), _descriptor3$y = _applyDecoratedDescriptor(_class2$S.prototype, "ratio", [ _dec4$m ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$r = _applyDecoratedDescriptor(_class2$S.prototype, "lifeTime", [ _dec5$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _applyDecoratedDescriptor(_class2$S.prototype, "minParticleDistance", [ _dec6$h ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "minParticleDistance"), _class2$S.prototype), 
    _descriptor5$n = _applyDecoratedDescriptor(_class2$S.prototype, "_minParticleDistance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor6$h = _applyDecoratedDescriptor(_class2$S.prototype, "_space", [ _dec7$c ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.World;
        }
    }), _applyDecoratedDescriptor(_class2$S.prototype, "space", [ _dec8$8 ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "space"), _class2$S.prototype), 
    _descriptor7$d = _applyDecoratedDescriptor(_class2$S.prototype, "existWithParticles", [ _dec9$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor8$a = _applyDecoratedDescriptor(_class2$S.prototype, "textureMode", [ _dec10$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return TextureMode.Stretch;
        }
    }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$S.prototype, "widthFromParticle", [ _dec11$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$S.prototype, "widthRatio", [ _dec12$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$S.prototype, "colorFromParticle", [ _dec13$5 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$S.prototype, "colorOverTrail", [ _dec14$4 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange();
        }
    }), _descriptor13$4 = _applyDecoratedDescriptor(_class2$S.prototype, "colorOvertime", [ _dec15$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange();
        }
    }), _class$12 = _class2$S)) || _class$12), _world_mat = mat4.create(), ParticleSystemComponent = (_dec$11 = ccclass("cc.ParticleSystemComponent"), 
    _dec2$G = menu("Components/ParticleSystemComponent"), _dec3$t = executionOrder(99), 
    _dec4$n = property({
        displayOrder: 1
    }), _dec5$j = property({
        type: GradientRange,
        displayOrder: 8
    }), _dec6$i = property({
        type: Space,
        displayOrder: 9
    }), _dec7$d = property({
        type: CurveRange,
        displayOrder: 10
    }), _dec8$9 = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 11
    }), _dec9$9 = property({
        type: CurveRange,
        range: [ -1, 1 ],
        radian: !0,
        displayOrder: 12
    }), _dec10$8 = property({
        type: CurveRange,
        displayOrder: 6
    }), _dec11$8 = property({
        type: CurveRange,
        displayOrder: 7
    }), _dec12$7 = property({
        displayOrder: 0
    }), _dec13$6 = property({
        displayOrder: 2
    }), _dec14$5 = property({
        displayOrder: 3
    }), _dec15$4 = property({
        type: Space,
        displayOrder: 4
    }), _dec16$3 = property({
        displayOrder: 5
    }), _dec17$2 = property({
        displayOrder: 2
    }), _dec18$2 = property({
        type: CurveRange,
        range: [ -1, 1 ],
        displayOrder: 13
    }), _dec19$1 = property({
        type: CurveRange,
        displayOrder: 14
    }), _dec20$1 = property({
        type: CurveRange,
        displayOrder: 15
    }), _dec21 = property({
        type: [ Burst ],
        displayOrder: 16
    }), _dec22 = property({
        type: Material,
        displayName: "Materials",
        visible: !1,
        override: !0
    }), _dec23 = property({
        type: ColorOvertimeModule,
        displayOrder: 23
    }), _dec24 = property({
        type: ShapeModule,
        displayOrder: 17
    }), _dec25 = property({
        type: SizeOvertimeModule,
        displayOrder: 21
    }), _dec26 = property({
        type: VelocityOvertimeModule,
        displayOrder: 18
    }), _dec27 = property({
        type: ForceOvertimeModule,
        displayOrder: 19
    }), _dec28 = property({
        type: LimitVelocityOvertimeModule,
        displayOrder: 20
    }), _dec29 = property({
        type: RotationOvertimeModule,
        displayOrder: 22
    }), _dec30 = property({
        type: TextureAnimationModule,
        displayOrder: 24
    }), _dec31 = property({
        type: TrailModule,
        displayOrder: 25
    }), _dec32 = property({
        type: ParticleSystemRenderer,
        displayOrder: 26
    }), _dec$11(_class$13 = _dec2$G(_class$13 = _dec3$t(_class$13 = executeInEditMode((_applyDecoratedDescriptor((_class2$T = function(_RenderableComponent) {
        function ParticleSystemComponent() {
            var _this;
            return _classCallCheck(this, ParticleSystemComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemComponent).call(this)), "startColor", _descriptor$S, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "scaleSpace", _descriptor2$J, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "startSize", _descriptor3$z, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "startSpeed", _descriptor4$s, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "startRotation", _descriptor5$o, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "startDelay", _descriptor6$i, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "startLifetime", _descriptor7$e, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "duration", _descriptor8$b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "loop", _descriptor9$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "simulationSpeed", _descriptor10$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "playOnAwake", _descriptor11$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "gravityModifier", _descriptor12$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "rateOverTime", _descriptor13$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "rateOverDistance", _descriptor14$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "bursts", _descriptor15$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "colorOverLifetimeModule", _descriptor16$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "shapeModule", _descriptor17$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "sizeOvertimeModule", _descriptor18$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "velocityOvertimeModule", _descriptor19$1, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "forceOvertimeModule", _descriptor20, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "limitVelocityOvertimeModule", _descriptor21, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "rotationOvertimeModule", _descriptor22, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "textureAnimationModule", _descriptor23, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "trailModule", _descriptor24, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "renderer", _descriptor25, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._isPlaying = void 0, _this._isPaused = void 0, _this._isStopped = void 0, 
            _this._isEmitting = void 0, _this._time = void 0, _this._emitRateTimeCounter = void 0, 
            _this._emitRateDistanceCounter = void 0, _this._oldWPos = void 0, _this._curWPos = void 0, 
            _this._customData1 = void 0, _this._customData2 = void 0, _this._subEmitters = void 0, 
            _initializerDefineProperty(_this, "_prewarm", _descriptor26, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_capacity", _descriptor27, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_simulationSpace", _descriptor28, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this.rateOverTime.constant = 10, _this.startLifetime.constant = 5, _this.startSize.constant = 1, 
            _this.startSpeed.constant = 1, _this._isPlaying = !1, _this._isPaused = !1, _this._isStopped = !0, 
            _this._isEmitting = !1, _this._time = 0, _this._emitRateTimeCounter = 0, _this._emitRateDistanceCounter = 0, 
            _this._oldWPos = vec3.create(0, 0, 0), _this._curWPos = vec3.create(0, 0, 0), _this._customData1 = vec2.create(0, 0), 
            _this._customData2 = vec2.create(0, 0), _this._subEmitters = [], _this;
        }
        return _inherits(ParticleSystemComponent, RenderableComponent), _createClass(ParticleSystemComponent, [ {
            key: "capacity",
            get: function get$$1() {
                return this._capacity;
            },
            set: function set$$1(val) {
                this._capacity = val, this.renderer && this.renderer._model && this.renderer._model.setCapacity(this._capacity);
            }
        }, {
            key: "prewarm",
            get: function get$$1() {
                return this._prewarm;
            },
            set: function set$$1(val) {
                !0 === val && this.loop, this._prewarm = val;
            }
        }, {
            key: "simulationSpace",
            get: function get$$1() {
                return this._simulationSpace;
            },
            set: function set$$1(val) {
                val !== this._simulationSpace && (this._simulationSpace = val, this.renderer._updateMaterialParams(), 
                this.renderer._updateTrailMaterial());
            }
        }, {
            key: "sharedMaterials",
            get: function get$$1() {
                return _get(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", this);
            },
            set: function set$$1(val) {
                _set(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", val, this, !0);
            }
        } ]), _createClass(ParticleSystemComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this.renderer.onInit(this), this.shapeModule.onInit(this), this.trailModule.init(this), 
                this.textureAnimationModule.onInit(this), this.node.getWorldPosition(this._oldWPos), 
                vec3.copy(this._curWPos, this._oldWPos);
            }
        }, {
            key: "_onMaterialModified",
            value: function _onMaterialModified(index, material) {
                this.renderer._onMaterialModified(index, material);
            }
        }, {
            key: "_onRebuildPSO",
            value: function _onRebuildPSO(index, material) {
                this.renderer._onRebuildPSO(index, material);
            }
        }, {
            key: "recreateModel",
            value: function recreateModel() {
                var r = this.renderer;
                r._model && (r._model.destroy(), r._model = null, r.onEnable());
            }
        }, {
            key: "play",
            value: function play() {
                this._isPaused && (this._isPaused = !1), this._isStopped && (this._isStopped = !1), 
                this._isPlaying = !0, this._isEmitting = !0, this._prewarm && this._prewarmSystem();
            }
        }, {
            key: "pause",
            value: function pause() {
                this._isStopped ? console.warn("pause(): particle system is already stopped.") : (this._isPlaying && (this._isPlaying = !1), 
                this._isPaused = !0);
            }
        }, {
            key: "stop",
            value: function stop() {
                this._isPlaying && (this._isPlaying = !1), this._isPaused && (this._isPaused = !1), 
                this.clear(), this._time = 0, this._emitRateTimeCounter = 0, this._emitRateDistanceCounter = 0, 
                this._isStopped = !0;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.renderer.clear(), this.trailModule.clear();
            }
        }, {
            key: "getParticleCount",
            value: function getParticleCount() {
                return this.renderer.getParticleCount();
            }
        }, {
            key: "setCustomData1",
            value: function setCustomData1(x, y) {
                vec2.set(this._customData1, x, y);
            }
        }, {
            key: "setCustomData2",
            value: function setCustomData2(x, y) {
                vec2.set(this._customData2, x, y);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.renderer.onDestroy(), this.trailModule.destroy();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.playOnAwake && this.play(), this.renderer.onEnable(), this.trailModule.onEnable();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.renderer.onDisable(), this.trailModule.onDisable();
            }
        }, {
            key: "update",
            value: function update(dt) {
                var scaledDeltaTime = dt * this.simulationSpeed;
                this._isPlaying && (this._time += scaledDeltaTime, this._emit(scaledDeltaTime), 
                0 !== this.renderer._updateParticles(scaledDeltaTime) || this._isEmitting || this.stop(), 
                this.renderer._updateRenderData(), this.trailModule.enable && this.trailModule.updateRenderData());
            }
        }, {
            key: "emit",
            value: function emit(count, dt) {
                for (var i = 0; i < count; ++i) {
                    var particle = this.renderer._getFreeParticle();
                    if (null === particle) return;
                    var rand = pseudoRandom(randomRangeInt(0, 2147483647));
                    switch (this.shapeModule.enable ? this.shapeModule.emit(particle) : (vec3.set(particle.position, 0, 0, 0), 
                    vec3.copy(particle.velocity, particleEmitZAxis)), vec3.scale(particle.velocity, particle.velocity, this.startSpeed.evaluate(this._time / this.duration, rand)), 
                    this._simulationSpace) {
                      case Space.Local:
                        break;

                      case Space.World:
                        this.node.getWorldMatrix(_world_mat), vec3.transformMat4(particle.position, particle.position, _world_mat);
                        var worldRot = quat.create();
                        this.node.getWorldRotation(worldRot), vec3.transformQuat(particle.velocity, particle.velocity, worldRot);
                        break;

                      case Space.Custom:
                    }
                    vec3.copy(particle.ultimateVelocity, particle.velocity), vec3.set(particle.rotation, this.startRotation.evaluate(this._time / this.duration, rand), 0, 0), 
                    vec3.set(particle.startSize, this.startSize.evaluate(this._time / this.duration, rand), 0, 0), 
                    vec3.copy(particle.size, particle.startSize), particle.startColor.set(this.startColor.evaluate(this._time / this.duration, rand)), 
                    particle.color.set(particle.startColor), particle.startLifetime = this.startLifetime.evaluate(this._time / this.duration, rand) + dt, 
                    particle.remainingLifetime = particle.startLifetime, particle.randomSeed = randomRangeInt(0, 233280), 
                    this.renderer._setNewParticle(particle);
                }
            }
        }, {
            key: "_prewarmSystem",
            value: function _prewarmSystem() {
                this.startDelay.mode = "constant", this.startDelay.constant = 0;
                for (var cnt = this.duration / 1, i = 0; i < cnt; ++i) this._time += 1, this._emit(1), 
                this.renderer._updateParticles(1);
            }
        }, {
            key: "_emit",
            value: function _emit(dt) {
                var startDelay = this.startDelay.evaluate(0, 1);
                if (this._time > startDelay) {
                    if (this._time > this.duration + startDelay && !this.loop) return void (this._isEmitting = !1);
                    if (this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt, 
                    1 < this._emitRateTimeCounter && this._isEmitting) {
                        var emitNum = Math.floor(this._emitRateTimeCounter);
                        this._emitRateTimeCounter -= emitNum, this.emit(emitNum, dt);
                    }
                    this.node.getWorldPosition(this._curWPos);
                    var distance = vec3.distance(this._curWPos, this._oldWPos);
                    if (vec3.copy(this._oldWPos, this._curWPos), this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1), 
                    1 < this._emitRateDistanceCounter && this._isEmitting) {
                        var _emitNum = Math.floor(this._emitRateDistanceCounter);
                        this._emitRateDistanceCounter -= _emitNum, this.emit(_emitNum, dt);
                    }
                    var _iterator = this.bursts, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.update(this, dt);
                    }
                }
            }
        }, {
            key: "addSubEmitter",
            value: function addSubEmitter(subEmitter) {
                this._subEmitters.push(subEmitter);
            }
        }, {
            key: "removeSubEmitter",
            value: function removeSubEmitter(idx) {
                this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
            }
        }, {
            key: "addBurst",
            value: function addBurst(burst) {
                this.bursts.push(burst);
            }
        }, {
            key: "removeBurst",
            value: function removeBurst(idx) {
                this.bursts.splice(this.bursts.indexOf(idx), 1);
            }
        }, {
            key: "isPlaying",
            get: function get$$1() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function get$$1() {
                return this._isPaused;
            }
        }, {
            key: "isStopped",
            get: function get$$1() {
                return this._isStopped;
            }
        }, {
            key: "isEmitting",
            get: function get$$1() {
                return this._isEmitting;
            }
        }, {
            key: "time",
            get: function get$$1() {
                return this._time;
            }
        } ]), ParticleSystemComponent;
    }()).prototype, "capacity", [ _dec4$n ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "capacity"), _class2$T.prototype), 
    _descriptor$S = _applyDecoratedDescriptor(_class2$T.prototype, "startColor", [ _dec5$j ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new GradientRange();
        }
    }), _descriptor2$J = _applyDecoratedDescriptor(_class2$T.prototype, "scaleSpace", [ _dec6$i ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _descriptor3$z = _applyDecoratedDescriptor(_class2$T.prototype, "startSize", [ _dec7$d ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor4$s = _applyDecoratedDescriptor(_class2$T.prototype, "startSpeed", [ _dec8$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor5$o = _applyDecoratedDescriptor(_class2$T.prototype, "startRotation", [ _dec9$9 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor6$i = _applyDecoratedDescriptor(_class2$T.prototype, "startDelay", [ _dec10$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor7$e = _applyDecoratedDescriptor(_class2$T.prototype, "startLifetime", [ _dec11$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor8$b = _applyDecoratedDescriptor(_class2$T.prototype, "duration", [ _dec12$7 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 5;
        }
    }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$T.prototype, "loop", [ _dec13$6 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _applyDecoratedDescriptor(_class2$T.prototype, "prewarm", [ _dec14$5 ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "prewarm"), _class2$T.prototype), 
    _applyDecoratedDescriptor(_class2$T.prototype, "simulationSpace", [ _dec15$4 ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "simulationSpace"), _class2$T.prototype), 
    _descriptor10$6 = _applyDecoratedDescriptor(_class2$T.prototype, "simulationSpeed", [ _dec16$3 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$T.prototype, "playOnAwake", [ _dec17$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$T.prototype, "gravityModifier", [ _dec18$2 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor13$5 = _applyDecoratedDescriptor(_class2$T.prototype, "rateOverTime", [ _dec19$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor14$1 = _applyDecoratedDescriptor(_class2$T.prototype, "rateOverDistance", [ _dec20$1 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new CurveRange();
        }
    }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$T.prototype, "bursts", [ _dec21 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Array();
        }
    }), _applyDecoratedDescriptor(_class2$T.prototype, "sharedMaterials", [ _dec22 ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "sharedMaterials"), _class2$T.prototype), 
    _descriptor16$1 = _applyDecoratedDescriptor(_class2$T.prototype, "colorOverLifetimeModule", [ _dec23 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ColorOvertimeModule();
        }
    }), _descriptor17$1 = _applyDecoratedDescriptor(_class2$T.prototype, "shapeModule", [ _dec24 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ShapeModule();
        }
    }), _descriptor18$1 = _applyDecoratedDescriptor(_class2$T.prototype, "sizeOvertimeModule", [ _dec25 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new SizeOvertimeModule();
        }
    }), _descriptor19$1 = _applyDecoratedDescriptor(_class2$T.prototype, "velocityOvertimeModule", [ _dec26 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new VelocityOvertimeModule();
        }
    }), _descriptor20 = _applyDecoratedDescriptor(_class2$T.prototype, "forceOvertimeModule", [ _dec27 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ForceOvertimeModule();
        }
    }), _descriptor21 = _applyDecoratedDescriptor(_class2$T.prototype, "limitVelocityOvertimeModule", [ _dec28 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new LimitVelocityOvertimeModule();
        }
    }), _descriptor22 = _applyDecoratedDescriptor(_class2$T.prototype, "rotationOvertimeModule", [ _dec29 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new RotationOvertimeModule();
        }
    }), _descriptor23 = _applyDecoratedDescriptor(_class2$T.prototype, "textureAnimationModule", [ _dec30 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new TextureAnimationModule();
        }
    }), _descriptor24 = _applyDecoratedDescriptor(_class2$T.prototype, "trailModule", [ _dec31 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new TrailModule();
        }
    }), _descriptor25 = _applyDecoratedDescriptor(_class2$T.prototype, "renderer", [ _dec32 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new ParticleSystemRenderer();
        }
    }), _descriptor26 = _applyDecoratedDescriptor(_class2$T.prototype, "_prewarm", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor27 = _applyDecoratedDescriptor(_class2$T.prototype, "_capacity", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 100;
        }
    }), _descriptor28 = _applyDecoratedDescriptor(_class2$T.prototype, "_simulationSpace", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Space.Local;
        }
    }), _class$13 = _class2$T)) || _class$13) || _class$13) || _class$13) || _class$13), ParticleUtils = function() {
        function ParticleUtils() {
            _classCallCheck(this, ParticleUtils);
        }
        return _createClass(ParticleUtils, null, [ {
            key: "instantiate",
            value: function instantiate(prefab) {
                return this.registeredSceneEvent || (cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this), 
                this.registeredSceneEvent = !0), this.particleSystemPool.has(prefab._uuid) || this.particleSystemPool.set(prefab._uuid, new Pool$1(function() {
                    return cc.instantiate(prefab);
                }, 1)), this.particleSystemPool.get(prefab._uuid).alloc();
            }
        }, {
            key: "destroy",
            value: function destroy(prefab) {
                this.particleSystemPool.has(prefab._prefab.asset._uuid) && (this.stop(prefab), this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab));
            }
        }, {
            key: "onSceneUnload",
            value: function onSceneUnload() {
                this.particleSystemPool.forEach(function(value) {
                    value.clear(function(prefab) {
                        prefab.destroy();
                    });
                }), this.particleSystemPool.clear();
            }
        }, {
            key: "play",
            value: function play(rootNode) {
                var _iterator = rootNode.getComponentsInChildren(cc.ParticleSystemComponent), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.play();
                }
            }
        }, {
            key: "stop",
            value: function stop(rootNode) {
                var _iterator2 = rootNode.getComponentsInChildren(cc.ParticleSystemComponent), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.stop();
                }
            }
        } ]), ParticleUtils;
    }();
    function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
    }
    ParticleUtils.particleSystemPool = new Map(), ParticleUtils.registeredSceneEvent = !1;
    var ERigidBodyType, ETransformSource, cannon = function createCommonjsModule(fn, module) {
        return fn(module = {
            exports: {}
        }, module.exports), module.exports;
    }(function(module, exports) {
        module.exports = function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = commonjsRequire;
                        if (!u && a) return a(o, !0);
                        if (i) return i(o, !0);
                        throw new Error("Cannot find module '" + o + "'");
                    }
                    var f = n[o] = {
                        exports: {}
                    };
                    t[o][0].call(f.exports, function(e) {
                        var n = t[o][1][e];
                        return s(n || e);
                    }, f, f.exports, e, t, n, r);
                }
                return n[o].exports;
            }
            for (var i = commonjsRequire, o = 0; o < r.length; o++) s(r[o]);
            return s;
        }({
            1: [ function(_dereq_, module, exports) {
                module.exports = {
                    name: "cannon",
                    version: "0.6.2",
                    description: "A lightweight 3D physics engine written in JavaScript.",
                    homepage: "https://github.com/schteppe/cannon.js",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    keywords: [ "cannon.js", "cannon", "physics", "engine", "3d" ],
                    main: "./build/cannon.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/schteppe/cannon.js.git"
                    },
                    bugs: {
                        url: "https://github.com/schteppe/cannon.js/issues"
                    },
                    licenses: [ {
                        type: "MIT"
                    } ],
                    devDependencies: {
                        jshint: "latest",
                        "uglify-js": "latest",
                        nodeunit: "^0.9.0",
                        grunt: "~0.4.0",
                        "grunt-contrib-jshint": "~0.1.1",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-concat": "~0.1.3",
                        "grunt-contrib-uglify": "^0.5.1",
                        "grunt-browserify": "^2.1.4",
                        "grunt-contrib-yuidoc": "^0.5.2",
                        browserify: "*"
                    },
                    dependencies: {}
                };
            }, {} ],
            2: [ function(_dereq_, module, exports) {
                module.exports = {
                    version: _dereq_("../package.json").version,
                    AABB: _dereq_("./collision/AABB"),
                    ArrayCollisionMatrix: _dereq_("./collision/ArrayCollisionMatrix"),
                    Body: _dereq_("./objects/Body"),
                    Box: _dereq_("./shapes/Box"),
                    Broadphase: _dereq_("./collision/Broadphase"),
                    Constraint: _dereq_("./constraints/Constraint"),
                    ContactEquation: _dereq_("./equations/ContactEquation"),
                    Narrowphase: _dereq_("./world/Narrowphase"),
                    ConeTwistConstraint: _dereq_("./constraints/ConeTwistConstraint"),
                    ContactMaterial: _dereq_("./material/ContactMaterial"),
                    ConvexPolyhedron: _dereq_("./shapes/ConvexPolyhedron"),
                    Cylinder: _dereq_("./shapes/Cylinder"),
                    DistanceConstraint: _dereq_("./constraints/DistanceConstraint"),
                    Equation: _dereq_("./equations/Equation"),
                    EventTarget: _dereq_("./utils/EventTarget"),
                    FrictionEquation: _dereq_("./equations/FrictionEquation"),
                    GSSolver: _dereq_("./solver/GSSolver"),
                    GridBroadphase: _dereq_("./collision/GridBroadphase"),
                    Heightfield: _dereq_("./shapes/Heightfield"),
                    HingeConstraint: _dereq_("./constraints/HingeConstraint"),
                    LockConstraint: _dereq_("./constraints/LockConstraint"),
                    Mat3: _dereq_("./math/Mat3"),
                    Material: _dereq_("./material/Material"),
                    NaiveBroadphase: _dereq_("./collision/NaiveBroadphase"),
                    ObjectCollisionMatrix: _dereq_("./collision/ObjectCollisionMatrix"),
                    Pool: _dereq_("./utils/Pool"),
                    Particle: _dereq_("./shapes/Particle"),
                    Plane: _dereq_("./shapes/Plane"),
                    PointToPointConstraint: _dereq_("./constraints/PointToPointConstraint"),
                    Quaternion: _dereq_("./math/Quaternion"),
                    Ray: _dereq_("./collision/Ray"),
                    RaycastVehicle: _dereq_("./objects/RaycastVehicle"),
                    RaycastResult: _dereq_("./collision/RaycastResult"),
                    RigidVehicle: _dereq_("./objects/RigidVehicle"),
                    RotationalEquation: _dereq_("./equations/RotationalEquation"),
                    RotationalMotorEquation: _dereq_("./equations/RotationalMotorEquation"),
                    SAPBroadphase: _dereq_("./collision/SAPBroadphase"),
                    SPHSystem: _dereq_("./objects/SPHSystem"),
                    Shape: _dereq_("./shapes/Shape"),
                    Solver: _dereq_("./solver/Solver"),
                    Sphere: _dereq_("./shapes/Sphere"),
                    SplitSolver: _dereq_("./solver/SplitSolver"),
                    Spring: _dereq_("./objects/Spring"),
                    Trimesh: _dereq_("./shapes/Trimesh"),
                    Vec3: _dereq_("./math/Vec3"),
                    Vec3Pool: _dereq_("./utils/Vec3Pool"),
                    World: _dereq_("./world/World")
                };
            }, {
                "../package.json": 1,
                "./collision/AABB": 3,
                "./collision/ArrayCollisionMatrix": 4,
                "./collision/Broadphase": 5,
                "./collision/GridBroadphase": 6,
                "./collision/NaiveBroadphase": 7,
                "./collision/ObjectCollisionMatrix": 8,
                "./collision/Ray": 9,
                "./collision/RaycastResult": 10,
                "./collision/SAPBroadphase": 11,
                "./constraints/ConeTwistConstraint": 12,
                "./constraints/Constraint": 13,
                "./constraints/DistanceConstraint": 14,
                "./constraints/HingeConstraint": 15,
                "./constraints/LockConstraint": 16,
                "./constraints/PointToPointConstraint": 17,
                "./equations/ContactEquation": 19,
                "./equations/Equation": 20,
                "./equations/FrictionEquation": 21,
                "./equations/RotationalEquation": 22,
                "./equations/RotationalMotorEquation": 23,
                "./material/ContactMaterial": 24,
                "./material/Material": 25,
                "./math/Mat3": 27,
                "./math/Quaternion": 28,
                "./math/Vec3": 30,
                "./objects/Body": 31,
                "./objects/RaycastVehicle": 32,
                "./objects/RigidVehicle": 33,
                "./objects/SPHSystem": 34,
                "./objects/Spring": 35,
                "./shapes/Box": 37,
                "./shapes/ConvexPolyhedron": 38,
                "./shapes/Cylinder": 39,
                "./shapes/Heightfield": 40,
                "./shapes/Particle": 41,
                "./shapes/Plane": 42,
                "./shapes/Shape": 43,
                "./shapes/Sphere": 44,
                "./shapes/Trimesh": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./solver/SplitSolver": 48,
                "./utils/EventTarget": 49,
                "./utils/Pool": 51,
                "./utils/Vec3Pool": 54,
                "./world/Narrowphase": 55,
                "./world/World": 56
            } ],
            3: [ function(_dereq_, module, exports) {
                var Vec3 = _dereq_("../math/Vec3");
                function AABB(options) {
                    options = options || {}, this.lowerBound = new Vec3(), options.lowerBound && this.lowerBound.copy(options.lowerBound), 
                    this.upperBound = new Vec3(), options.upperBound && this.upperBound.copy(options.upperBound);
                }
                _dereq_("../utils/Utils"), module.exports = AABB;
                var tmp = new Vec3();
                AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize) {
                    var l = this.lowerBound, u = this.upperBound, q = quaternion;
                    l.copy(points[0]), q && q.vmult(l, l), u.copy(l);
                    for (var i = 1; i < points.length; i++) {
                        var p = points[i];
                        q && (q.vmult(p, tmp), p = tmp), p.x > u.x && (u.x = p.x), p.x < l.x && (l.x = p.x), 
                        p.y > u.y && (u.y = p.y), p.y < l.y && (l.y = p.y), p.z > u.z && (u.z = p.z), p.z < l.z && (l.z = p.z);
                    }
                    return position && (position.vadd(l, l), position.vadd(u, u)), skinSize && (l.x -= skinSize, 
                    l.y -= skinSize, l.z -= skinSize, u.x += skinSize, u.y += skinSize, u.z += skinSize), 
                    this;
                }, AABB.prototype.copy = function(aabb) {
                    return this.lowerBound.copy(aabb.lowerBound), this.upperBound.copy(aabb.upperBound), 
                    this;
                }, AABB.prototype.clone = function() {
                    return new AABB().copy(this);
                }, AABB.prototype.extend = function(aabb) {
                    var l = aabb.lowerBound.x;
                    this.lowerBound.x > l && (this.lowerBound.x = l);
                    var u = aabb.upperBound.x;
                    this.upperBound.x < u && (this.upperBound.x = u);
                    var l = aabb.lowerBound.y;
                    this.lowerBound.y > l && (this.lowerBound.y = l);
                    var u = aabb.upperBound.y;
                    this.upperBound.y < u && (this.upperBound.y = u);
                    var l = aabb.lowerBound.z;
                    this.lowerBound.z > l && (this.lowerBound.z = l);
                    var u = aabb.upperBound.z;
                    this.upperBound.z < u && (this.upperBound.z = u);
                }, AABB.prototype.overlaps = function(aabb) {
                    var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
                    return (l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x) && (l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y) && (l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z);
                }, AABB.prototype.contains = function(aabb) {
                    var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
                    return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
                }, AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h) {
                    var l = this.lowerBound, u = this.upperBound;
                    a.copy(l), b.set(u.x, l.y, l.z), c.set(u.x, u.y, l.z), d.set(l.x, u.y, u.z), e.set(u.x, l.y, l.z), 
                    f.set(l.x, u.y, l.z), g.set(l.x, l.y, u.z), h.copy(u);
                };
                var transformIntoFrame_corners = [ new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3() ];
                AABB.prototype.toLocalFrame = function(frame, target) {
                    var corners = transformIntoFrame_corners, a = corners[0], b = corners[1], c = corners[2], d = corners[3], e = corners[4], f = corners[5], g = corners[6], h = corners[7];
                    this.getCorners(a, b, c, d, e, f, g, h);
                    for (var i = 0; 8 !== i; i++) {
                        var corner = corners[i];
                        frame.pointToLocal(corner, corner);
                    }
                    return target.setFromPoints(corners);
                }, AABB.prototype.toWorldFrame = function(frame, target) {
                    var corners = transformIntoFrame_corners, a = corners[0], b = corners[1], c = corners[2], d = corners[3], e = corners[4], f = corners[5], g = corners[6], h = corners[7];
                    this.getCorners(a, b, c, d, e, f, g, h);
                    for (var i = 0; 8 !== i; i++) {
                        var corner = corners[i];
                        frame.pointToWorld(corner, corner);
                    }
                    return target.setFromPoints(corners);
                };
            }, {
                "../math/Vec3": 30,
                "../utils/Utils": 53
            } ],
            4: [ function(_dereq_, module, exports) {
                function ArrayCollisionMatrix() {
                    this.matrix = [];
                }
                (module.exports = ArrayCollisionMatrix).prototype.get = function(i, j) {
                    if (i = i.index, j = j.index, i < j) {
                        var temp = j;
                        j = i, i = temp;
                    }
                    return this.matrix[(i * (i + 1) >> 1) + j - 1];
                }, ArrayCollisionMatrix.prototype.set = function(i, j, value) {
                    if (i = i.index, j = j.index, i < j) {
                        var temp = j;
                        j = i, i = temp;
                    }
                    this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
                }, ArrayCollisionMatrix.prototype.reset = function() {
                    for (var i = 0, l = this.matrix.length; i !== l; i++) this.matrix[i] = 0;
                }, ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
                    this.matrix.length = n * (n - 1) >> 1;
                };
            }, {} ],
            5: [ function(_dereq_, module, exports) {
                var Body = _dereq_("../objects/Body"), Vec3 = _dereq_("../math/Vec3"), Quaternion = _dereq_("../math/Quaternion");
                function Broadphase() {
                    this.world = null, this.useBoundingBoxes = !1, this.dirty = !0;
                }
                _dereq_("../shapes/Shape"), _dereq_("../shapes/Plane"), (module.exports = Broadphase).prototype.collisionPairs = function(world, p1, p2) {
                    throw new Error("collisionPairs not implemented for this BroadPhase class!");
                };
                var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
                Broadphase.prototype.needBroadphaseCollision = function(bodyA, bodyB) {
                    return 0 != (bodyA.collisionFilterGroup & bodyB.collisionFilterMask) && 0 != (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) && (0 == (bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC) && bodyA.sleepState !== Body.SLEEPING || 0 == (bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC) && bodyB.sleepState !== Body.SLEEPING);
                }, Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2) {
                    this.useBoundingBoxes ? this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) : this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
                };
                var Broadphase_collisionPairs_r = new Vec3();
                new Vec3(), new Quaternion(), new Vec3(), Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA, bodyB, pairs1, pairs2) {
                    var r = Broadphase_collisionPairs_r;
                    bodyB.position.vsub(bodyA.position, r);
                    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2), norm2 = r.norm2();
                    norm2 < boundingRadiusSum2 && (pairs1.push(bodyA), pairs2.push(bodyB));
                }, Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA, bodyB, pairs1, pairs2) {
                    bodyA.aabbNeedsUpdate && bodyA.computeAABB(), bodyB.aabbNeedsUpdate && bodyB.computeAABB(), 
                    bodyA.aabb.overlaps(bodyB.aabb) && (pairs1.push(bodyA), pairs2.push(bodyB));
                };
                var Broadphase_makePairsUnique_temp = {
                    keys: []
                }, Broadphase_makePairsUnique_p1 = [], Broadphase_makePairsUnique_p2 = [];
                Broadphase.prototype.makePairsUnique = function(pairs1, pairs2) {
                    for (var t = Broadphase_makePairsUnique_temp, p1 = Broadphase_makePairsUnique_p1, p2 = Broadphase_makePairsUnique_p2, N = pairs1.length, i = 0; i !== N; i++) p1[i] = pairs1[i], 
                    p2[i] = pairs2[i];
                    pairs1.length = 0;
                    for (var i = pairs2.length = 0; i !== N; i++) {
                        var id1 = p1[i].id, id2 = p2[i].id, key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
                        t[key] = i, t.keys.push(key);
                    }
                    for (var i = 0; i !== t.keys.length; i++) {
                        var key = t.keys.pop(), pairIndex = t[key];
                        pairs1.push(p1[pairIndex]), pairs2.push(p2[pairIndex]), delete t[key];
                    }
                }, Broadphase.prototype.setWorld = function(world) {};
                var bsc_dist = new Vec3();
                Broadphase.boundingSphereCheck = function(bodyA, bodyB) {
                    var dist = bsc_dist;
                    return bodyA.position.vsub(bodyB.position, dist), Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();
                }, Broadphase.prototype.aabbQuery = function(world, aabb, result) {
                    return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), 
                    [];
                };
            }, {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "../shapes/Plane": 42,
                "../shapes/Shape": 43
            } ],
            6: [ function(_dereq_, module, exports) {
                module.exports = GridBroadphase;
                var Broadphase = _dereq_("./Broadphase"), Vec3 = _dereq_("../math/Vec3"), Shape = _dereq_("../shapes/Shape");
                function GridBroadphase(aabbMin, aabbMax, nx, ny, nz) {
                    Broadphase.apply(this), this.nx = nx || 10, this.ny = ny || 10, this.nz = nz || 10, 
                    this.aabbMin = aabbMin || new Vec3(100, 100, 100), this.aabbMax = aabbMax || new Vec3(-100, -100, -100);
                    var nbins = this.nx * this.ny * this.nz;
                    if (nbins <= 0) throw "GridBroadphase: Each dimension's n must be >0";
                    this.bins = [], this.binLengths = [], this.bins.length = nbins, this.binLengths.length = nbins;
                    for (var i = 0; i < nbins; i++) this.bins[i] = [], this.binLengths[i] = 0;
                }
                (GridBroadphase.prototype = new Broadphase()).constructor = GridBroadphase;
                var GridBroadphase_collisionPairs_d = new Vec3();
                new Vec3(), GridBroadphase.prototype.collisionPairs = function(world, pairs1, pairs2) {
                    for (var N = world.numObjects(), bodies = world.bodies, max = this.aabbMax, min = this.aabbMin, nx = this.nx, ny = this.ny, nz = this.nz, xstep = ny * nz, ystep = nz, zstep = 1, xmax = max.x, ymax = max.y, zmax = max.z, xmin = min.x, ymin = min.y, zmin = min.z, xmult = nx / (xmax - xmin), ymult = ny / (ymax - ymin), zmult = nz / (zmax - zmin), binsizeX = (xmax - xmin) / nx, binsizeY = (ymax - ymin) / ny, binsizeZ = (zmax - zmin) / nz, binRadius = .5 * Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ), types = Shape.types, SPHERE = types.SPHERE, PLANE = types.PLANE, bins = (types.BOX, 
                    types.COMPOUND, types.CONVEXPOLYHEDRON, this.bins), binLengths = this.binLengths, Nbins = this.bins.length, i = 0; i !== Nbins; i++) binLengths[i] = 0;
                    var ceil = Math.ceil, min = Math.min, max = Math.max;
                    function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
                        var xoff0 = (x0 - xmin) * xmult | 0, yoff0 = (y0 - ymin) * ymult | 0, zoff0 = (z0 - zmin) * zmult | 0, xoff1 = ceil((x1 - xmin) * xmult), yoff1 = ceil((y1 - ymin) * ymult), zoff1 = ceil((z1 - zmin) * zmult);
                        xoff0 < 0 ? xoff0 = 0 : nx <= xoff0 && (xoff0 = nx - 1), yoff0 < 0 ? yoff0 = 0 : ny <= yoff0 && (yoff0 = ny - 1), 
                        zoff0 < 0 ? zoff0 = 0 : nz <= zoff0 && (zoff0 = nz - 1), xoff1 < 0 ? xoff1 = 0 : nx <= xoff1 && (xoff1 = nx - 1), 
                        yoff1 < 0 ? yoff1 = 0 : ny <= yoff1 && (yoff1 = ny - 1), zoff1 < 0 ? zoff1 = 0 : nz <= zoff1 && (zoff1 = nz - 1), 
                        yoff0 *= ystep, zoff0 *= zstep, xoff1 *= xstep, yoff1 *= ystep, zoff1 *= zstep;
                        for (var xoff = xoff0 *= xstep; xoff <= xoff1; xoff += xstep) for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                            var idx = xoff + yoff + zoff;
                            bins[idx][binLengths[idx]++] = bi;
                        }
                    }
                    for (var i = 0; i !== N; i++) {
                        var bi = bodies[i], si = bi.shape;
                        switch (si.type) {
                          case SPHERE:
                            var x = bi.position.x, y = bi.position.y, z = bi.position.z, r = si.radius;
                            addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
                            break;

                          case PLANE:
                            si.worldNormalNeedsUpdate && si.computeWorldNormal(bi.quaternion);
                            var planeNormal = si.worldNormal, xreset = xmin + .5 * binsizeX - bi.position.x, yreset = ymin + .5 * binsizeY - bi.position.y, zreset = zmin + .5 * binsizeZ - bi.position.z, d = GridBroadphase_collisionPairs_d;
                            d.set(xreset, yreset, zreset);
                            for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) for (var yi = 0, yoff = 0; yi !== ny; yi++, 
                            yoff += ystep, d.z = zreset, d.y += binsizeY) for (var zi = 0, zoff = 0; zi !== nz; zi++, 
                            zoff += zstep, d.z += binsizeZ) if (d.dot(planeNormal) < binRadius) {
                                var idx = xoff + yoff + zoff;
                                bins[idx][binLengths[idx]++] = bi;
                            }
                            break;

                          default:
                            bi.aabbNeedsUpdate && bi.computeAABB(), addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
                        }
                    }
                    for (var i = 0; i !== Nbins; i++) {
                        var binLength = binLengths[i];
                        if (1 < binLength) for (var bin = bins[i], xi = 0; xi !== binLength; xi++) for (var bi = bin[xi], yi = 0; yi !== xi; yi++) {
                            var bj = bin[yi];
                            this.needBroadphaseCollision(bi, bj) && this.intersectionTest(bi, bj, pairs1, pairs2);
                        }
                    }
                    this.makePairsUnique(pairs1, pairs2);
                };
            }, {
                "../math/Vec3": 30,
                "../shapes/Shape": 43,
                "./Broadphase": 5
            } ],
            7: [ function(_dereq_, module, exports) {
                module.exports = NaiveBroadphase;
                var Broadphase = _dereq_("./Broadphase"), AABB = _dereq_("./AABB");
                function NaiveBroadphase() {
                    Broadphase.apply(this);
                }
                ((NaiveBroadphase.prototype = new Broadphase()).constructor = NaiveBroadphase).prototype.collisionPairs = function(world, pairs1, pairs2) {
                    var i, j, bi, bj, bodies = world.bodies, n = bodies.length;
                    for (i = 0; i !== n; i++) for (j = 0; j !== i; j++) bi = bodies[i], bj = bodies[j], 
                    this.needBroadphaseCollision(bi, bj) && this.intersectionTest(bi, bj, pairs1, pairs2);
                }, new AABB(), NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result) {
                    result = result || [];
                    for (var i = 0; i < world.bodies.length; i++) {
                        var b = world.bodies[i];
                        b.aabbNeedsUpdate && b.computeAABB(), b.aabb.overlaps(aabb) && result.push(b);
                    }
                    return result;
                };
            }, {
                "./AABB": 3,
                "./Broadphase": 5
            } ],
            8: [ function(_dereq_, module, exports) {
                function ObjectCollisionMatrix() {
                    this.matrix = {};
                }
                (module.exports = ObjectCollisionMatrix).prototype.get = function(i, j) {
                    if (i = i.id, j = j.id, i < j) {
                        var temp = j;
                        j = i, i = temp;
                    }
                    return i + "-" + j in this.matrix;
                }, ObjectCollisionMatrix.prototype.set = function(i, j, value) {
                    if (i = i.id, j = j.id, i < j) {
                        var temp = j;
                        j = i, i = temp;
                    }
                    value ? this.matrix[i + "-" + j] = !0 : delete this.matrix[i + "-" + j];
                }, ObjectCollisionMatrix.prototype.reset = function() {
                    this.matrix = {};
                }, ObjectCollisionMatrix.prototype.setNumObjects = function(n) {};
            }, {} ],
            9: [ function(_dereq_, module, exports) {
                module.exports = Ray;
                var Vec3 = _dereq_("../math/Vec3"), Quaternion = _dereq_("../math/Quaternion"), Transform = _dereq_("../math/Transform"), RaycastResult = (_dereq_("../shapes/ConvexPolyhedron"), 
                _dereq_("../shapes/Box"), _dereq_("../collision/RaycastResult")), Shape = _dereq_("../shapes/Shape"), AABB = _dereq_("../collision/AABB");
                function Ray(from, to) {
                    this.from = from ? from.clone() : new Vec3(), this.to = to ? to.clone() : new Vec3(), 
                    this._direction = new Vec3(), this.precision = 1e-4, this.checkCollisionResponse = !0, 
                    this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, 
                    this.mode = Ray.ANY, this.result = new RaycastResult(), this.hasHit = !1, this.callback = function(result) {};
                }
                (Ray.prototype.constructor = Ray).CLOSEST = 1, Ray.ANY = 2, Ray.ALL = 4;
                var tmpAABB = new AABB(), tmpArray = [];
                Ray.prototype.intersectWorld = function(world, options) {
                    return this.mode = options.mode || Ray.ANY, this.result = options.result || new RaycastResult(), 
                    this.skipBackfaces = !!options.skipBackfaces, this.collisionFilterMask = void 0 !== options.collisionFilterMask ? options.collisionFilterMask : -1, 
                    this.collisionFilterGroup = void 0 !== options.collisionFilterGroup ? options.collisionFilterGroup : -1, 
                    options.from && this.from.copy(options.from), options.to && this.to.copy(options.to), 
                    this.callback = options.callback || function() {}, this.hasHit = !1, this.result.reset(), 
                    this._updateDirection(), this.getAABB(tmpAABB), tmpArray.length = 0, world.broadphase.aabbQuery(world, tmpAABB, tmpArray), 
                    this.intersectBodies(tmpArray), this.hasHit;
                };
                var v1 = new Vec3(), v2 = new Vec3();
                function pointInTriangle(p, a, b, c) {
                    c.vsub(a, v0), b.vsub(a, v1), p.vsub(a, v2);
                    var u, v, dot00 = v0.dot(v0), dot01 = v0.dot(v1), dot02 = v0.dot(v2), dot11 = v1.dot(v1), dot12 = v1.dot(v2);
                    return 0 <= (u = dot11 * dot02 - dot01 * dot12) && 0 <= (v = dot00 * dot12 - dot01 * dot02) && u + v < dot00 * dot11 - dot01 * dot01;
                }
                Ray.pointInTriangle = pointInTriangle;
                var intersectBody_xi = new Vec3(), intersectBody_qi = new Quaternion();
                Ray.prototype.intersectBody = function(body, result) {
                    result && (this.result = result, this._updateDirection());
                    var checkCollisionResponse = this.checkCollisionResponse;
                    if ((!checkCollisionResponse || body.collisionResponse) && 0 != (this.collisionFilterGroup & body.collisionFilterMask) && 0 != (body.collisionFilterGroup & this.collisionFilterMask)) for (var xi = intersectBody_xi, qi = intersectBody_qi, i = 0, N = body.shapes.length; i < N; i++) {
                        var shape = body.shapes[i];
                        if ((!checkCollisionResponse || shape.collisionResponse) && (body.quaternion.mult(body.shapeOrientations[i], qi), 
                        body.quaternion.vmult(body.shapeOffsets[i], xi), xi.vadd(body.position, xi), this.intersectShape(shape, qi, xi, body), 
                        this.result._shouldStop)) break;
                    }
                }, Ray.prototype.intersectBodies = function(bodies, result) {
                    result && (this.result = result, this._updateDirection());
                    for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) this.intersectBody(bodies[i]);
                }, Ray.prototype._updateDirection = function() {
                    this.to.vsub(this.from, this._direction), this._direction.normalize();
                }, Ray.prototype.intersectShape = function(shape, quat, position, body) {
                    var from = this.from, distance = function distanceFromIntersection(from, direction, position) {
                        position.vsub(from, v0);
                        var dot = v0.dot(direction);
                        return direction.mult(dot, intersect), intersect.vadd(from, intersect), position.distanceTo(intersect);
                    }(from, this._direction, position);
                    if (!(distance > shape.boundingSphereRadius)) {
                        var intersectMethod = this[shape.type];
                        intersectMethod && intersectMethod.call(this, shape, quat, position, body);
                    }
                }, new Vec3(), new Vec3();
                var intersectPoint = new Vec3(), a = new Vec3(), b = new Vec3(), c = new Vec3();
                new Vec3(), new RaycastResult(), Ray.prototype.intersectBox = function(shape, quat, position, body) {
                    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body);
                }, Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox, Ray.prototype.intersectPlane = function(shape, quat, position, body) {
                    var from = this.from, to = this.to, direction = this._direction, worldNormal = new Vec3(0, 0, 1);
                    quat.vmult(worldNormal, worldNormal);
                    var len = new Vec3();
                    from.vsub(position, len);
                    var planeToFrom = len.dot(worldNormal);
                    to.vsub(position, len);
                    var planeToTo = len.dot(worldNormal);
                    if (!(0 < planeToFrom * planeToTo || from.distanceTo(to) < planeToFrom)) {
                        var n_dot_dir = worldNormal.dot(direction);
                        if (!(Math.abs(n_dot_dir) < this.precision)) {
                            var planePointToFrom = new Vec3(), dir_scaled_with_t = new Vec3(), hitPointWorld = new Vec3();
                            from.vsub(position, planePointToFrom);
                            var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
                            direction.scale(t, dir_scaled_with_t), from.vadd(dir_scaled_with_t, hitPointWorld), 
                            this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
                        }
                    }
                }, Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane, Ray.prototype.getAABB = function(result) {
                    var to = this.to, from = this.from;
                    result.lowerBound.x = Math.min(to.x, from.x), result.lowerBound.y = Math.min(to.y, from.y), 
                    result.lowerBound.z = Math.min(to.z, from.z), result.upperBound.x = Math.max(to.x, from.x), 
                    result.upperBound.y = Math.max(to.y, from.y), result.upperBound.z = Math.max(to.z, from.z);
                };
                var intersectConvexOptions = {
                    faceList: [ 0 ]
                };
                Ray.prototype.intersectHeightfield = function(shape, quat, position, body) {
                    shape.data, shape.elementSize;
                    var worldPillarOffset = new Vec3(), localRay = new Ray(this.from, this.to);
                    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from), Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
                    var index = [], iMinX = null, iMinY = null, iMaxX = null, iMaxY = null, inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, !1);
                    if (inside && (iMaxX = iMinX = index[0], iMaxY = iMinY = index[1]), (inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, !1)) && ((null === iMinX || index[0] < iMinX) && (iMinX = index[0]), 
                    (null === iMaxX || iMaxX < index[0]) && (iMaxX = index[0]), (null === iMinY || index[1] < iMinY) && (iMinY = index[1]), 
                    (null === iMaxY || iMaxY < index[1]) && (iMaxY = index[1])), null !== iMinX) {
                        shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, []);
                        for (var i = iMinX; i <= iMaxX; i++) for (var j = iMinY; j <= iMaxY; j++) {
                            if (this.result._shouldStop) return;
                            if (shape.getConvexTrianglePillar(i, j, !1), Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset), 
                            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions), 
                            this.result._shouldStop) return;
                            shape.getConvexTrianglePillar(i, j, !0), Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset), 
                            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);
                        }
                    }
                }, Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;
                var Ray_intersectSphere_intersectionPoint = new Vec3(), Ray_intersectSphere_normal = new Vec3();
                Ray.prototype.intersectSphere = function(shape, quat, position, body) {
                    var from = this.from, to = this.to, r = shape.radius, a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2), b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z)), c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2), delta = Math.pow(b, 2) - 4 * a * c, intersectionPoint = Ray_intersectSphere_intersectionPoint, normal = Ray_intersectSphere_normal;
                    if (!(delta < 0)) if (0 === delta) from.lerp(to, delta, intersectionPoint), intersectionPoint.vsub(position, normal), 
                    normal.normalize(), this.reportIntersection(normal, intersectionPoint, shape, body, -1); else {
                        var d1 = (-b - Math.sqrt(delta)) / (2 * a), d2 = (-b + Math.sqrt(delta)) / (2 * a);
                        if (0 <= d1 && d1 <= 1 && (from.lerp(to, d1, intersectionPoint), intersectionPoint.vsub(position, normal), 
                        normal.normalize(), this.reportIntersection(normal, intersectionPoint, shape, body, -1)), 
                        this.result._shouldStop) return;
                        0 <= d2 && d2 <= 1 && (from.lerp(to, d2, intersectionPoint), intersectionPoint.vsub(position, normal), 
                        normal.normalize(), this.reportIntersection(normal, intersectionPoint, shape, body, -1));
                    }
                }, Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;
                var intersectConvex_normal = new Vec3(), intersectConvex_vector = (new Vec3(), new Vec3(), 
                new Vec3());
                Ray.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, options) {
                    for (var normal = intersectConvex_normal, vector = intersectConvex_vector, faceList = options && options.faceList || null, faces = shape.faces, vertices = shape.vertices, normals = shape.faceNormals, direction = this._direction, from = this.from, to = this.to, fromToDistance = from.distanceTo(to), Nfaces = faceList ? faceList.length : faces.length, result = this.result, j = 0; !result._shouldStop && j < Nfaces; j++) {
                        var fi = faceList ? faceList[j] : j, face = faces[fi], faceNormal = normals[fi], q = quat, x = position;
                        vector.copy(vertices[face[0]]), q.vmult(vector, vector), vector.vadd(x, vector), 
                        vector.vsub(from, vector), q.vmult(faceNormal, normal);
                        var dot = direction.dot(normal);
                        if (!(Math.abs(dot) < this.precision)) {
                            var scalar = normal.dot(vector) / dot;
                            if (!(scalar < 0)) {
                                direction.mult(scalar, intersectPoint), intersectPoint.vadd(from, intersectPoint), 
                                a.copy(vertices[face[0]]), q.vmult(a, a), x.vadd(a, a);
                                for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {
                                    b.copy(vertices[face[i]]), c.copy(vertices[face[i + 1]]), q.vmult(b, b), q.vmult(c, c), 
                                    x.vadd(b, b), x.vadd(c, c);
                                    var distance = intersectPoint.distanceTo(from);
                                    !pointInTriangle(intersectPoint, a, b, c) && !pointInTriangle(intersectPoint, b, a, c) || fromToDistance < distance || this.reportIntersection(normal, intersectPoint, shape, body, fi);
                                }
                            }
                        }
                    }
                }, Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;
                var intersectTrimesh_normal = new Vec3(), intersectTrimesh_localDirection = new Vec3(), intersectTrimesh_localFrom = new Vec3(), intersectTrimesh_localTo = new Vec3(), intersectTrimesh_worldNormal = new Vec3(), intersectTrimesh_worldIntersectPoint = new Vec3(), intersectTrimesh_triangles = (new AABB(), 
                []), intersectTrimesh_treeTransform = new Transform();
                Ray.prototype.intersectTrimesh = function intersectTrimesh(mesh, quat, position, body, options) {
                    var normal = intersectTrimesh_normal, triangles = intersectTrimesh_triangles, treeTransform = intersectTrimesh_treeTransform, vector = intersectConvex_vector, localDirection = intersectTrimesh_localDirection, localFrom = intersectTrimesh_localFrom, localTo = intersectTrimesh_localTo, worldIntersectPoint = intersectTrimesh_worldIntersectPoint, worldNormal = intersectTrimesh_worldNormal, indices = (options && options.faceList, 
                    mesh.indices), from = (mesh.vertices, mesh.faceNormals, this.from), to = this.to, direction = this._direction;
                    treeTransform.position.copy(position), treeTransform.quaternion.copy(quat), Transform.vectorToLocalFrame(position, quat, direction, localDirection), 
                    Transform.pointToLocalFrame(position, quat, from, localFrom), Transform.pointToLocalFrame(position, quat, to, localTo);
                    var fromToDistanceSquared = localFrom.distanceSquared(localTo);
                    mesh.tree.rayQuery(this, treeTransform, triangles);
                    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
                        var trianglesIndex = triangles[i];
                        mesh.getNormal(trianglesIndex, normal), mesh.getVertex(indices[3 * trianglesIndex], a), 
                        a.vsub(localFrom, vector);
                        var dot = localDirection.dot(normal), scalar = normal.dot(vector) / dot;
                        if (!(scalar < 0)) {
                            localDirection.scale(scalar, intersectPoint), intersectPoint.vadd(localFrom, intersectPoint), 
                            mesh.getVertex(indices[3 * trianglesIndex + 1], b), mesh.getVertex(indices[3 * trianglesIndex + 2], c);
                            var squaredDistance = intersectPoint.distanceSquared(localFrom);
                            !pointInTriangle(intersectPoint, b, a, c) && !pointInTriangle(intersectPoint, a, b, c) || fromToDistanceSquared < squaredDistance || (Transform.vectorToWorldFrame(quat, normal, worldNormal), 
                            Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint), 
                            this.reportIntersection(worldNormal, worldIntersectPoint, mesh, body, trianglesIndex));
                        }
                    }
                    triangles.length = 0;
                }, Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh, Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex) {
                    var from = this.from, to = this.to, distance = from.distanceTo(hitPointWorld), result = this.result;
                    if (!(this.skipBackfaces && 0 < normal.dot(this._direction))) switch (result.hitFaceIndex = void 0 !== hitFaceIndex ? hitFaceIndex : -1, 
                    this.mode) {
                      case Ray.ALL:
                        this.hasHit = !0, result.set(from, to, normal, hitPointWorld, shape, body, distance), 
                        result.hasHit = !0, this.callback(result);
                        break;

                      case Ray.CLOSEST:
                        (distance < result.distance || !result.hasHit) && (this.hasHit = !0, result.hasHit = !0, 
                        result.set(from, to, normal, hitPointWorld, shape, body, distance));
                        break;

                      case Ray.ANY:
                        this.hasHit = !0, result.hasHit = !0, result.set(from, to, normal, hitPointWorld, shape, body, distance), 
                        result._shouldStop = !0;
                    }
                };
                var v0 = new Vec3(), intersect = new Vec3();
            }, {
                "../collision/AABB": 3,
                "../collision/RaycastResult": 10,
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../shapes/Box": 37,
                "../shapes/ConvexPolyhedron": 38,
                "../shapes/Shape": 43
            } ],
            10: [ function(_dereq_, module, exports) {
                var Vec3 = _dereq_("../math/Vec3");
                function RaycastResult() {
                    this.rayFromWorld = new Vec3(), this.rayToWorld = new Vec3(), this.hitNormalWorld = new Vec3(), 
                    this.hitPointWorld = new Vec3(), this.hasHit = !1, this.shape = null, this.body = null, 
                    this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
                }
                (module.exports = RaycastResult).prototype.reset = function() {
                    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), 
                    this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, 
                    this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
                }, RaycastResult.prototype.abort = function() {
                    this._shouldStop = !0;
                }, RaycastResult.prototype.set = function(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
                    this.rayFromWorld.copy(rayFromWorld), this.rayToWorld.copy(rayToWorld), this.hitNormalWorld.copy(hitNormalWorld), 
                    this.hitPointWorld.copy(hitPointWorld), this.shape = shape, this.body = body, this.distance = distance;
                };
            }, {
                "../math/Vec3": 30
            } ],
            11: [ function(_dereq_, module, exports) {
                _dereq_("../shapes/Shape");
                var Broadphase = _dereq_("../collision/Broadphase");
                function SAPBroadphase(world) {
                    Broadphase.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0;
                    var axisList = this.axisList;
                    this._addBodyHandler = function(e) {
                        axisList.push(e.body);
                    }, this._removeBodyHandler = function(e) {
                        var idx = axisList.indexOf(e.body);
                        -1 !== idx && axisList.splice(idx, 1);
                    }, world && this.setWorld(world);
                }
                ((module.exports = SAPBroadphase).prototype = new Broadphase()).setWorld = function(world) {
                    for (var i = this.axisList.length = 0; i < world.bodies.length; i++) this.axisList.push(world.bodies[i]);
                    world.removeEventListener("addBody", this._addBodyHandler), world.removeEventListener("removeBody", this._removeBodyHandler), 
                    world.addEventListener("addBody", this._addBodyHandler), world.addEventListener("removeBody", this._removeBodyHandler), 
                    this.world = world, this.dirty = !0;
                }, SAPBroadphase.insertionSortX = function(a) {
                    for (var i = 1, l = a.length; i < l; i++) {
                        for (var v = a[i], j = i - 1; 0 <= j && !(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x); j--) a[j + 1] = a[j];
                        a[j + 1] = v;
                    }
                    return a;
                }, SAPBroadphase.insertionSortY = function(a) {
                    for (var i = 1, l = a.length; i < l; i++) {
                        for (var v = a[i], j = i - 1; 0 <= j && !(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y); j--) a[j + 1] = a[j];
                        a[j + 1] = v;
                    }
                    return a;
                }, SAPBroadphase.insertionSortZ = function(a) {
                    for (var i = 1, l = a.length; i < l; i++) {
                        for (var v = a[i], j = i - 1; 0 <= j && !(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z); j--) a[j + 1] = a[j];
                        a[j + 1] = v;
                    }
                    return a;
                }, SAPBroadphase.prototype.collisionPairs = function(world, p1, p2) {
                    var i, j, bodies = this.axisList, N = bodies.length, axisIndex = this.axisIndex;
                    for (this.dirty && (this.sortList(), this.dirty = !1), i = 0; i !== N; i++) {
                        var bi = bodies[i];
                        for (j = i + 1; j < N; j++) {
                            var bj = bodies[j];
                            if (this.needBroadphaseCollision(bi, bj)) {
                                if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) break;
                                this.intersectionTest(bi, bj, p1, p2);
                            }
                        }
                    }
                }, SAPBroadphase.prototype.sortList = function() {
                    for (var axisList = this.axisList, axisIndex = this.axisIndex, N = axisList.length, i = 0; i !== N; i++) {
                        var bi = axisList[i];
                        bi.aabbNeedsUpdate && bi.computeAABB();
                    }
                    0 === axisIndex ? SAPBroadphase.insertionSortX(axisList) : 1 === axisIndex ? SAPBroadphase.insertionSortY(axisList) : 2 === axisIndex && SAPBroadphase.insertionSortZ(axisList);
                }, SAPBroadphase.checkBounds = function(bi, bj, axisIndex) {
                    var biPos, bjPos;
                    0 === axisIndex ? (biPos = bi.position.x, bjPos = bj.position.x) : 1 === axisIndex ? (biPos = bi.position.y, 
                    bjPos = bj.position.y) : 2 === axisIndex && (biPos = bi.position.z, bjPos = bj.position.z);
                    var ri = bi.boundingRadius, rj = bj.boundingRadius, boundA2 = biPos + ri, boundB1 = bjPos - rj;
                    return boundB1 < boundA2;
                }, SAPBroadphase.prototype.autoDetectAxis = function() {
                    for (var sumX = 0, sumX2 = 0, sumY = 0, sumY2 = 0, sumZ = 0, sumZ2 = 0, bodies = this.axisList, N = bodies.length, invN = 1 / N, i = 0; i !== N; i++) {
                        var b = bodies[i], centerX = b.position.x;
                        sumX += centerX, sumX2 += centerX * centerX;
                        var centerY = b.position.y;
                        sumY += centerY, sumY2 += centerY * centerY;
                        var centerZ = b.position.z;
                        sumZ += centerZ, sumZ2 += centerZ * centerZ;
                    }
                    var varianceX = sumX2 - sumX * sumX * invN, varianceY = sumY2 - sumY * sumY * invN, varianceZ = sumZ2 - sumZ * sumZ * invN;
                    this.axisIndex = varianceY < varianceX ? varianceZ < varianceX ? 0 : 2 : varianceZ < varianceY ? 1 : 2;
                }, SAPBroadphase.prototype.aabbQuery = function(world, aabb, result) {
                    result = result || [], this.dirty && (this.sortList(), this.dirty = !1);
                    var axisIndex = this.axisIndex, axis = "x";
                    1 === axisIndex && (axis = "y"), 2 === axisIndex && (axis = "z");
                    for (var axisList = this.axisList, i = (aabb.lowerBound[axis], aabb.upperBound[axis], 
                    0); i < axisList.length; i++) {
                        var b = axisList[i];
                        b.aabbNeedsUpdate && b.computeAABB(), b.aabb.overlaps(aabb) && result.push(b);
                    }
                    return result;
                };
            }, {
                "../collision/Broadphase": 5,
                "../shapes/Shape": 43
            } ],
            12: [ function(_dereq_, module, exports) {
                module.exports = ConeTwistConstraint, _dereq_("./Constraint");
                var PointToPointConstraint = _dereq_("./PointToPointConstraint"), ConeEquation = _dereq_("../equations/ConeEquation"), RotationalEquation = _dereq_("../equations/RotationalEquation"), Vec3 = (_dereq_("../equations/ContactEquation"), 
                _dereq_("../math/Vec3"));
                function ConeTwistConstraint(bodyA, bodyB, options) {
                    var maxForce = void 0 !== (options = options || {}).maxForce ? options.maxForce : 1e6, pivotA = options.pivotA ? options.pivotA.clone() : new Vec3(), pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
                    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(), this.axisB = options.axisB ? options.axisB.clone() : new Vec3(), 
                    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce), this.collideConnected = !!options.collideConnected, 
                    this.angle = void 0 !== options.angle ? options.angle : 0;
                    var c = this.coneEquation = new ConeEquation(bodyA, bodyB, options), t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
                    this.twistAngle = void 0 !== options.twistAngle ? options.twistAngle : 0, c.maxForce = 0, 
                    c.minForce = -maxForce, t.maxForce = 0, t.minForce = -maxForce, this.equations.push(c, t);
                }
                ConeTwistConstraint.prototype = new PointToPointConstraint(), ConeTwistConstraint.constructor = ConeTwistConstraint, 
                new Vec3(), new Vec3(), ConeTwistConstraint.prototype.update = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, cone = this.coneEquation, twist = this.twistEquation;
                    PointToPointConstraint.prototype.update.call(this), bodyA.vectorToWorldFrame(this.axisA, cone.axisA), 
                    bodyB.vectorToWorldFrame(this.axisB, cone.axisB), this.axisA.tangents(twist.axisA, twist.axisA), 
                    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA), this.axisB.tangents(twist.axisB, twist.axisB), 
                    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB), cone.angle = this.angle, twist.maxAngle = this.twistAngle;
                };
            }, {
                "../equations/ConeEquation": 18,
                "../equations/ContactEquation": 19,
                "../equations/RotationalEquation": 22,
                "../math/Vec3": 30,
                "./Constraint": 13,
                "./PointToPointConstraint": 17
            } ],
            13: [ function(_dereq_, module, exports) {
                module.exports = Constraint;
                var Utils = _dereq_("../utils/Utils");
                function Constraint(bodyA, bodyB, options) {
                    options = Utils.defaults(options, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }), this.equations = [], this.bodyA = bodyA, this.bodyB = bodyB, this.id = Constraint.idCounter++, 
                    this.collideConnected = options.collideConnected, options.wakeUpBodies && (bodyA && bodyA.wakeUp(), 
                    bodyB && bodyB.wakeUp());
                }
                Constraint.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!");
                }, Constraint.prototype.enable = function() {
                    for (var eqs = this.equations, i = 0; i < eqs.length; i++) eqs[i].enabled = !0;
                }, Constraint.prototype.disable = function() {
                    for (var eqs = this.equations, i = 0; i < eqs.length; i++) eqs[i].enabled = !1;
                }, Constraint.idCounter = 0;
            }, {
                "../utils/Utils": 53
            } ],
            14: [ function(_dereq_, module, exports) {
                module.exports = DistanceConstraint;
                var Constraint = _dereq_("./Constraint"), ContactEquation = _dereq_("../equations/ContactEquation");
                function DistanceConstraint(bodyA, bodyB, distance, maxForce) {
                    Constraint.call(this, bodyA, bodyB), void 0 === distance && (distance = bodyA.position.distanceTo(bodyB.position)), 
                    void 0 === maxForce && (maxForce = 1e6), this.distance = distance;
                    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
                    this.equations.push(eq), eq.minForce = -maxForce, eq.maxForce = maxForce;
                }
                (DistanceConstraint.prototype = new Constraint()).update = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, eq = this.distanceEquation, halfDist = .5 * this.distance, normal = eq.ni;
                    bodyB.position.vsub(bodyA.position, normal), normal.normalize(), normal.mult(halfDist, eq.ri), 
                    normal.mult(-halfDist, eq.rj);
                };
            }, {
                "../equations/ContactEquation": 19,
                "./Constraint": 13
            } ],
            15: [ function(_dereq_, module, exports) {
                module.exports = HingeConstraint, _dereq_("./Constraint");
                var PointToPointConstraint = _dereq_("./PointToPointConstraint"), RotationalEquation = _dereq_("../equations/RotationalEquation"), RotationalMotorEquation = _dereq_("../equations/RotationalMotorEquation"), Vec3 = (_dereq_("../equations/ContactEquation"), 
                _dereq_("../math/Vec3"));
                function HingeConstraint(bodyA, bodyB, options) {
                    var maxForce = void 0 !== (options = options || {}).maxForce ? options.maxForce : 1e6, pivotA = options.pivotA ? options.pivotA.clone() : new Vec3(), pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
                    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
                    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
                    axisA.normalize();
                    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
                    axisB.normalize();
                    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options), r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options), motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
                    motor.enabled = !1, this.equations.push(r1, r2, motor);
                }
                HingeConstraint.prototype = new PointToPointConstraint(), (HingeConstraint.constructor = HingeConstraint).prototype.enableMotor = function() {
                    this.motorEquation.enabled = !0;
                }, HingeConstraint.prototype.disableMotor = function() {
                    this.motorEquation.enabled = !1;
                }, HingeConstraint.prototype.setMotorSpeed = function(speed) {
                    this.motorEquation.targetVelocity = speed;
                }, HingeConstraint.prototype.setMotorMaxForce = function(maxForce) {
                    this.motorEquation.maxForce = maxForce, this.motorEquation.minForce = -maxForce;
                };
                var HingeConstraint_update_tmpVec1 = new Vec3(), HingeConstraint_update_tmpVec2 = new Vec3();
                HingeConstraint.prototype.update = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, motor = this.motorEquation, r1 = this.rotationalEquation1, r2 = this.rotationalEquation2, worldAxisA = HingeConstraint_update_tmpVec1, worldAxisB = HingeConstraint_update_tmpVec2, axisA = this.axisA, axisB = this.axisB;
                    PointToPointConstraint.prototype.update.call(this), bodyA.quaternion.vmult(axisA, worldAxisA), 
                    bodyB.quaternion.vmult(axisB, worldAxisB), worldAxisA.tangents(r1.axisA, r2.axisA), 
                    r1.axisB.copy(worldAxisB), r2.axisB.copy(worldAxisB), this.motorEquation.enabled && (bodyA.quaternion.vmult(this.axisA, motor.axisA), 
                    bodyB.quaternion.vmult(this.axisB, motor.axisB));
                };
            }, {
                "../equations/ContactEquation": 19,
                "../equations/RotationalEquation": 22,
                "../equations/RotationalMotorEquation": 23,
                "../math/Vec3": 30,
                "./Constraint": 13,
                "./PointToPointConstraint": 17
            } ],
            16: [ function(_dereq_, module, exports) {
                module.exports = LockConstraint, _dereq_("./Constraint");
                var PointToPointConstraint = _dereq_("./PointToPointConstraint"), RotationalEquation = _dereq_("../equations/RotationalEquation"), Vec3 = (_dereq_("../equations/RotationalMotorEquation"), 
                _dereq_("../equations/ContactEquation"), _dereq_("../math/Vec3"));
                function LockConstraint(bodyA, bodyB, options) {
                    var maxForce = void 0 !== (options = options || {}).maxForce ? options.maxForce : 1e6, pivotA = new Vec3(), pivotB = new Vec3(), halfWay = new Vec3();
                    bodyA.position.vadd(bodyB.position, halfWay), halfWay.scale(.5, halfWay), bodyB.pointToLocalFrame(halfWay, pivotB), 
                    bodyA.pointToLocalFrame(halfWay, pivotA), PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
                    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options), r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options), r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
                    this.equations.push(r1, r2, r3);
                }
                LockConstraint.prototype = new PointToPointConstraint(), LockConstraint.constructor = LockConstraint, 
                new Vec3(), new Vec3(), LockConstraint.prototype.update = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, r1 = (this.motorEquation, this.rotationalEquation1), r2 = this.rotationalEquation2, r3 = this.rotationalEquation3;
                    PointToPointConstraint.prototype.update.call(this), bodyA.vectorToWorldFrame(Vec3.UNIT_X, r1.axisA), 
                    bodyB.vectorToWorldFrame(Vec3.UNIT_Y, r1.axisB), bodyA.vectorToWorldFrame(Vec3.UNIT_Y, r2.axisA), 
                    bodyB.vectorToWorldFrame(Vec3.UNIT_Z, r2.axisB), bodyA.vectorToWorldFrame(Vec3.UNIT_Z, r3.axisA), 
                    bodyB.vectorToWorldFrame(Vec3.UNIT_X, r3.axisB);
                };
            }, {
                "../equations/ContactEquation": 19,
                "../equations/RotationalEquation": 22,
                "../equations/RotationalMotorEquation": 23,
                "../math/Vec3": 30,
                "./Constraint": 13,
                "./PointToPointConstraint": 17
            } ],
            17: [ function(_dereq_, module, exports) {
                module.exports = PointToPointConstraint;
                var Constraint = _dereq_("./Constraint"), ContactEquation = _dereq_("../equations/ContactEquation"), Vec3 = _dereq_("../math/Vec3");
                function PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {
                    Constraint.call(this, bodyA, bodyB), maxForce = void 0 !== maxForce ? maxForce : 1e6, 
                    this.pivotA = pivotA ? pivotA.clone() : new Vec3(), this.pivotB = pivotB ? pivotB.clone() : new Vec3();
                    var x = this.equationX = new ContactEquation(bodyA, bodyB), y = this.equationY = new ContactEquation(bodyA, bodyB), z = this.equationZ = new ContactEquation(bodyA, bodyB);
                    this.equations.push(x, y, z), x.minForce = y.minForce = z.minForce = -maxForce, 
                    x.maxForce = y.maxForce = z.maxForce = maxForce, x.ni.set(1, 0, 0), y.ni.set(0, 1, 0), 
                    z.ni.set(0, 0, 1);
                }
                (PointToPointConstraint.prototype = new Constraint()).update = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, x = this.equationX, y = this.equationY, z = this.equationZ;
                    bodyA.quaternion.vmult(this.pivotA, x.ri), bodyB.quaternion.vmult(this.pivotB, x.rj), 
                    y.ri.copy(x.ri), y.rj.copy(x.rj), z.ri.copy(x.ri), z.rj.copy(x.rj);
                };
            }, {
                "../equations/ContactEquation": 19,
                "../math/Vec3": 30,
                "./Constraint": 13
            } ],
            18: [ function(_dereq_, module, exports) {
                module.exports = ConeEquation;
                var Vec3 = _dereq_("../math/Vec3"), Equation = (_dereq_("../math/Mat3"), _dereq_("./Equation"));
                function ConeEquation(bodyA, bodyB, options) {
                    var maxForce = void 0 !== (options = options || {}).maxForce ? options.maxForce : 1e6;
                    Equation.call(this, bodyA, bodyB, -maxForce, maxForce), this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0), 
                    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0), this.angle = void 0 !== options.angle ? options.angle : 0;
                }
                (ConeEquation.prototype = new Equation()).constructor = ConeEquation;
                var tmpVec1 = new Vec3(), tmpVec2 = new Vec3();
                ConeEquation.prototype.computeB = function(h) {
                    var a = this.a, b = this.b, ni = this.axisA, nj = this.axisB, nixnj = tmpVec1, njxni = tmpVec2, GA = this.jacobianElementA, GB = this.jacobianElementB;
                    ni.cross(nj, nixnj), nj.cross(ni, njxni), GA.rotational.copy(njxni), GB.rotational.copy(nixnj);
                    var g = Math.cos(this.angle) - ni.dot(nj), GW = this.computeGW(), GiMf = this.computeGiMf(), B = -g * a - GW * b - h * GiMf;
                    return B;
                };
            }, {
                "../math/Mat3": 27,
                "../math/Vec3": 30,
                "./Equation": 20
            } ],
            19: [ function(_dereq_, module, exports) {
                module.exports = ContactEquation;
                var Equation = _dereq_("./Equation"), Vec3 = _dereq_("../math/Vec3");
                function ContactEquation(bodyA, bodyB, maxForce) {
                    maxForce = void 0 !== maxForce ? maxForce : 1e6, Equation.call(this, bodyA, bodyB, 0, maxForce), 
                    this.restitution = 0, this.ri = new Vec3(), this.rj = new Vec3(), this.ni = new Vec3();
                }
                _dereq_("../math/Mat3"), (ContactEquation.prototype = new Equation()).constructor = ContactEquation;
                var ContactEquation_computeB_temp1 = new Vec3(), ContactEquation_computeB_temp2 = new Vec3(), ContactEquation_computeB_temp3 = new Vec3();
                ContactEquation.prototype.computeB = function(h) {
                    var a = this.a, b = this.b, bi = this.bi, bj = this.bj, ri = this.ri, rj = this.rj, rixn = ContactEquation_computeB_temp1, rjxn = ContactEquation_computeB_temp2, vi = bi.velocity, wi = bi.angularVelocity, vj = (bi.force, 
                    bi.torque, bj.velocity), wj = bj.angularVelocity, penetrationVec = (bj.force, bj.torque, 
                    ContactEquation_computeB_temp3), GA = this.jacobianElementA, GB = this.jacobianElementB, n = this.ni;
                    ri.cross(n, rixn), rj.cross(n, rjxn), n.negate(GA.spatial), rixn.negate(GA.rotational), 
                    GB.spatial.copy(n), GB.rotational.copy(rjxn), penetrationVec.copy(bj.position), 
                    penetrationVec.vadd(rj, penetrationVec), penetrationVec.vsub(bi.position, penetrationVec), 
                    penetrationVec.vsub(ri, penetrationVec);
                    var g = n.dot(penetrationVec), ePlusOne = this.restitution + 1, GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn), GiMf = this.computeGiMf(), B = -g * a - GW * b - h * GiMf;
                    return B;
                };
                var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3(), ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3(), ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3(), ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3(), ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();
                ContactEquation.prototype.getImpactVelocityAlongNormal = function() {
                    var vi = ContactEquation_getImpactVelocityAlongNormal_vi, vj = ContactEquation_getImpactVelocityAlongNormal_vj, xi = ContactEquation_getImpactVelocityAlongNormal_xi, xj = ContactEquation_getImpactVelocityAlongNormal_xj, relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
                    return this.bi.position.vadd(this.ri, xi), this.bj.position.vadd(this.rj, xj), this.bi.getVelocityAtWorldPoint(xi, vi), 
                    this.bj.getVelocityAtWorldPoint(xj, vj), vi.vsub(vj, relVel), this.ni.dot(relVel);
                };
            }, {
                "../math/Mat3": 27,
                "../math/Vec3": 30,
                "./Equation": 20
            } ],
            20: [ function(_dereq_, module, exports) {
                module.exports = Equation;
                var JacobianElement = _dereq_("../math/JacobianElement"), Vec3 = _dereq_("../math/Vec3");
                function Equation(bi, bj, minForce, maxForce) {
                    this.id = Equation.id++, this.minForce = void 0 === minForce ? -1e6 : minForce, 
                    this.maxForce = void 0 === maxForce ? 1e6 : maxForce, this.bi = bi, this.bj = bj, 
                    this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new JacobianElement(), 
                    this.jacobianElementB = new JacobianElement(), this.enabled = !0, this.setSpookParams(1e7, 4, 1 / 60);
                }
                (Equation.prototype.constructor = Equation).id = 0, Equation.prototype.setSpookParams = function(stiffness, relaxation, timeStep) {
                    var d = relaxation, k = stiffness, h = timeStep;
                    this.a = 4 / (h * (1 + 4 * d)), this.b = 4 * d / (1 + 4 * d), this.eps = 4 / (h * h * k * (1 + 4 * d));
                }, Equation.prototype.computeB = function(a, b, h) {
                    var GW = this.computeGW(), Gq = this.computeGq(), GiMf = this.computeGiMf();
                    return -Gq * a - GW * b - GiMf * h;
                }, Equation.prototype.computeGq = function() {
                    var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, xi = bi.position, xj = bj.position;
                    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
                };
                var zero = new Vec3();
                Equation.prototype.computeGW = function() {
                    var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity || zero, wj = bj.angularVelocity || zero;
                    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
                }, Equation.prototype.computeGWlambda = function() {
                    var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda || zero, wj = bj.wlambda || zero;
                    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
                };
                var iMfi = new Vec3(), iMfj = new Vec3(), invIi_vmult_taui = new Vec3(), invIj_vmult_tauj = new Vec3();
                Equation.prototype.computeGiMf = function() {
                    var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, fi = bi.force, ti = bi.torque, fj = bj.force, tj = bj.torque, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve;
                    return bi.invInertiaWorldSolve ? bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui) : invIi_vmult_taui.set(0, 0, 0), 
                    bj.invInertiaWorldSolve ? bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj) : invIj_vmult_tauj.set(0, 0, 0), 
                    fi.mult(invMassi, iMfi), fj.mult(invMassj, iMfj), GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
                };
                var tmp = new Vec3();
                Equation.prototype.computeGiMGt = function() {
                    var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaWorldSolve, invIj = bj.invInertiaWorldSolve, result = invMassi + invMassj;
                    return invIi && (invIi.vmult(GA.rotational, tmp), result += tmp.dot(GA.rotational)), 
                    invIj && (invIj.vmult(GB.rotational, tmp), result += tmp.dot(GB.rotational)), result;
                };
                var addToWlambda_temp = new Vec3();
                new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), Equation.prototype.addToWlambda = function(deltalambda) {
                    var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, temp = addToWlambda_temp;
                    GA.spatial.mult(bi.invMassSolve * deltalambda, temp), bi.vlambda.vadd(temp, bi.vlambda), 
                    GB.spatial.mult(bj.invMassSolve * deltalambda, temp), bj.vlambda.vadd(temp, bj.vlambda), 
                    bi.invInertiaWorldSolve && (bi.invInertiaWorldSolve.vmult(GA.rotational, temp), 
                    temp.mult(deltalambda, temp), bi.wlambda.vadd(temp, bi.wlambda)), bj.invInertiaWorldSolve && (bj.invInertiaWorldSolve.vmult(GB.rotational, temp), 
                    temp.mult(deltalambda, temp), bj.wlambda.vadd(temp, bj.wlambda));
                }, Equation.prototype.computeC = function() {
                    return this.computeGiMGt() + this.eps;
                };
            }, {
                "../math/JacobianElement": 26,
                "../math/Vec3": 30
            } ],
            21: [ function(_dereq_, module, exports) {
                module.exports = FrictionEquation;
                var Equation = _dereq_("./Equation"), Vec3 = _dereq_("../math/Vec3");
                function FrictionEquation(bodyA, bodyB, slipForce) {
                    Equation.call(this, bodyA, bodyB, -slipForce, slipForce), this.ri = new Vec3(), 
                    this.rj = new Vec3(), this.t = new Vec3();
                }
                _dereq_("../math/Mat3"), (FrictionEquation.prototype = new Equation()).constructor = FrictionEquation;
                var FrictionEquation_computeB_temp1 = new Vec3(), FrictionEquation_computeB_temp2 = new Vec3();
                FrictionEquation.prototype.computeB = function(h) {
                    this.a;
                    var b = this.b, ri = (this.bi, this.bj, this.ri), rj = this.rj, rixt = FrictionEquation_computeB_temp1, rjxt = FrictionEquation_computeB_temp2, t = this.t;
                    ri.cross(t, rixt), rj.cross(t, rjxt);
                    var GA = this.jacobianElementA, GB = this.jacobianElementB;
                    t.negate(GA.spatial), rixt.negate(GA.rotational), GB.spatial.copy(t), GB.rotational.copy(rjxt);
                    var GW = this.computeGW(), GiMf = this.computeGiMf(), B = -GW * b - h * GiMf;
                    return B;
                };
            }, {
                "../math/Mat3": 27,
                "../math/Vec3": 30,
                "./Equation": 20
            } ],
            22: [ function(_dereq_, module, exports) {
                module.exports = RotationalEquation;
                var Vec3 = _dereq_("../math/Vec3"), Equation = (_dereq_("../math/Mat3"), _dereq_("./Equation"));
                function RotationalEquation(bodyA, bodyB, options) {
                    var maxForce = void 0 !== (options = options || {}).maxForce ? options.maxForce : 1e6;
                    Equation.call(this, bodyA, bodyB, -maxForce, maxForce), this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0), 
                    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0), this.maxAngle = Math.PI / 2;
                }
                (RotationalEquation.prototype = new Equation()).constructor = RotationalEquation;
                var tmpVec1 = new Vec3(), tmpVec2 = new Vec3();
                RotationalEquation.prototype.computeB = function(h) {
                    var a = this.a, b = this.b, ni = this.axisA, nj = this.axisB, nixnj = tmpVec1, njxni = tmpVec2, GA = this.jacobianElementA, GB = this.jacobianElementB;
                    ni.cross(nj, nixnj), nj.cross(ni, njxni), GA.rotational.copy(njxni), GB.rotational.copy(nixnj);
                    var g = Math.cos(this.maxAngle) - ni.dot(nj), GW = this.computeGW(), GiMf = this.computeGiMf(), B = -g * a - GW * b - h * GiMf;
                    return B;
                };
            }, {
                "../math/Mat3": 27,
                "../math/Vec3": 30,
                "./Equation": 20
            } ],
            23: [ function(_dereq_, module, exports) {
                module.exports = RotationalMotorEquation;
                var Vec3 = _dereq_("../math/Vec3"), Equation = (_dereq_("../math/Mat3"), _dereq_("./Equation"));
                function RotationalMotorEquation(bodyA, bodyB, maxForce) {
                    maxForce = void 0 !== maxForce ? maxForce : 1e6, Equation.call(this, bodyA, bodyB, -maxForce, maxForce), 
                    this.axisA = new Vec3(), this.axisB = new Vec3(), this.targetVelocity = 0;
                }
                ((RotationalMotorEquation.prototype = new Equation()).constructor = RotationalMotorEquation).prototype.computeB = function(h) {
                    this.a;
                    var b = this.b, axisA = (this.bi, this.bj, this.axisA), axisB = this.axisB, GA = this.jacobianElementA, GB = this.jacobianElementB;
                    GA.rotational.copy(axisA), axisB.negate(GB.rotational);
                    var GW = this.computeGW() - this.targetVelocity, GiMf = this.computeGiMf(), B = -GW * b - h * GiMf;
                    return B;
                };
            }, {
                "../math/Mat3": 27,
                "../math/Vec3": 30,
                "./Equation": 20
            } ],
            24: [ function(_dereq_, module, exports) {
                var Utils = _dereq_("../utils/Utils");
                function ContactMaterial(m1, m2, options) {
                    options = Utils.defaults(options, {
                        friction: .3,
                        restitution: .3,
                        contactEquationStiffness: 1e7,
                        contactEquationRelaxation: 3,
                        frictionEquationStiffness: 1e7,
                        frictionEquationRelaxation: 3
                    }), this.id = ContactMaterial.idCounter++, this.materials = [ m1, m2 ], this.friction = options.friction, 
                    this.restitution = options.restitution, this.contactEquationStiffness = options.contactEquationStiffness, 
                    this.contactEquationRelaxation = options.contactEquationRelaxation, this.frictionEquationStiffness = options.frictionEquationStiffness, 
                    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
                }
                (module.exports = ContactMaterial).idCounter = 0;
            }, {
                "../utils/Utils": 53
            } ],
            25: [ function(_dereq_, module, exports) {
                function Material(options) {
                    var name = "";
                    "string" == typeof (options = options || {}) ? (name = options, options = {}) : "object" == typeof options && (name = ""), 
                    this.name = name, this.id = Material.idCounter++, this.friction = void 0 !== options.friction ? options.friction : -1, 
                    this.restitution = void 0 !== options.restitution ? options.restitution : -1;
                }
                (module.exports = Material).idCounter = 0;
            }, {} ],
            26: [ function(_dereq_, module, exports) {
                module.exports = JacobianElement;
                var Vec3 = _dereq_("./Vec3");
                function JacobianElement() {
                    this.spatial = new Vec3(), this.rotational = new Vec3();
                }
                JacobianElement.prototype.multiplyElement = function(element) {
                    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
                }, JacobianElement.prototype.multiplyVectors = function(spatial, rotational) {
                    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
                };
            }, {
                "./Vec3": 30
            } ],
            27: [ function(_dereq_, module, exports) {
                module.exports = Mat3;
                var Vec3 = _dereq_("./Vec3");
                function Mat3(elements) {
                    this.elements = elements || [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                }
                Mat3.prototype.identity = function() {
                    var e = this.elements;
                    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
                    e[8] = 1;
                }, Mat3.prototype.setZero = function() {
                    var e = this.elements;
                    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, 
                    e[8] = 0;
                }, Mat3.prototype.setTrace = function(vec3) {
                    var e = this.elements;
                    e[0] = vec3.x, e[4] = vec3.y, e[8] = vec3.z;
                }, Mat3.prototype.getTrace = function(target) {
                    var target = target || new Vec3(), e = this.elements;
                    target.x = e[0], target.y = e[4], target.z = e[8];
                }, Mat3.prototype.vmult = function(v, target) {
                    target = target || new Vec3();
                    var e = this.elements, x = v.x, y = v.y, z = v.z;
                    return target.x = e[0] * x + e[1] * y + e[2] * z, target.y = e[3] * x + e[4] * y + e[5] * z, 
                    target.z = e[6] * x + e[7] * y + e[8] * z, target;
                }, Mat3.prototype.smult = function(s) {
                    for (var i = 0; i < this.elements.length; i++) this.elements[i] *= s;
                }, Mat3.prototype.mmult = function(m, target) {
                    for (var r = target || new Mat3(), i = 0; i < 3; i++) for (var j = 0; j < 3; j++) {
                        for (var sum = 0, k = 0; k < 3; k++) sum += m.elements[i + 3 * k] * this.elements[k + 3 * j];
                        r.elements[i + 3 * j] = sum;
                    }
                    return r;
                }, Mat3.prototype.scale = function(v, target) {
                    target = target || new Mat3();
                    for (var e = this.elements, t = target.elements, i = 0; 3 !== i; i++) t[3 * i + 0] = v.x * e[3 * i + 0], 
                    t[3 * i + 1] = v.y * e[3 * i + 1], t[3 * i + 2] = v.z * e[3 * i + 2];
                    return target;
                }, Mat3.prototype.solve = function(b, target) {
                    target = target || new Vec3();
                    for (var j, eqns = [], i = 0; i < 12; i++) eqns.push(0);
                    for (i = 0; i < 3; i++) for (j = 0; j < 3; j++) eqns[i + 4 * j] = this.elements[i + 3 * j];
                    eqns[3] = b.x, eqns[7] = b.y, eqns[11] = b.z;
                    var np, p, n = 3, k = n;
                    do {
                        if (0 === eqns[(i = k - n) + 4 * i]) for (j = i + 1; j < k; j++) if (0 !== eqns[i + 4 * j]) {
                            for (np = 4; eqns[(p = 4 - np) + 4 * i] += eqns[p + 4 * j], --np; ) ;
                            break;
                        }
                        if (0 !== eqns[i + 4 * i]) for (j = i + 1; j < k; j++) {
                            var multiplier = eqns[i + 4 * j] / eqns[i + 4 * i];
                            for (np = 4; eqns[(p = 4 - np) + 4 * j] = p <= i ? 0 : eqns[p + 4 * j] - eqns[p + 4 * i] * multiplier, 
                            --np; ) ;
                        }
                    } while (--n);
                    if (target.z = eqns[11] / eqns[10], target.y = (eqns[7] - eqns[6] * target.z) / eqns[5], 
                    target.x = (eqns[3] - eqns[2] * target.z - eqns[1] * target.y) / eqns[0], isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === 1 / 0 || target.y === 1 / 0 || target.z === 1 / 0) throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
                    return target;
                }, Mat3.prototype.e = function(row, column, value) {
                    if (void 0 === value) return this.elements[column + 3 * row];
                    this.elements[column + 3 * row] = value;
                }, Mat3.prototype.copy = function(source) {
                    for (var i = 0; i < source.elements.length; i++) this.elements[i] = source.elements[i];
                    return this;
                }, Mat3.prototype.toString = function() {
                    for (var r = "", i = 0; i < 9; i++) r += this.elements[i] + ",";
                    return r;
                }, Mat3.prototype.reverse = function(target) {
                    target = target || new Mat3();
                    for (var j, eqns = [], i = 0; i < 18; i++) eqns.push(0);
                    for (i = 0; i < 3; i++) for (j = 0; j < 3; j++) eqns[i + 6 * j] = this.elements[i + 3 * j];
                    eqns[3] = 1, eqns[9] = 0, eqns[15] = 0, eqns[4] = 0, eqns[10] = 1, eqns[16] = 0, 
                    eqns[5] = 0, eqns[11] = 0, eqns[17] = 1;
                    var np, p, n = 3, k = n;
                    do {
                        if (0 === eqns[(i = k - n) + 6 * i]) for (j = i + 1; j < k; j++) if (0 !== eqns[i + 6 * j]) {
                            for (np = 6; eqns[(p = 6 - np) + 6 * i] += eqns[p + 6 * j], --np; ) ;
                            break;
                        }
                        if (0 !== eqns[i + 6 * i]) for (j = i + 1; j < k; j++) {
                            var multiplier = eqns[i + 6 * j] / eqns[i + 6 * i];
                            for (np = 6; eqns[(p = 6 - np) + 6 * j] = p <= i ? 0 : eqns[p + 6 * j] - eqns[p + 6 * i] * multiplier, 
                            --np; ) ;
                        }
                    } while (--n);
                    i = 2;
                    do {
                        j = i - 1;
                        do {
                            var multiplier = eqns[i + 6 * j] / eqns[i + 6 * i];
                            for (np = 6; eqns[(p = 6 - np) + 6 * j] = eqns[p + 6 * j] - eqns[p + 6 * i] * multiplier, 
                            --np; ) ;
                        } while (j--);
                    } while (--i);
                    i = 2;
                    do {
                        var multiplier = 1 / eqns[i + 6 * i];
                        for (np = 6; eqns[(p = 6 - np) + 6 * i] = eqns[p + 6 * i] * multiplier, --np; ) ;
                    } while (i--);
                    i = 2;
                    do {
                        j = 2;
                        do {
                            if (p = eqns[3 + j + 6 * i], isNaN(p) || p === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                            target.e(i, j, p);
                        } while (j--);
                    } while (i--);
                    return target;
                }, Mat3.prototype.setRotationFromQuaternion = function(q) {
                    var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, e = this.elements;
                    return e[0] = 1 - (yy + zz), e[1] = xy - wz, e[2] = xz + wy, e[3] = xy + wz, e[4] = 1 - (xx + zz), 
                    e[5] = yz - wx, e[6] = xz - wy, e[7] = yz + wx, e[8] = 1 - (xx + yy), this;
                }, Mat3.prototype.transpose = function(target) {
                    for (var Mt = (target = target || new Mat3()).elements, M = this.elements, i = 0; 3 !== i; i++) for (var j = 0; 3 !== j; j++) Mt[3 * i + j] = M[3 * j + i];
                    return target;
                };
            }, {
                "./Vec3": 30
            } ],
            28: [ function(_dereq_, module, exports) {
                module.exports = Quaternion;
                var Vec3 = _dereq_("./Vec3");
                function Quaternion(x, y, z, w) {
                    this.x = void 0 !== x ? x : 0, this.y = void 0 !== y ? y : 0, this.z = void 0 !== z ? z : 0, 
                    this.w = void 0 !== w ? w : 1;
                }
                Quaternion.prototype.set = function(x, y, z, w) {
                    this.x = x, this.y = y, this.z = z, this.w = w;
                }, Quaternion.prototype.toString = function() {
                    return this.x + "," + this.y + "," + this.z + "," + this.w;
                }, Quaternion.prototype.toArray = function() {
                    return [ this.x, this.y, this.z, this.w ];
                }, Quaternion.prototype.setFromAxisAngle = function(axis, angle) {
                    var s = Math.sin(.5 * angle);
                    this.x = axis.x * s, this.y = axis.y * s, this.z = axis.z * s, this.w = Math.cos(.5 * angle);
                }, Quaternion.prototype.toAxisAngle = function(targetAxis) {
                    targetAxis = targetAxis || new Vec3(), this.normalize();
                    var angle = 2 * Math.acos(this.w), s = Math.sqrt(1 - this.w * this.w);
                    return targetAxis.z = s < .001 ? (targetAxis.x = this.x, targetAxis.y = this.y, 
                    this.z) : (targetAxis.x = this.x / s, targetAxis.y = this.y / s, this.z / s), [ targetAxis, angle ];
                };
                var sfv_t1 = new Vec3(), sfv_t2 = new Vec3();
                Quaternion.prototype.setFromVectors = function(u, v) {
                    if (u.isAntiparallelTo(v)) {
                        var t1 = sfv_t1, t2 = sfv_t2;
                        u.tangents(t1, t2), this.setFromAxisAngle(t1, Math.PI);
                    } else {
                        var a = u.cross(v);
                        this.x = a.x, this.y = a.y, this.z = a.z, this.w = Math.sqrt(Math.pow(u.norm(), 2) * Math.pow(v.norm(), 2)) + u.dot(v), 
                        this.normalize();
                    }
                };
                var Quaternion_mult_va = new Vec3(), Quaternion_mult_vb = new Vec3(), Quaternion_mult_vaxvb = new Vec3();
                Quaternion.prototype.mult = function(q, target) {
                    target = target || new Quaternion();
                    var w = this.w, va = Quaternion_mult_va, vb = Quaternion_mult_vb, vaxvb = Quaternion_mult_vaxvb;
                    return va.set(this.x, this.y, this.z), vb.set(q.x, q.y, q.z), target.w = w * q.w - va.dot(vb), 
                    va.cross(vb, vaxvb), target.x = w * vb.x + q.w * va.x + vaxvb.x, target.y = w * vb.y + q.w * va.y + vaxvb.y, 
                    target.z = w * vb.z + q.w * va.z + vaxvb.z, target;
                }, Quaternion.prototype.inverse = function(target) {
                    var x = this.x, y = this.y, z = this.z, w = this.w;
                    target = target || new Quaternion(), this.conjugate(target);
                    var inorm2 = 1 / (x * x + y * y + z * z + w * w);
                    return target.x *= inorm2, target.y *= inorm2, target.z *= inorm2, target.w *= inorm2, 
                    target;
                }, Quaternion.prototype.conjugate = function(target) {
                    return (target = target || new Quaternion()).x = -this.x, target.y = -this.y, target.z = -this.z, 
                    target.w = this.w, target;
                }, Quaternion.prototype.normalize = function() {
                    var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    0 === l ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (l = 1 / l, this.x *= l, 
                    this.y *= l, this.z *= l, this.w *= l);
                }, Quaternion.prototype.normalizeFast = function() {
                    var f = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
                    0 === f ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= f, this.y *= f, 
                    this.z *= f, this.w *= f);
                }, Quaternion.prototype.vmult = function(v, target) {
                    target = target || new Vec3();
                    var x = v.x, y = v.y, z = v.z, qx = this.x, qy = this.y, qz = this.z, qw = this.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                    return target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, 
                    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, target;
                }, Quaternion.prototype.copy = function(source) {
                    return this.x = source.x, this.y = source.y, this.z = source.z, this.w = source.w, 
                    this;
                }, Quaternion.prototype.toEuler = function(target, order) {
                    var heading, attitude, bank;
                    order = order || "YZX";
                    var x = this.x, y = this.y, z = this.z, w = this.w;
                    switch (order) {
                      case "YZX":
                        var test = x * y + z * w;
                        if (.499 < test && (heading = 2 * Math.atan2(x, w), attitude = Math.PI / 2, bank = 0), 
                        test < -.499 && (heading = -2 * Math.atan2(x, w), attitude = -Math.PI / 2, bank = 0), 
                        isNaN(heading)) {
                            var sqx = x * x, sqy = y * y, sqz = z * z;
                            heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz), attitude = Math.asin(2 * test), 
                            bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
                        }
                        break;

                      default:
                        throw new Error("Euler order " + order + " not supported yet.");
                    }
                    target.y = heading, target.z = attitude, target.x = bank;
                }, Quaternion.prototype.setFromEuler = function(x, y, z, order) {
                    order = order || "XYZ";
                    var c1 = Math.cos(x / 2), c2 = Math.cos(y / 2), c3 = Math.cos(z / 2), s1 = Math.sin(x / 2), s2 = Math.sin(y / 2), s3 = Math.sin(z / 2);
                    return "XYZ" === order ? (this.x = s1 * c2 * c3 + c1 * s2 * s3, this.y = c1 * s2 * c3 - s1 * c2 * s3, 
                    this.z = c1 * c2 * s3 + s1 * s2 * c3, this.w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this.x = s1 * c2 * c3 + c1 * s2 * s3, 
                    this.y = c1 * s2 * c3 - s1 * c2 * s3, this.z = c1 * c2 * s3 - s1 * s2 * c3, this.w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this.x = s1 * c2 * c3 - c1 * s2 * s3, 
                    this.y = c1 * s2 * c3 + s1 * c2 * s3, this.z = c1 * c2 * s3 + s1 * s2 * c3, this.w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this.x = s1 * c2 * c3 - c1 * s2 * s3, 
                    this.y = c1 * s2 * c3 + s1 * c2 * s3, this.z = c1 * c2 * s3 - s1 * s2 * c3, this.w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this.x = s1 * c2 * c3 + c1 * s2 * s3, 
                    this.y = c1 * s2 * c3 + s1 * c2 * s3, this.z = c1 * c2 * s3 - s1 * s2 * c3, this.w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this.x = s1 * c2 * c3 - c1 * s2 * s3, 
                    this.y = c1 * s2 * c3 - s1 * c2 * s3, this.z = c1 * c2 * s3 + s1 * s2 * c3, this.w = c1 * c2 * c3 + s1 * s2 * s3), 
                    this;
                }, Quaternion.prototype.clone = function() {
                    return new Quaternion(this.x, this.y, this.z, this.w);
                };
            }, {
                "./Vec3": 30
            } ],
            29: [ function(_dereq_, module, exports) {
                var Vec3 = _dereq_("./Vec3"), Quaternion = _dereq_("./Quaternion");
                function Transform(options) {
                    options = options || {}, this.position = new Vec3(), options.position && this.position.copy(options.position), 
                    this.quaternion = new Quaternion(), options.quaternion && this.quaternion.copy(options.quaternion);
                }
                module.exports = Transform;
                var tmpQuat = new Quaternion();
                Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result) {
                    var result = result || new Vec3();
                    return worldPoint.vsub(position, result), quaternion.conjugate(tmpQuat), tmpQuat.vmult(result, result), 
                    result;
                }, Transform.prototype.pointToLocal = function(worldPoint, result) {
                    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
                }, Transform.pointToWorldFrame = function(position, quaternion, localPoint, result) {
                    var result = result || new Vec3();
                    return quaternion.vmult(localPoint, result), result.vadd(position, result), result;
                }, Transform.prototype.pointToWorld = function(localPoint, result) {
                    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
                }, Transform.prototype.vectorToWorldFrame = function(localVector, result) {
                    var result = result || new Vec3();
                    return this.quaternion.vmult(localVector, result), result;
                }, Transform.vectorToWorldFrame = function(quaternion, localVector, result) {
                    return quaternion.vmult(localVector, result), result;
                }, Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result) {
                    var result = result || new Vec3();
                    return quaternion.w *= -1, quaternion.vmult(worldVector, result), quaternion.w *= -1, 
                    result;
                };
            }, {
                "./Quaternion": 28,
                "./Vec3": 30
            } ],
            30: [ function(_dereq_, module, exports) {
                module.exports = Vec3;
                var Mat3 = _dereq_("./Mat3");
                function Vec3(x, y, z) {
                    this.x = x || 0, this.y = y || 0, this.z = z || 0;
                }
                Vec3.ZERO = new Vec3(0, 0, 0), Vec3.UNIT_X = new Vec3(1, 0, 0), Vec3.UNIT_Y = new Vec3(0, 1, 0), 
                Vec3.UNIT_Z = new Vec3(0, 0, 1), Vec3.prototype.cross = function(v, target) {
                    var vx = v.x, vy = v.y, vz = v.z, x = this.x, y = this.y, z = this.z;
                    return (target = target || new Vec3()).x = y * vz - z * vy, target.y = z * vx - x * vz, 
                    target.z = x * vy - y * vx, target;
                }, Vec3.prototype.set = function(x, y, z) {
                    return this.x = x, this.y = y, this.z = z, this;
                }, Vec3.prototype.setZero = function() {
                    this.x = this.y = this.z = 0;
                }, Vec3.prototype.vadd = function(v, target) {
                    if (!target) return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
                    target.x = v.x + this.x, target.y = v.y + this.y, target.z = v.z + this.z;
                }, Vec3.prototype.vsub = function(v, target) {
                    if (!target) return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
                    target.x = this.x - v.x, target.y = this.y - v.y, target.z = this.z - v.z;
                }, Vec3.prototype.crossmat = function() {
                    return new Mat3([ 0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0 ]);
                }, Vec3.prototype.normalize = function() {
                    var x = this.x, y = this.y, z = this.z, n = Math.sqrt(x * x + y * y + z * z);
                    if (0 < n) {
                        var invN = 1 / n;
                        this.x *= invN, this.y *= invN, this.z *= invN;
                    } else this.x = 0, this.y = 0, this.z = 0;
                    return n;
                }, Vec3.prototype.unit = function(target) {
                    target = target || new Vec3();
                    var x = this.x, y = this.y, z = this.z, ninv = Math.sqrt(x * x + y * y + z * z);
                    return target.z = 0 < ninv ? (ninv = 1 / ninv, target.x = x * ninv, target.y = y * ninv, 
                    z * ninv) : (target.x = 1, target.y = 0), target;
                }, Vec3.prototype.length = Vec3.prototype.norm = function() {
                    var x = this.x, y = this.y, z = this.z;
                    return Math.sqrt(x * x + y * y + z * z);
                }, Vec3.prototype.lengthSquared = Vec3.prototype.norm2 = function() {
                    return this.dot(this);
                }, Vec3.prototype.distanceTo = function(p) {
                    var x = this.x, y = this.y, z = this.z, px = p.x, py = p.y, pz = p.z;
                    return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
                }, Vec3.prototype.distanceSquared = function(p) {
                    var x = this.x, y = this.y, z = this.z, px = p.x, py = p.y, pz = p.z;
                    return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
                }, Vec3.prototype.scale = Vec3.prototype.mult = function(scalar, target) {
                    target = target || new Vec3();
                    var x = this.x, y = this.y, z = this.z;
                    return target.x = scalar * x, target.y = scalar * y, target.z = scalar * z, target;
                }, Vec3.prototype.dot = function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z;
                }, Vec3.prototype.isZero = function() {
                    return 0 === this.x && 0 === this.y && 0 === this.z;
                }, Vec3.prototype.negate = function(target) {
                    return (target = target || new Vec3()).x = -this.x, target.y = -this.y, target.z = -this.z, 
                    target;
                };
                var Vec3_tangents_n = new Vec3(), Vec3_tangents_randVec = new Vec3();
                Vec3.prototype.tangents = function(t1, t2) {
                    var norm = this.norm();
                    if (0 < norm) {
                        var n = Vec3_tangents_n, inorm = 1 / norm;
                        n.set(this.x * inorm, this.y * inorm, this.z * inorm);
                        var randVec = Vec3_tangents_randVec;
                        Math.abs(n.x) < .9 ? randVec.set(1, 0, 0) : randVec.set(0, 1, 0), n.cross(randVec, t1), 
                        n.cross(t1, t2);
                    } else t1.set(1, 0, 0), t2.set(0, 1, 0);
                }, Vec3.prototype.toString = function() {
                    return this.x + "," + this.y + "," + this.z;
                }, Vec3.prototype.toArray = function() {
                    return [ this.x, this.y, this.z ];
                }, Vec3.prototype.copy = function(source) {
                    return this.x = source.x, this.y = source.y, this.z = source.z, this;
                }, Vec3.prototype.lerp = function(v, t, target) {
                    var x = this.x, y = this.y, z = this.z;
                    target.x = x + (v.x - x) * t, target.y = y + (v.y - y) * t, target.z = z + (v.z - z) * t;
                }, Vec3.prototype.almostEquals = function(v, precision) {
                    return void 0 === precision && (precision = 1e-6), !(Math.abs(this.x - v.x) > precision || Math.abs(this.y - v.y) > precision || Math.abs(this.z - v.z) > precision);
                }, Vec3.prototype.almostZero = function(precision) {
                    return void 0 === precision && (precision = 1e-6), !(Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision);
                };
                var antip_neg = new Vec3();
                Vec3.prototype.isAntiparallelTo = function(v, precision) {
                    return this.negate(antip_neg), antip_neg.almostEquals(v, precision);
                }, Vec3.prototype.clone = function() {
                    return new Vec3(this.x, this.y, this.z);
                };
            }, {
                "./Mat3": 27
            } ],
            31: [ function(_dereq_, module, exports) {
                module.exports = Body;
                var EventTarget = _dereq_("../utils/EventTarget"), Vec3 = (_dereq_("../shapes/Shape"), 
                _dereq_("../math/Vec3")), Mat3 = _dereq_("../math/Mat3"), Quaternion = _dereq_("../math/Quaternion"), AABB = (_dereq_("../material/Material"), 
                _dereq_("../collision/AABB")), Box = _dereq_("../shapes/Box");
                function Body(options) {
                    options = options || {}, EventTarget.apply(this), this.id = Body.idCounter++, this.world = null, 
                    this.preStep = null, this.postStep = null, this.vlambda = new Vec3(), this.collisionFilterGroup = "number" == typeof options.collisionFilterGroup ? options.collisionFilterGroup : 1, 
                    this.collisionFilterMask = "number" == typeof options.collisionFilterMask ? options.collisionFilterMask : 1, 
                    this.collisionResponse = !0, this.position = new Vec3(), options.position && this.position.copy(options.position), 
                    this.previousPosition = new Vec3(), this.initPosition = new Vec3(), this.velocity = new Vec3(), 
                    options.velocity && this.velocity.copy(options.velocity), this.initVelocity = new Vec3(), 
                    this.force = new Vec3();
                    var mass = "number" == typeof options.mass ? options.mass : 0;
                    this.mass = mass, this.invMass = 0 < mass ? 1 / mass : 0, this.material = options.material || null, 
                    this.linearDamping = "number" == typeof options.linearDamping ? options.linearDamping : .01, 
                    this.type = mass <= 0 ? Body.STATIC : Body.DYNAMIC, typeof options.type == typeof Body.STATIC && (this.type = options.type), 
                    this.allowSleep = void 0 === options.allowSleep || options.allowSleep, this.sleepState = 0, 
                    this.sleepSpeedLimit = void 0 !== options.sleepSpeedLimit ? options.sleepSpeedLimit : .1, 
                    this.sleepTimeLimit = void 0 !== options.sleepTimeLimit ? options.sleepTimeLimit : 1, 
                    this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new Vec3(), 
                    this.quaternion = new Quaternion(), options.quaternion && this.quaternion.copy(options.quaternion), 
                    this.initQuaternion = new Quaternion(), this.angularVelocity = new Vec3(), options.angularVelocity && this.angularVelocity.copy(options.angularVelocity), 
                    this.initAngularVelocity = new Vec3(), this.interpolatedPosition = new Vec3(), this.interpolatedQuaternion = new Quaternion(), 
                    this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new Vec3(), 
                    this.invInertia = new Vec3(), this.invInertiaWorld = new Mat3(), this.invMassSolve = 0, 
                    this.invInertiaSolve = new Vec3(), this.invInertiaWorldSolve = new Mat3(), this.fixedRotation = void 0 !== options.fixedRotation && options.fixedRotation, 
                    this.angularDamping = void 0 !== options.angularDamping ? options.angularDamping : .01, 
                    this.aabb = new AABB(), this.aabbNeedsUpdate = !0, this.wlambda = new Vec3(), options.shape && this.addShape(options.shape), 
                    this.updateMassProperties();
                }
                ((Body.prototype = new EventTarget()).constructor = Body).DYNAMIC = 1, Body.STATIC = 2, 
                Body.KINEMATIC = 4, Body.AWAKE = 0, Body.SLEEPY = 1, Body.SLEEPING = 2, Body.idCounter = 0, 
                Body.prototype.wakeUp = function() {
                    var s = this.sleepState;
                    this.sleepState = 0, s === Body.SLEEPING && this.dispatchEvent({
                        type: "wakeup"
                    });
                }, Body.prototype.sleep = function() {
                    this.sleepState = Body.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0);
                }, Body.sleepyEvent = {
                    type: "sleepy"
                }, Body.sleepEvent = {
                    type: "sleep"
                }, Body.prototype.sleepTick = function(time) {
                    if (this.allowSleep) {
                        var sleepState = this.sleepState, speedSquared = this.velocity.norm2() + this.angularVelocity.norm2(), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                        sleepState === Body.AWAKE && speedSquared < speedLimitSquared ? (this.sleepState = Body.SLEEPY, 
                        this.timeLastSleepy = time, this.dispatchEvent(Body.sleepyEvent)) : sleepState === Body.SLEEPY && speedLimitSquared < speedSquared ? this.wakeUp() : sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), 
                        this.dispatchEvent(Body.sleepEvent));
                    }
                }, Body.prototype.updateSolveMassProperties = function() {
                    this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC ? (this.invMassSolve = 0, 
                    this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, 
                    this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
                }, Body.prototype.pointToLocalFrame = function(worldPoint, result) {
                    var result = result || new Vec3();
                    return worldPoint.vsub(this.position, result), this.quaternion.conjugate().vmult(result, result), 
                    result;
                }, Body.prototype.vectorToLocalFrame = function(worldVector, result) {
                    var result = result || new Vec3();
                    return this.quaternion.conjugate().vmult(worldVector, result), result;
                }, Body.prototype.pointToWorldFrame = function(localPoint, result) {
                    var result = result || new Vec3();
                    return this.quaternion.vmult(localPoint, result), result.vadd(this.position, result), 
                    result;
                }, Body.prototype.vectorToWorldFrame = function(localVector, result) {
                    var result = result || new Vec3();
                    return this.quaternion.vmult(localVector, result), result;
                };
                var tmpVec = new Vec3(), tmpQuat = new Quaternion();
                Body.prototype.addShape = function(shape, _offset, _orientation) {
                    var offset = new Vec3(), orientation = new Quaternion();
                    return _offset && offset.copy(_offset), _orientation && orientation.copy(_orientation), 
                    this.shapes.push(shape), this.shapeOffsets.push(offset), this.shapeOrientations.push(orientation), 
                    this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, 
                    this;
                }, Body.prototype.updateBoundingRadius = function() {
                    for (var shapes = this.shapes, shapeOffsets = this.shapeOffsets, N = shapes.length, radius = 0, i = 0; i !== N; i++) {
                        var shape = shapes[i];
                        shape.updateBoundingSphereRadius();
                        var offset = shapeOffsets[i].norm(), r = shape.boundingSphereRadius;
                        radius < offset + r && (radius = offset + r);
                    }
                    this.boundingRadius = radius;
                };
                var computeAABB_shapeAABB = new AABB();
                Body.prototype.computeAABB = function() {
                    for (var shapes = this.shapes, shapeOffsets = this.shapeOffsets, shapeOrientations = this.shapeOrientations, N = shapes.length, offset = tmpVec, orientation = tmpQuat, bodyQuat = this.quaternion, aabb = this.aabb, shapeAABB = computeAABB_shapeAABB, i = 0; i !== N; i++) {
                        var shape = shapes[i];
                        shapeOrientations[i].mult(bodyQuat, orientation), orientation.vmult(shapeOffsets[i], offset), 
                        offset.vadd(this.position, offset), shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound), 
                        0 === i ? aabb.copy(shapeAABB) : aabb.extend(shapeAABB);
                    }
                    this.aabbNeedsUpdate = !1;
                };
                var uiw_m1 = new Mat3(), uiw_m2 = new Mat3();
                new Mat3(), Body.prototype.updateInertiaWorld = function(force) {
                    var I = this.invInertia;
                    if (I.x !== I.y || I.y !== I.z || force) {
                        var m1 = uiw_m1, m2 = uiw_m2;
                        m1.setRotationFromQuaternion(this.quaternion), m1.transpose(m2), m1.scale(I, m1), 
                        m1.mmult(m2, this.invInertiaWorld);
                    }
                };
                var Body_applyForce_r = new Vec3(), Body_applyForce_rotForce = new Vec3();
                Body.prototype.applyForce = function(force, worldPoint) {
                    if (this.type === Body.DYNAMIC) {
                        var r = Body_applyForce_r;
                        worldPoint.vsub(this.position, r);
                        var rotForce = Body_applyForce_rotForce;
                        r.cross(force, rotForce), this.force.vadd(force, this.force), this.torque.vadd(rotForce, this.torque);
                    }
                };
                var Body_applyLocalForce_worldForce = new Vec3(), Body_applyLocalForce_worldPoint = new Vec3();
                Body.prototype.applyLocalForce = function(localForce, localPoint) {
                    if (this.type === Body.DYNAMIC) {
                        var worldForce = Body_applyLocalForce_worldForce, worldPoint = Body_applyLocalForce_worldPoint;
                        this.vectorToWorldFrame(localForce, worldForce), this.pointToWorldFrame(localPoint, worldPoint), 
                        this.applyForce(worldForce, worldPoint);
                    }
                };
                var Body_applyImpulse_r = new Vec3(), Body_applyImpulse_velo = new Vec3(), Body_applyImpulse_rotVelo = new Vec3();
                Body.prototype.applyImpulse = function(impulse, worldPoint) {
                    if (this.type === Body.DYNAMIC) {
                        var r = Body_applyImpulse_r;
                        worldPoint.vsub(this.position, r);
                        var velo = Body_applyImpulse_velo;
                        velo.copy(impulse), velo.mult(this.invMass, velo), this.velocity.vadd(velo, this.velocity);
                        var rotVelo = Body_applyImpulse_rotVelo;
                        r.cross(impulse, rotVelo), this.invInertiaWorld.vmult(rotVelo, rotVelo), this.angularVelocity.vadd(rotVelo, this.angularVelocity);
                    }
                };
                var Body_applyLocalImpulse_worldImpulse = new Vec3(), Body_applyLocalImpulse_worldPoint = new Vec3();
                Body.prototype.applyLocalImpulse = function(localImpulse, localPoint) {
                    if (this.type === Body.DYNAMIC) {
                        var worldImpulse = Body_applyLocalImpulse_worldImpulse, worldPoint = Body_applyLocalImpulse_worldPoint;
                        this.vectorToWorldFrame(localImpulse, worldImpulse), this.pointToWorldFrame(localPoint, worldPoint), 
                        this.applyImpulse(worldImpulse, worldPoint);
                    }
                };
                var Body_updateMassProperties_halfExtents = new Vec3();
                Body.prototype.updateMassProperties = function() {
                    var halfExtents = Body_updateMassProperties_halfExtents;
                    this.invMass = 0 < this.mass ? 1 / this.mass : 0;
                    var I = this.inertia, fixed = this.fixedRotation;
                    this.computeAABB(), halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), 
                    Box.calculateInertia(halfExtents, this.mass, I), this.invInertia.set(0 < I.x && !fixed ? 1 / I.x : 0, 0 < I.y && !fixed ? 1 / I.y : 0, 0 < I.z && !fixed ? 1 / I.z : 0), 
                    this.updateInertiaWorld(!0);
                }, Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result) {
                    var r = new Vec3();
                    return worldPoint.vsub(this.position, r), this.angularVelocity.cross(r, result), 
                    this.velocity.vadd(result, result), result;
                };
            }, {
                "../collision/AABB": 3,
                "../material/Material": 25,
                "../math/Mat3": 27,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../shapes/Box": 37,
                "../shapes/Shape": 43,
                "../utils/EventTarget": 49
            } ],
            32: [ function(_dereq_, module, exports) {
                _dereq_("./Body");
                var Vec3 = _dereq_("../math/Vec3"), Quaternion = _dereq_("../math/Quaternion"), Ray = (_dereq_("../collision/RaycastResult"), 
                _dereq_("../collision/Ray")), WheelInfo = _dereq_("../objects/WheelInfo");
                function RaycastVehicle(options) {
                    this.chassisBody = options.chassisBody, this.wheelInfos = [], this.sliding = !1, 
                    this.world = null, this.indexRightAxis = void 0 !== options.indexRightAxis ? options.indexRightAxis : 1, 
                    this.indexForwardAxis = void 0 !== options.indexForwardAxis ? options.indexForwardAxis : 0, 
                    this.indexUpAxis = void 0 !== options.indexUpAxis ? options.indexUpAxis : 2;
                }
                module.exports = RaycastVehicle, new Vec3(), new Vec3(), new Vec3();
                var tmpVec4 = new Vec3(), tmpVec5 = new Vec3(), tmpVec6 = new Vec3();
                new Ray(), RaycastVehicle.prototype.addWheel = function(options) {
                    var info = new WheelInfo(options = options || {}), index = this.wheelInfos.length;
                    return this.wheelInfos.push(info), index;
                }, RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex) {
                    var wheel = this.wheelInfos[wheelIndex];
                    wheel.steering = value;
                }, new Vec3(), RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex) {
                    this.wheelInfos[wheelIndex].engineForce = value;
                }, RaycastVehicle.prototype.setBrake = function(brake, wheelIndex) {
                    this.wheelInfos[wheelIndex].brake = brake;
                }, RaycastVehicle.prototype.addToWorld = function(world) {
                    this.constraints, world.add(this.chassisBody);
                    var that = this;
                    this.preStepCallback = function() {
                        that.updateVehicle(world.dt);
                    }, world.addEventListener("preStep", this.preStepCallback), this.world = world;
                }, RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result) {
                    result.set(0 === axisIndex ? 1 : 0, 1 === axisIndex ? 1 : 0, 2 === axisIndex ? 1 : 0), 
                    this.chassisBody.vectorToWorldFrame(result, result);
                }, RaycastVehicle.prototype.updateVehicle = function(timeStep) {
                    for (var wheelInfos = this.wheelInfos, numWheels = wheelInfos.length, chassisBody = this.chassisBody, i = 0; i < numWheels; i++) this.updateWheelTransform(i);
                    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();
                    var forwardWorld = new Vec3();
                    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld), forwardWorld.dot(chassisBody.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1);
                    for (var i = 0; i < numWheels; i++) this.castRay(wheelInfos[i]);
                    this.updateSuspension(timeStep);
                    for (var impulse = new Vec3(), relpos = new Vec3(), i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i], suspensionForce = wheel.suspensionForce;
                        suspensionForce > wheel.maxSuspensionForce && (suspensionForce = wheel.maxSuspensionForce), 
                        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse), wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos), 
                        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld);
                    }
                    this.updateFriction(timeStep);
                    var hitNormalWorldScaledWithProj = new Vec3(), fwd = new Vec3(), vel = new Vec3();
                    for (i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i];
                        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);
                        var m = 1;
                        switch (this.indexUpAxis) {
                          case 1:
                            m = -1;
                        }
                        if (wheel.isInContact) {
                            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
                            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
                            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj), fwd.vsub(hitNormalWorldScaledWithProj, fwd);
                            var proj2 = fwd.dot(vel);
                            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
                        }
                        !wheel.sliding && wheel.isInContact || 0 === wheel.engineForce || !wheel.useCustomSlidingRotationalSpeed || (wheel.deltaRotation = (0 < wheel.engineForce ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep), 
                        Math.abs(wheel.brake) > Math.abs(wheel.engineForce) && (wheel.deltaRotation = 0), 
                        wheel.rotation += wheel.deltaRotation, wheel.deltaRotation *= .99;
                    }
                }, RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
                    for (var chassisBody = this.chassisBody, chassisMass = chassisBody.mass, wheelInfos = this.wheelInfos, numWheels = wheelInfos.length, w_it = 0; w_it < numWheels; w_it++) {
                        var wheel = wheelInfos[w_it];
                        if (wheel.isInContact) {
                            var force, susp_length = wheel.suspensionRestLength, current_length = wheel.suspensionLength, length_diff = susp_length - current_length;
                            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;
                            var susp_damping, projected_rel_vel = wheel.suspensionRelativeVelocity;
                            susp_damping = projected_rel_vel < 0 ? wheel.dampingCompression : wheel.dampingRelaxation, 
                            force -= susp_damping * projected_rel_vel, wheel.suspensionForce = force * chassisMass, 
                            wheel.suspensionForce < 0 && (wheel.suspensionForce = 0);
                        } else wheel.suspensionForce = 0;
                    }
                }, RaycastVehicle.prototype.removeFromWorld = function(world) {
                    this.constraints, world.remove(this.chassisBody), world.removeEventListener("preStep", this.preStepCallback), 
                    this.world = null;
                };
                var castRay_rayvector = new Vec3(), castRay_target = new Vec3();
                RaycastVehicle.prototype.castRay = function(wheel) {
                    var rayvector = castRay_rayvector, target = castRay_target;
                    this.updateWheelTransformWorld(wheel);
                    var chassisBody = this.chassisBody, depth = -1, raylen = wheel.suspensionRestLength + wheel.radius;
                    wheel.directionWorld.scale(raylen, rayvector);
                    var source = wheel.chassisConnectionPointWorld;
                    source.vadd(rayvector, target);
                    var raycastResult = wheel.raycastResult;
                    raycastResult.reset();
                    var oldState = chassisBody.collisionResponse;
                    chassisBody.collisionResponse = !1, this.world.rayTest(source, target, raycastResult), 
                    chassisBody.collisionResponse = oldState;
                    var object = raycastResult.body;
                    if (wheel.raycastResult.groundObject = 0, object) {
                        depth = raycastResult.distance, wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld, 
                        wheel.isInContact = !0;
                        var hitDistance = raycastResult.distance;
                        wheel.suspensionLength = hitDistance - wheel.radius;
                        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel, maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
                        wheel.suspensionLength < minSuspensionLength && (wheel.suspensionLength = minSuspensionLength), 
                        wheel.suspensionLength > maxSuspensionLength && (wheel.suspensionLength = maxSuspensionLength, 
                        wheel.raycastResult.reset());
                        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld), chassis_velocity_at_contactPoint = new Vec3();
                        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
                        var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
                        if (-.1 <= denominator) wheel.suspensionRelativeVelocity = 0, wheel.clippedInvContactDotSuspension = 10; else {
                            var inv = -1 / denominator;
                            wheel.suspensionRelativeVelocity = projVel * inv, wheel.clippedInvContactDotSuspension = inv;
                        }
                    } else wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel, 
                    wheel.suspensionRelativeVelocity = 0, wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld), 
                    wheel.clippedInvContactDotSuspension = 1;
                    return depth;
                }, RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel) {
                    wheel.isInContact = !1;
                    var chassisBody = this.chassisBody;
                    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld), 
                    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld), chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
                }, RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex) {
                    var up = tmpVec4, right = tmpVec5, fwd = tmpVec6, wheel = this.wheelInfos[wheelIndex];
                    this.updateWheelTransformWorld(wheel), wheel.directionLocal.scale(-1, up), right.copy(wheel.axleLocal), 
                    up.cross(right, fwd), fwd.normalize(), right.normalize();
                    var steering = wheel.steering, steeringOrn = new Quaternion();
                    steeringOrn.setFromAxisAngle(up, steering);
                    var rotatingOrn = new Quaternion();
                    rotatingOrn.setFromAxisAngle(right, wheel.rotation);
                    var q = wheel.worldTransform.quaternion;
                    this.chassisBody.quaternion.mult(steeringOrn, q), q.mult(rotatingOrn, q), q.normalize();
                    var p = wheel.worldTransform.position;
                    p.copy(wheel.directionWorld), p.scale(wheel.suspensionLength, p), p.vadd(wheel.chassisConnectionPointWorld, p);
                };
                var directions = [ new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1) ];
                RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
                    return this.wheelInfos[wheelIndex].worldTransform;
                };
                var updateFriction_surfNormalWS_scaled_proj = new Vec3(), updateFriction_axle = [], updateFriction_forwardWS = [];
                RaycastVehicle.prototype.updateFriction = function(timeStep) {
                    for (var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj, wheelInfos = this.wheelInfos, numWheels = wheelInfos.length, chassisBody = this.chassisBody, forwardWS = updateFriction_forwardWS, axle = updateFriction_axle, i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i], groundObject = wheel.raycastResult.body;
                        wheel.sideImpulse = 0, wheel.forwardImpulse = 0, forwardWS[i] || (forwardWS[i] = new Vec3()), 
                        axle[i] || (axle[i] = new Vec3());
                    }
                    for (var i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i], groundObject = wheel.raycastResult.body;
                        if (groundObject) {
                            var axlei = axle[i], wheelTrans = this.getWheelTransformWorld(i);
                            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
                            var surfNormalWS = wheel.raycastResult.hitNormalWorld, proj = axlei.dot(surfNormalWS);
                            surfNormalWS.scale(proj, surfNormalWS_scaled_proj), axlei.vsub(surfNormalWS_scaled_proj, axlei), 
                            axlei.normalize(), surfNormalWS.cross(axlei, forwardWS[i]), forwardWS[i].normalize(), 
                            wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei), 
                            wheel.sideImpulse *= 1;
                        }
                    }
                    this.sliding = !1;
                    for (var i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i], groundObject = wheel.raycastResult.body, rollingFriction = 0;
                        if (wheel.slipInfo = 1, groundObject) {
                            var maxImpulse = wheel.brake ? wheel.brake : 0;
                            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse), 
                            rollingFriction += wheel.engineForce * timeStep;
                            var factor = maxImpulse / rollingFriction;
                            wheel.slipInfo *= factor;
                        }
                        if (wheel.forwardImpulse = 0, wheel.skidInfo = 1, groundObject) {
                            wheel.skidInfo = 1;
                            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip, maximpSide = maximp, maximpSquared = maximp * maximpSide;
                            wheel.forwardImpulse = rollingFriction;
                            var x = .5 * wheel.forwardImpulse, y = 1 * wheel.sideImpulse, impulseSquared = x * x + y * y;
                            if (wheel.sliding = !1, maximpSquared < impulseSquared) {
                                this.sliding = !0, wheel.sliding = !0;
                                var factor = maximp / Math.sqrt(impulseSquared);
                                wheel.skidInfo *= factor;
                            }
                        }
                    }
                    if (this.sliding) for (var i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i];
                        0 !== wheel.sideImpulse && wheel.skidInfo < 1 && (wheel.forwardImpulse *= wheel.skidInfo, 
                        wheel.sideImpulse *= wheel.skidInfo);
                    }
                    for (var i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i], rel_pos = new Vec3();
                        if (rel_pos.copy(wheel.raycastResult.hitPointWorld), 0 !== wheel.forwardImpulse) {
                            var impulse = new Vec3();
                            forwardWS[i].scale(wheel.forwardImpulse, impulse), chassisBody.applyImpulse(impulse, rel_pos);
                        }
                        if (0 !== wheel.sideImpulse) {
                            var groundObject = wheel.raycastResult.body, rel_pos2 = new Vec3();
                            rel_pos2.copy(wheel.raycastResult.hitPointWorld);
                            var sideImp = new Vec3();
                            axle[i].scale(wheel.sideImpulse, sideImp), chassisBody.pointToLocalFrame(rel_pos, rel_pos), 
                            rel_pos["xyz"[this.indexUpAxis]] *= wheel.rollInfluence, chassisBody.pointToWorldFrame(rel_pos, rel_pos), 
                            chassisBody.applyImpulse(sideImp, rel_pos), sideImp.scale(-1, sideImp), groundObject.applyImpulse(sideImp, rel_pos2);
                        }
                    }
                };
                var calcRollingFriction_vel1 = new Vec3(), calcRollingFriction_vel2 = new Vec3(), calcRollingFriction_vel = new Vec3();
                function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
                    var j1 = 0, contactPosWorld = frictionPosWorld, vel1 = calcRollingFriction_vel1, vel2 = calcRollingFriction_vel2, vel = calcRollingFriction_vel;
                    body0.getVelocityAtWorldPoint(contactPosWorld, vel1), body1.getVelocityAtWorldPoint(contactPosWorld, vel2), 
                    vel1.vsub(vel2, vel);
                    var vrel = frictionDirectionWorld.dot(vel), denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld), denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld), jacDiagABInv = 1 / (denom0 + denom1);
                    return maxImpulse < (j1 = -vrel * jacDiagABInv) && (j1 = maxImpulse), j1 < -maxImpulse && (j1 = -maxImpulse), 
                    j1;
                }
                var computeImpulseDenominator_r0 = new Vec3(), computeImpulseDenominator_c0 = new Vec3(), computeImpulseDenominator_vec = new Vec3(), computeImpulseDenominator_m = new Vec3();
                function computeImpulseDenominator(body, pos, normal) {
                    var r0 = computeImpulseDenominator_r0, c0 = computeImpulseDenominator_c0, vec = computeImpulseDenominator_vec, m = computeImpulseDenominator_m;
                    return pos.vsub(body.position, r0), r0.cross(normal, c0), body.invInertiaWorld.vmult(c0, m), 
                    m.cross(r0, vec), body.invMass + normal.dot(vec);
                }
                var resolveSingleBilateral_vel1 = new Vec3(), resolveSingleBilateral_vel2 = new Vec3(), resolveSingleBilateral_vel = new Vec3();
                function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse) {
                    var normalLenSqr = normal.norm2();
                    if (1.1 < normalLenSqr) return 0;
                    var vel1 = resolveSingleBilateral_vel1, vel2 = resolveSingleBilateral_vel2, vel = resolveSingleBilateral_vel;
                    body1.getVelocityAtWorldPoint(pos1, vel1), body2.getVelocityAtWorldPoint(pos2, vel2), 
                    vel1.vsub(vel2, vel);
                    var rel_vel = normal.dot(vel), massTerm = 1 / (body1.invMass + body2.invMass), impulse = -.2 * rel_vel * massTerm;
                    return impulse;
                }
            }, {
                "../collision/Ray": 9,
                "../collision/RaycastResult": 10,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/WheelInfo": 36,
                "./Body": 31
            } ],
            33: [ function(_dereq_, module, exports) {
                var Body = _dereq_("./Body"), Sphere = _dereq_("../shapes/Sphere"), Box = _dereq_("../shapes/Box"), Vec3 = _dereq_("../math/Vec3"), HingeConstraint = _dereq_("../constraints/HingeConstraint");
                function RigidVehicle(options) {
                    if (this.wheelBodies = [], this.coordinateSystem = void 0 === options.coordinateSystem ? new Vec3(1, 2, 3) : options.coordinateSystem.clone(), 
                    this.chassisBody = options.chassisBody, !this.chassisBody) {
                        var chassisShape = new Box(new Vec3(5, 2, .5));
                        this.chassisBody = new Body(1, chassisShape);
                    }
                    this.constraints = [], this.wheelAxes = [], this.wheelForces = [];
                }
                (module.exports = RigidVehicle).prototype.addWheel = function(options) {
                    var wheelBody = (options = options || {}).body;
                    wheelBody || (wheelBody = new Body(1, new Sphere(1.2))), this.wheelBodies.push(wheelBody), 
                    this.wheelForces.push(0), new Vec3();
                    var position = void 0 !== options.position ? options.position.clone() : new Vec3(), worldPosition = new Vec3();
                    this.chassisBody.pointToWorldFrame(position, worldPosition), wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);
                    var axis = void 0 !== options.axis ? options.axis.clone() : new Vec3(0, 1, 0);
                    this.wheelAxes.push(axis);
                    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
                        pivotA: position,
                        axisA: axis,
                        pivotB: Vec3.ZERO,
                        axisB: axis,
                        collideConnected: !1
                    });
                    return this.constraints.push(hingeConstraint), this.wheelBodies.length - 1;
                }, RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex) {
                    var axis = this.wheelAxes[wheelIndex], c = Math.cos(value), s = Math.sin(value), x = axis.x, y = axis.y;
                    this.constraints[wheelIndex].axisA.set(c * x - s * y, s * x + c * y, 0);
                }, RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex) {
                    var hingeConstraint = this.constraints[wheelIndex];
                    hingeConstraint.enableMotor(), hingeConstraint.motorTargetVelocity = value;
                }, RigidVehicle.prototype.disableMotor = function(wheelIndex) {
                    var hingeConstraint = this.constraints[wheelIndex];
                    hingeConstraint.disableMotor();
                };
                var torque = new Vec3();
                RigidVehicle.prototype.setWheelForce = function(value, wheelIndex) {
                    this.wheelForces[wheelIndex] = value;
                }, RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex) {
                    var axis = this.wheelAxes[wheelIndex], wheelBody = this.wheelBodies[wheelIndex], bodyTorque = wheelBody.torque;
                    axis.scale(value, torque), wheelBody.vectorToWorldFrame(torque, torque), bodyTorque.vadd(torque, bodyTorque);
                }, RigidVehicle.prototype.addToWorld = function(world) {
                    for (var constraints = this.constraints, bodies = this.wheelBodies.concat([ this.chassisBody ]), i = 0; i < bodies.length; i++) world.add(bodies[i]);
                    for (var i = 0; i < constraints.length; i++) world.addConstraint(constraints[i]);
                    world.addEventListener("preStep", this._update.bind(this));
                }, RigidVehicle.prototype._update = function() {
                    for (var wheelForces = this.wheelForces, i = 0; i < wheelForces.length; i++) this.applyWheelForce(wheelForces[i], i);
                }, RigidVehicle.prototype.removeFromWorld = function(world) {
                    for (var constraints = this.constraints, bodies = this.wheelBodies.concat([ this.chassisBody ]), i = 0; i < bodies.length; i++) world.remove(bodies[i]);
                    for (var i = 0; i < constraints.length; i++) world.removeConstraint(constraints[i]);
                };
                var worldAxis = new Vec3();
                RigidVehicle.prototype.getWheelSpeed = function(wheelIndex) {
                    var axis = this.wheelAxes[wheelIndex], wheelBody = this.wheelBodies[wheelIndex], w = wheelBody.angularVelocity;
                    return this.chassisBody.vectorToWorldFrame(axis, worldAxis), w.dot(worldAxis);
                };
            }, {
                "../constraints/HingeConstraint": 15,
                "../math/Vec3": 30,
                "../shapes/Box": 37,
                "../shapes/Sphere": 44,
                "./Body": 31
            } ],
            34: [ function(_dereq_, module, exports) {
                module.exports = SPHSystem, _dereq_("../shapes/Shape");
                var Vec3 = _dereq_("../math/Vec3");
                function SPHSystem() {
                    this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, 
                    this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], 
                    this.neighbors = [];
                }
                _dereq_("../math/Quaternion"), _dereq_("../shapes/Particle"), _dereq_("../objects/Body"), 
                _dereq_("../material/Material"), SPHSystem.prototype.add = function(particle) {
                    this.particles.push(particle), this.neighbors.length < this.particles.length && this.neighbors.push([]);
                }, SPHSystem.prototype.remove = function(particle) {
                    var idx = this.particles.indexOf(particle);
                    -1 !== idx && (this.particles.splice(idx, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
                };
                var SPHSystem_getNeighbors_dist = new Vec3();
                SPHSystem.prototype.getNeighbors = function(particle, neighbors) {
                    for (var N = this.particles.length, id = particle.id, R2 = this.smoothingRadius * this.smoothingRadius, dist = SPHSystem_getNeighbors_dist, i = 0; i !== N; i++) {
                        var p = this.particles[i];
                        p.position.vsub(particle.position, dist), id !== p.id && dist.norm2() < R2 && neighbors.push(p);
                    }
                };
                var SPHSystem_update_dist = new Vec3(), SPHSystem_update_a_pressure = new Vec3(), SPHSystem_update_a_visc = new Vec3(), SPHSystem_update_gradW = new Vec3(), SPHSystem_update_r_vec = new Vec3(), SPHSystem_update_u = new Vec3();
                SPHSystem.prototype.update = function() {
                    for (var N = this.particles.length, dist = SPHSystem_update_dist, cs = this.speedOfSound, eps = this.eps, i = 0; i !== N; i++) {
                        var p = this.particles[i], neighbors = this.neighbors[i];
                        neighbors.length = 0, this.getNeighbors(p, neighbors), neighbors.push(this.particles[i]);
                        for (var numNeighbors = neighbors.length, sum = 0, j = 0; j !== numNeighbors; j++) {
                            p.position.vsub(neighbors[j].position, dist);
                            var len = dist.norm(), weight = this.w(len);
                            sum += neighbors[j].mass * weight;
                        }
                        this.densities[i] = sum, this.pressures[i] = cs * cs * (this.densities[i] - this.density);
                    }
                    for (var a_pressure = SPHSystem_update_a_pressure, a_visc = SPHSystem_update_a_visc, gradW = SPHSystem_update_gradW, r_vec = SPHSystem_update_r_vec, u = SPHSystem_update_u, i = 0; i !== N; i++) {
                        var Pij, nabla, particle = this.particles[i];
                        a_pressure.set(0, 0, 0), a_visc.set(0, 0, 0);
                        for (var neighbors = this.neighbors[i], numNeighbors = neighbors.length, j = 0; j !== numNeighbors; j++) {
                            var neighbor = neighbors[j];
                            particle.position.vsub(neighbor.position, r_vec);
                            var r = r_vec.norm();
                            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps)), 
                            this.gradw(r_vec, gradW), gradW.mult(Pij, gradW), a_pressure.vadd(gradW, a_pressure), 
                            neighbor.velocity.vsub(particle.velocity, u), u.mult(1 / (1e-4 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u), 
                            nabla = this.nablaw(r), u.mult(nabla, u), a_visc.vadd(u, a_visc);
                        }
                        a_visc.mult(particle.mass, a_visc), a_pressure.mult(particle.mass, a_pressure), 
                        particle.force.vadd(a_visc, particle.force), particle.force.vadd(a_pressure, particle.force);
                    }
                }, SPHSystem.prototype.w = function(r) {
                    var h = this.smoothingRadius;
                    return 315 / (64 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 3);
                }, SPHSystem.prototype.gradw = function(rVec, resultVec) {
                    var r = rVec.norm(), h = this.smoothingRadius;
                    rVec.mult(945 / (32 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 2), resultVec);
                }, SPHSystem.prototype.nablaw = function(r) {
                    var h = this.smoothingRadius, nabla = 945 / (32 * Math.PI * Math.pow(h, 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
                    return nabla;
                };
            }, {
                "../material/Material": 25,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "../shapes/Particle": 41,
                "../shapes/Shape": 43
            } ],
            35: [ function(_dereq_, module, exports) {
                var Vec3 = _dereq_("../math/Vec3");
                function Spring(bodyA, bodyB, options) {
                    options = options || {}, this.restLength = "number" == typeof options.restLength ? options.restLength : 1, 
                    this.stiffness = options.stiffness || 100, this.damping = options.damping || 1, 
                    this.bodyA = bodyA, this.bodyB = bodyB, this.localAnchorA = new Vec3(), this.localAnchorB = new Vec3(), 
                    options.localAnchorA && this.localAnchorA.copy(options.localAnchorA), options.localAnchorB && this.localAnchorB.copy(options.localAnchorB), 
                    options.worldAnchorA && this.setWorldAnchorA(options.worldAnchorA), options.worldAnchorB && this.setWorldAnchorB(options.worldAnchorB);
                }
                (module.exports = Spring).prototype.setWorldAnchorA = function(worldAnchorA) {
                    this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
                }, Spring.prototype.setWorldAnchorB = function(worldAnchorB) {
                    this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
                }, Spring.prototype.getWorldAnchorA = function(result) {
                    this.bodyA.pointToWorldFrame(this.localAnchorA, result);
                }, Spring.prototype.getWorldAnchorB = function(result) {
                    this.bodyB.pointToWorldFrame(this.localAnchorB, result);
                };
                var applyForce_r = new Vec3(), applyForce_r_unit = new Vec3(), applyForce_u = new Vec3(), applyForce_f = new Vec3(), applyForce_worldAnchorA = new Vec3(), applyForce_worldAnchorB = new Vec3(), applyForce_ri = new Vec3(), applyForce_rj = new Vec3(), applyForce_ri_x_f = new Vec3(), applyForce_rj_x_f = new Vec3(), applyForce_tmp = new Vec3();
                Spring.prototype.applyForce = function() {
                    var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp, worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj, ri_x_f = applyForce_ri_x_f, rj_x_f = applyForce_rj_x_f;
                    this.getWorldAnchorA(worldAnchorA), this.getWorldAnchorB(worldAnchorB), worldAnchorA.vsub(bodyA.position, ri), 
                    worldAnchorB.vsub(bodyB.position, rj), worldAnchorB.vsub(worldAnchorA, r);
                    var rlen = r.norm();
                    r_unit.copy(r), r_unit.normalize(), bodyB.velocity.vsub(bodyA.velocity, u), bodyB.angularVelocity.cross(rj, tmp), 
                    u.vadd(tmp, u), bodyA.angularVelocity.cross(ri, tmp), u.vsub(tmp, u), r_unit.mult(-k * (rlen - l) - d * u.dot(r_unit), f), 
                    bodyA.force.vsub(f, bodyA.force), bodyB.force.vadd(f, bodyB.force), ri.cross(f, ri_x_f), 
                    rj.cross(f, rj_x_f), bodyA.torque.vsub(ri_x_f, bodyA.torque), bodyB.torque.vadd(rj_x_f, bodyB.torque);
                };
            }, {
                "../math/Vec3": 30
            } ],
            36: [ function(_dereq_, module, exports) {
                var Vec3 = _dereq_("../math/Vec3"), Transform = _dereq_("../math/Transform"), RaycastResult = _dereq_("../collision/RaycastResult"), Utils = _dereq_("../utils/Utils");
                function WheelInfo(options) {
                    options = Utils.defaults(options, {
                        chassisConnectionPointLocal: new Vec3(),
                        chassisConnectionPointWorld: new Vec3(),
                        directionLocal: new Vec3(),
                        directionWorld: new Vec3(),
                        axleLocal: new Vec3(),
                        axleWorld: new Vec3(),
                        suspensionRestLength: 1,
                        suspensionMaxLength: 2,
                        radius: 1,
                        suspensionStiffness: 100,
                        dampingCompression: 10,
                        dampingRelaxation: 10,
                        frictionSlip: 1e4,
                        steering: 0,
                        rotation: 0,
                        deltaRotation: 0,
                        rollInfluence: .01,
                        maxSuspensionForce: Number.MAX_VALUE,
                        isFrontWheel: !0,
                        clippedInvContactDotSuspension: 1,
                        suspensionRelativeVelocity: 0,
                        suspensionForce: 0,
                        skidInfo: 0,
                        suspensionLength: 0,
                        maxSuspensionTravel: 1,
                        useCustomSlidingRotationalSpeed: !1,
                        customSlidingRotationalSpeed: -.1
                    }), this.maxSuspensionTravel = options.maxSuspensionTravel, this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed, 
                    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed, 
                    this.sliding = !1, this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone(), 
                    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone(), 
                    this.directionLocal = options.directionLocal.clone(), this.directionWorld = options.directionWorld.clone(), 
                    this.axleLocal = options.axleLocal.clone(), this.axleWorld = options.axleWorld.clone(), 
                    this.suspensionRestLength = options.suspensionRestLength, this.suspensionMaxLength = options.suspensionMaxLength, 
                    this.radius = options.radius, this.suspensionStiffness = options.suspensionStiffness, 
                    this.dampingCompression = options.dampingCompression, this.dampingRelaxation = options.dampingRelaxation, 
                    this.frictionSlip = options.frictionSlip, this.steering = 0, this.rotation = 0, 
                    this.deltaRotation = 0, this.rollInfluence = options.rollInfluence, this.maxSuspensionForce = options.maxSuspensionForce, 
                    this.engineForce = 0, this.brake = 0, this.isFrontWheel = options.isFrontWheel, 
                    this.clippedInvContactDotSuspension = 1, this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, 
                    this.skidInfo = 0, this.suspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, 
                    this.raycastResult = new RaycastResult(), this.worldTransform = new Transform(), 
                    this.isInContact = !1;
                }
                module.exports = WheelInfo;
                var chassis_velocity_at_contactPoint = new Vec3(), relpos = new Vec3(), chassis_velocity_at_contactPoint = new Vec3();
                WheelInfo.prototype.updateWheel = function(chassis) {
                    var raycastResult = this.raycastResult;
                    if (this.isInContact) {
                        var project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
                        raycastResult.hitPointWorld.vsub(chassis.position, relpos), chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
                        var projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
                        if (-.1 <= project) this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10; else {
                            var inv = -1 / project;
                            this.suspensionRelativeVelocity = projVel * inv, this.clippedInvContactDotSuspension = inv;
                        }
                    } else raycastResult.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, 
                    raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
                };
            }, {
                "../collision/RaycastResult": 10,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../utils/Utils": 53
            } ],
            37: [ function(_dereq_, module, exports) {
                module.exports = Box;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3"), ConvexPolyhedron = _dereq_("./ConvexPolyhedron");
                function Box(halfExtents) {
                    Shape.call(this), this.type = Shape.types.BOX, this.halfExtents = halfExtents, this.convexPolyhedronRepresentation = null, 
                    this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius();
                }
                ((Box.prototype = new Shape()).constructor = Box).prototype.updateConvexPolyhedronRepresentation = function() {
                    var sx = this.halfExtents.x, sy = this.halfExtents.y, sz = this.halfExtents.z, V = Vec3, vertices = [ new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz) ], h = (new V(0, 0, 1), 
                    new V(0, 1, 0), new V(1, 0, 0), new ConvexPolyhedron(vertices, [ [ 3, 2, 1, 0 ], [ 4, 5, 6, 7 ], [ 5, 4, 0, 1 ], [ 2, 3, 7, 6 ], [ 0, 4, 7, 3 ], [ 1, 2, 6, 5 ] ]));
                    (this.convexPolyhedronRepresentation = h).material = this.material;
                }, Box.prototype.calculateLocalInertia = function(mass, target) {
                    return target = target || new Vec3(), Box.calculateInertia(this.halfExtents, mass, target), 
                    target;
                }, Box.calculateInertia = function(halfExtents, mass, target) {
                    var e = halfExtents;
                    target.x = 1 / 12 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z), target.y = 1 / 12 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z), 
                    target.z = 1 / 12 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
                }, Box.prototype.getSideNormals = function(sixTargetVectors, quat) {
                    var sides = sixTargetVectors, ex = this.halfExtents;
                    if (sides[0].set(ex.x, 0, 0), sides[1].set(0, ex.y, 0), sides[2].set(0, 0, ex.z), 
                    sides[3].set(-ex.x, 0, 0), sides[4].set(0, -ex.y, 0), sides[5].set(0, 0, -ex.z), 
                    void 0 !== quat) for (var i = 0; i !== sides.length; i++) quat.vmult(sides[i], sides[i]);
                    return sides;
                }, Box.prototype.volume = function() {
                    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
                }, Box.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = this.halfExtents.norm();
                };
                var worldCornerTempPos = new Vec3();
                new Vec3(), Box.prototype.forEachWorldCorner = function(pos, quat, callback) {
                    for (var e = this.halfExtents, corners = [ [ e.x, e.y, e.z ], [ -e.x, e.y, e.z ], [ -e.x, -e.y, e.z ], [ -e.x, -e.y, -e.z ], [ e.x, -e.y, -e.z ], [ e.x, e.y, -e.z ], [ -e.x, e.y, -e.z ], [ e.x, -e.y, e.z ] ], i = 0; i < corners.length; i++) worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]), 
                    quat.vmult(worldCornerTempPos, worldCornerTempPos), pos.vadd(worldCornerTempPos, worldCornerTempPos), 
                    callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
                };
                var worldCornersTemp = [ new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3() ];
                Box.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    var e = this.halfExtents;
                    worldCornersTemp[0].set(e.x, e.y, e.z), worldCornersTemp[1].set(-e.x, e.y, e.z), 
                    worldCornersTemp[2].set(-e.x, -e.y, e.z), worldCornersTemp[3].set(-e.x, -e.y, -e.z), 
                    worldCornersTemp[4].set(e.x, -e.y, -e.z), worldCornersTemp[5].set(e.x, e.y, -e.z), 
                    worldCornersTemp[6].set(-e.x, e.y, -e.z), worldCornersTemp[7].set(e.x, -e.y, e.z);
                    var wc = worldCornersTemp[0];
                    quat.vmult(wc, wc), pos.vadd(wc, wc), max.copy(wc), min.copy(wc);
                    for (var i = 1; i < 8; i++) {
                        var wc = worldCornersTemp[i];
                        quat.vmult(wc, wc), pos.vadd(wc, wc);
                        var x = wc.x, y = wc.y, z = wc.z;
                        x > max.x && (max.x = x), y > max.y && (max.y = y), z > max.z && (max.z = z), x < min.x && (min.x = x), 
                        y < min.y && (min.y = y), z < min.z && (min.z = z);
                    }
                };
            }, {
                "../math/Vec3": 30,
                "./ConvexPolyhedron": 38,
                "./Shape": 43
            } ],
            38: [ function(_dereq_, module, exports) {
                module.exports = ConvexPolyhedron;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3"), Transform = (_dereq_("../math/Quaternion"), 
                _dereq_("../math/Transform"));
                function ConvexPolyhedron(points, faces, uniqueAxes) {
                    Shape.call(this), this.type = Shape.types.CONVEXPOLYHEDRON, this.vertices = points || [], 
                    this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.faces = faces || [], 
                    this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, 
                    this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null, 
                    this.computeEdges(), this.updateBoundingSphereRadius();
                }
                (ConvexPolyhedron.prototype = new Shape()).constructor = ConvexPolyhedron;
                var computeEdges_tmpEdge = new Vec3();
                ConvexPolyhedron.prototype.computeEdges = function() {
                    var faces = this.faces, vertices = this.vertices, edges = (vertices.length, this.uniqueEdges);
                    edges.length = 0;
                    for (var edge = computeEdges_tmpEdge, i = 0; i !== faces.length; i++) for (var face = faces[i], numVertices = face.length, j = 0; j !== numVertices; j++) {
                        var k = (j + 1) % numVertices;
                        vertices[face[j]].vsub(vertices[face[k]], edge), edge.normalize();
                        for (var found = !1, p = 0; p !== edges.length; p++) if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
                            found = !0;
                            break;
                        }
                        found || edges.push(edge.clone());
                    }
                }, ConvexPolyhedron.prototype.computeNormals = function() {
                    this.faceNormals.length = this.faces.length;
                    for (var i = 0; i < this.faces.length; i++) {
                        for (var j = 0; j < this.faces[i].length; j++) if (!this.vertices[this.faces[i][j]]) throw new Error("Vertex " + this.faces[i][j] + " not found!");
                        var n = this.faceNormals[i] || new Vec3();
                        this.getFaceNormal(i, n), n.negate(n), this.faceNormals[i] = n;
                        var vertex = this.vertices[this.faces[i][0]];
                        if (n.dot(vertex) < 0) {
                            console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
                            for (var j = 0; j < this.faces[i].length; j++) console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
                        }
                    }
                };
                var cb = new Vec3(), ab = new Vec3();
                ConvexPolyhedron.computeNormal = function(va, vb, vc, target) {
                    vb.vsub(va, ab), vc.vsub(vb, cb), cb.cross(ab, target), target.isZero() || target.normalize();
                }, ConvexPolyhedron.prototype.getFaceNormal = function(i, target) {
                    var f = this.faces[i], va = this.vertices[f[0]], vb = this.vertices[f[1]], vc = this.vertices[f[2]];
                    return ConvexPolyhedron.computeNormal(va, vb, vc, target);
                };
                var cah_WorldNormal = new Vec3();
                ConvexPolyhedron.prototype.clipAgainstHull = function(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
                    for (var WorldNormal = cah_WorldNormal, closestFaceB = -1, dmax = -Number.MAX_VALUE, face = 0; face < hullB.faces.length; face++) {
                        WorldNormal.copy(hullB.faceNormals[face]), quatB.vmult(WorldNormal, WorldNormal);
                        var d = WorldNormal.dot(separatingNormal);
                        dmax < d && (dmax = d, closestFaceB = face);
                    }
                    for (var worldVertsB1 = [], polyB = hullB.faces[closestFaceB], numVertices = polyB.length, e0 = 0; e0 < numVertices; e0++) {
                        var b = hullB.vertices[polyB[e0]], worldb = new Vec3();
                        worldb.copy(b), quatB.vmult(worldb, worldb), posB.vadd(worldb, worldb), worldVertsB1.push(worldb);
                    }
                    0 <= closestFaceB && this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
                };
                var fsa_faceANormalWS3 = new Vec3(), fsa_Worldnormal1 = new Vec3(), fsa_deltaC = new Vec3(), fsa_worldEdge0 = new Vec3(), fsa_worldEdge1 = new Vec3(), fsa_Cross = new Vec3();
                ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
                    var faceANormalWS3 = fsa_faceANormalWS3, Worldnormal1 = fsa_Worldnormal1, deltaC = fsa_deltaC, worldEdge0 = fsa_worldEdge0, worldEdge1 = fsa_worldEdge1, Cross = fsa_Cross, dmin = Number.MAX_VALUE;
                    if (this.uniqueAxes) for (var i = 0; i !== this.uniqueAxes.length; i++) {
                        quatA.vmult(this.uniqueAxes[i], faceANormalWS3);
                        var d = this.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                        if (!1 === d) return !1;
                        d < dmin && (dmin = d, target.copy(faceANormalWS3));
                    } else for (var numFacesA = faceListA ? faceListA.length : this.faces.length, i = 0; i < numFacesA; i++) {
                        var fi = faceListA ? faceListA[i] : i;
                        faceANormalWS3.copy(this.faceNormals[fi]), quatA.vmult(faceANormalWS3, faceANormalWS3);
                        var d = this.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                        if (!1 === d) return !1;
                        d < dmin && (dmin = d, target.copy(faceANormalWS3));
                    }
                    if (hullB.uniqueAxes) for (var i = 0; i !== hullB.uniqueAxes.length; i++) {
                        quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
                        var d = this.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                        if (!1 === d) return !1;
                        d < dmin && (dmin = d, target.copy(Worldnormal1));
                    } else for (var numFacesB = faceListB ? faceListB.length : hullB.faces.length, i = 0; i < numFacesB; i++) {
                        var fi = faceListB ? faceListB[i] : i;
                        Worldnormal1.copy(hullB.faceNormals[fi]), quatB.vmult(Worldnormal1, Worldnormal1);
                        var d = this.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                        if (!1 === d) return !1;
                        d < dmin && (dmin = d, target.copy(Worldnormal1));
                    }
                    for (var e0 = 0; e0 !== this.uniqueEdges.length; e0++) {
                        quatA.vmult(this.uniqueEdges[e0], worldEdge0);
                        for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) if (quatB.vmult(hullB.uniqueEdges[e1], worldEdge1), 
                        worldEdge0.cross(worldEdge1, Cross), !Cross.almostZero()) {
                            Cross.normalize();
                            var dist = this.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                            if (!1 === dist) return !1;
                            dist < dmin && (dmin = dist, target.copy(Cross));
                        }
                    }
                    return posB.vsub(posA, deltaC), 0 < deltaC.dot(target) && target.negate(target), 
                    !0;
                };
                var maxminA = [], maxminB = [];
                ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB) {
                    ConvexPolyhedron.project(this, axis, posA, quatA, maxminA), ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
                    var maxA = maxminA[0], minA = maxminA[1], maxB = maxminB[0], minB = maxminB[1];
                    if (maxA < minB || maxB < minA) return !1;
                    var d0 = maxA - minB, d1 = maxB - minA, depth = d0 < d1 ? d0 : d1;
                    return depth;
                };
                var cli_aabbmin = new Vec3(), cli_aabbmax = new Vec3();
                ConvexPolyhedron.prototype.calculateLocalInertia = function(mass, target) {
                    this.computeLocalAABB(cli_aabbmin, cli_aabbmax);
                    var x = cli_aabbmax.x - cli_aabbmin.x, y = cli_aabbmax.y - cli_aabbmin.y, z = cli_aabbmax.z - cli_aabbmin.z;
                    target.x = 1 / 12 * mass * (2 * y * 2 * y + 2 * z * 2 * z), target.y = 1 / 12 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 
                    target.z = 1 / 12 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
                }, ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i) {
                    var f = this.faces[face_i], n = this.faceNormals[face_i], v = this.vertices[f[0]], c = -n.dot(v);
                    return c;
                };
                var cfah_faceANormalWS = new Vec3(), cfah_edge0 = new Vec3(), cfah_WorldEdge0 = new Vec3(), cfah_worldPlaneAnormal1 = new Vec3(), cfah_planeNormalWS1 = new Vec3(), cfah_worldA1 = new Vec3(), cfah_localPlaneNormal = new Vec3(), cfah_planeNormalWS = new Vec3();
                ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
                    for (var faceANormalWS = cfah_faceANormalWS, edge0 = cfah_edge0, WorldEdge0 = cfah_WorldEdge0, worldPlaneAnormal1 = cfah_worldPlaneAnormal1, planeNormalWS1 = cfah_planeNormalWS1, worldA1 = cfah_worldA1, localPlaneNormal = cfah_localPlaneNormal, planeNormalWS = cfah_planeNormalWS, pVtxIn = worldVertsB1, pVtxOut = [], closestFaceA = -1, dmin = Number.MAX_VALUE, face = 0; face < this.faces.length; face++) {
                        faceANormalWS.copy(this.faceNormals[face]), quatA.vmult(faceANormalWS, faceANormalWS);
                        var d = faceANormalWS.dot(separatingNormal);
                        d < dmin && (dmin = d, closestFaceA = face);
                    }
                    if (!(closestFaceA < 0)) {
                        var polyA = this.faces[closestFaceA];
                        polyA.connectedFaces = [];
                        for (var i = 0; i < this.faces.length; i++) for (var j = 0; j < this.faces[i].length; j++) -1 !== polyA.indexOf(this.faces[i][j]) && i !== closestFaceA && -1 === polyA.connectedFaces.indexOf(i) && polyA.connectedFaces.push(i);
                        pVtxIn.length;
                        for (var numVerticesA = polyA.length, e0 = 0; e0 < numVerticesA; e0++) {
                            var a = this.vertices[polyA[e0]], b = this.vertices[polyA[(e0 + 1) % numVerticesA]];
                            a.vsub(b, edge0), WorldEdge0.copy(edge0), quatA.vmult(WorldEdge0, WorldEdge0), posA.vadd(WorldEdge0, WorldEdge0), 
                            worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]), quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1), 
                            posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1), WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1), 
                            planeNormalWS1.negate(planeNormalWS1), worldA1.copy(a), quatA.vmult(worldA1, worldA1), 
                            posA.vadd(worldA1, worldA1), worldA1.dot(planeNormalWS1);
                            var otherFace = polyA.connectedFaces[e0];
                            localPlaneNormal.copy(this.faceNormals[otherFace]);
                            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);
                            planeNormalWS.copy(localPlaneNormal), quatA.vmult(planeNormalWS, planeNormalWS);
                            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
                            for (this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); pVtxIn.length; ) pVtxIn.shift();
                            for (;pVtxOut.length; ) pVtxIn.push(pVtxOut.shift());
                        }
                        localPlaneNormal.copy(this.faceNormals[closestFaceA]);
                        var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
                        planeNormalWS.copy(localPlaneNormal), quatA.vmult(planeNormalWS, planeNormalWS);
                        for (var planeEqWS = localPlaneEq - planeNormalWS.dot(posA), i = 0; i < pVtxIn.length; i++) {
                            var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS;
                            if (depth <= minDist && (console.log("clamped: depth=" + depth + " to minDist=" + minDist), 
                            depth = minDist), depth <= maxDist) {
                                var point = pVtxIn[i];
                                if (depth <= 0) {
                                    var p = {
                                        point: point,
                                        normal: planeNormalWS,
                                        depth: depth
                                    };
                                    result.push(p);
                                }
                            }
                        }
                    }
                }, ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices, outVertices, planeNormal, planeConstant) {
                    var n_dot_first, n_dot_last, numVerts = inVertices.length;
                    if (numVerts < 2) return outVertices;
                    var firstVertex = inVertices[inVertices.length - 1], lastVertex = inVertices[0];
                    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;
                    for (var vi = 0; vi < numVerts; vi++) {
                        if (lastVertex = inVertices[vi], n_dot_last = planeNormal.dot(lastVertex) + planeConstant, 
                        n_dot_first < 0) if (n_dot_last < 0) {
                            var newv = new Vec3();
                            newv.copy(lastVertex), outVertices.push(newv);
                        } else {
                            var newv = new Vec3();
                            firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv), outVertices.push(newv);
                        } else if (n_dot_last < 0) {
                            var newv = new Vec3();
                            firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv), outVertices.push(newv), 
                            outVertices.push(lastVertex);
                        }
                        firstVertex = lastVertex, n_dot_first = n_dot_last;
                    }
                    return outVertices;
                }, ConvexPolyhedron.prototype.computeWorldVertices = function(position, quat) {
                    for (var N = this.vertices.length; this.worldVertices.length < N; ) this.worldVertices.push(new Vec3());
                    for (var verts = this.vertices, worldVerts = this.worldVertices, i = 0; i !== N; i++) quat.vmult(verts[i], worldVerts[i]), 
                    position.vadd(worldVerts[i], worldVerts[i]);
                    this.worldVerticesNeedsUpdate = !1;
                }, new Vec3(), ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin, aabbmax) {
                    var n = this.vertices.length, vertices = this.vertices;
                    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (var i = 0; i < n; i++) {
                        var v = vertices[i];
                        v.x < aabbmin.x ? aabbmin.x = v.x : v.x > aabbmax.x && (aabbmax.x = v.x), v.y < aabbmin.y ? aabbmin.y = v.y : v.y > aabbmax.y && (aabbmax.y = v.y), 
                        v.z < aabbmin.z ? aabbmin.z = v.z : v.z > aabbmax.z && (aabbmax.z = v.z);
                    }
                }, ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat) {
                    for (var N = this.faceNormals.length; this.worldFaceNormals.length < N; ) this.worldFaceNormals.push(new Vec3());
                    for (var normals = this.faceNormals, worldNormals = this.worldFaceNormals, i = 0; i !== N; i++) quat.vmult(normals[i], worldNormals[i]);
                    this.worldFaceNormalsNeedsUpdate = !1;
                }, ConvexPolyhedron.prototype.updateBoundingSphereRadius = function() {
                    for (var max2 = 0, verts = this.vertices, i = 0, N = verts.length; i !== N; i++) {
                        var norm2 = verts[i].norm2();
                        max2 < norm2 && (max2 = norm2);
                    }
                    this.boundingSphereRadius = Math.sqrt(max2);
                };
                var tempWorldVertex = new Vec3();
                ConvexPolyhedron.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    for (var minx, miny, minz, maxx, maxy, maxz, n = this.vertices.length, verts = this.vertices, i = 0; i < n; i++) {
                        tempWorldVertex.copy(verts[i]), quat.vmult(tempWorldVertex, tempWorldVertex), pos.vadd(tempWorldVertex, tempWorldVertex);
                        var v = tempWorldVertex;
                        v.x < minx || void 0 === minx ? minx = v.x : (v.x > maxx || void 0 === maxx) && (maxx = v.x), 
                        v.y < miny || void 0 === miny ? miny = v.y : (v.y > maxy || void 0 === maxy) && (maxy = v.y), 
                        v.z < minz || void 0 === minz ? minz = v.z : (v.z > maxz || void 0 === maxz) && (maxz = v.z);
                    }
                    min.set(minx, miny, minz), max.set(maxx, maxy, maxz);
                }, ConvexPolyhedron.prototype.volume = function() {
                    return 4 * Math.PI * this.boundingSphereRadius / 3;
                }, ConvexPolyhedron.prototype.getAveragePointLocal = function(target) {
                    target = target || new Vec3();
                    for (var n = this.vertices.length, verts = this.vertices, i = 0; i < n; i++) target.vadd(verts[i], target);
                    return target.mult(1 / n, target), target;
                }, ConvexPolyhedron.prototype.transformAllPoints = function(offset, quat) {
                    var n = this.vertices.length, verts = this.vertices;
                    if (quat) {
                        for (var i = 0; i < n; i++) {
                            var v = verts[i];
                            quat.vmult(v, v);
                        }
                        for (var i = 0; i < this.faceNormals.length; i++) {
                            var v = this.faceNormals[i];
                            quat.vmult(v, v);
                        }
                    }
                    if (offset) for (var i = 0; i < n; i++) {
                        var v = verts[i];
                        v.vadd(offset, v);
                    }
                };
                var ConvexPolyhedron_pointIsInside = new Vec3(), ConvexPolyhedron_vToP = new Vec3(), ConvexPolyhedron_vToPointInside = new Vec3();
                ConvexPolyhedron.prototype.pointIsInside = function(p) {
                    var n = this.vertices.length, verts = this.vertices, faces = this.faces, normals = this.faceNormals, N = this.faces.length, pointInside = ConvexPolyhedron_pointIsInside;
                    this.getAveragePointLocal(pointInside);
                    for (var i = 0; i < N; i++) {
                        this.faces[i].length;
                        var n = normals[i], v = verts[faces[i][0]], vToP = ConvexPolyhedron_vToP;
                        p.vsub(v, vToP);
                        var r1 = n.dot(vToP), vToPointInside = ConvexPolyhedron_vToPointInside;
                        pointInside.vsub(v, vToPointInside);
                        var r2 = n.dot(vToPointInside);
                        if (r1 < 0 && 0 < r2 || 0 < r1 && r2 < 0) return !1;
                    }
                    return -1;
                }, new Vec3();
                var project_localAxis = new Vec3(), project_localOrigin = new Vec3();
                ConvexPolyhedron.project = function(hull, axis, pos, quat, result) {
                    var n = hull.vertices.length, localAxis = project_localAxis, max = 0, min = 0, localOrigin = project_localOrigin, vs = hull.vertices;
                    localOrigin.setZero(), Transform.vectorToLocalFrame(pos, quat, axis, localAxis), 
                    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
                    var add = localOrigin.dot(localAxis);
                    min = max = vs[0].dot(localAxis);
                    for (var i = 1; i < n; i++) {
                        var val = vs[i].dot(localAxis);
                        max < val && (max = val), val < min && (min = val);
                    }
                    if ((max -= add) < (min -= add)) {
                        var temp = min;
                        min = max, max = temp;
                    }
                    result[0] = max, result[1] = min;
                };
            }, {
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "./Shape": 43
            } ],
            39: [ function(_dereq_, module, exports) {
                module.exports = Cylinder;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3"), ConvexPolyhedron = (_dereq_("../math/Quaternion"), 
                _dereq_("./ConvexPolyhedron"));
                function Cylinder(radiusTop, radiusBottom, height, numSegments) {
                    var N = numSegments, verts = [], axes = [], faces = [], bottomface = [], topface = [], cos = Math.cos, sin = Math.sin;
                    verts.push(new Vec3(radiusBottom * cos(0), radiusBottom * sin(0), .5 * -height)), 
                    bottomface.push(0), verts.push(new Vec3(radiusTop * cos(0), radiusTop * sin(0), .5 * height)), 
                    topface.push(1);
                    for (var i = 0; i < N; i++) {
                        var theta = 2 * Math.PI / N * (i + 1), thetaN = 2 * Math.PI / N * (i + .5);
                        i < N - 1 ? (verts.push(new Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), .5 * -height)), 
                        bottomface.push(2 * i + 2), verts.push(new Vec3(radiusTop * cos(theta), radiusTop * sin(theta), .5 * height)), 
                        topface.push(2 * i + 3), faces.push([ 2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i ])) : faces.push([ 0, 1, 2 * i + 1, 2 * i ]), 
                        (N % 2 == 1 || i < N / 2) && axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
                    }
                    faces.push(topface), axes.push(new Vec3(0, 0, 1));
                    for (var temp = [], i = 0; i < bottomface.length; i++) temp.push(bottomface[bottomface.length - i - 1]);
                    faces.push(temp), this.type = Shape.types.CONVEXPOLYHEDRON, ConvexPolyhedron.call(this, verts, faces, axes);
                }
                Cylinder.prototype = new ConvexPolyhedron();
            }, {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "./ConvexPolyhedron": 38,
                "./Shape": 43
            } ],
            40: [ function(_dereq_, module, exports) {
                var Shape = _dereq_("./Shape"), ConvexPolyhedron = _dereq_("./ConvexPolyhedron"), Vec3 = _dereq_("../math/Vec3"), Utils = _dereq_("../utils/Utils");
                function Heightfield(data, options) {
                    options = Utils.defaults(options, {
                        maxValue: null,
                        minValue: null,
                        elementSize: 1
                    }), this.data = data, this.maxValue = options.maxValue, this.minValue = options.minValue, 
                    this.elementSize = options.elementSize, null === options.minValue && this.updateMinValue(), 
                    null === options.maxValue && this.updateMaxValue(), this.cacheEnabled = !0, Shape.call(this), 
                    this.pillarConvex = new ConvexPolyhedron(), this.pillarOffset = new Vec3(), this.type = Shape.types.HEIGHTFIELD, 
                    this.updateBoundingSphereRadius(), this._cachedPillars = {};
                }
                ((module.exports = Heightfield).prototype = new Shape()).update = function() {
                    this._cachedPillars = {};
                }, Heightfield.prototype.updateMinValue = function() {
                    for (var data = this.data, minValue = data[0][0], i = 0; i !== data.length; i++) for (var j = 0; j !== data[i].length; j++) {
                        var v = data[i][j];
                        v < minValue && (minValue = v);
                    }
                    this.minValue = minValue;
                }, Heightfield.prototype.updateMaxValue = function() {
                    for (var data = this.data, maxValue = data[0][0], i = 0; i !== data.length; i++) for (var j = 0; j !== data[i].length; j++) {
                        var v = data[i][j];
                        maxValue < v && (maxValue = v);
                    }
                    this.maxValue = maxValue;
                }, Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value) {
                    var data = this.data;
                    data[xi][yi] = value, this.clearCachedConvexTrianglePillar(xi, yi, !1), 0 < xi && (this.clearCachedConvexTrianglePillar(xi - 1, yi, !0), 
                    this.clearCachedConvexTrianglePillar(xi - 1, yi, !1)), 0 < yi && (this.clearCachedConvexTrianglePillar(xi, yi - 1, !0), 
                    this.clearCachedConvexTrianglePillar(xi, yi - 1, !1)), 0 < yi && 0 < xi && this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, !0);
                }, Heightfield.prototype.getRectMinMax = function(iMinX, iMinY, iMaxX, iMaxY, result) {
                    result = result || [];
                    for (var data = this.data, max = this.minValue, i = iMinX; i <= iMaxX; i++) for (var j = iMinY; j <= iMaxY; j++) {
                        var height = data[i][j];
                        max < height && (max = height);
                    }
                    result[0] = this.minValue, result[1] = max;
                }, Heightfield.prototype.getIndexOfPosition = function(x, y, result, clamp) {
                    var w = this.elementSize, data = this.data, xi = Math.floor(x / w), yi = Math.floor(y / w);
                    return result[0] = xi, result[1] = yi, clamp && (xi < 0 && (xi = 0), yi < 0 && (yi = 0), 
                    xi >= data.length - 1 && (xi = data.length - 1), yi >= data[0].length - 1 && (yi = data[0].length - 1)), 
                    !(xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1);
                }, Heightfield.prototype.getHeightAt = function(x, y, edgeClamp) {
                    var idx = [];
                    this.getIndexOfPosition(x, y, idx, edgeClamp);
                    var minmax = [];
                    return this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax), (minmax[0] + minmax[1]) / 2;
                }, Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle) {
                    return xi + "_" + yi + "_" + (getUpperTriangle ? 1 : 0);
                }, Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle) {
                    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
                }, Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset) {
                    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
                        convex: convex,
                        offset: offset
                    };
                }, Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle) {
                    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
                }, Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle) {
                    var result = this.pillarConvex, offsetResult = this.pillarOffset;
                    if (this.cacheEnabled) {
                        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
                        if (data) return this.pillarConvex = data.convex, void (this.pillarOffset = data.offset);
                        result = new ConvexPolyhedron(), offsetResult = new Vec3(), this.pillarConvex = result, 
                        this.pillarOffset = offsetResult;
                    }
                    var data = this.data, elementSize = this.elementSize, faces = result.faces;
                    result.vertices.length = 6;
                    for (var i = 0; i < 6; i++) result.vertices[i] || (result.vertices[i] = new Vec3());
                    faces.length = 5;
                    for (var i = 0; i < 5; i++) faces[i] || (faces[i] = []);
                    var verts = result.vertices, h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;
                    faces[4][3] = getUpperTriangle ? (offsetResult.set((xi + .75) * elementSize, (yi + .75) * elementSize, h), 
                    verts[0].set(.25 * elementSize, .25 * elementSize, data[xi + 1][yi + 1] - h), verts[1].set(-.75 * elementSize, .25 * elementSize, data[xi][yi + 1] - h), 
                    verts[2].set(.25 * elementSize, -.75 * elementSize, data[xi + 1][yi] - h), verts[3].set(.25 * elementSize, .25 * elementSize, -h - 1), 
                    verts[4].set(-.75 * elementSize, .25 * elementSize, -h - 1), verts[5].set(.25 * elementSize, -.75 * elementSize, -h - 1), 
                    faces[0][0] = 0, faces[0][1] = 1, faces[0][2] = 2, faces[1][0] = 5, faces[1][1] = 4, 
                    faces[1][2] = 3, faces[2][0] = 2, faces[2][1] = 5, faces[2][2] = 3, faces[2][3] = 0, 
                    faces[3][0] = 3, faces[3][1] = 4, faces[3][2] = 1, faces[3][3] = 0, faces[4][0] = 1, 
                    faces[4][1] = 4, faces[4][2] = 5, 2) : (offsetResult.set((xi + .25) * elementSize, (yi + .25) * elementSize, h), 
                    verts[0].set(-.25 * elementSize, -.25 * elementSize, data[xi][yi] - h), verts[1].set(.75 * elementSize, -.25 * elementSize, data[xi + 1][yi] - h), 
                    verts[2].set(-.25 * elementSize, .75 * elementSize, data[xi][yi + 1] - h), verts[3].set(-.25 * elementSize, -.25 * elementSize, -h - 1), 
                    verts[4].set(.75 * elementSize, -.25 * elementSize, -h - 1), verts[5].set(-.25 * elementSize, .75 * elementSize, -h - 1), 
                    faces[0][0] = 0, faces[0][1] = 1, faces[0][2] = 2, faces[1][0] = 5, faces[1][1] = 4, 
                    faces[1][2] = 3, faces[2][0] = 0, faces[2][1] = 2, faces[2][2] = 5, faces[2][3] = 3, 
                    faces[3][0] = 1, faces[3][1] = 0, faces[3][2] = 3, faces[3][3] = 4, faces[4][0] = 4, 
                    faces[4][1] = 5, faces[4][2] = 2, 1), result.computeNormals(), result.computeEdges(), 
                    result.updateBoundingSphereRadius(), this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
                }, Heightfield.prototype.calculateLocalInertia = function(mass, target) {
                    return (target = target || new Vec3()).set(0, 0, 0), target;
                }, Heightfield.prototype.volume = function() {
                    return Number.MAX_VALUE;
                }, Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                }, Heightfield.prototype.updateBoundingSphereRadius = function() {
                    var data = this.data, s = this.elementSize;
                    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
                };
            }, {
                "../math/Vec3": 30,
                "../utils/Utils": 53,
                "./ConvexPolyhedron": 38,
                "./Shape": 43
            } ],
            41: [ function(_dereq_, module, exports) {
                module.exports = Particle;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3");
                function Particle() {
                    Shape.call(this), this.type = Shape.types.PARTICLE;
                }
                ((Particle.prototype = new Shape()).constructor = Particle).prototype.calculateLocalInertia = function(mass, target) {
                    return (target = target || new Vec3()).set(0, 0, 0), target;
                }, Particle.prototype.volume = function() {
                    return 0;
                }, Particle.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = 0;
                }, Particle.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    min.copy(pos), max.copy(pos);
                };
            }, {
                "../math/Vec3": 30,
                "./Shape": 43
            } ],
            42: [ function(_dereq_, module, exports) {
                module.exports = Plane;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3");
                function Plane() {
                    Shape.call(this), this.type = Shape.types.PLANE, this.worldNormal = new Vec3(), 
                    this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE;
                }
                ((Plane.prototype = new Shape()).constructor = Plane).prototype.computeWorldNormal = function(quat) {
                    var n = this.worldNormal;
                    n.set(0, 0, 1), quat.vmult(n, n), this.worldNormalNeedsUpdate = !1;
                }, Plane.prototype.calculateLocalInertia = function(mass, target) {
                    return target = target || new Vec3();
                }, Plane.prototype.volume = function() {
                    return Number.MAX_VALUE;
                };
                var tempNormal = new Vec3();
                Plane.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    tempNormal.set(0, 0, 1), quat.vmult(tempNormal, tempNormal);
                    var maxVal = Number.MAX_VALUE;
                    min.set(-maxVal, -maxVal, -maxVal), max.set(maxVal, maxVal, maxVal), 1 === tempNormal.x && (max.x = pos.x), 
                    1 === tempNormal.y && (max.y = pos.y), 1 === tempNormal.z && (max.z = pos.z), -1 === tempNormal.x && (min.x = pos.x), 
                    -1 === tempNormal.y && (min.y = pos.y), -1 === tempNormal.z && (min.z = pos.z);
                }, Plane.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = Number.MAX_VALUE;
                };
            }, {
                "../math/Vec3": 30,
                "./Shape": 43
            } ],
            43: [ function(_dereq_, module, exports) {
                module.exports = Shape;
                var Shape = _dereq_("./Shape");
                function Shape() {
                    this.id = Shape.idCounter++, this.type = 0, this.boundingSphereRadius = 0, this.collisionResponse = !0, 
                    this.material = null;
                }
                _dereq_("../math/Vec3"), _dereq_("../math/Quaternion"), _dereq_("../material/Material"), 
                (Shape.prototype.constructor = Shape).prototype.updateBoundingSphereRadius = function() {
                    throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
                }, Shape.prototype.volume = function() {
                    throw "volume() not implemented for shape type " + this.type;
                }, Shape.prototype.calculateLocalInertia = function(mass, target) {
                    throw "calculateLocalInertia() not implemented for shape type " + this.type;
                }, Shape.idCounter = 0, Shape.types = {
                    SPHERE: 1,
                    PLANE: 2,
                    BOX: 4,
                    COMPOUND: 8,
                    CONVEXPOLYHEDRON: 16,
                    HEIGHTFIELD: 32,
                    PARTICLE: 64,
                    CYLINDER: 128,
                    TRIMESH: 256
                };
            }, {
                "../material/Material": 25,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "./Shape": 43
            } ],
            44: [ function(_dereq_, module, exports) {
                module.exports = Sphere;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3");
                function Sphere(radius) {
                    if (Shape.call(this), this.radius = void 0 !== radius ? Number(radius) : 1, this.type = Shape.types.SPHERE, 
                    this.radius < 0) throw new Error("The sphere radius cannot be negative.");
                    this.updateBoundingSphereRadius();
                }
                ((Sphere.prototype = new Shape()).constructor = Sphere).prototype.calculateLocalInertia = function(mass, target) {
                    target = target || new Vec3();
                    var I = 2 * mass * this.radius * this.radius / 5;
                    return target.x = I, target.y = I, target.z = I, target;
                }, Sphere.prototype.volume = function() {
                    return 4 * Math.PI * this.radius / 3;
                }, Sphere.prototype.updateBoundingSphereRadius = function() {
                    this.boundingSphereRadius = this.radius;
                }, Sphere.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    for (var r = this.radius, axes = [ "x", "y", "z" ], i = 0; i < axes.length; i++) {
                        var ax = axes[i];
                        min[ax] = pos[ax] - r, max[ax] = pos[ax] + r;
                    }
                };
            }, {
                "../math/Vec3": 30,
                "./Shape": 43
            } ],
            45: [ function(_dereq_, module, exports) {
                module.exports = Trimesh;
                var Shape = _dereq_("./Shape"), Vec3 = _dereq_("../math/Vec3"), Transform = (_dereq_("../math/Quaternion"), 
                _dereq_("../math/Transform")), AABB = _dereq_("../collision/AABB"), Octree = _dereq_("../utils/Octree");
                function Trimesh(vertices, indices) {
                    Shape.call(this), this.type = Shape.types.TRIMESH, this.vertices = new Float32Array(vertices), 
                    this.indices = new Int16Array(indices), this.normals = new Float32Array(indices.length), 
                    this.aabb = new AABB(), this.edges = null, this.scale = new Vec3(1, 1, 1), this.tree = new Octree(), 
                    this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), 
                    this.updateTree();
                }
                (Trimesh.prototype = new Shape()).constructor = Trimesh;
                var computeNormals_n = new Vec3();
                Trimesh.prototype.updateTree = function() {
                    var tree = this.tree;
                    tree.reset(), tree.aabb.copy(this.aabb);
                    var scale = this.scale;
                    tree.aabb.lowerBound.x *= 1 / scale.x, tree.aabb.lowerBound.y *= 1 / scale.y, tree.aabb.lowerBound.z *= 1 / scale.z, 
                    tree.aabb.upperBound.x *= 1 / scale.x, tree.aabb.upperBound.y *= 1 / scale.y, tree.aabb.upperBound.z *= 1 / scale.z;
                    for (var triangleAABB = new AABB(), a = new Vec3(), b = new Vec3(), c = new Vec3(), points = [ a, b, c ], i = 0; i < this.indices.length / 3; i++) {
                        var i3 = 3 * i;
                        this._getUnscaledVertex(this.indices[i3], a), this._getUnscaledVertex(this.indices[i3 + 1], b), 
                        this._getUnscaledVertex(this.indices[i3 + 2], c), triangleAABB.setFromPoints(points), 
                        tree.insert(triangleAABB, i);
                    }
                    tree.removeEmptyNodes();
                };
                var unscaledAABB = new AABB();
                Trimesh.prototype.getTrianglesInAABB = function(aabb, result) {
                    unscaledAABB.copy(aabb);
                    var scale = this.scale, isx = scale.x, isy = scale.y, isz = scale.z, l = unscaledAABB.lowerBound, u = unscaledAABB.upperBound;
                    return l.x /= isx, l.y /= isy, l.z /= isz, u.x /= isx, u.y /= isy, u.z /= isz, this.tree.aabbQuery(unscaledAABB, result);
                }, Trimesh.prototype.setScale = function(scale) {
                    var wasUniform = this.scale.x === this.scale.y === this.scale.z, isUniform = scale.x === scale.y === scale.z;
                    wasUniform && isUniform || this.updateNormals(), this.scale.copy(scale), this.updateAABB(), 
                    this.updateBoundingSphereRadius();
                }, Trimesh.prototype.updateNormals = function() {
                    for (var n = computeNormals_n, normals = this.normals, i = 0; i < this.indices.length / 3; i++) {
                        var i3 = 3 * i, a = this.indices[i3], b = this.indices[i3 + 1], c = this.indices[i3 + 2];
                        this.getVertex(a, va), this.getVertex(b, vb), this.getVertex(c, vc), Trimesh.computeNormal(vb, va, vc, n), 
                        normals[i3] = n.x, normals[i3 + 1] = n.y, normals[i3 + 2] = n.z;
                    }
                }, Trimesh.prototype.updateEdges = function() {
                    for (var edges = {}, add = function(indexA, indexB) {
                        var key = a < b ? a + "_" + b : b + "_" + a;
                        edges[key] = !0;
                    }, i = 0; i < this.indices.length / 3; i++) {
                        var i3 = 3 * i, a = this.indices[i3], b = this.indices[i3 + 1];
                        this.indices[i3 + 2];
                        add(), add(), add();
                    }
                    var keys = Object.keys(edges);
                    this.edges = new Int16Array(2 * keys.length);
                    for (var i = 0; i < keys.length; i++) {
                        var indices = keys[i].split("_");
                        this.edges[2 * i] = parseInt(indices[0], 10), this.edges[2 * i + 1] = parseInt(indices[1], 10);
                    }
                }, Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore) {
                    var vertexIndex = this.edges[2 * edgeIndex + (firstOrSecond ? 1 : 0)];
                    this.getVertex(vertexIndex, vertexStore);
                };
                var getEdgeVector_va = new Vec3(), getEdgeVector_vb = new Vec3();
                Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore) {
                    var va = getEdgeVector_va, vb = getEdgeVector_vb;
                    this.getEdgeVertex(edgeIndex, 0, va), this.getEdgeVertex(edgeIndex, 1, vb), vb.vsub(va, vectorStore);
                };
                var cb = new Vec3(), ab = new Vec3();
                Trimesh.computeNormal = function(va, vb, vc, target) {
                    vb.vsub(va, ab), vc.vsub(vb, cb), cb.cross(ab, target), target.isZero() || target.normalize();
                };
                var va = new Vec3(), vb = new Vec3(), vc = new Vec3();
                Trimesh.prototype.getVertex = function(i, out) {
                    var scale = this.scale;
                    return this._getUnscaledVertex(i, out), out.x *= scale.x, out.y *= scale.y, out.z *= scale.z, 
                    out;
                }, Trimesh.prototype._getUnscaledVertex = function(i, out) {
                    var i3 = 3 * i, vertices = this.vertices;
                    return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                }, Trimesh.prototype.getWorldVertex = function(i, pos, quat, out) {
                    return this.getVertex(i, out), Transform.pointToWorldFrame(pos, quat, out, out), 
                    out;
                }, Trimesh.prototype.getTriangleVertices = function(i, a, b, c) {
                    var i3 = 3 * i;
                    this.getVertex(this.indices[i3], a), this.getVertex(this.indices[i3 + 1], b), this.getVertex(this.indices[i3 + 2], c);
                }, Trimesh.prototype.getNormal = function(i, target) {
                    var i3 = 3 * i;
                    return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
                };
                var cli_aabb = new AABB();
                Trimesh.prototype.calculateLocalInertia = function(mass, target) {
                    this.computeLocalAABB(cli_aabb);
                    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x, y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y, z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
                    return target.set(1 / 12 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1 / 12 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1 / 12 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
                };
                var computeLocalAABB_worldVert = new Vec3();
                Trimesh.prototype.computeLocalAABB = function(aabb) {
                    var l = aabb.lowerBound, u = aabb.upperBound, n = this.vertices.length, v = (this.vertices, 
                    computeLocalAABB_worldVert);
                    this.getVertex(0, v), l.copy(v), u.copy(v);
                    for (var i = 0; i !== n; i++) this.getVertex(i, v), v.x < l.x ? l.x = v.x : v.x > u.x && (u.x = v.x), 
                    v.y < l.y ? l.y = v.y : v.y > u.y && (u.y = v.y), v.z < l.z ? l.z = v.z : v.z > u.z && (u.z = v.z);
                }, Trimesh.prototype.updateAABB = function() {
                    this.computeLocalAABB(this.aabb);
                }, Trimesh.prototype.updateBoundingSphereRadius = function() {
                    for (var max2 = 0, vertices = this.vertices, v = new Vec3(), i = 0, N = vertices.length / 3; i !== N; i++) {
                        this.getVertex(i, v);
                        var norm2 = v.norm2();
                        max2 < norm2 && (max2 = norm2);
                    }
                    this.boundingSphereRadius = Math.sqrt(max2);
                }, new Vec3();
                var calculateWorldAABB_frame = new Transform(), calculateWorldAABB_aabb = new AABB();
                Trimesh.prototype.calculateWorldAABB = function(pos, quat, min, max) {
                    var frame = calculateWorldAABB_frame, result = calculateWorldAABB_aabb;
                    frame.position = pos, frame.quaternion = quat, this.aabb.toWorldFrame(frame, result), 
                    min.copy(result.lowerBound), max.copy(result.upperBound);
                }, Trimesh.prototype.volume = function() {
                    return 4 * Math.PI * this.boundingSphereRadius / 3;
                }, Trimesh.createTorus = function(radius, tube, radialSegments, tubularSegments, arc) {
                    radius = radius || 1, tube = tube || .5, radialSegments = radialSegments || 8, tubularSegments = tubularSegments || 6, 
                    arc = arc || 2 * Math.PI;
                    for (var vertices = [], indices = [], j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
                        var u = i / tubularSegments * arc, v = j / radialSegments * Math.PI * 2, x = (radius + tube * Math.cos(v)) * Math.cos(u), y = (radius + tube * Math.cos(v)) * Math.sin(u), z = tube * Math.sin(v);
                        vertices.push(x, y, z);
                    }
                    for (var j = 1; j <= radialSegments; j++) for (var i = 1; i <= tubularSegments; i++) {
                        var a = (tubularSegments + 1) * j + i - 1, b = (tubularSegments + 1) * (j - 1) + i - 1, c = (tubularSegments + 1) * (j - 1) + i, d = (tubularSegments + 1) * j + i;
                        indices.push(a, b, d), indices.push(b, c, d);
                    }
                    return new Trimesh(vertices, indices);
                };
            }, {
                "../collision/AABB": 3,
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../utils/Octree": 50,
                "./Shape": 43
            } ],
            46: [ function(_dereq_, module, exports) {
                module.exports = GSSolver, _dereq_("../math/Vec3"), _dereq_("../math/Quaternion");
                var Solver = _dereq_("./Solver");
                function GSSolver() {
                    Solver.call(this), this.iterations = 10, this.tolerance = 1e-7;
                }
                GSSolver.prototype = new Solver();
                var GSSolver_solve_lambda = [], GSSolver_solve_invCs = [], GSSolver_solve_Bs = [];
                GSSolver.prototype.solve = function(dt, world) {
                    var B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj, iter = 0, maxIter = this.iterations, tolSquared = this.tolerance * this.tolerance, equations = this.equations, Neq = equations.length, bodies = world.bodies, Nbodies = bodies.length, h = dt;
                    if (0 !== Neq) for (var i = 0; i !== Nbodies; i++) bodies[i].updateSolveMassProperties();
                    var invCs = GSSolver_solve_invCs, Bs = GSSolver_solve_Bs, lambda = GSSolver_solve_lambda;
                    invCs.length = Neq, Bs.length = Neq, lambda.length = Neq;
                    for (var i = 0; i !== Neq; i++) {
                        var c = equations[i];
                        lambda[i] = 0, Bs[i] = c.computeB(h), invCs[i] = 1 / c.computeC();
                    }
                    if (0 !== Neq) {
                        for (var i = 0; i !== Nbodies; i++) {
                            var b = bodies[i], vlambda = b.vlambda, wlambda = b.wlambda;
                            vlambda.set(0, 0, 0), wlambda && wlambda.set(0, 0, 0);
                        }
                        for (iter = 0; iter !== maxIter; iter++) {
                            for (var j = deltalambdaTot = 0; j !== Neq; j++) {
                                var c = equations[j];
                                B = Bs[j], invC = invCs[j], lambdaj = lambda[j], GWlambda = c.computeGWlambda(), 
                                deltalambda = invC * (B - GWlambda - c.eps * lambdaj), lambdaj + deltalambda < c.minForce ? deltalambda = c.minForce - lambdaj : lambdaj + deltalambda > c.maxForce && (deltalambda = c.maxForce - lambdaj), 
                                lambda[j] += deltalambda, deltalambdaTot += 0 < deltalambda ? deltalambda : -deltalambda, 
                                c.addToWlambda(deltalambda);
                            }
                            if (deltalambdaTot * deltalambdaTot < tolSquared) break;
                        }
                        for (var i = 0; i !== Nbodies; i++) {
                            var b = bodies[i], v = b.velocity, w = b.angularVelocity;
                            v.vadd(b.vlambda, v), w && w.vadd(b.wlambda, w);
                        }
                    }
                    return iter;
                };
            }, {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "./Solver": 47
            } ],
            47: [ function(_dereq_, module, exports) {
                function Solver() {
                    this.equations = [];
                }
                (module.exports = Solver).prototype.solve = function(dt, world) {
                    return 0;
                }, Solver.prototype.addEquation = function(eq) {
                    eq.enabled && this.equations.push(eq);
                }, Solver.prototype.removeEquation = function(eq) {
                    var eqs = this.equations, i = eqs.indexOf(eq);
                    -1 !== i && eqs.splice(i, 1);
                }, Solver.prototype.removeAllEquations = function() {
                    this.equations.length = 0;
                };
            }, {} ],
            48: [ function(_dereq_, module, exports) {
                module.exports = SplitSolver, _dereq_("../math/Vec3"), _dereq_("../math/Quaternion");
                var Solver = _dereq_("./Solver"), Body = _dereq_("../objects/Body");
                function SplitSolver(subsolver) {
                    for (Solver.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = subsolver, 
                    this.nodes = [], this.nodePool = []; this.nodePool.length < 128; ) this.nodePool.push(this.createNode());
                }
                SplitSolver.prototype = new Solver();
                var SplitSolver_solve_nodes = [], SplitSolver_solve_eqs = [], SplitSolver_solve_dummyWorld = {
                    bodies: []
                }, STATIC = Body.STATIC;
                function getUnvisitedNode(nodes) {
                    for (var Nnodes = nodes.length, i = 0; i !== Nnodes; i++) {
                        var node = nodes[i];
                        if (!(node.visited || node.body.type & STATIC)) return node;
                    }
                    return !1;
                }
                var queue = [];
                function bfs(root, visitFunc, bds, eqs) {
                    for (queue.push(root), root.visited = !0, visitFunc(root, bds, eqs); queue.length; ) for (var child, node = queue.pop(); child = getUnvisitedNode(node.children); ) child.visited = !0, 
                    visitFunc(child, bds, eqs), queue.push(child);
                }
                function visitFunc(node, bds, eqs) {
                    bds.push(node.body);
                    for (var Neqs = node.eqs.length, i = 0; i !== Neqs; i++) {
                        var eq = node.eqs[i];
                        -1 === eqs.indexOf(eq) && eqs.push(eq);
                    }
                }
                function sortById(a, b) {
                    return b.id - a.id;
                }
                SplitSolver.prototype.createNode = function() {
                    return {
                        body: null,
                        children: [],
                        eqs: [],
                        visited: !1
                    };
                }, SplitSolver.prototype.solve = function(dt, world) {
                    for (var nodes = SplitSolver_solve_nodes, nodePool = this.nodePool, bodies = world.bodies, equations = this.equations, Neq = equations.length, Nbodies = bodies.length, subsolver = this.subsolver; nodePool.length < Nbodies; ) nodePool.push(this.createNode());
                    nodes.length = Nbodies;
                    for (var i = 0; i < Nbodies; i++) nodes[i] = nodePool[i];
                    for (var i = 0; i !== Nbodies; i++) {
                        var node = nodes[i];
                        node.body = bodies[i], node.children.length = 0, node.eqs.length = 0, node.visited = !1;
                    }
                    for (var k = 0; k !== Neq; k++) {
                        var eq = equations[k], i = bodies.indexOf(eq.bi), j = bodies.indexOf(eq.bj), ni = nodes[i], nj = nodes[j];
                        ni.children.push(nj), ni.eqs.push(eq), nj.children.push(ni), nj.eqs.push(eq);
                    }
                    var child, n = 0, eqs = SplitSolver_solve_eqs;
                    subsolver.tolerance = this.tolerance, subsolver.iterations = this.iterations;
                    for (var dummyWorld = SplitSolver_solve_dummyWorld; child = getUnvisitedNode(nodes); ) {
                        eqs.length = 0, dummyWorld.bodies.length = 0, bfs(child, visitFunc, dummyWorld.bodies, eqs);
                        var Neqs = eqs.length;
                        eqs = eqs.sort(sortById);
                        for (var i = 0; i !== Neqs; i++) subsolver.addEquation(eqs[i]);
                        subsolver.solve(dt, dummyWorld), subsolver.removeAllEquations(), n++;
                    }
                    return n;
                };
            }, {
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "./Solver": 47
            } ],
            49: [ function(_dereq_, module, exports) {
                var EventTarget = function() {};
                (module.exports = EventTarget).prototype = {
                    constructor: EventTarget,
                    addEventListener: function(type, listener) {
                        void 0 === this._listeners && (this._listeners = {});
                        var listeners = this._listeners;
                        return void 0 === listeners[type] && (listeners[type] = []), -1 === listeners[type].indexOf(listener) && listeners[type].push(listener), 
                        this;
                    },
                    hasEventListener: function(type, listener) {
                        if (void 0 === this._listeners) return !1;
                        var listeners = this._listeners;
                        return void 0 !== listeners[type] && -1 !== listeners[type].indexOf(listener);
                    },
                    removeEventListener: function(type, listener) {
                        if (void 0 === this._listeners) return this;
                        var listeners = this._listeners;
                        if (void 0 === listeners[type]) return this;
                        var index = listeners[type].indexOf(listener);
                        return -1 !== index && listeners[type].splice(index, 1), this;
                    },
                    dispatchEvent: function(event) {
                        if (void 0 === this._listeners) return this;
                        var listeners = this._listeners, listenerArray = listeners[event.type];
                        if (void 0 !== listenerArray) {
                            event.target = this;
                            for (var i = 0, l = listenerArray.length; i < l; i++) listenerArray[i].call(this, event);
                        }
                        return this;
                    }
                };
            }, {} ],
            50: [ function(_dereq_, module, exports) {
                var AABB = _dereq_("../collision/AABB"), Vec3 = _dereq_("../math/Vec3");
                function OctreeNode(options) {
                    options = options || {}, this.root = options.root || null, this.aabb = options.aabb ? options.aabb.clone() : new AABB(), 
                    this.data = [], this.children = [];
                }
                function Octree(aabb, options) {
                    (options = options || {}).root = null, options.aabb = aabb, OctreeNode.call(this, options), 
                    this.maxDepth = void 0 !== options.maxDepth ? options.maxDepth : 8;
                }
                (module.exports = Octree).prototype = new OctreeNode(), OctreeNode.prototype.reset = function(aabb, options) {
                    this.children.length = this.data.length = 0;
                }, OctreeNode.prototype.insert = function(aabb, elementData, level) {
                    var nodeData = this.data;
                    if (level = level || 0, !this.aabb.contains(aabb)) return !1;
                    var children = this.children;
                    if (level < (this.maxDepth || this.root.maxDepth)) {
                        var subdivided = !1;
                        children.length || (this.subdivide(), subdivided = !0);
                        for (var i = 0; 8 !== i; i++) if (children[i].insert(aabb, elementData, level + 1)) return !0;
                        subdivided && (children.length = 0);
                    }
                    return nodeData.push(elementData), !0;
                };
                var halfDiagonal = new Vec3();
                OctreeNode.prototype.subdivide = function() {
                    var aabb = this.aabb, l = aabb.lowerBound, u = aabb.upperBound, children = this.children;
                    children.push(new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(0, 0, 0)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(1, 0, 0)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(1, 1, 0)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(1, 1, 1)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(0, 1, 1)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(0, 0, 1)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(1, 0, 1)
                        })
                    }), new OctreeNode({
                        aabb: new AABB({
                            lowerBound: new Vec3(0, 1, 0)
                        })
                    })), u.vsub(l, halfDiagonal), halfDiagonal.scale(.5, halfDiagonal);
                    for (var root = this.root || this, i = 0; 8 !== i; i++) {
                        var child = children[i];
                        child.root = root;
                        var lowerBound = child.aabb.lowerBound;
                        lowerBound.x *= halfDiagonal.x, lowerBound.y *= halfDiagonal.y, lowerBound.z *= halfDiagonal.z, 
                        lowerBound.vadd(l, lowerBound), lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
                    }
                }, OctreeNode.prototype.aabbQuery = function(aabb, result) {
                    this.data, this.children;
                    for (var queue = [ this ]; queue.length; ) {
                        var node = queue.pop();
                        node.aabb.overlaps(aabb) && Array.prototype.push.apply(result, node.data), Array.prototype.push.apply(queue, node.children);
                    }
                    return result;
                };
                var tmpAABB = new AABB();
                OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {
                    return ray.getAABB(tmpAABB), tmpAABB.toLocalFrame(treeTransform, tmpAABB), this.aabbQuery(tmpAABB, result), 
                    result;
                }, OctreeNode.prototype.removeEmptyNodes = function() {
                    for (var queue = [ this ]; queue.length; ) {
                        for (var node = queue.pop(), i = node.children.length - 1; 0 <= i; i--) node.children[i].data.length || node.children.splice(i, 1);
                        Array.prototype.push.apply(queue, node.children);
                    }
                };
            }, {
                "../collision/AABB": 3,
                "../math/Vec3": 30
            } ],
            51: [ function(_dereq_, module, exports) {
                function Pool() {
                    this.objects = [], this.type = Object;
                }
                (module.exports = Pool).prototype.release = function() {
                    for (var Nargs = arguments.length, i = 0; i !== Nargs; i++) this.objects.push(arguments[i]);
                }, Pool.prototype.get = function() {
                    return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
                }, Pool.prototype.constructObject = function() {
                    throw new Error("constructObject() not implemented in this Pool subclass yet!");
                };
            }, {} ],
            52: [ function(_dereq_, module, exports) {
                function TupleDictionary() {
                    this.data = {
                        keys: []
                    };
                }
                (module.exports = TupleDictionary).prototype.get = function(i, j) {
                    if (j < i) {
                        var temp = j;
                        j = i, i = temp;
                    }
                    return this.data[i + "-" + j];
                }, TupleDictionary.prototype.set = function(i, j, value) {
                    if (j < i) {
                        var temp = j;
                        j = i, i = temp;
                    }
                    var key = i + "-" + j;
                    this.get(i, j) || this.data.keys.push(key), this.data[key] = value;
                }, TupleDictionary.prototype.reset = function() {
                    for (var data = this.data, keys = data.keys; 0 < keys.length; ) {
                        var key = keys.pop();
                        delete data[key];
                    }
                };
            }, {} ],
            53: [ function(_dereq_, module, exports) {
                function Utils() {}
                (module.exports = Utils).defaults = function(options, defaults) {
                    for (var key in options = options || {}, defaults) key in options || (options[key] = defaults[key]);
                    return options;
                };
            }, {} ],
            54: [ function(_dereq_, module, exports) {
                module.exports = Vec3Pool;
                var Vec3 = _dereq_("../math/Vec3"), Pool = _dereq_("./Pool");
                function Vec3Pool() {
                    Pool.call(this), this.type = Vec3;
                }
                (Vec3Pool.prototype = new Pool()).constructObject = function() {
                    return new Vec3();
                };
            }, {
                "../math/Vec3": 30,
                "./Pool": 51
            } ],
            55: [ function(_dereq_, module, exports) {
                module.exports = Narrowphase;
                var AABB = _dereq_("../collision/AABB"), Shape = _dereq_("../shapes/Shape"), Ray = _dereq_("../collision/Ray"), Vec3 = _dereq_("../math/Vec3"), Transform = _dereq_("../math/Transform"), Quaternion = (_dereq_("../shapes/ConvexPolyhedron"), 
                _dereq_("../math/Quaternion")), Vec3Pool = (_dereq_("../solver/Solver"), _dereq_("../utils/Vec3Pool")), ContactEquation = _dereq_("../equations/ContactEquation"), FrictionEquation = _dereq_("../equations/FrictionEquation");
                function Narrowphase(world) {
                    this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], 
                    this.v3pool = new Vec3Pool(), this.world = world, this.currentContactMaterial = null, 
                    this.enableFrictionReduction = !1;
                }
                Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, rsi, rsj) {
                    var c;
                    this.contactPointPool.length ? ((c = this.contactPointPool.pop()).bi = bi, c.bj = bj) : c = new ContactEquation(bi, bj), 
                    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
                    var cm = this.currentContactMaterial;
                    c.restitution = cm.restitution, c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
                    var matA = si.material || bi.material, matB = sj.material || bj.material;
                    return matA && matB && 0 <= matA.restitution && 0 <= matB.restitution && (c.restitution = matA.restitution * matB.restitution), 
                    c.si = rsi || si, c.sj = rsj || sj, c;
                }, Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray) {
                    var bodyA = contactEquation.bi, bodyB = contactEquation.bj, shapeA = contactEquation.si, shapeB = contactEquation.sj, world = this.world, cm = this.currentContactMaterial, friction = cm.friction, matA = shapeA.material || bodyA.material, matB = shapeB.material || bodyB.material;
                    if (matA && matB && 0 <= matA.friction && 0 <= matB.friction && (friction = matA.friction * matB.friction), 
                    0 < friction) {
                        var mug = friction * world.gravity.length(), reducedMass = bodyA.invMass + bodyB.invMass;
                        0 < reducedMass && (reducedMass = 1 / reducedMass);
                        var pool = this.frictionEquationPool, c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass), c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
                        return c1.bi = c2.bi = bodyA, c1.bj = c2.bj = bodyB, c1.minForce = c2.minForce = -mug * reducedMass, 
                        c1.maxForce = c2.maxForce = mug * reducedMass, c1.ri.copy(contactEquation.ri), c1.rj.copy(contactEquation.rj), 
                        c2.ri.copy(contactEquation.ri), c2.rj.copy(contactEquation.rj), contactEquation.ni.tangents(c1.t, c2.t), 
                        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt), 
                        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt), 
                        c1.enabled = c2.enabled = contactEquation.enabled, outArray.push(c1, c2), !0;
                    }
                    return !1;
                };
                var averageNormal = new Vec3(), averageContactPointA = new Vec3(), averageContactPointB = new Vec3();
                Narrowphase.prototype.createFrictionFromAverage = function(numContacts) {
                    var c = this.result[this.result.length - 1];
                    if (this.createFrictionEquationsFromContact(c, this.frictionResult) && 1 !== numContacts) {
                        var f1 = this.frictionResult[this.frictionResult.length - 2], f2 = this.frictionResult[this.frictionResult.length - 1];
                        averageNormal.setZero(), averageContactPointA.setZero(), averageContactPointB.setZero();
                        for (var bodyA = c.bi, i = (c.bj, 0); i !== numContacts; i++) (c = this.result[this.result.length - 1 - i]).bodyA !== bodyA ? (averageNormal.vadd(c.ni, averageNormal), 
                        averageContactPointA.vadd(c.ri, averageContactPointA), averageContactPointB.vadd(c.rj, averageContactPointB)) : (averageNormal.vsub(c.ni, averageNormal), 
                        averageContactPointA.vadd(c.rj, averageContactPointA), averageContactPointB.vadd(c.ri, averageContactPointB));
                        var invNumContacts = 1 / numContacts;
                        averageContactPointA.scale(invNumContacts, f1.ri), averageContactPointB.scale(invNumContacts, f1.rj), 
                        f2.ri.copy(f1.ri), f2.rj.copy(f1.rj), averageNormal.normalize(), averageNormal.tangents(f1.t, f2.t);
                    }
                };
                var tmpVec1 = new Vec3(), tmpVec2 = new Vec3(), tmpQuat1 = new Quaternion(), tmpQuat2 = new Quaternion();
                Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
                    this.contactPointPool = oldcontacts, this.frictionEquationPool = frictionPool, this.result = result, 
                    this.frictionResult = frictionResult;
                    for (var qi = tmpQuat1, qj = tmpQuat2, xi = tmpVec1, xj = tmpVec2, k = 0, N = p1.length; k !== N; k++) {
                        var bi = p1[k], bj = p2[k], bodyContactMaterial = null;
                        bi.material && bj.material && (bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null);
                        for (var i = 0; i < bi.shapes.length; i++) {
                            bi.quaternion.mult(bi.shapeOrientations[i], qi), bi.quaternion.vmult(bi.shapeOffsets[i], xi), 
                            xi.vadd(bi.position, xi);
                            for (var si = bi.shapes[i], j = 0; j < bj.shapes.length; j++) {
                                bj.quaternion.mult(bj.shapeOrientations[j], qj), bj.quaternion.vmult(bj.shapeOffsets[j], xj), 
                                xj.vadd(bj.position, xj);
                                var sj = bj.shapes[j];
                                if (!(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius)) {
                                    var shapeContactMaterial = null;
                                    si.material && sj.material && (shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null), 
                                    this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;
                                    var resolver = this[si.type | sj.type];
                                    resolver && (si.type < sj.type ? resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj) : resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj));
                                }
                            }
                        }
                    }
                }, Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] = Narrowphase.prototype.boxBox = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material, sj.convexPolyhedronRepresentation.material = sj.material, 
                    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse, sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse, 
                    this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj);
                }, Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.boxConvex = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material, si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse, 
                    this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj);
                }, Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] = Narrowphase.prototype.boxParticle = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material, si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse, 
                    this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj);
                }, Narrowphase.prototype[Shape.types.SPHERE] = Narrowphase.prototype.sphereSphere = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    var r = this.createContactEquation(bi, bj, si, sj);
                    xj.vsub(xi, r.ni), r.ni.normalize(), r.ri.copy(r.ni), r.rj.copy(r.ni), r.ri.mult(si.radius, r.ri), 
                    r.rj.mult(-sj.radius, r.rj), r.ri.vadd(xi, r.ri), r.ri.vsub(bi.position, r.ri), 
                    r.rj.vadd(xj, r.rj), r.rj.vsub(bj.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                };
                var planeTrimesh_normal = new Vec3(), planeTrimesh_relpos = new Vec3(), planeTrimesh_projected = new Vec3();
                Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] = Narrowphase.prototype.planeTrimesh = function(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody) {
                    var v = new Vec3(), normal = planeTrimesh_normal;
                    normal.set(0, 0, 1), planeQuat.vmult(normal, normal);
                    for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {
                        trimeshShape.getVertex(i, v);
                        var v2 = new Vec3();
                        v2.copy(v), Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
                        var relpos = planeTrimesh_relpos;
                        v.vsub(planePos, relpos);
                        var dot = normal.dot(relpos);
                        if (dot <= 0) {
                            var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape);
                            r.ni.copy(normal);
                            var projected = planeTrimesh_projected;
                            normal.scale(relpos.dot(normal), projected), v.vsub(projected, projected), r.ri.copy(projected), 
                            r.ri.vsub(planeBody.position, r.ri), r.rj.copy(v), r.rj.vsub(trimeshBody.position, r.rj), 
                            this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                };
                var sphereTrimesh_normal = new Vec3(), sphereTrimesh_relpos = new Vec3(), sphereTrimesh_v = (new Vec3(), 
                new Vec3()), sphereTrimesh_v2 = new Vec3(), sphereTrimesh_edgeVertexA = new Vec3(), sphereTrimesh_edgeVertexB = new Vec3(), sphereTrimesh_edgeVector = new Vec3(), sphereTrimesh_edgeVectorUnit = new Vec3(), sphereTrimesh_localSpherePos = new Vec3(), sphereTrimesh_tmp = new Vec3(), sphereTrimesh_va = new Vec3(), sphereTrimesh_vb = new Vec3(), sphereTrimesh_vc = new Vec3(), sphereTrimesh_localSphereAABB = new AABB(), sphereTrimesh_triangles = [];
                Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] = Narrowphase.prototype.sphereTrimesh = function(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody) {
                    var edgeVertexA = sphereTrimesh_edgeVertexA, edgeVertexB = sphereTrimesh_edgeVertexB, edgeVector = sphereTrimesh_edgeVector, edgeVectorUnit = sphereTrimesh_edgeVectorUnit, localSpherePos = sphereTrimesh_localSpherePos, tmp = sphereTrimesh_tmp, localSphereAABB = sphereTrimesh_localSphereAABB, v2 = sphereTrimesh_v2, relpos = sphereTrimesh_relpos, triangles = sphereTrimesh_triangles;
                    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);
                    var sphereRadius = sphereShape.radius;
                    localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius), 
                    localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius), 
                    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
                    for (var v = sphereTrimesh_v, radiusSquared = sphereShape.radius * sphereShape.radius, i = 0; i < triangles.length; i++) for (var j = 0; j < 3; j++) if (trimeshShape.getVertex(trimeshShape.indices[3 * triangles[i] + j], v), 
                    v.vsub(localSpherePos, relpos), relpos.norm2() <= radiusSquared) {
                        v2.copy(v), Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v), v.vsub(spherePos, relpos);
                        var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);
                        r.ni.copy(relpos), r.ni.normalize(), r.ri.copy(r.ni), r.ri.scale(sphereShape.radius, r.ri), 
                        r.ri.vadd(spherePos, r.ri), r.ri.vsub(sphereBody.position, r.ri), r.rj.copy(v), 
                        r.rj.vsub(trimeshBody.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                    for (var i = 0; i < triangles.length; i++) for (var j = 0; j < 3; j++) {
                        trimeshShape.getVertex(trimeshShape.indices[3 * triangles[i] + j], edgeVertexA), 
                        trimeshShape.getVertex(trimeshShape.indices[3 * triangles[i] + (j + 1) % 3], edgeVertexB), 
                        edgeVertexB.vsub(edgeVertexA, edgeVector), localSpherePos.vsub(edgeVertexB, tmp);
                        var positionAlongEdgeB = tmp.dot(edgeVector);
                        localSpherePos.vsub(edgeVertexA, tmp);
                        var positionAlongEdgeA = tmp.dot(edgeVector);
                        if (0 < positionAlongEdgeA && positionAlongEdgeB < 0) {
                            localSpherePos.vsub(edgeVertexA, tmp), edgeVectorUnit.copy(edgeVector), edgeVectorUnit.normalize(), 
                            positionAlongEdgeA = tmp.dot(edgeVectorUnit), edgeVectorUnit.scale(positionAlongEdgeA, tmp), 
                            tmp.vadd(edgeVertexA, tmp);
                            var dist = tmp.distanceTo(localSpherePos);
                            if (dist < sphereShape.radius) {
                                var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);
                                tmp.vsub(localSpherePos, r.ni), r.ni.normalize(), r.ni.scale(sphereShape.radius, r.ri), 
                                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp), tmp.vsub(trimeshBody.position, r.rj), 
                                Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni), Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri), 
                                this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                            }
                        }
                    }
                    for (var va = sphereTrimesh_va, vb = sphereTrimesh_vb, vc = sphereTrimesh_vc, normal = sphereTrimesh_normal, i = 0, N = triangles.length; i !== N; i++) {
                        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc), trimeshShape.getNormal(triangles[i], normal), 
                        localSpherePos.vsub(va, tmp);
                        var dist = tmp.dot(normal);
                        if (normal.scale(dist, tmp), localSpherePos.vsub(tmp, tmp), dist = tmp.distanceTo(localSpherePos), 
                        Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
                            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);
                            tmp.vsub(localSpherePos, r.ni), r.ni.normalize(), r.ni.scale(sphereShape.radius, r.ri), 
                            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp), tmp.vsub(trimeshBody.position, r.rj), 
                            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni), Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri), 
                            this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                    triangles.length = 0;
                };
                var point_on_plane_to_sphere = new Vec3(), plane_to_sphere_ortho = new Vec3();
                Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] = Narrowphase.prototype.spherePlane = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    var r = this.createContactEquation(bi, bj, si, sj);
                    if (r.ni.set(0, 0, 1), qj.vmult(r.ni, r.ni), r.ni.negate(r.ni), r.ni.normalize(), 
                    r.ni.mult(si.radius, r.ri), xi.vsub(xj, point_on_plane_to_sphere), r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho), 
                    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj), -point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
                        var ri = r.ri, rj = r.rj;
                        ri.vadd(xi, ri), ri.vsub(bi.position, ri), rj.vadd(xj, rj), rj.vsub(bj.position, rj), 
                        this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                };
                var pointInPolygon_edge = new Vec3(), pointInPolygon_edge_x_normal = new Vec3(), pointInPolygon_vtp = new Vec3();
                function pointInPolygon(verts, normal, p) {
                    for (var positiveResult = null, N = verts.length, i = 0; i !== N; i++) {
                        var v = verts[i], edge = pointInPolygon_edge;
                        verts[(i + 1) % N].vsub(v, edge);
                        var edge_x_normal = pointInPolygon_edge_x_normal;
                        edge.cross(normal, edge_x_normal);
                        var vertex_to_p = pointInPolygon_vtp;
                        p.vsub(v, vertex_to_p);
                        var r = edge_x_normal.dot(vertex_to_p);
                        if (!(null === positiveResult || 0 < r && !0 === positiveResult || r <= 0 && !1 === positiveResult)) return !1;
                        null === positiveResult && (positiveResult = 0 < r);
                    }
                    return !0;
                }
                var box_to_sphere = new Vec3(), sphereBox_ns = new Vec3(), sphereBox_ns1 = new Vec3(), sphereBox_ns2 = new Vec3(), sphereBox_sides = [ new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3() ], sphereBox_sphere_to_corner = new Vec3(), sphereBox_side_ns = new Vec3(), sphereBox_side_ns1 = new Vec3(), sphereBox_side_ns2 = new Vec3();
                Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] = Narrowphase.prototype.sphereBox = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    var v3pool = this.v3pool, sides = sphereBox_sides;
                    xi.vsub(xj, box_to_sphere), sj.getSideNormals(sides, qj);
                    for (var R = si.radius, found = !1, side_ns = sphereBox_side_ns, side_ns1 = sphereBox_side_ns1, side_ns2 = sphereBox_side_ns2, side_h = null, side_penetrations = 0, side_dot1 = 0, side_dot2 = 0, side_distance = null, idx = 0, nsides = sides.length; idx !== nsides && !1 === found; idx++) {
                        var ns = sphereBox_ns;
                        ns.copy(sides[idx]);
                        var h = ns.norm();
                        ns.normalize();
                        var dot = box_to_sphere.dot(ns);
                        if (dot < h + R && 0 < dot) {
                            var ns1 = sphereBox_ns1, ns2 = sphereBox_ns2;
                            ns1.copy(sides[(idx + 1) % 3]), ns2.copy(sides[(idx + 2) % 3]);
                            var h1 = ns1.norm(), h2 = ns2.norm();
                            ns1.normalize(), ns2.normalize();
                            var dot1 = box_to_sphere.dot(ns1), dot2 = box_to_sphere.dot(ns2);
                            if (dot1 < h1 && -h1 < dot1 && dot2 < h2 && -h2 < dot2) {
                                var dist = Math.abs(dot - h - R);
                                (null === side_distance || dist < side_distance) && (side_distance = dist, side_dot1 = dot1, 
                                side_dot2 = dot2, side_h = h, side_ns.copy(ns), side_ns1.copy(ns1), side_ns2.copy(ns2), 
                                side_penetrations++);
                            }
                        }
                    }
                    if (side_penetrations) {
                        found = !0;
                        var r = this.createContactEquation(bi, bj, si, sj);
                        side_ns.mult(-R, r.ri), r.ni.copy(side_ns), r.ni.negate(r.ni), side_ns.mult(side_h, side_ns), 
                        side_ns1.mult(side_dot1, side_ns1), side_ns.vadd(side_ns1, side_ns), side_ns2.mult(side_dot2, side_ns2), 
                        side_ns.vadd(side_ns2, r.rj), r.ri.vadd(xi, r.ri), r.ri.vsub(bi.position, r.ri), 
                        r.rj.vadd(xj, r.rj), r.rj.vsub(bj.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                    for (var rj = v3pool.get(), sphere_to_corner = sphereBox_sphere_to_corner, j = 0; 2 !== j && !found; j++) for (var k = 0; 2 !== k && !found; k++) for (var l = 0; 2 !== l && !found; l++) if (rj.set(0, 0, 0), 
                    j ? rj.vadd(sides[0], rj) : rj.vsub(sides[0], rj), k ? rj.vadd(sides[1], rj) : rj.vsub(sides[1], rj), 
                    l ? rj.vadd(sides[2], rj) : rj.vsub(sides[2], rj), xj.vadd(rj, sphere_to_corner), 
                    sphere_to_corner.vsub(xi, sphere_to_corner), sphere_to_corner.norm2() < R * R) {
                        found = !0;
                        var r = this.createContactEquation(bi, bj, si, sj);
                        r.ri.copy(sphere_to_corner), r.ri.normalize(), r.ni.copy(r.ri), r.ri.mult(R, r.ri), 
                        r.rj.copy(rj), r.ri.vadd(xi, r.ri), r.ri.vsub(bi.position, r.ri), r.rj.vadd(xj, r.rj), 
                        r.rj.vsub(bj.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                    v3pool.release(rj), rj = null;
                    for (var edgeTangent = v3pool.get(), edgeCenter = v3pool.get(), r = v3pool.get(), orthogonal = v3pool.get(), dist = v3pool.get(), Nsides = sides.length, j = 0; j !== Nsides && !found; j++) for (var k = 0; k !== Nsides && !found; k++) if (j % 3 != k % 3) {
                        sides[k].cross(sides[j], edgeTangent), edgeTangent.normalize(), sides[j].vadd(sides[k], edgeCenter), 
                        r.copy(xi), r.vsub(edgeCenter, r), r.vsub(xj, r);
                        var orthonorm = r.dot(edgeTangent);
                        edgeTangent.mult(orthonorm, orthogonal);
                        for (var l = 0; l === j % 3 || l === k % 3; ) l++;
                        dist.copy(xi), dist.vsub(orthogonal, dist), dist.vsub(edgeCenter, dist), dist.vsub(xj, dist);
                        var tdist = Math.abs(orthonorm), ndist = dist.norm();
                        if (tdist < sides[l].norm() && ndist < R) {
                            found = !0;
                            var res = this.createContactEquation(bi, bj, si, sj);
                            edgeCenter.vadd(orthogonal, res.rj), res.rj.copy(res.rj), dist.negate(res.ni), res.ni.normalize(), 
                            res.ri.copy(res.rj), res.ri.vadd(xj, res.ri), res.ri.vsub(xi, res.ri), res.ri.normalize(), 
                            res.ri.mult(R, res.ri), res.ri.vadd(xi, res.ri), res.ri.vsub(bi.position, res.ri), 
                            res.rj.vadd(xj, res.rj), res.rj.vsub(bj.position, res.rj), this.result.push(res), 
                            this.createFrictionEquationsFromContact(res, this.frictionResult);
                        }
                    }
                    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
                };
                var convex_to_sphere = new Vec3(), sphereConvex_edge = new Vec3(), sphereConvex_edgeUnit = new Vec3(), sphereConvex_sphereToCorner = new Vec3(), sphereConvex_worldCorner = new Vec3(), sphereConvex_worldNormal = new Vec3(), sphereConvex_worldPoint = new Vec3(), sphereConvex_worldSpherePointClosestToPlane = new Vec3(), sphereConvex_penetrationVec = new Vec3(), sphereConvex_sphereToWorldPoint = new Vec3();
                Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.sphereConvex = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    var v3pool = this.v3pool;
                    xi.vsub(xj, convex_to_sphere);
                    for (var normals = sj.faceNormals, faces = sj.faces, verts = sj.vertices, R = si.radius, i = 0; i !== verts.length; i++) {
                        var v = verts[i], worldCorner = sphereConvex_worldCorner;
                        qj.vmult(v, worldCorner), xj.vadd(worldCorner, worldCorner);
                        var sphere_to_corner = sphereConvex_sphereToCorner;
                        if (worldCorner.vsub(xi, sphere_to_corner), sphere_to_corner.norm2() < R * R) {
                            found = !0;
                            var r = this.createContactEquation(bi, bj, si, sj);
                            return r.ri.copy(sphere_to_corner), r.ri.normalize(), r.ni.copy(r.ri), r.ri.mult(R, r.ri), 
                            worldCorner.vsub(xj, r.rj), r.ri.vadd(xi, r.ri), r.ri.vsub(bi.position, r.ri), r.rj.vadd(xj, r.rj), 
                            r.rj.vsub(bj.position, r.rj), this.result.push(r), void this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                    for (var found = !1, i = 0, nfaces = faces.length; i !== nfaces && !1 === found; i++) {
                        var normal = normals[i], face = faces[i], worldNormal = sphereConvex_worldNormal;
                        qj.vmult(normal, worldNormal);
                        var worldPoint = sphereConvex_worldPoint;
                        qj.vmult(verts[face[0]], worldPoint), worldPoint.vadd(xj, worldPoint);
                        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
                        worldNormal.mult(-R, worldSpherePointClosestToPlane), xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);
                        var penetrationVec = sphereConvex_penetrationVec;
                        worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec);
                        var penetration = penetrationVec.dot(worldNormal), worldPointToSphere = sphereConvex_sphereToWorldPoint;
                        if (xi.vsub(worldPoint, worldPointToSphere), penetration < 0 && 0 < worldPointToSphere.dot(worldNormal)) {
                            for (var faceVerts = [], j = 0, Nverts = face.length; j !== Nverts; j++) {
                                var worldVertex = v3pool.get();
                                qj.vmult(verts[face[j]], worldVertex), xj.vadd(worldVertex, worldVertex), faceVerts.push(worldVertex);
                            }
                            if (pointInPolygon(faceVerts, worldNormal, xi)) {
                                found = !0;
                                var r = this.createContactEquation(bi, bj, si, sj);
                                worldNormal.mult(-R, r.ri), worldNormal.negate(r.ni);
                                var penetrationVec2 = v3pool.get();
                                worldNormal.mult(-penetration, penetrationVec2);
                                var penetrationSpherePoint = v3pool.get();
                                worldNormal.mult(-R, penetrationSpherePoint), xi.vsub(xj, r.rj), r.rj.vadd(penetrationSpherePoint, r.rj), 
                                r.rj.vadd(penetrationVec2, r.rj), r.rj.vadd(xj, r.rj), r.rj.vsub(bj.position, r.rj), 
                                r.ri.vadd(xi, r.ri), r.ri.vsub(bi.position, r.ri), v3pool.release(penetrationVec2), 
                                v3pool.release(penetrationSpherePoint), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                                for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) v3pool.release(faceVerts[j]);
                                return;
                            }
                            for (var j = 0; j !== face.length; j++) {
                                var v1 = v3pool.get(), v2 = v3pool.get();
                                qj.vmult(verts[face[(j + 1) % face.length]], v1), qj.vmult(verts[face[(j + 2) % face.length]], v2), 
                                xj.vadd(v1, v1), xj.vadd(v2, v2);
                                var edge = sphereConvex_edge;
                                v2.vsub(v1, edge);
                                var edgeUnit = sphereConvex_edgeUnit;
                                edge.unit(edgeUnit);
                                var p = v3pool.get(), v1_to_xi = v3pool.get();
                                xi.vsub(v1, v1_to_xi);
                                var dot = v1_to_xi.dot(edgeUnit);
                                edgeUnit.mult(dot, p), p.vadd(v1, p);
                                var xi_to_p = v3pool.get();
                                if (p.vsub(xi, xi_to_p), 0 < dot && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) {
                                    var r = this.createContactEquation(bi, bj, si, sj);
                                    p.vsub(xj, r.rj), p.vsub(xi, r.ni), r.ni.normalize(), r.ni.mult(R, r.ri), r.rj.vadd(xj, r.rj), 
                                    r.rj.vsub(bj.position, r.rj), r.ri.vadd(xi, r.ri), r.ri.vsub(bi.position, r.ri), 
                                    this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                                    for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) v3pool.release(faceVerts[j]);
                                    return v3pool.release(v1), v3pool.release(v2), v3pool.release(p), v3pool.release(xi_to_p), 
                                    void v3pool.release(v1_to_xi);
                                }
                                v3pool.release(v1), v3pool.release(v2), v3pool.release(p), v3pool.release(xi_to_p), 
                                v3pool.release(v1_to_xi);
                            }
                            for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) v3pool.release(faceVerts[j]);
                        }
                    }
                }, new Vec3(), new Vec3(), Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] = Narrowphase.prototype.planeBox = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    sj.convexPolyhedronRepresentation.material = sj.material, sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse, 
                    this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj);
                };
                var planeConvex_v = new Vec3(), planeConvex_normal = new Vec3(), planeConvex_relpos = new Vec3(), planeConvex_projected = new Vec3();
                Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.planeConvex = function(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody) {
                    var worldVertex = planeConvex_v, worldNormal = planeConvex_normal;
                    worldNormal.set(0, 0, 1), planeQuat.vmult(worldNormal, worldNormal);
                    for (var numContacts = 0, relpos = planeConvex_relpos, i = 0; i !== convexShape.vertices.length; i++) {
                        worldVertex.copy(convexShape.vertices[i]), convexQuat.vmult(worldVertex, worldVertex), 
                        convexPosition.vadd(worldVertex, worldVertex), worldVertex.vsub(planePosition, relpos);
                        var dot = worldNormal.dot(relpos);
                        if (dot <= 0) {
                            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape), projected = planeConvex_projected;
                            worldNormal.mult(worldNormal.dot(relpos), projected), worldVertex.vsub(projected, projected), 
                            projected.vsub(planePosition, r.ri), r.ni.copy(worldNormal), worldVertex.vsub(convexPosition, r.rj), 
                            r.ri.vadd(planePosition, r.ri), r.ri.vsub(planeBody.position, r.ri), r.rj.vadd(convexPosition, r.rj), 
                            r.rj.vsub(convexBody.position, r.rj), this.result.push(r), numContacts++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                    this.enableFrictionReduction && numContacts && this.createFrictionFromAverage(numContacts);
                };
                var convexConvex_sepAxis = new Vec3(), convexConvex_q = new Vec3();
                Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexConvex = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, faceListA, faceListB) {
                    var sepAxis = convexConvex_sepAxis;
                    if (!(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) && si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
                        var res = [], q = convexConvex_q;
                        si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
                        for (var numContacts = 0, j = 0; j !== res.length; j++) {
                            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj), ri = r.ri, rj = r.rj;
                            sepAxis.negate(r.ni), res[j].normal.negate(q), q.mult(res[j].depth, q), res[j].point.vadd(q, ri), 
                            rj.copy(res[j].point), ri.vsub(xi, ri), rj.vsub(xj, rj), ri.vadd(xi, ri), ri.vsub(bi.position, ri), 
                            rj.vadd(xj, rj), rj.vsub(bj.position, rj), this.result.push(r), numContacts++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                        this.enableFrictionReduction && numContacts && this.createFrictionFromAverage(numContacts);
                    }
                };
                var particlePlane_normal = new Vec3(), particlePlane_relpos = new Vec3(), particlePlane_projected = new Vec3();
                Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] = Narrowphase.prototype.planeParticle = function(sj, si, xj, xi, qj, qi, bj, bi) {
                    var normal = particlePlane_normal;
                    normal.set(0, 0, 1), bj.quaternion.vmult(normal, normal);
                    var relpos = particlePlane_relpos;
                    xi.vsub(bj.position, relpos);
                    var dot = normal.dot(relpos);
                    if (dot <= 0) {
                        var r = this.createContactEquation(bi, bj, si, sj);
                        r.ni.copy(normal), r.ni.negate(r.ni), r.ri.set(0, 0, 0);
                        var projected = particlePlane_projected;
                        normal.mult(normal.dot(xi), projected), xi.vsub(projected, projected), r.rj.copy(projected), 
                        this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                };
                var particleSphere_normal = new Vec3();
                Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] = Narrowphase.prototype.sphereParticle = function(sj, si, xj, xi, qj, qi, bj, bi) {
                    var normal = particleSphere_normal;
                    normal.set(0, 0, 1), xi.vsub(xj, normal);
                    var lengthSquared = normal.norm2();
                    if (lengthSquared <= sj.radius * sj.radius) {
                        var r = this.createContactEquation(bi, bj, si, sj);
                        normal.normalize(), r.rj.copy(normal), r.rj.mult(sj.radius, r.rj), r.ni.copy(normal), 
                        r.ni.negate(r.ni), r.ri.set(0, 0, 0), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                };
                var cqj = new Quaternion(), convexParticle_local = new Vec3(), convexParticle_penetratedFaceNormal = (new Vec3(), 
                new Vec3()), convexParticle_vertexToParticle = new Vec3(), convexParticle_worldPenetrationVec = new Vec3();
                Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexParticle = function(sj, si, xj, xi, qj, qi, bj, bi) {
                    var penetratedFaceIndex = -1, penetratedFaceNormal = convexParticle_penetratedFaceNormal, worldPenetrationVec = convexParticle_worldPenetrationVec, minPenetration = null, local = convexParticle_local;
                    if (local.copy(xi), local.vsub(xj, local), qj.conjugate(cqj), cqj.vmult(local, local), 
                    sj.pointIsInside(local)) {
                        sj.worldVerticesNeedsUpdate && sj.computeWorldVertices(xj, qj), sj.worldFaceNormalsNeedsUpdate && sj.computeWorldFaceNormals(qj);
                        for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
                            var verts = [ sj.worldVertices[sj.faces[i][0]] ], normal = sj.worldFaceNormals[i];
                            xi.vsub(verts[0], convexParticle_vertexToParticle);
                            var penetration = -normal.dot(convexParticle_vertexToParticle);
                            (null === minPenetration || Math.abs(penetration) < Math.abs(minPenetration)) && (minPenetration = penetration, 
                            penetratedFaceIndex = i, penetratedFaceNormal.copy(normal));
                        }
                        if (-1 !== penetratedFaceIndex) {
                            var r = this.createContactEquation(bi, bj, si, sj);
                            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec), worldPenetrationVec.vadd(xi, worldPenetrationVec), 
                            worldPenetrationVec.vsub(xj, worldPenetrationVec), r.rj.copy(worldPenetrationVec), 
                            penetratedFaceNormal.negate(r.ni), r.ri.set(0, 0, 0);
                            var ri = r.ri, rj = r.rj;
                            ri.vadd(xi, ri), ri.vsub(bi.position, ri), rj.vadd(xj, rj), rj.vsub(bj.position, rj), 
                            this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
                        } else console.warn("Point found inside convex, but did not find penetrating face!");
                    }
                }, Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.boxHeightfield = function(si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material, si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse, 
                    this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj);
                };
                var convexHeightfield_tmp1 = new Vec3(), convexHeightfield_tmp2 = new Vec3(), convexHeightfield_faceList = [ 0 ];
                Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody) {
                    var data = hfShape.data, w = hfShape.elementSize, radius = convexShape.boundingSphereRadius, worldPillarOffset = convexHeightfield_tmp2, faceList = convexHeightfield_faceList, localConvexPos = convexHeightfield_tmp1;
                    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);
                    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1, iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1, iMinY = Math.floor((localConvexPos.y - radius) / w) - 1, iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;
                    if (!(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length)) {
                        iMinX < 0 && (iMinX = 0), iMaxX < 0 && (iMaxX = 0), iMinY < 0 && (iMinY = 0), iMaxY < 0 && (iMaxY = 0), 
                        iMinX >= data.length && (iMinX = data.length - 1), iMaxX >= data.length && (iMaxX = data.length - 1), 
                        iMaxY >= data[0].length && (iMaxY = data[0].length - 1), iMinY >= data[0].length && (iMinY = data[0].length - 1);
                        var minMax = [];
                        hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                        var min = minMax[0], max = minMax[1];
                        if (!(localConvexPos.z - radius > max || localConvexPos.z + radius < min)) for (var i = iMinX; i < iMaxX; i++) for (var j = iMinY; j < iMaxY; j++) hfShape.getConvexTrianglePillar(i, j, !1), 
                        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset), 
                        convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius && this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null), 
                        hfShape.getConvexTrianglePillar(i, j, !0), Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset), 
                        convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius && this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
                    }
                };
                var sphereHeightfield_tmp1 = new Vec3(), sphereHeightfield_tmp2 = new Vec3();
                Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.sphereHeightfield = function(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody) {
                    var data = hfShape.data, radius = sphereShape.radius, w = hfShape.elementSize, worldPillarOffset = sphereHeightfield_tmp2, localSpherePos = sphereHeightfield_tmp1;
                    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);
                    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1, iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1, iMinY = Math.floor((localSpherePos.y - radius) / w) - 1, iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;
                    if (!(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length)) {
                        iMinX < 0 && (iMinX = 0), iMaxX < 0 && (iMaxX = 0), iMinY < 0 && (iMinY = 0), iMaxY < 0 && (iMaxY = 0), 
                        iMinX >= data.length && (iMinX = data.length - 1), iMaxX >= data.length && (iMaxX = data.length - 1), 
                        iMaxY >= data[0].length && (iMaxY = data[0].length - 1), iMinY >= data[0].length && (iMinY = data[0].length - 1);
                        var minMax = [];
                        hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                        var min = minMax[0], max = minMax[1];
                        if (!(localSpherePos.z - radius > max || localSpherePos.z + radius < min)) for (var result = this.result, i = iMinX; i < iMaxX; i++) for (var j = iMinY; j < iMaxY; j++) {
                            var numContactsBefore = result.length;
                            hfShape.getConvexTrianglePillar(i, j, !1), Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset), 
                            spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius && this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody), 
                            hfShape.getConvexTrianglePillar(i, j, !0), Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset), 
                            spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius && this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
                            var numContacts = result.length - numContactsBefore;
                            if (2 < numContacts) return;
                        }
                    }
                };
            }, {
                "../collision/AABB": 3,
                "../collision/Ray": 9,
                "../equations/ContactEquation": 19,
                "../equations/FrictionEquation": 21,
                "../math/Quaternion": 28,
                "../math/Transform": 29,
                "../math/Vec3": 30,
                "../shapes/ConvexPolyhedron": 38,
                "../shapes/Shape": 43,
                "../solver/Solver": 47,
                "../utils/Vec3Pool": 54
            } ],
            56: [ function(_dereq_, module, exports) {
                module.exports = World;
                var Shape = _dereq_("../shapes/Shape"), Vec3 = _dereq_("../math/Vec3"), Quaternion = _dereq_("../math/Quaternion"), GSSolver = _dereq_("../solver/GSSolver"), Narrowphase = (_dereq_("../utils/Vec3Pool"), 
                _dereq_("../equations/ContactEquation"), _dereq_("../equations/FrictionEquation"), 
                _dereq_("./Narrowphase")), EventTarget = _dereq_("../utils/EventTarget"), ArrayCollisionMatrix = _dereq_("../collision/ArrayCollisionMatrix"), Material = _dereq_("../material/Material"), ContactMaterial = _dereq_("../material/ContactMaterial"), Body = _dereq_("../objects/Body"), TupleDictionary = _dereq_("../utils/TupleDictionary"), RaycastResult = _dereq_("../collision/RaycastResult"), AABB = _dereq_("../collision/AABB"), Ray = _dereq_("../collision/Ray"), NaiveBroadphase = _dereq_("../collision/NaiveBroadphase");
                function World() {
                    EventTarget.apply(this), this.dt = -1, this.allowSleep = !1, this.contacts = [], 
                    this.frictionEquations = [], this.quatNormalizeSkip = 0, this.quatNormalizeFast = !1, 
                    this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new Vec3(), 
                    this.broadphase = new NaiveBroadphase(), this.bodies = [], this.solver = new GSSolver(), 
                    this.constraints = [], this.narrowphase = new Narrowphase(this), this.collisionMatrix = new ArrayCollisionMatrix(), 
                    this.collisionMatrixPrevious = new ArrayCollisionMatrix(), this.materials = [], 
                    this.contactmaterials = [], this.contactMaterialTable = new TupleDictionary(), this.defaultMaterial = new Material("default"), 
                    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
                        friction: .3,
                        restitution: 0
                    }), this.doProfiling = !1, this.profile = {
                        solve: 0,
                        makeContactConstraints: 0,
                        broadphase: 0,
                        integrate: 0,
                        narrowphase: 0
                    }, this.subsystems = [], this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    }, this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    };
                }
                World.prototype = new EventTarget(), new AABB();
                var tmpRay = new Ray();
                if (World.prototype.getContactMaterial = function(m1, m2) {
                    return this.contactMaterialTable.get(m1.id, m2.id);
                }, World.prototype.numObjects = function() {
                    return this.bodies.length;
                }, World.prototype.collisionMatrixTick = function() {
                    var temp = this.collisionMatrixPrevious;
                    this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = temp, 
                    this.collisionMatrix.reset();
                }, World.prototype.add = World.prototype.addBody = function(body) {
                    -1 === this.bodies.indexOf(body) && (body.index = this.bodies.length, this.bodies.push(body), 
                    body.world = this, body.initPosition.copy(body.position), body.initVelocity.copy(body.velocity), 
                    body.timeLastSleepy = this.time, body instanceof Body && (body.initAngularVelocity.copy(body.angularVelocity), 
                    body.initQuaternion.copy(body.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), 
                    this.addBodyEvent.body = body, this.dispatchEvent(this.addBodyEvent));
                }, World.prototype.addConstraint = function(c) {
                    this.constraints.push(c);
                }, World.prototype.removeConstraint = function(c) {
                    var idx = this.constraints.indexOf(c);
                    -1 !== idx && this.constraints.splice(idx, 1);
                }, World.prototype.rayTest = function(from, to, result) {
                    result instanceof RaycastResult ? this.raycastClosest(from, to, {
                        skipBackfaces: !0
                    }, result) : this.raycastAll(from, to, {
                        skipBackfaces: !0
                    }, result);
                }, World.prototype.raycastAll = function(from, to, options, callback) {
                    return options.mode = Ray.ALL, options.from = from, options.to = to, options.callback = callback, 
                    tmpRay.intersectWorld(this, options);
                }, World.prototype.raycastAny = function(from, to, options, result) {
                    return options.mode = Ray.ANY, options.from = from, options.to = to, options.result = result, 
                    tmpRay.intersectWorld(this, options);
                }, World.prototype.raycastClosest = function(from, to, options, result) {
                    return options.mode = Ray.CLOSEST, options.from = from, options.to = to, options.result = result, 
                    tmpRay.intersectWorld(this, options);
                }, World.prototype.removeBody = World.prototype.remove = function(body) {
                    body.world = null;
                    var n = this.bodies.length - 1, bodies = this.bodies, idx = bodies.indexOf(body);
                    if (-1 !== idx) {
                        bodies.splice(idx, 1);
                        for (var i = 0; i !== bodies.length; i++) bodies[i].index = i;
                        this.collisionMatrix.setNumObjects(n), this.removeBodyEvent.body = body, this.dispatchEvent(this.removeBodyEvent);
                    }
                }, World.prototype.addMaterial = function(m) {
                    this.materials.push(m);
                }, World.prototype.addContactMaterial = function(cmat) {
                    this.contactmaterials.push(cmat), this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
                }, "undefined" == typeof performance && (performance = {}), !performance.now) {
                    var nowOffset = Date.now();
                    performance.timing && performance.timing.navigationStart && (nowOffset = performance.timing.navigationStart), 
                    performance.now = function() {
                        return Date.now() - nowOffset;
                    };
                }
                var step_tmp1 = new Vec3();
                World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
                    if (maxSubSteps = maxSubSteps || 10, 0 === (timeSinceLastCalled = timeSinceLastCalled || 0)) this.internalStep(dt), 
                    this.time += dt; else {
                        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                        internalSteps = Math.min(internalSteps, maxSubSteps);
                        for (var t0 = performance.now(), i = 0; i !== internalSteps && (this.internalStep(dt), 
                        !(performance.now() - t0 > 1e3 * dt)); i++) ;
                        this.time += timeSinceLastCalled;
                        for (var h = this.time % dt, h_div_dt = h / dt, interpvelo = step_tmp1, bodies = this.bodies, j = 0; j !== bodies.length; j++) {
                            var b = bodies[j];
                            b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING ? (b.position.vsub(b.previousPosition, interpvelo), 
                            interpvelo.scale(h_div_dt, interpvelo), b.position.vadd(interpvelo, b.interpolatedPosition)) : (b.interpolatedPosition.copy(b.position), 
                            b.interpolatedQuaternion.copy(b.quaternion));
                        }
                    }
                };
                var World_step_postStepEvent = {
                    type: "postStep"
                }, World_step_preStepEvent = {
                    type: "preStep"
                }, World_step_collideEvent = {
                    type: "collide",
                    body: null,
                    contact: null
                }, World_step_oldContacts = [], World_step_frictionEquationPool = [], World_step_p1 = [], World_step_p2 = [], World_step_step_w = (new Vec3(), 
                new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), 
                new Vec3(), new Quaternion(), new Quaternion()), World_step_step_wq = new Quaternion(), invI_tau_dt = new Vec3();
                World.prototype.internalStep = function(dt) {
                    this.dt = dt;
                    var profilingStart, contacts = this.contacts, p1 = World_step_p1, p2 = World_step_p2, N = this.numObjects(), bodies = this.bodies, solver = this.solver, gravity = this.gravity, doProfiling = this.doProfiling, profile = this.profile, DYNAMIC = Body.DYNAMIC, constraints = this.constraints, frictionEquationPool = World_step_frictionEquationPool, gx = (gravity.norm(), 
                    gravity.x), gy = gravity.y, gz = gravity.z, i = 0;
                    for (doProfiling && (profilingStart = performance.now()), i = 0; i !== N; i++) {
                        var bi = bodies[i];
                        if (bi.type & DYNAMIC) {
                            var f = bi.force, m = bi.mass;
                            f.x += m * gx, f.y += m * gy, f.z += m * gz;
                        }
                    }
                    for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) this.subsystems[i].update();
                    doProfiling && (profilingStart = performance.now()), p1.length = 0, p2.length = 0, 
                    this.broadphase.collisionPairs(this, p1, p2), doProfiling && (profile.broadphase = performance.now() - profilingStart);
                    var Nconstraints = constraints.length;
                    for (i = 0; i !== Nconstraints; i++) {
                        var c = constraints[i];
                        if (!c.collideConnected) for (var j = p1.length - 1; 0 <= j; j -= 1) (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) && (p1.splice(j, 1), 
                        p2.splice(j, 1));
                    }
                    this.collisionMatrixTick(), doProfiling && (profilingStart = performance.now());
                    var oldcontacts = World_step_oldContacts, NoldContacts = contacts.length;
                    for (i = 0; i !== NoldContacts; i++) oldcontacts.push(contacts[i]);
                    contacts.length = 0;
                    var NoldFrictionEquations = this.frictionEquations.length;
                    for (i = 0; i !== NoldFrictionEquations; i++) frictionEquationPool.push(this.frictionEquations[i]);
                    this.frictionEquations.length = 0, this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, this.frictionEquations, frictionEquationPool), 
                    doProfiling && (profile.narrowphase = performance.now() - profilingStart), doProfiling && (profilingStart = performance.now());
                    for (var i = 0; i < this.frictionEquations.length; i++) solver.addEquation(this.frictionEquations[i]);
                    for (var ncontacts = contacts.length, k = 0; k !== ncontacts; k++) {
                        var c = contacts[k], bi = c.bi, bj = c.bj;
                        if (c.si, c.sj, (bi.material && bj.material && this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial).friction, 
                        bi.material && bj.material && (0 <= bi.material.friction && 0 <= bj.material.friction && (bi.material.friction, 
                        bj.material.friction), 0 <= bi.material.restitution && 0 <= bj.material.restitution && (c.restitution = bi.material.restitution * bj.material.restitution)), 
                        solver.addEquation(c), bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
                            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2(), speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                            2 * speedLimitSquaredB <= speedSquaredB && (bi._wakeUpAfterNarrowphase = !0);
                        }
                        if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
                            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2(), speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                            2 * speedLimitSquaredA <= speedSquaredA && (bj._wakeUpAfterNarrowphase = !0);
                        }
                        this.collisionMatrix.set(bi, bj, !0), this.collisionMatrixPrevious.get(bi, bj) || (World_step_collideEvent.body = bj, 
                        World_step_collideEvent.contact = c, bi.dispatchEvent(World_step_collideEvent), 
                        World_step_collideEvent.body = bi, bj.dispatchEvent(World_step_collideEvent));
                    }
                    for (doProfiling && (profile.makeContactConstraints = performance.now() - profilingStart, 
                    profilingStart = performance.now()), i = 0; i !== N; i++) {
                        var bi = bodies[i];
                        bi._wakeUpAfterNarrowphase && (bi.wakeUp(), bi._wakeUpAfterNarrowphase = !1);
                    }
                    var Nconstraints = constraints.length;
                    for (i = 0; i !== Nconstraints; i++) {
                        var c = constraints[i];
                        c.update();
                        for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {
                            var eq = c.equations[j];
                            solver.addEquation(eq);
                        }
                    }
                    solver.solve(dt, this), doProfiling && (profile.solve = performance.now() - profilingStart), 
                    solver.removeAllEquations();
                    var pow = Math.pow;
                    for (i = 0; i !== N; i++) {
                        var bi = bodies[i];
                        if (bi.type & DYNAMIC) {
                            var ld = pow(1 - bi.linearDamping, dt), v = bi.velocity;
                            v.mult(ld, v);
                            var av = bi.angularVelocity;
                            if (av) {
                                var ad = pow(1 - bi.angularDamping, dt);
                                av.mult(ad, av);
                            }
                        }
                    }
                    for (this.dispatchEvent(World_step_preStepEvent), i = 0; i !== N; i++) {
                        var bi = bodies[i];
                        bi.preStep && bi.preStep.call(bi);
                    }
                    doProfiling && (profilingStart = performance.now());
                    var w = World_step_step_w, wq = World_step_step_wq, stepnumber = this.stepnumber, DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC, quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) == 0, quatNormalizeFast = this.quatNormalizeFast, half_dt = .5 * dt;
                    for (Shape.types.PLANE, Shape.types.CONVEXPOLYHEDRON, i = 0; i !== N; i++) {
                        var b = bodies[i], force = b.force, tau = b.torque;
                        if (b.type & DYNAMIC_OR_KINEMATIC && b.sleepState !== Body.SLEEPING) {
                            var velo = b.velocity, angularVelo = b.angularVelocity, pos = b.position, quat = b.quaternion, invMass = b.invMass, invInertia = b.invInertiaWorld;
                            velo.x += force.x * invMass * dt, velo.y += force.y * invMass * dt, velo.z += force.z * invMass * dt, 
                            b.angularVelocity && (invInertia.vmult(tau, invI_tau_dt), invI_tau_dt.mult(dt, invI_tau_dt), 
                            invI_tau_dt.vadd(angularVelo, angularVelo)), pos.x += velo.x * dt, pos.y += velo.y * dt, 
                            pos.z += velo.z * dt, b.angularVelocity && (w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0), 
                            w.mult(quat, wq), quat.x += half_dt * wq.x, quat.y += half_dt * wq.y, quat.z += half_dt * wq.z, 
                            quat.w += half_dt * wq.w, quatNormalize && (quatNormalizeFast ? quat.normalizeFast() : quat.normalize())), 
                            b.aabb && (b.aabbNeedsUpdate = !0), b.updateInertiaWorld && b.updateInertiaWorld();
                        }
                    }
                    for (this.clearForces(), this.broadphase.dirty = !0, doProfiling && (profile.integrate = performance.now() - profilingStart), 
                    this.time += dt, this.stepnumber += 1, this.dispatchEvent(World_step_postStepEvent), 
                    i = 0; i !== N; i++) {
                        var bi = bodies[i], postStep = bi.postStep;
                        postStep && postStep.call(bi);
                    }
                    if (this.allowSleep) for (i = 0; i !== N; i++) bodies[i].sleepTick(this.time);
                }, World.prototype.clearForces = function() {
                    for (var bodies = this.bodies, N = bodies.length, i = 0; i !== N; i++) {
                        var b = bodies[i];
                        b.force, b.torque, b.force.set(0, 0, 0), b.torque.set(0, 0, 0);
                    }
                };
            }, {
                "../collision/AABB": 3,
                "../collision/ArrayCollisionMatrix": 4,
                "../collision/NaiveBroadphase": 7,
                "../collision/Ray": 9,
                "../collision/RaycastResult": 10,
                "../equations/ContactEquation": 19,
                "../equations/FrictionEquation": 21,
                "../material/ContactMaterial": 24,
                "../material/Material": 25,
                "../math/Quaternion": 28,
                "../math/Vec3": 30,
                "../objects/Body": 31,
                "../shapes/Shape": 43,
                "../solver/GSSolver": 46,
                "../utils/EventTarget": 49,
                "../utils/TupleDictionary": 52,
                "../utils/Vec3Pool": 54,
                "./Narrowphase": 55
            } ]
        }, {}, [ 2 ])(2);
    });
    cannon.CANNON, cannon.Shape;
    function stringfyVec3(value) {
        return vec3.exactEquals(value, vec3.create()) ? "<origin>" : "(x: ".concat(value.x, ", y: ").concat(value.y, ", z: ").concat(value.z, ")");
    }
    function setWrap(object, wrapper) {
        object.__cc_wrapper__ = wrapper;
    }
    function getWrap(object) {
        return object.__cc_wrapper__;
    }
    !function(ERigidBodyType) {
        ERigidBodyType[ERigidBodyType.DYNAMIC = 1] = "DYNAMIC", ERigidBodyType[ERigidBodyType.STATIC = 2] = "STATIC", 
        ERigidBodyType[ERigidBodyType.KINEMATIC = 4] = "KINEMATIC";
    }(ERigidBodyType || (ERigidBodyType = {})), function(ETransformSource) {
        ETransformSource[ETransformSource.SCENE = 0] = "SCENE", ETransformSource[ETransformSource.PHYSIC = 1] = "PHYSIC";
    }(ETransformSource || (ETransformSource = {}));
    var defaultCannonMaterial = new cannon.Material(""), defaultCannonContactMaterial = new cannon.ContactMaterial(defaultCannonMaterial, defaultCannonMaterial, {
        friction: .06,
        restitution: 0
    });
    function toCannonRaycastOptions(options) {
        return function toCannonOptions(options, optionsRename) {
            for (var result = {}, _arr = Object.keys(options), _i = 0; _i < _arr.length; _i++) {
                var key = _arr[_i], destKey = key;
                if (optionsRename) {
                    var rename = optionsRename[key];
                    rename && (destKey = rename);
                }
                result[destKey] = options[key];
            }
            return result;
        }(options, {
            queryTriggerInteraction: "checkCollisionResponse"
        });
    }
    function toCannonVec3(value) {
        return new cannon.Vec3(value.x, value.y, value.z);
    }
    function fillRaycastResult(result, cannonResult) {
        result._assign(cannonResult.hitPointWorld, cannonResult.distance, getWrap(cannonResult.shape), getWrap(cannonResult.body));
    }
    function commitShapeUpdates(body) {
        body.updateMassProperties(), body.updateBoundingRadius(), body.aabbNeedsUpdate = !0;
    }
    var CannonRigidBody = function() {
        function CannonRigidBody(options) {
            var _this = this;
            _classCallCheck(this, CannonRigidBody), this._group = 1, this._body = void 0, this._velocityResult = new Vec3(), 
            this._useGravity = !0, this._material = void 0, this._onCollidedListener = void 0, 
            this._onWorldBeforeStepListener = void 0, this._onWorldPostStepListener = void 0, 
            this._collisionCallbacks = [], this._shapes = [], this._transformSource = ETransformSource.SCENE, 
            this._userData = void 0, this._world = null, this._name = void 0, options = options || {}, 
            this._name = options.name || "", this._material = defaultCannonMaterial, this._body = new cannon.Body({
                material: this._material,
                type: ERigidBodyType.DYNAMIC
            }), setWrap(this._body, this), this._body.allowSleep = !0, this._body.sleepSpeedLimit = .1, 
            this._body.sleepTimeLimit = 1, this._onCollidedListener = this._onCollided.bind(this), 
            this._onWorldBeforeStepListener = this._onWorldBeforeStep.bind(this), this._onWorldPostStepListener = this._onWorldPostStep.bind(this), 
            this._body.preStep = function() {
                _this._onSelfPreStep();
            }, this._body.postStep = function() {
                _this._onSelfPostStep();
            };
        }
        return _createClass(CannonRigidBody, [ {
            key: "impl",
            get: function get() {
                return this._body;
            }
        } ]), _createClass(CannonRigidBody, [ {
            key: "getGroup",
            value: function getGroup() {
                return this._group;
            }
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                this._group = clamp(v, 0, 31), this._body.collisionFilterGroup = 1 << this._group;
            }
        }, {
            key: "setCollisionFilterGroup",
            value: function setCollisionFilterGroup(group) {
                this._body.collisionFilterGroup = group;
            }
        }, {
            key: "getCollisionFilterGroup",
            value: function getCollisionFilterGroup() {
                return this._body.collisionFilterGroup;
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                v = clamp(Math.floor(v), 0, 31), this._body.collisionFilterMask = 1 << v;
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                v = Math.floor(v), this._body.collisionFilterMask += 1 << v;
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                v = clamp(Math.floor(v), 0, 31), this._body.collisionFilterMask -= 1 << v;
            }
        }, {
            key: "getCollisionFilterMask",
            value: function getCollisionFilterMask() {
                return this._body.collisionFilterMask;
            }
        }, {
            key: "setCollisionFilterMask",
            value: function setCollisionFilterMask(v) {
                this._body.collisionFilterMask = v;
            }
        }, {
            key: "wakeUp",
            value: function wakeUp() {
                return this._body.wakeUp();
            }
        }, {
            key: "sleep",
            value: function sleep() {
                return this._body.sleep();
            }
        }, {
            key: "name",
            value: function name() {
                return this._name;
            }
        }, {
            key: "getType",
            value: function getType() {
                return this._body.type;
            }
        }, {
            key: "setType",
            value: function setType(v) {
                this._body.type = v;
            }
        }, {
            key: "addShape",
            value: function addShape(shape, offset) {
                var index = this._shapes.length;
                this._shapes.push(shape), null != offset ? this._body.addShape(shape.impl, toCannonVec3(offset)) : this._body.addShape(shape.impl), 
                shape._setBody(this._body, index);
            }
        }, {
            key: "removeShape",
            value: function removeShape(shape) {
                var i = this._shapes.indexOf(shape);
                if (!(i < 0)) {
                    this._removeShape(i);
                    for (var j = i + 1; j < this._shapes.length; ++j) {
                        this._shapes[j]._setIndex(j - 1);
                    }
                    this._shapes.splice(i, 1);
                }
            }
        }, {
            key: "getMass",
            value: function getMass() {
                return this._body.mass;
            }
        }, {
            key: "setMass",
            value: function setMass(value) {
                this._body.mass = value, this._body.updateMassProperties();
            }
        }, {
            key: "getIsKinematic",
            value: function getIsKinematic() {
                return this._body.type === cannon.Body.KINEMATIC;
            }
        }, {
            key: "setIsKinematic",
            value: function setIsKinematic(value) {
                this._body.type = value ? cannon.Body.KINEMATIC : cannon.Body.DYNAMIC;
            }
        }, {
            key: "getLinearDamping",
            value: function getLinearDamping() {
                return this._body.linearDamping;
            }
        }, {
            key: "setLinearDamping",
            value: function setLinearDamping(value) {
                this._body.linearDamping = value;
            }
        }, {
            key: "getAngularDamping",
            value: function getAngularDamping() {
                return this._body.angularDamping;
            }
        }, {
            key: "setAngularDamping",
            value: function setAngularDamping(value) {
                this._body.angularDamping = value;
            }
        }, {
            key: "getUseGravity",
            value: function getUseGravity() {
                return this._useGravity;
            }
        }, {
            key: "setUseGravity",
            value: function setUseGravity(value) {
                this._useGravity = value;
            }
        }, {
            key: "getIsTrigger",
            value: function getIsTrigger() {
                return this._body.collisionResponse;
            }
        }, {
            key: "setIsTrigger",
            value: function setIsTrigger(value) {
                this._body.collisionResponse = !value;
            }
        }, {
            key: "getVelocity",
            value: function getVelocity() {
                return vec3.copy(this._velocityResult, this._body.velocity), this._velocityResult;
            }
        }, {
            key: "setVelocity",
            value: function setVelocity(value) {
                vec3.copy(this._body.velocity, value);
            }
        }, {
            key: "getFreezeRotation",
            value: function getFreezeRotation() {
                return this._body.fixedRotation;
            }
        }, {
            key: "setFreezeRotation",
            value: function setFreezeRotation(value) {
                this._body.fixedRotation = value, this._body.updateMassProperties();
            }
        }, {
            key: "applyForce",
            value: function applyForce(force, position) {
                position || (position = new Vec3(), vec3.copy(position, this._body.position)), this._body.wakeUp(), 
                this._body.applyForce(toCannonVec3(force), toCannonVec3(position));
            }
        }, {
            key: "applyImpulse",
            value: function applyImpulse(impulse) {
                this._body.wakeUp(), this._body.applyImpulse(toCannonVec3(impulse), this._body.position);
            }
        }, {
            key: "setCollisionFilter",
            value: function setCollisionFilter(group, mask) {
                this._body.collisionFilterGroup = group, this._body.collisionFilterMask = mask;
            }
        }, {
            key: "setWorld",
            value: function setWorld(world) {
                this._world && (this._body.world.removeEventListener("postStep", this._onWorldPostStepListener), 
                this._world.removeBeforeStep(this._onWorldBeforeStepListener), this._body.removeEventListener("collide", this._onCollidedListener), 
                this._body.world.remove(this._body), this._world = null);
                var cworld = world;
                cworld && (cworld.impl.addBody(this._body), this._body.addEventListener("collide", this._onCollidedListener), 
                cworld.addBeforeStep(this._onWorldBeforeStepListener), this._body.world.addEventListener("postStep", this._onWorldPostStepListener)), 
                this._world = cworld;
            }
        }, {
            key: "isPhysicsManagedTransform",
            value: function isPhysicsManagedTransform() {
                return this._transformSource === ETransformSource.PHYSIC;
            }
        }, {
            key: "getPosition",
            value: function getPosition(out) {
                vec3.copy(out, this._body.position);
            }
        }, {
            key: "setPosition",
            value: function setPosition(value) {
                vec3.copy(this._body.position, value);
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {
                quat.copy(out, this._body.quaternion);
            }
        }, {
            key: "setRotation",
            value: function setRotation(value) {
                quat.copy(this._body.quaternion, value);
            }
        }, {
            key: "translateAndRotate",
            value: function translateAndRotate(m, rot) {
                mat4.getTranslation(this._body.position, m), quat.copy(this._body.quaternion, rot);
            }
        }, {
            key: "scaleAllShapes",
            value: function scaleAllShapes(scale) {
                var _iterator = this._shapes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.setScale(scale);
                }
            }
        }, {
            key: "addCollisionCallback",
            value: function addCollisionCallback(callback) {
                this._collisionCallbacks.push(callback);
            }
        }, {
            key: "removeCollisionCllback",
            value: function removeCollisionCllback(callback) {
                var i = this._collisionCallbacks.indexOf(callback);
                0 <= i && this._collisionCallbacks.splice(i, 1);
            }
        }, {
            key: "getUserData",
            value: function getUserData() {
                return this._userData;
            }
        }, {
            key: "setUserData",
            value: function setUserData(data) {
                this._userData = data;
            }
        }, {
            key: "_stringfyThis",
            value: function _stringfyThis() {
                return "".concat(this._name.length ? this._name : "<No-name>");
            }
        }, {
            key: "_devStrinfy",
            value: function _devStrinfy() {
                var shapes = this._body.shapes.map(function(s) {
                    return getWrap(s)._devStrinfy();
                }).join("; ");
                return "Name: [[".concat(this._name.length ? this._name : "<No-name>", "]], position: ").concat(stringfyVec3(this._body.position), ", shapes: [").concat(shapes, "]");
            }
        }, {
            key: "_resetBodyTypeAccordingMess",
            value: function _resetBodyTypeAccordingMess() {
                this._body.mass <= 0 ? this._body.type = cannon.Body.STATIC : this._body.type = cannon.Body.DYNAMIC;
            }
        }, {
            key: "_onBodyTypeUpdated",
            value: function _onBodyTypeUpdated() {
                this._body && (this._body.type === cannon.Body.STATIC ? this._transformSource = ETransformSource.SCENE : this._transformSource = ETransformSource.PHYSIC);
            }
        }, {
            key: "_onCollided",
            value: function _onCollided(event) {
                var evt = {
                    source: getWrap(event.body),
                    target: getWrap(event.target)
                }, _iterator2 = this._collisionCallbacks, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2("onCollisionStay", evt);
                }
            }
        }, {
            key: "_onWorldBeforeStep",
            value: function _onWorldBeforeStep() {}
        }, {
            key: "_onWorldPostStep",
            value: function _onWorldPostStep(event) {}
        }, {
            key: "_onSelfPreStep",
            value: function _onSelfPreStep() {
                this._useGravity || (this._body.force.y -= this._body.mass * this._body.world.gravity.y);
            }
        }, {
            key: "_onSelfPostStep",
            value: function _onSelfPostStep() {}
        }, {
            key: "_removeShape",
            value: function _removeShape(iShape) {
                var body = this._body, shape = body.shapes[iShape];
                body.shapes.splice(iShape, 1), body.shapeOffsets.splice(iShape, 1), body.shapeOrientations.splice(iShape, 1), 
                body.updateMassProperties(), body.updateBoundingRadius(), body.aabbNeedsUpdate = !0, 
                shape.body = null;
            }
        } ]), CannonRigidBody;
    }(), RaycastResult = function() {
        function RaycastResult() {
            _classCallCheck(this, RaycastResult), this._hitPoint = new Vec3(), this._distance = 0, 
            this._collidier = null, this._node = null;
        }
        return _createClass(RaycastResult, [ {
            key: "_assign",
            value: function _assign(hitPoint, distance, shape, body) {
                vec3.copy(this._hitPoint, hitPoint), this._distance = distance, this._node = body.getUserData(), 
                this._collidier = shape.getUserData();
            }
        }, {
            key: "hitPoint",
            get: function get() {
                return this._hitPoint;
            }
        }, {
            key: "distance",
            get: function get() {
                return this._distance;
            }
        }, {
            key: "collider",
            get: function get() {
                return this._collidier;
            }
        }, {
            key: "node",
            get: function get() {
                return this._node;
            }
        } ]), RaycastResult;
    }(), CannonWorld = function() {
        function CannonWorld() {
            _classCallCheck(this, CannonWorld), this._world = void 0, this._customBeforeStepListener = [], 
            this._customAfterStepListener = [], this._onCannonPreStepListener = void 0, this._onCannonPostStepListener = void 0, 
            this._raycastResult = new cannon.RaycastResult(), this._world = new cannon.World(), 
            setWrap(this._world, this), this._world.gravity.set(0, -9.81, 0), this._world.broadphase = new cannon.NaiveBroadphase(), 
            this._world.defaultMaterial = defaultCannonMaterial, this._world.defaultContactMaterial = defaultCannonContactMaterial, 
            this._onCannonPreStepListener = this._onCannonPreStep.bind(this), this._onCannonPostStepListener = this._onCannonPostStep.bind(this), 
            this._world.addEventListener("preStep", this._onCannonPreStepListener), this._world.addEventListener("postStep", this._onCannonPostStepListener);
        }
        return _createClass(CannonWorld, [ {
            key: "destroy",
            value: function destroy() {
                this._world.removeEventListener("preStep", this._onCannonPreStepListener), this._world.removeEventListener("postStep", this._onCannonPostStepListener);
            }
        }, {
            key: "step",
            value: function step(deltaTime) {
                this._callCustomBeforeSteps(), this._world.step(deltaTime), this._callCustomAfterSteps();
            }
        }, {
            key: "addBeforeStep",
            value: function addBeforeStep(cb) {
                this._customBeforeStepListener.push(cb);
            }
        }, {
            key: "removeBeforeStep",
            value: function removeBeforeStep(cb) {
                var i = this._customBeforeStepListener.indexOf(cb);
                i < 0 || this._customBeforeStepListener.splice(i, 1);
            }
        }, {
            key: "addAfterStep",
            value: function addAfterStep(cb) {
                this._customAfterStepListener.push(cb);
            }
        }, {
            key: "removeAfterStep",
            value: function removeAfterStep(cb) {
                var i = this._customAfterStepListener.indexOf(cb);
                i < 0 || this._customAfterStepListener.splice(i, 1);
            }
        }, {
            key: "raycastClosest",
            value: function raycastClosest(from, to, options, result) {
                var hit = this._world.raycastClosest(from, to, toCannonRaycastOptions(options), this._raycastResult);
                return hit && fillRaycastResult(result, this._raycastResult), hit;
            }
        }, {
            key: "raycastAny",
            value: function raycastAny(from, to, options, result) {
                var hit = this._world.raycastAny(from, to, toCannonRaycastOptions(options), this._raycastResult);
                return hit && fillRaycastResult(result, this._raycastResult), hit;
            }
        }, {
            key: "raycastAll",
            value: function raycastAll(from, to, options, callback) {
                return this._world.raycastAll(from, to, toCannonRaycastOptions(options), function(cannonResult) {
                    var result = new RaycastResult();
                    fillRaycastResult(result, cannonResult), callback(result);
                });
            }
        }, {
            key: "addConstraint",
            value: function addConstraint(constraint) {
                this._world.addConstraint(constraint.impl);
            }
        }, {
            key: "removeConstraint",
            value: function removeConstraint(constraint) {
                this._world.removeConstraint(constraint.impl);
            }
        }, {
            key: "_onCannonPreStep",
            value: function _onCannonPreStep() {}
        }, {
            key: "_onCannonPostStep",
            value: function _onCannonPostStep() {}
        }, {
            key: "_callCustomBeforeSteps",
            value: function _callCustomBeforeSteps() {
                this._customBeforeStepListener.forEach(function(fx) {
                    return fx();
                });
            }
        }, {
            key: "_callCustomAfterSteps",
            value: function _callCustomAfterSteps() {
                this._customAfterStepListener.forEach(function(fx) {
                    return fx();
                });
            }
        }, {
            key: "impl",
            get: function get() {
                return this._world;
            }
        } ]), CannonWorld;
    }(), CannonShape = function() {
        function CannonShape() {
            _classCallCheck(this, CannonShape), this._scale = new Vec3(1, 1, 1), this._shape = null, 
            this._body = null, this._index = -1, this._center = new Vec3(0, 0, 0), this._userData = void 0;
        }
        return _createClass(CannonShape, [ {
            key: "impl",
            get: function get() {
                return this._shape;
            }
        } ]), _createClass(CannonShape, [ {
            key: "getUserData",
            value: function getUserData() {
                return this._userData;
            }
        }, {
            key: "setUserData",
            value: function setUserData(data) {
                this._userData = data;
            }
        }, {
            key: "_setIndex",
            value: function _setIndex(index) {
                this._index = index, this._recalcCenter();
            }
        }, {
            key: "_setBody",
            value: function _setBody(body, index) {
                this._body = body, this._setIndex(index);
            }
        }, {
            key: "setCenter",
            value: function setCenter(center) {
                vec3.copy(this._center, center), this._recalcCenter();
            }
        }, {
            key: "setScale",
            value: function setScale(scale) {
                vec3.copy(this._scale, scale), this._recalcCenter();
            }
        }, {
            key: "setRotation",
            value: function setRotation(rotation) {}
        }, {
            key: "getCollisionResponse",
            value: function getCollisionResponse() {
                return this.impl.collisionResponse;
            }
        }, {
            key: "setCollisionResponse",
            value: function setCollisionResponse(v) {
                this.impl.collisionResponse = v;
            }
        }, {
            key: "_devStrinfy",
            value: function _devStrinfy() {
                return this._body ? "centerOffset: ".concat(stringfyVec3(this._body.shapeOffsets[this._index])) : "<NotAttached>";
            }
        }, {
            key: "_recalcCenter",
            value: function _recalcCenter() {
                if (this._body) {
                    var shapeOffset = this._body.shapeOffsets[this._index];
                    vec3.copy(shapeOffset, this._center), vec3.multiply(shapeOffset, shapeOffset, this._scale), 
                    commitShapeUpdates(this._body);
                }
            }
        } ]), CannonShape;
    }(), CannonBoxShape = function(_CannonShape) {
        function CannonBoxShape(size) {
            var _this;
            return _classCallCheck(this, CannonBoxShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonBoxShape).call(this)))._box = void 0, 
            _this._halfExtent = new cannon.Vec3(), vec3.scale(_this._halfExtent, size, .5), 
            _this._box = new cannon.Box(_this._halfExtent.clone()), setWrap(_this._box, _assertThisInitialized(_assertThisInitialized(_this))), 
            setWrap(_this._box.convexPolyhedronRepresentation, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._shape = _this._box, _this;
        }
        return _inherits(CannonBoxShape, CannonShape), _createClass(CannonBoxShape, [ {
            key: "setScale",
            value: function setScale(scale) {
                _get(_getPrototypeOf(CannonBoxShape.prototype), "setScale", this).call(this, scale), 
                this._recalcExtents();
            }
        }, {
            key: "setSize",
            value: function setSize(size) {
                vec3.scale(this._halfExtent, size, .5), this._recalcExtents();
            }
        }, {
            key: "_stringfyThis",
            value: function _stringfyThis() {
                return "".concat(this._body ? getWrap(this._body)._stringfyThis() : "<No-body>", "(Box)");
            }
        }, {
            key: "_devStrinfy",
            value: function _devStrinfy() {
                return "Box(".concat(_get(_getPrototypeOf(CannonBoxShape.prototype), "_devStrinfy", this).call(this), ", halfExtents: ").concat(stringfyVec3(this._box.halfExtents), ")");
            }
        }, {
            key: "_recalcExtents",
            value: function _recalcExtents() {
                vec3.multiply(this._box.halfExtents, this._halfExtent, this._scale), this._box.updateConvexPolyhedronRepresentation(), 
                setWrap(this._box.convexPolyhedronRepresentation, this), null != this._body && commitShapeUpdates(this._body);
            }
        } ]), CannonBoxShape;
    }(), CannonSphereShape = function(_CannonShape) {
        function CannonSphereShape(radius) {
            var _this;
            return _classCallCheck(this, CannonSphereShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonSphereShape).call(this)))._sphere = void 0, 
            _this._radius = 0, _this._radius = radius, _this._sphere = new cannon.Sphere(_this._radius), 
            setWrap(_this._sphere, _assertThisInitialized(_assertThisInitialized(_this))), _this._shape = _this._sphere, 
            _this;
        }
        return _inherits(CannonSphereShape, CannonShape), _createClass(CannonSphereShape, [ {
            key: "setScale",
            value: function setScale(scale) {
                _get(_getPrototypeOf(CannonSphereShape.prototype), "setScale", this).call(this, scale), 
                this._recalcRadius();
            }
        }, {
            key: "setRadius",
            value: function setRadius(radius) {
                this._radius = radius, this._recalcRadius();
            }
        }, {
            key: "_devStrinfy",
            value: function _devStrinfy() {
                return "Sphere(".concat(_get(_getPrototypeOf(CannonSphereShape.prototype), "_devStrinfy", this).call(this), ", radius: ").concat(this._sphere.radius, ")");
            }
        }, {
            key: "_recalcRadius",
            value: function _recalcRadius() {
                this._sphere.radius = this._radius * function maxComponent$1(v) {
                    return Math.max(v.x, Math.max(v.y, v.z));
                }(this._scale), null != this._body && commitShapeUpdates(this._body);
            }
        } ]), CannonSphereShape;
    }(), BuiltInBody = function() {
        function BuiltInBody(options) {
            _classCallCheck(this, BuiltInBody), this._id = void 0, this._type = ERigidBodyType.DYNAMIC, 
            this._group = 0, this._collisionFilterGroup = 1, this._collisionFilterMask = 1, 
            this._collisionCB = [], this._world = void 0, this._shapes = [], this.userData = void 0, 
            this._id = BuiltInBody.idCounter++;
        }
        return _createClass(BuiltInBody, [ {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "collisionFilterGroup",
            get: function get() {
                return this._collisionFilterGroup;
            }
        }, {
            key: "collisionFilterMask",
            get: function get() {
                return this._collisionFilterMask;
            }
        } ]), _createClass(BuiltInBody, [ {
            key: "getGroup",
            value: function getGroup() {
                return this._group;
            }
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                this._group = clamp(Math.floor(v), 0, 31), this._collisionFilterGroup = 1 << this._group;
            }
        }, {
            key: "getCollisionFilterGroup",
            value: function getCollisionFilterGroup() {
                return this._collisionFilterGroup;
            }
        }, {
            key: "setCollisionFilterGroup",
            value: function setCollisionFilterGroup(group) {
                this._collisionFilterGroup = group;
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                v = clamp(Math.floor(v), 0, 31), this._collisionFilterMask = 1 << v;
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                v = 1 << (v = clamp(Math.floor(v), 0, 31)), this._collisionFilterMask & v || (this._collisionFilterMask += v);
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                v = 1 << (v = clamp(Math.floor(v), 0, 31)), this._collisionFilterMask & v && (this._collisionFilterMask -= v);
            }
        }, {
            key: "getCollisionFilterMask",
            value: function getCollisionFilterMask() {
                return this._collisionFilterMask;
            }
        }, {
            key: "setCollisionFilterMask",
            value: function setCollisionFilterMask(v) {
                this._collisionFilterMask = v;
            }
        }, {
            key: "intersects",
            value: function intersects(body) {
                for (var i = 0; i < this._shapes.length; i++) for (var shapeA = this._shapes[i], j = 0; j < body._shapes.length; j++) {
                    var shapeB = body._shapes[j];
                    if (intersect.resolve(shapeA.worldShape, shapeB.worldShape)) return !0;
                }
                return !1;
            }
        }, {
            key: "onCollision",
            value: function onCollision(type, event) {
                var _iterator = this._collisionCB, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref(type, event);
                }
            }
        }, {
            key: "onTrigger",
            value: function onTrigger(type, event) {
                var _iterator2 = this._collisionCB, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2(type, event);
                }
            }
        }, {
            key: "wakeUp",
            value: function wakeUp() {}
        }, {
            key: "sleep",
            value: function sleep() {}
        }, {
            key: "addShape",
            value: function addShape(shape) {
                this._shapes.push(shape);
            }
        }, {
            key: "removeShape",
            value: function removeShape(shape) {
                var i = this._shapes.indexOf(shape);
                0 <= i && this._shapes.splice(i, 1);
            }
        }, {
            key: "setCollisionFilter",
            value: function setCollisionFilter(group, mask) {
                this._collisionFilterGroup = group, this._collisionFilterMask = mask;
            }
        }, {
            key: "setWorld",
            value: function setWorld(world) {
                var cworld = world;
                cworld ? cworld.addBody(this) : null != this._world && this._world.removeBody(this), 
                this._world = cworld;
            }
        }, {
            key: "getPosition",
            value: function getPosition(out) {}
        }, {
            key: "setPosition",
            value: function setPosition(pos) {
                var _iterator3 = this._shapes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.setPosition(pos);
                }
            }
        }, {
            key: "getRotation",
            value: function getRotation(out) {}
        }, {
            key: "setRotation",
            value: function setRotation(rot) {
                var _iterator4 = this._shapes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.setRotation(rot);
                }
            }
        }, {
            key: "scaleAllShapes",
            value: function scaleAllShapes(scale) {
                var _iterator5 = this._shapes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.setScale(scale);
                }
            }
        }, {
            key: "addCollisionCallback",
            value: function addCollisionCallback(callback) {
                this._collisionCB.push(callback);
            }
        }, {
            key: "removeCollisionCllback",
            value: function removeCollisionCllback(callback) {
                var i = this._collisionCB.indexOf(callback);
                0 <= i && this._collisionCB.splice(i, 1);
            }
        }, {
            key: "getUserData",
            value: function getUserData() {
                return this.userData;
            }
        }, {
            key: "setUserData",
            value: function setUserData(data) {
                this.userData = data;
            }
        }, {
            key: "transform",
            value: function transform(m, pos, rot, scale) {
                for (var i = this._shapes.length; i--; ) this._shapes[i].transform(m, pos, rot, scale);
            }
        }, {
            key: "translateAndRotate",
            value: function translateAndRotate(m, rot) {
                for (var i = this._shapes.length; i--; ) this._shapes[i].translateAndRotate(m, rot);
            }
        } ]), BuiltInBody;
    }();
    BuiltInBody.idCounter = 0;
    var BoxShape, SphereShape, RigidBody, PhysicsWorld, _global$1 = "undefined" == typeof window ? global : window;
    void 0 === _global$1.CC_PHYSICS_CANNON && (_global$1.CC_PHYSICS_CANNON = !1), void 0 === _global$1.CC_PHYSICS_AMMO && (_global$1.CC_PHYSICS_AMMO = !1), 
    void 0 === _global$1.CC_PHYSICS_BUILT_IN && (_global$1.CC_PHYSICS_BUILT_IN = !0), 
    BoxShape = CannonBoxShape, SphereShape = CannonSphereShape, RigidBody = CannonRigidBody, 
    PhysicsWorld = CannonWorld, cc.createRaycastResult = function createRaycastResult() {
        return new RaycastResult();
    };
    var _dec$12, _dec2$H, _dec3$u, _class$14, _class2$U, _descriptor$T, _descriptor2$K, PhysicsBasedComponent = function(_Component) {
        function PhysicsBasedComponent() {
            var _this;
            return _classCallCheck(this, PhysicsBasedComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsBasedComponent).call(this)))._sharedBody = void 0, 
            _this._isPreLoaded = !1, _this;
        }
        return _inherits(PhysicsBasedComponent, Component), _createClass(PhysicsBasedComponent, [ {
            key: "_body",
            get: function get() {
                return this._sharedBody.body;
            }
        }, {
            key: "sharedBody",
            get: function get() {
                return this._sharedBody;
            }
        }, {
            key: "_assertPreload",
            get: function get() {
                return this._isPreLoaded || console.error("Physic Error :", "Please make sure that the node has been added to the scene"), 
                this._isPreLoaded;
            }
        } ]), _createClass(PhysicsBasedComponent, [ {
            key: "getGroup",
            value: function getGroup() {
                return this._assertPreload ? this._body.getGroup() : 0;
            }
        }, {
            key: "setGroup",
            value: function setGroup(v) {
                if (this._assertPreload) return this._body.setGroup(v);
            }
        }, {
            key: "setCollisionFilterGroup",
            value: function setCollisionFilterGroup(v) {
                if (this._assertPreload) return this._body.setCollisionFilterGroup(v);
            }
        }, {
            key: "getCollisionFilterGroup",
            value: function getCollisionFilterGroup() {
                return this._assertPreload ? this._body.getCollisionFilterGroup() : 0;
            }
        }, {
            key: "setMask",
            value: function setMask(v) {
                if (this._assertPreload) return this._body.setMask(v);
            }
        }, {
            key: "addMask",
            value: function addMask(v) {
                if (this._assertPreload) return this._body.addMask(v);
            }
        }, {
            key: "removeMask",
            value: function removeMask(v) {
                if (this._assertPreload) return this._body.removeMask(v);
            }
        }, {
            key: "getCollisionFilterMask",
            value: function getCollisionFilterMask() {
                return this._assertPreload ? this._body.getCollisionFilterMask() : 0;
            }
        }, {
            key: "setCollisionFilterMask",
            value: function setCollisionFilterMask(v) {
                if (this._assertPreload) return this._body.setCollisionFilterMask(v);
            }
        }, {
            key: "setCollisionFilter",
            value: function setCollisionFilter(group, mask) {
                this._assertPreload && this._body.setCollisionFilter(group, mask);
            }
        }, {
            key: "__preload",
            value: function __preload() {
                if (null == this._sharedBody) {
                    var sharedBody = null, _iterator = this.node.getComponents(PhysicsBasedComponent), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var physicsBasedComponent = _ref;
                        if (physicsBasedComponent._sharedBody) {
                            sharedBody = physicsBasedComponent._sharedBody;
                            break;
                        }
                    }
                    sharedBody || (sharedBody = new SharedRigidBody(this.node, cc.director._physicsSystem.world)), 
                    sharedBody.ref(), this._sharedBody = sharedBody;
                }
                this._isPreLoaded = !0;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.sharedBody.enable();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.sharedBody.disable();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._sharedBody.deref(), this._sharedBody = null;
            }
        } ]), PhysicsBasedComponent;
    }(), SharedRigidBody = function() {
        function SharedRigidBody(node, world) {
            _classCallCheck(this, SharedRigidBody), this._body = void 0, this._refCount = 0, 
            this._actived = !1, this._world = void 0, this._node = void 0, this._worldScale = new Vec3(1, 1, 1), 
            this._beforeStepCallback = void 0, this._afterStepCallback = void 0, this._transformInitialized = !1, 
            this._isShapeOnly = !0, this._prevScale = new Vec3(), this._body = function createRigidBody(options) {
                return new RigidBody(options);
            }({
                name: node.name
            }), this._node = node, this._world = world, this._body.setUserData(this._node), 
            this._beforeStepCallback = this._beforeStep.bind(this), this._afterStepCallback = this._afterStep.bind(this);
        }
        return _createClass(SharedRigidBody, [ {
            key: "isShapeOnly",
            get: function get() {
                return this._isShapeOnly;
            }
        }, {
            key: "body",
            get: function get() {
                return this._body;
            }
        }, {
            key: "transfromSource",
            set: function set(v) {
                v === ETransformSource.SCENE ? this._isShapeOnly = !0 : this._isShapeOnly = !1;
            }
        } ]), _createClass(SharedRigidBody, [ {
            key: "ref",
            value: function ref() {
                ++this._refCount;
            }
        }, {
            key: "deref",
            value: function deref() {
                --this._refCount, this._refCount || this.destroy();
            }
        }, {
            key: "enable",
            value: function enable() {
                this._activeBody();
            }
        }, {
            key: "disable",
            value: function disable() {
                this._deactiveBody();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._deactiveBody(), this._body.setUserData(null), this._body = null, this._beforeStepCallback = null, 
                this._afterStepCallback = null, this._world = null, this._node = null;
            }
        }, {
            key: "syncPhysWithScene",
            value: function syncPhysWithScene(node) {
                node.getWorldMatrix(SharedRigidBody._tempMat4), node.getWorldRotation(SharedRigidBody._tempQuat), 
                this._body.translateAndRotate(SharedRigidBody._tempMat4, SharedRigidBody._tempQuat);
            }
        }, {
            key: "_syncSceneWithPhys",
            value: function _syncSceneWithPhys() {
                this._node && (this._body.getPosition(SharedRigidBody._tempVec3), this._node.setWorldPosition(SharedRigidBody._tempVec3), 
                this._body.getFreezeRotation() || (this._body.getRotation(SharedRigidBody._tempQuat), 
                this._node.setWorldRotation(SharedRigidBody._tempQuat)));
            }
        }, {
            key: "_activeBody",
            value: function _activeBody() {
                this._transformInitialized || (this._transformInitialized = !0, this.syncPhysWithScene(this._node)), 
                this._actived || (this._actived = !0, this._body.setWorld(this._world), this._world.addBeforeStep(this._beforeStepCallback), 
                this._world.addAfterStep(this._afterStepCallback), this._body.wakeUp());
            }
        }, {
            key: "_deactiveBody",
            value: function _deactiveBody() {
                this._actived && (this._actived = !1, this._world.removeBeforeStep(this._beforeStepCallback), 
                this._world.removeAfterStep(this._afterStepCallback), this._body.sleep(), this._body.setWorld(null));
            }
        }, {
            key: "_beforeStep",
            value: function _beforeStep() {
                this._node.hasChanged && (vec3.equals(this._prevScale, this._node.worldScale) || (this._body.scaleAllShapes(this._node.worldScale), 
                vec3.copy(this._prevScale, this._node.worldScale)), this.syncPhysWithScene(this._node));
            }
        }, {
            key: "_afterStep",
            value: function _afterStep() {
                this._isShapeOnly || this._body.getType() !== ERigidBodyType.DYNAMIC ? this._node.hasChanged && this.syncPhysWithScene(this._node) : this._syncSceneWithPhys();
            }
        } ]), SharedRigidBody;
    }();
    SharedRigidBody._tempMat4 = new Mat4(), SharedRigidBody._tempQuat = new Quat(), 
    SharedRigidBody._tempVec3 = new Vec3();
    var _dec$13, _dec2$I, _dec3$v, _dec4$o, _class$15, _class2$V, _descriptor$U, ColliderComponent = (_dec$12 = ccclass("cc.ColliderComponent"), 
    _dec2$H = property({
        displayOrder: 0
    }), _dec3$u = property({
        type: Vec3,
        displayOrder: 1,
        tooltip: "The center of the collider, in local space"
    }), _dec$12((_applyDecoratedDescriptor((_class2$U = function(_PhysicsBasedComponen) {
        function ColliderComponent() {
            var _this;
            return _classCallCheck(this, ColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ColliderComponent).call(this)))._callbackTable = createMap(!0), 
            _this._shapeBase = void 0, _this._collisionCallBack = void 0, _initializerDefineProperty(_this, "_isTrigger", _descriptor$T, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_center", _descriptor2$K, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._collisionCallBack = _this._onCollision.bind(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(ColliderComponent, PhysicsBasedComponent), _createClass(ColliderComponent, [ {
            key: "isTrigger",
            get: function get$$1() {
                return this._isTrigger;
            },
            set: function set(value$$1) {
                this._isTrigger = value$$1;
                var type = this._isTrigger ? ERigidBodyType.DYNAMIC : ERigidBodyType.STATIC;
                this.sharedBody.body.setType(type), this._shapeBase.setCollisionResponse(!this._isTrigger);
            }
        }, {
            key: "center",
            get: function get$$1() {
                return this._center;
            },
            set: function set(value$$1) {
                vec3.copy(this._center, value$$1), this._shapeBase.setCenter(this._center);
            }
        } ]), _createClass(ColliderComponent, [ {
            key: "on",
            value: function on(type, callback, target, useCapture) {}
        }, {
            key: "off",
            value: function off(type, callback, target, useCapture) {}
        }, {
            key: "once",
            value: function once(type, callback, target, useCapture) {}
        }, {
            key: "targetOff",
            value: function targetOff(keyOrTarget) {}
        }, {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {}
        }, {
            key: "hasEventListener",
            value: function hasEventListener(key, callback, target) {
                return !1;
            }
        }, {
            key: "removeAll",
            value: function removeAll(keyOrTarget) {}
        }, {
            key: "emit",
            value: function emit(key) {}
        }, {
            key: "onLoad",
            value: function onLoad() {
                this.sharedBody.transfromSource = ETransformSource.SCENE, this.sharedBody.body.setUseGravity(!1), 
                this.isTrigger = this._isTrigger, this.center = this._center;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(ColliderComponent.prototype), "onEnable", this).call(this), 
                this.sharedBody.body.addShape(this._shapeBase, this._center), this.sharedBody.body.addCollisionCallback(this._collisionCallBack);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.sharedBody.body.removeCollisionCllback(this._collisionCallBack), this.sharedBody.body.removeShape(this._shapeBase), 
                this.sharedBody.isShapeOnly && _get(_getPrototypeOf(ColliderComponent.prototype), "onDisable", this).call(this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.sharedBody.body.removeShape(this._shapeBase), _get(_getPrototypeOf(ColliderComponent.prototype), "onDestroy", this).call(this);
            }
        }, {
            key: "_onCollision",
            value: function _onCollision(type, event) {
                this.emit(type, type, {
                    source: event.source.getUserData(),
                    target: event.target.getUserData()
                });
            }
        } ]), ColliderComponent;
    }()).prototype, "isTrigger", [ _dec2$H ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "isTrigger"), _class2$U.prototype), 
    _applyDecoratedDescriptor(_class2$U.prototype, "center", [ _dec3$u ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "center"), _class2$U.prototype), 
    _descriptor$T = _applyDecoratedDescriptor(_class2$U.prototype, "_isTrigger", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor2$K = _applyDecoratedDescriptor(_class2$U.prototype, "_center", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new cc.Vec3(0, 0, 0);
        }
    }), _class$14 = _class2$U)) || _class$14);
    applyMixins(ColliderComponent, [ CallbacksInvoker, EventTarget ]);
    var _class$16, _class2$W, _descriptor$V, _dec$15, _dec2$K, _dec3$x, _dec4$p, _dec5$k, _dec6$j, _dec7$e, _dec8$a, _dec9$a, _class$17, _class2$X, _descriptor$W, _descriptor2$L, _descriptor3$A, _descriptor4$t, _descriptor5$p, _descriptor6$j, _descriptor7$f, _dec$16, _dec2$L, _dec3$y, _dec4$q, _dec5$l, _class$18, _class2$Y, _descriptor$X, _descriptor2$M, _descriptor3$B, _descriptor4$u, _dec$17, _dec2$M, _dec3$z, _dec4$r, _dec5$m, _dec6$k, _class$19, _class2$Z, _descriptor$Y, _descriptor2$N, _descriptor3$C, _descriptor4$v, _descriptor5$q, BoxColliderComponent = (_dec$13 = ccclass("cc.BoxColliderComponent"), 
    _dec2$I = executionOrder(98), _dec3$v = menu("Components/BoxColliderComponent"), 
    _dec4$o = property({
        type: Vec3
    }), _dec$13(_class$15 = _dec2$I(_class$15 = _dec3$v(_class$15 = executeInEditMode((_descriptor$U = _applyDecoratedDescriptor((_class2$V = function(_ColliderComponent) {
        function BoxColliderComponent() {
            var _this;
            return _classCallCheck(this, BoxColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderComponent).call(this)))._shape = void 0, 
            _initializerDefineProperty(_this, "_size", _descriptor$U, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._shape = function createBoxShape(size) {
                return new BoxShape(size);
            }(_this._size), _this._shape.setUserData(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this._shapeBase = _this._shape, _this;
        }
        return _inherits(BoxColliderComponent, ColliderComponent), _createClass(BoxColliderComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(BoxColliderComponent.prototype), "onLoad", this).call(this), 
                this.size = this._size, this._shape.setScale(this.node._scale);
            }
        }, {
            key: "size",
            get: function get$$1() {
                return this._size;
            },
            set: function set(value) {
                vec3.copy(this._size, value), this._shape.setSize(this._size);
            }
        } ]), BoxColliderComponent;
    }()).prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec3(0, 0, 0);
        }
    }), _applyDecoratedDescriptor(_class2$V.prototype, "size", [ _dec4$o ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "size"), _class2$V.prototype), 
    _class$15 = _class2$V)) || _class$15) || _class$15) || _class$15) || _class$15), SphereColliderComponent = ccclass("cc.SphereColliderComponent")(_class$16 = executionOrder(98)(_class$16 = menu("Components/SphereColliderComponent")(_class$16 = executeInEditMode((_descriptor$V = _applyDecoratedDescriptor((_class2$W = function(_ColliderComponent) {
        function SphereColliderComponent() {
            var _this;
            return _classCallCheck(this, SphereColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderComponent).call(this)))._shape = void 0, 
            _initializerDefineProperty(_this, "_radius", _descriptor$V, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._shape = function createSphereShape(radius) {
                return new SphereShape(radius);
            }(_this._radius), _this._shape.setUserData(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this._shapeBase = _this._shape, _this;
        }
        return _inherits(SphereColliderComponent, ColliderComponent), _createClass(SphereColliderComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                _get(_getPrototypeOf(SphereColliderComponent.prototype), "onLoad", this).call(this), 
                this.radius = this._radius, this._shape.setScale(this.node._scale);
            }
        }, {
            key: "radius",
            get: function get$$1() {
                return this._radius;
            },
            set: function set(value) {
                this._radius = value, this._shape.setRadius(value);
            }
        } ]), SphereColliderComponent;
    }()).prototype, "_radius", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _applyDecoratedDescriptor(_class2$W.prototype, "radius", [ property ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "radius"), _class2$W.prototype), 
    _class$16 = _class2$W)) || _class$16) || _class$16) || _class$16) || _class$16, NonRigidBodyProperties_mass = 10, NonRigidBodyProperties_linearDamping = 0, NonRigidBodyProperties_angularDamping = 0, RigidBodyComponent = (_dec$15 = ccclass("cc.RigidBodyComponent"), 
    _dec2$K = executionOrder(99), _dec3$x = menu("Components/RigidBodyComponent"), _dec4$p = property({
        displayOrder: 0
    }), _dec5$k = property({
        displayOrder: 1
    }), _dec6$j = property({
        displayOrder: 2
    }), _dec7$e = property({
        displayOrder: 3
    }), _dec8$a = property({
        displayOrder: 4
    }), _dec9$a = property({
        displayOrder: 5
    }), _dec$15(_class$17 = _dec2$K(_class$17 = _dec3$x(_class$17 = executeInEditMode((_applyDecoratedDescriptor((_class2$X = function(_PhysicsBasedComponen) {
        function RigidBodyComponent() {
            var _this;
            return _classCallCheck(this, RigidBodyComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RigidBodyComponent).call(this)), "_material", _descriptor$W, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_mass", _descriptor2$L, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_linearDamping", _descriptor3$A, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_angularDamping", _descriptor4$t, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fixedRotation", _descriptor5$p, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isKinematic", _descriptor6$j, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_useGravity", _descriptor7$f, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(RigidBodyComponent, PhysicsBasedComponent), _createClass(RigidBodyComponent, [ {
            key: "mass",
            get: function get() {
                return this._mass;
            },
            set: function set(value) {
                this._mass = value, this._body.setMass(value);
            }
        }, {
            key: "linearDamping",
            get: function get() {
                return this._linearDamping;
            },
            set: function set(value) {
                this._linearDamping = value, this._body.setLinearDamping(value);
            }
        }, {
            key: "angularDamping",
            get: function get() {
                return this._angularDamping;
            },
            set: function set(value) {
                this._angularDamping = value, this._body.setAngularDamping(value);
            }
        }, {
            key: "isKinematic",
            get: function get() {
                return this._isKinematic;
            },
            set: function set(value) {
                this._isKinematic = value, this._body.setIsKinematic(value);
            }
        }, {
            key: "useGravity",
            get: function get() {
                return this._useGravity;
            },
            set: function set(value) {
                this._useGravity = value, this._body.setUseGravity(value);
            }
        }, {
            key: "fixedRotation",
            get: function get() {
                return this._fixedRotation;
            },
            set: function set(value) {
                this._fixedRotation = value, this._body.setFreezeRotation(value);
            }
        } ]), _createClass(RigidBodyComponent, [ {
            key: "applyForce",
            value: function applyForce(force, position) {
                this._assertPreload && this._body.applyForce(force, position);
            }
        }, {
            key: "applyImpulse",
            value: function applyImpulse(impulse, position) {
                this._assertPreload && this._body.applyImpulse(impulse, position);
            }
        }, {
            key: "wakeUp",
            value: function wakeUp() {
                this._assertPreload && this._body.wakeUp();
            }
        }, {
            key: "sleep",
            value: function sleep() {
                this._assertPreload && this._body.sleep();
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                this.sharedBody && (this.sharedBody.transfromSource = ETransformSource.PHYSIC, this.mass = this._mass, 
                this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, 
                this.useGravity = this._useGravity, this.isKinematic = this._isKinematic, this.fixedRotation = this._fixedRotation);
            }
        } ]), RigidBodyComponent;
    }()).prototype, "mass", [ _dec4$p ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "mass"), _class2$X.prototype), 
    _applyDecoratedDescriptor(_class2$X.prototype, "linearDamping", [ _dec5$k ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "linearDamping"), _class2$X.prototype), 
    _applyDecoratedDescriptor(_class2$X.prototype, "angularDamping", [ _dec6$j ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "angularDamping"), _class2$X.prototype), 
    _applyDecoratedDescriptor(_class2$X.prototype, "isKinematic", [ _dec7$e ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "isKinematic"), _class2$X.prototype), 
    _applyDecoratedDescriptor(_class2$X.prototype, "useGravity", [ _dec8$a ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "useGravity"), _class2$X.prototype), 
    _applyDecoratedDescriptor(_class2$X.prototype, "fixedRotation", [ _dec9$a ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "fixedRotation"), _class2$X.prototype), 
    _descriptor$W = _applyDecoratedDescriptor(_class2$X.prototype, "_material", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$L = _applyDecoratedDescriptor(_class2$X.prototype, "_mass", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return NonRigidBodyProperties_mass;
        }
    }), _descriptor3$A = _applyDecoratedDescriptor(_class2$X.prototype, "_linearDamping", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return NonRigidBodyProperties_linearDamping;
        }
    }), _descriptor4$t = _applyDecoratedDescriptor(_class2$X.prototype, "_angularDamping", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return NonRigidBodyProperties_angularDamping;
        }
    }), _descriptor5$p = _applyDecoratedDescriptor(_class2$X.prototype, "_fixedRotation", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor6$j = _applyDecoratedDescriptor(_class2$X.prototype, "_isKinematic", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor7$f = _applyDecoratedDescriptor(_class2$X.prototype, "_useGravity", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _class$17 = _class2$X)) || _class$17) || _class$17) || _class$17) || _class$17), SphereLightComponent = (_dec$16 = ccclass("cc.SphereLightComponent"), 
    _dec2$L = menu("Components/SphereLightComponent"), _dec3$y = property({
        unit: "lm"
    }), _dec4$q = property({
        unit: "cd/m²"
    }), _dec5$l = property({
        type: PhotometricTerm
    }), _dec$16(_class$18 = _dec2$L(_class$18 = executeInEditMode((_descriptor$X = _applyDecoratedDescriptor((_class2$Y = function(_LightComponent) {
        function SphereLightComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SphereLightComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SphereLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_size", _descriptor$X, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_luminance", _descriptor2$M, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_term", _descriptor3$B, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_range", _descriptor4$u, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._type = LightType.SPHERE, _this._light = null, _this;
        }
        return _inherits(SphereLightComponent, LightComponent), _createClass(SphereLightComponent, [ {
            key: "_createLight",
            value: function _createLight(scene) {
                var _this2 = this;
                this.node.scene && (scene || (scene = this._getRenderScene()), this._light && scene.sphereLights.find(function(c) {
                    return c === _this2._light;
                }) || (this._light = scene.createSphereLight(this.name, this.node), this._light ? (this._light.luminance = this._luminance, 
                this.size = this._size, this.range = this._range, _get(_getPrototypeOf(SphereLightComponent.prototype), "_createLight", this).call(this, scene)) : console.warn("we don't support this many lights in forward pipeline.")));
            }
        }, {
            key: "_destroyLight",
            value: function _destroyLight(scene) {
                this.node.scene && this._light && (scene || (scene = this._getRenderScene()), scene.destroySphereLight(this._light), 
                _get(_getPrototypeOf(SphereLightComponent.prototype), "_destroyLight", this).call(this, scene));
            }
        }, {
            key: "luminousPower",
            get: function get$$1() {
                return this._luminance * nt2lm(this._size);
            },
            set: function set(val) {
                this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
            }
        }, {
            key: "luminance",
            get: function get$$1() {
                return this._luminance;
            },
            set: function set(val) {
                this._luminance = val, this._light && (this._light.luminance = val);
            }
        }, {
            key: "term",
            get: function get$$1() {
                return this._term;
            },
            set: function set(val) {
                this._term = val;
            }
        }, {
            key: "size",
            get: function get$$1() {
                return this._size;
            },
            set: function set(val) {
                this._size = val, this._light && (this._light.size = val);
            }
        }, {
            key: "range",
            get: function get$$1() {
                return this._range;
            },
            set: function set(val) {
                this._range = val, this._light && (this._light.range = val);
            }
        } ]), SphereLightComponent;
    }()).prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .15;
        }
    }), _descriptor2$M = _applyDecoratedDescriptor(_class2$Y.prototype, "_luminance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1700 / nt2lm(.15);
        }
    }), _descriptor3$B = _applyDecoratedDescriptor(_class2$Y.prototype, "_term", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PhotometricTerm.LUMINOUS_POWER;
        }
    }), _descriptor4$u = _applyDecoratedDescriptor(_class2$Y.prototype, "_range", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$Y.prototype, "luminousPower", [ _dec3$y ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "luminousPower"), _class2$Y.prototype), 
    _applyDecoratedDescriptor(_class2$Y.prototype, "luminance", [ _dec4$q ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "luminance"), _class2$Y.prototype), 
    _applyDecoratedDescriptor(_class2$Y.prototype, "term", [ _dec5$l ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "term"), _class2$Y.prototype), 
    _applyDecoratedDescriptor(_class2$Y.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "size"), _class2$Y.prototype), 
    _applyDecoratedDescriptor(_class2$Y.prototype, "range", [ property ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "range"), _class2$Y.prototype), 
    _class$18 = _class2$Y)) || _class$18) || _class$18) || _class$18), SpotLightComponent = (_dec$17 = ccclass("cc.SpotLightComponent"), 
    _dec2$M = menu("Components/SpotLightComponent"), _dec3$z = property({
        unit: "lm"
    }), _dec4$r = property({
        unit: "cd/m²"
    }), _dec5$m = property({
        type: PhotometricTerm
    }), _dec6$k = property({
        slide: !0,
        range: [ 2, 180, 1 ]
    }), _dec$17(_class$19 = _dec2$M(_class$19 = executeInEditMode((_descriptor$Y = _applyDecoratedDescriptor((_class2$Z = function(_LightComponent) {
        function SpotLightComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SpotLightComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpotLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_size", _descriptor$Y, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_luminance", _descriptor2$N, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_term", _descriptor3$C, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_range", _descriptor4$v, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_spotAngle", _descriptor5$q, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._type = LightType.SPOT, _this._light = null, _this;
        }
        return _inherits(SpotLightComponent, LightComponent), _createClass(SpotLightComponent, [ {
            key: "_createLight",
            value: function _createLight(scene) {
                var _this2 = this;
                this.node.scene && (scene || (scene = this._getRenderScene()), this._light && scene.spotLights.find(function(c) {
                    return c === _this2._light;
                }) || (this._light = scene.createSpotLight(this.name, this.node), this._light ? (this._light.luminance = this._luminance, 
                this.size = this._size, this.range = this._range, this.spotAngle = this._spotAngle, 
                _get(_getPrototypeOf(SpotLightComponent.prototype), "_createLight", this).call(this, scene)) : console.warn("we don't support this many lights in forward pipeline.")));
            }
        }, {
            key: "_destroyLight",
            value: function _destroyLight(scene) {
                this.node.scene && this._light && (scene || (scene = this._getRenderScene()), scene.destroySpotLight(this._light), 
                _get(_getPrototypeOf(SpotLightComponent.prototype), "_destroyLight", this).call(this, scene));
            }
        }, {
            key: "luminousPower",
            get: function get$$1() {
                return this._luminance * nt2lm(this._size);
            },
            set: function set(val) {
                this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
            }
        }, {
            key: "luminance",
            get: function get$$1() {
                return this._luminance;
            },
            set: function set(val) {
                this._luminance = val, this._light && (this._light.luminance = val);
            }
        }, {
            key: "term",
            get: function get$$1() {
                return this._term;
            },
            set: function set(val) {
                this._term = val;
            }
        }, {
            key: "size",
            get: function get$$1() {
                return this._size;
            },
            set: function set(val) {
                this._size = val, this._light && (this._light.size = val);
            }
        }, {
            key: "range",
            get: function get$$1() {
                return this._range;
            },
            set: function set(val) {
                this._range = val, this._light && (this._light.range = val);
            }
        }, {
            key: "spotAngle",
            get: function get$$1() {
                return this._spotAngle;
            },
            set: function set(val) {
                this._spotAngle = val, this._light && (this._light.spotAngle = toRadian(val));
            }
        } ]), SpotLightComponent;
    }()).prototype, "_size", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .15;
        }
    }), _descriptor2$N = _applyDecoratedDescriptor(_class2$Z.prototype, "_luminance", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1700 / nt2lm(.15);
        }
    }), _descriptor3$C = _applyDecoratedDescriptor(_class2$Z.prototype, "_term", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return PhotometricTerm.LUMINOUS_POWER;
        }
    }), _descriptor4$v = _applyDecoratedDescriptor(_class2$Z.prototype, "_range", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor5$q = _applyDecoratedDescriptor(_class2$Z.prototype, "_spotAngle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 60;
        }
    }), _applyDecoratedDescriptor(_class2$Z.prototype, "luminousPower", [ _dec3$z ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "luminousPower"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "luminance", [ _dec4$r ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "luminance"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "term", [ _dec5$m ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "term"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "size"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "range", [ property ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "range"), _class2$Z.prototype), 
    _applyDecoratedDescriptor(_class2$Z.prototype, "spotAngle", [ _dec6$k ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "spotAngle"), _class2$Z.prototype), 
    _class$19 = _class2$Z)) || _class$19) || _class$19) || _class$19), PhysicsSystem = function() {
        function PhysicsSystem() {
            _classCallCheck(this, PhysicsSystem), this._world = void 0, this._paused = !1, this._singleStep = !1, 
            this._deltaTime = 1 / 60, this._world = function createPhysicsWorld() {
                return new PhysicsWorld();
            }();
        }
        return _createClass(PhysicsSystem, [ {
            key: "setSingleStep",
            value: function setSingleStep(b) {
                this._singleStep = b;
            }
        }, {
            key: "resume",
            value: function resume() {
                this._paused = !1;
            }
        }, {
            key: "pause",
            value: function pause() {
                this._paused = !0;
            }
        }, {
            key: "update",
            value: function update(deltaTime) {
                this._paused || (this._world.step(this._deltaTime), this._singleStep && (this._paused = !0));
            }
        }, {
            key: "world",
            get: function get() {
                return this._world;
            }
        } ]), PhysicsSystem;
    }();
    function applyDefaultGeometryOptions(options) {
        return void 0 === (options = options || {}).includeNormal && (options.includeNormal = !0), 
        void 0 === options.includeUV && (options.includeUV = !0), options;
    }
    function box(options) {
        var ws = (options = options || {}).widthSegments || 1, hs = options.heightSegments || 1, ls = options.lengthSegments || 1, hw = (options.width || 1) / 2, hh = (options.height || 1) / 2, hl = (options.length || 1) / 2, corners = [ vec3.set(c0, -hw, -hh, hl), vec3.set(c1, hw, -hh, hl), vec3.set(c2, hw, hh, hl), vec3.set(c3, -hw, hh, hl), vec3.set(c4, hw, -hh, -hl), vec3.set(c5, -hw, -hh, -hl), vec3.set(c6, -hw, hh, -hl), vec3.set(c7, hw, hh, -hl) ], faceAxes = [ [ 2, 3, 1 ], [ 4, 5, 7 ], [ 7, 6, 2 ], [ 1, 0, 4 ], [ 1, 4, 2 ], [ 5, 0, 6 ] ], faceNormals = [ [ 0, 0, 1 ], [ 0, 0, -1 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 1, 0, 0 ], [ -1, 0, 0 ] ], positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-hw, -hh, -hl), maxPos = new Vec3(hw, hh, hl), boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
        function _buildPlane(side, uSegments, vSegments) {
            var u, v, ix, iy, offset = positions.length / 3, faceAxe = faceAxes[side], faceNormal = faceNormals[side];
            for (iy = 0; iy <= vSegments; iy++) for (ix = 0; ix <= uSegments; ix++) if (u = ix / uSegments, 
            v = iy / vSegments, vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u), 
            vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v), vec3.subtract(temp3, temp2, corners[faceAxe[0]]), 
            vec3.add(r, temp1, temp3), positions.push(r.x, r.y, r.z), normals.push(faceNormal[0], faceNormal[1], faceNormal[2]), 
            uvs.push(u, v), ix < uSegments && iy < vSegments) {
                var useg1 = uSegments + 1, a = ix + iy * useg1, b = ix + (iy + 1) * useg1, c = ix + 1 + (iy + 1) * useg1, d = ix + 1 + iy * useg1;
                indices.push(offset + a, offset + d, offset + b), indices.push(offset + b, offset + d, offset + c);
            }
        }
        return _buildPlane(0, ws, hs), _buildPlane(4, ls, hs), _buildPlane(1, ws, hs), _buildPlane(5, ls, hs), 
        _buildPlane(3, ws, ls), _buildPlane(2, ws, ls), {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    }
    cc.AudioSourceComponent = AudioSourceComponent, cc.CameraComponent = CameraComponent, 
    cc.EditorComponent = EditorCameraComponent, cc.RenderableComponent = RenderableComponent, 
    cc.ModelComponent = ModelComponent, cc.SkinningModelComponent = SkinningModelComponent, 
    cc.AvatarModelComponent = AvatarModelComponent, cc.AvatarUnit = AvatarUnit, cc.BatchedSkinningModelComponent = BatchedSkinningModelComponent, 
    cc.SkinningModelUnit = SkinningModelUnit, cc.LightComponent = LightComponent, cc.DirectionalLightComponent = DirectionalLightComponent, 
    cc.SphereLightComponent = SphereLightComponent, cc.SpotLightComponent = SpotLightComponent, 
    cc.ParticleSystemComponent = ParticleSystemComponent, cc.BillboardComponent = BillboardComponent, 
    cc.LineComponent = LineComponent, cc.ColliderComponent = ColliderComponent, cc.BoxColliderComponent = BoxColliderComponent, 
    cc.SphereColliderComponent = SphereColliderComponent, cc.RigidBodyComponent = RigidBodyComponent, 
    cc.ParticleUtils = ParticleUtils;
    var temp1 = new Vec3(), temp2 = new Vec3(), temp3 = new Vec3(), r = new Vec3(), c0 = new Vec3(), c1 = new Vec3(), c2 = new Vec3(), c3 = new Vec3(), c4 = new Vec3(), c5 = new Vec3(), c6 = new Vec3(), c7 = new Vec3(), temp1$1 = vec3.create(0, 0, 0), temp2$1 = vec3.create(0, 0, 0);
    function cylinder() {
        var radiusTop = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .5, height = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 2, opts = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {}, halfHeight = .5 * height, radialSegments = opts.radialSegments || 32, heightSegments = opts.heightSegments || 1, capped = void 0 === opts.capped || opts.capped, arc = opts.arc || 2 * Math.PI, cntCap = 0;
        capped || (0 < radiusTop && cntCap++, 0 < radiusBottom && cntCap++);
        var vertCount = (radialSegments + 1) * (heightSegments + 1);
        capped && (vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap);
        var indexCount = radialSegments * heightSegments * 2 * 3;
        capped && (indexCount += radialSegments * cntCap * 3);
        var indices = new Array(indexCount), positions = new Array(3 * vertCount), normals = new Array(3 * vertCount), uvs = new Array(2 * vertCount), maxRadius = Math.max(radiusTop, radiusBottom), minPos = vec3.create(-maxRadius, -halfHeight, -maxRadius), maxPos = vec3.create(maxRadius, halfHeight, maxRadius), boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight), index = 0, indexOffset = 0;
        return function generateTorso() {
            for (var indexArray = [], r = radiusTop - radiusBottom, slope = r * r / height * Math.sign(r), y = 0; y <= heightSegments; y++) {
                for (var indexRow = [], v = y / heightSegments, radius = v * r + radiusBottom, x = 0; x <= radialSegments; ++x) {
                    var u = x / radialSegments, theta = u * arc, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = v * height - halfHeight, 
                    positions[3 * index + 2] = radius * cosTheta, vec3.normalize(temp1$1, vec3.set(temp2$1, sinTheta, -slope, cosTheta)), 
                    normals[3 * index] = temp1$1.x, normals[3 * index + 1] = temp1$1.y, normals[3 * index + 2] = temp1$1.z, 
                    uvs[2 * index] = 2 * (1 - u) % 1, uvs[2 * index + 1] = v, indexRow.push(index), 
                    ++index;
                }
                indexArray.push(indexRow);
            }
            for (var _y = 0; _y < heightSegments; ++_y) for (var _x = 0; _x < radialSegments; ++_x) {
                var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                indices[indexOffset] = i1, indices[++indexOffset] = i4, indices[++indexOffset] = i2, 
                indices[++indexOffset] = i4, indices[++indexOffset] = i3, indices[++indexOffset] = i2, 
                ++indexOffset;
            }
        }(), capped && (0 < radiusBottom && generateCap(!1), 0 < radiusTop && generateCap(!0)), 
        {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
        function generateCap(top) {
            for (var radius = top ? radiusTop : radiusBottom, sign$$1 = top ? 1 : -1, centerIndexStart = index, x = 1; x <= radialSegments; ++x) positions[3 * index] = 0, 
            positions[3 * index + 1] = halfHeight * sign$$1, positions[3 * index + 2] = 0, normals[3 * index] = 0, 
            normals[3 * index + 1] = sign$$1, normals[3 * index + 2] = 0, uvs[2 * index] = .5, 
            uvs[2 * index + 1] = .5, ++index;
            for (var centerIndexEnd = index, _x2 = 0; _x2 <= radialSegments; ++_x2) {
                var theta = _x2 / radialSegments * arc, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = halfHeight * sign$$1, 
                positions[3 * index + 2] = radius * cosTheta, normals[3 * index] = 0, normals[3 * index + 1] = sign$$1, 
                normals[3 * index + 2] = 0, uvs[2 * index] = .5 - .5 * sinTheta * sign$$1, uvs[2 * index + 1] = .5 + .5 * cosTheta, 
                ++index;
            }
            for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
                var c = centerIndexStart + _x3, i = centerIndexEnd + _x3;
                indices[++indexOffset] = (indices[++indexOffset] = top ? (indices[indexOffset] = i + 1, 
                c) : (indices[indexOffset] = c, i + 1), i), ++indexOffset;
            }
        }
    }
    var temp1$2 = vec3.create(0, 0, 0), temp2$2 = vec3.create(0, 0, 0), temp3$1 = vec3.create(0, 0, 0), r$1 = vec3.create(0, 0, 0), c00 = vec3.create(0, 0, 0), c10 = vec3.create(0, 0, 0), c01 = vec3.create(0, 0, 0);
    var temp1$3 = vec3.create(0, 0, 0), temp2$3 = vec3.create(0, 0, 0);
    var _dec$18, _dec2$N, _dec3$A, _dec4$s, _dec5$n, _class$1a, _class2$_, _descriptor$Z, _descriptor2$O, _class3$j, _temp$16, _dec$19, _dec2$O, _dec3$B, _dec4$t, _dec5$o, _class$1b, _class2$10, _descriptor$_, primitives = Object.freeze({
        box: box,
        cone: function cone() {
            return cylinder(0, 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {});
        },
        cylinder: cylinder,
        plane: function plane$1(options) {
            var normalizedOptions = function applyDefaultPlaneOptions(options) {
                return (options = applyDefaultGeometryOptions(options)).width = options.width || 10, 
                options.length = options.length || 10, options.widthSegments = options.widthSegments || 10, 
                options.lengthSegments = options.lengthSegments || 10, options;
            }(options), width = normalizedOptions.width, length = normalizedOptions.length, uSegments = normalizedOptions.widthSegments, vSegments = normalizedOptions.lengthSegments, hw = .5 * width, hl = .5 * length, positions = [], uvs = [], indices = [], minPos = new Vec3(-hw, 0, -hl), maxPos = new Vec3(hw, 0, hl), boundingRadius = Math.sqrt(width * width + length * length);
            vec3.set(c00, -hw, 0, hl), vec3.set(c10, hw, 0, hl), vec3.set(c01, -hw, 0, -hl);
            for (var y = 0; y <= vSegments; y++) for (var x = 0; x <= uSegments; x++) {
                var u = x / uSegments, v = y / vSegments;
                if (vec3.lerp(temp1$2, c00, c10, u), vec3.lerp(temp2$2, c00, c01, v), vec3.subtract(temp3$1, temp2$2, c00), 
                vec3.add(r$1, temp1$2, temp3$1), positions.push(r$1.x, r$1.y, r$1.z), normalizedOptions.includeUV && uvs.push(u, v), 
                x < uSegments && y < vSegments) {
                    var useg1 = uSegments + 1, a = x + y * useg1, b = x + (y + 1) * useg1, c = x + 1 + (y + 1) * useg1, d = x + 1 + y * useg1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
            var result = {
                positions: positions,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
            if (normalizedOptions.includeNormal) {
                var nVertex = (vSegments + 1) * (uSegments + 1), normals = new Array(3 * nVertex);
                result.normals = normals;
                for (var i = 0; i < nVertex; ++i) normals[3 * i + 0] = 0, normals[3 * i + 1] = 1, 
                normals[3 * i + 2] = 0;
            }
            return normalizedOptions.includeUV && (result.uvs = uvs), result;
        },
        quad: function quad(options) {
            var normalizedOptions = applyDefaultGeometryOptions(options), result = {
                positions: [ -.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0 ],
                indices: [ 0, 3, 1, 3, 2, 1 ],
                minPos: {
                    x: -.5,
                    y: -.5,
                    z: 0
                },
                maxPos: {
                    x: .5,
                    y: .5,
                    z: 0
                },
                boundingRadius: Math.sqrt(.5)
            };
            return !1 !== normalizedOptions.includeNormal && (result.normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]), 
            !1 !== normalizedOptions.includeUV && (result.uvs = [ 0, 0, 0, 1, 1, 1, 1, 0 ]), 
            result;
        },
        sphere: function sphere$1() {
            for (var radius = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, opts = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, segments = void 0 !== opts.segments ? opts.segments : 32, positions = [], normals = [], uvs = [], indices = [], minPos = vec3.create(-radius, -radius, -radius), maxPos = vec3.create(radius, radius, radius), boundingRadius = radius, lat = 0; lat <= segments; ++lat) for (var theta = lat * Math.PI / segments, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= segments; ++lon) {
                var phi = 2 * lon * Math.PI / segments - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / segments, v = lat / segments;
                if (positions.push(x * radius, y * radius, z * radius), normals.push(x, y, z), uvs.push(u, v), 
                lat < segments && lon < segments) {
                    var seg1 = segments + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
            return {
                positions: positions,
                indices: indices,
                normals: normals,
                uvs: uvs,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
        },
        torus: function torus() {
            for (var radius = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .4, tube = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .1, opts = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}, radialSegments = opts.radialSegments || 32, tubularSegments = opts.tubularSegments || 32, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], minPos = vec3.create(-radius - tube, -tube, -radius - tube), maxPos = vec3.create(radius + tube, tube, radius + tube), boundingRadius = radius + tube, j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments, v = j / radialSegments, u1 = u * arc, v1 = v * Math.PI * 2, x = (radius + tube * Math.cos(v1)) * Math.sin(u1), y = tube * Math.sin(v1), z = (radius + tube * Math.cos(v1)) * Math.cos(u1), nx = Math.sin(u1) * Math.cos(v1), ny = Math.sin(v1), nz = Math.cos(u1) * Math.cos(v1);
                if (positions.push(x, y, z), normals.push(nx, ny, nz), uvs.push(u, v), i < tubularSegments && j < radialSegments) {
                    var seg1 = tubularSegments + 1, a = seg1 * j + i, b = seg1 * (j + 1) + i, c = seg1 * (j + 1) + i + 1, d = seg1 * j + i + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
            return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
        },
        capsule: function capsule() {
            var radiusTop = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .5, height = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 2, opts = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {}, torsoHeight = height - radiusTop - radiusBottom, sides = opts.sides || 32, heightSegments = opts.heightSegments || 32, bottomProp = radiusBottom / height, torProp = torsoHeight / height, topProp = radiusTop / height, bottomSegments = Math.floor(heightSegments * bottomProp), topSegments = Math.floor(heightSegments * topProp), torSegments = Math.floor(heightSegments * torProp), topOffset = torsoHeight + radiusBottom - height / 2, torOffset = radiusBottom - height / 2, bottomOffset = radiusBottom - height / 2, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], maxRadius = Math.max(radiusTop, radiusBottom), minPos = vec3.create(-maxRadius, -height / 2, -maxRadius), maxPos = vec3.create(maxRadius, height / 2, maxRadius), boundingRadius = height / 2, index = 0, indexArray = [];
            return function generateBottom() {
                for (var lat = 0; lat <= bottomSegments; ++lat) for (var theta = lat * Math.PI / bottomSegments / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                    var phi = 2 * lon * Math.PI / sides - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / sides, v = lat / heightSegments;
                    if (positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom), 
                    normals.push(x, y, z), uvs.push(u, v), lat < bottomSegments && lon < sides) {
                        var seg1 = sides + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                        indices.push(a, d, b), indices.push(d, c, b);
                    }
                    ++index;
                }
            }(), function generateTorso() {
                for (var slope = (radiusTop - radiusBottom) / torsoHeight, y = 0; y <= torSegments; y++) {
                    for (var indexRow = [], lat = y / torSegments, radius = lat * (radiusTop - radiusBottom) + radiusBottom, x = 0; x <= sides; ++x) {
                        var u = x / sides, v = lat * torProp + bottomProp, theta = u * arc - arc / 4, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                        positions.push(radius * sinTheta), positions.push(lat * torsoHeight + torOffset), 
                        positions.push(radius * cosTheta), vec3.normalize(temp1$3, vec3.set(temp2$3, sinTheta, -slope, cosTheta)), 
                        normals.push(temp1$3.x), normals.push(temp1$3.y), normals.push(temp1$3.z), uvs.push(u, v), 
                        indexRow.push(index), ++index;
                    }
                    indexArray.push(indexRow);
                }
                for (var _y = 0; _y < torSegments; ++_y) for (var _x = 0; _x < sides; ++_x) {
                    var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                    indices.push(i1), indices.push(i4), indices.push(i2), indices.push(i4), indices.push(i3), 
                    indices.push(i2);
                }
            }(), function generateTop() {
                for (var lat = 0; lat <= topSegments; ++lat) for (var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                    var phi = 2 * lon * Math.PI / sides - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / sides, v = lat / heightSegments + (1 - topProp);
                    if (positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop), normals.push(x, y, z), 
                    uvs.push(u, v), lat < topSegments && lon < sides) {
                        var seg1 = sides + 1, a = seg1 * lat + lon + indexArray[torSegments][sides] + 1, b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1, c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1, d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                        indices.push(a, d, b), indices.push(d, c, b);
                    }
                }
            }(), {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
            };
        },
        circle: function circle(options) {
            var segments = function applyDefaultCircleOptions(options) {
                return (options = applyDefaultGeometryOptions(options)).segments = 64, options;
            }(options).segments, positions = new Array(3 * (segments + 1));
            positions[0] = 0, positions[1] = 0, positions[2] = 0;
            var indices = new Array(1 + 2 * segments);
            indices[0] = 0;
            for (var step = 2 * Math.PI / segments, iSegment = 0; iSegment < segments; ++iSegment) {
                var angle = step * iSegment, x = Math.cos(angle), y = Math.sin(angle), p = 3 * (iSegment + 1);
                positions[p + 0] = x, positions[p + 1] = y, positions[p + 2] = 0;
                var i = 2 * iSegment;
                indices[1 + i] = iSegment + 1, indices[1 + (i + 1)] = iSegment + 2;
            }
            return 0 < segments && (indices[indices.length - 1] = 1), {
                positions: positions,
                indices: indices,
                minPos: {
                    x: 1,
                    y: 1,
                    z: 0
                },
                maxPos: {
                    x: -1,
                    y: -1,
                    z: 0
                },
                boundingRadius: 1,
                primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_FAN
            };
        },
        translate: function translate(geometry, offset) {
            for (var x = offset.x || 0, y = offset.y || 0, z = offset.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
                var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
                geometry.positions[iX] = geometry.positions[iX] + x, geometry.positions[iY] = geometry.positions[iY] + y, 
                geometry.positions[iZ] = geometry.positions[iZ] + z;
            }
            return geometry.minPos && (geometry.minPos.x += x, geometry.minPos.y += y, geometry.minPos.z += z), 
            geometry.maxPos && (geometry.maxPos.x += x, geometry.maxPos.y += y, geometry.maxPos.z += z), 
            geometry;
        },
        scale: function scale(geometry, value) {
            for (var x = value.x || 0, y = value.y || 0, z = value.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
                var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
                geometry.positions[iX] *= x, geometry.positions[iY] *= y, geometry.positions[iZ] *= z;
            }
            return geometry.minPos && (geometry.minPos.x *= x, geometry.minPos.y *= y, geometry.minPos.z *= z), 
            geometry.maxPos && (geometry.maxPos.x *= x, geometry.maxPos.y *= y, geometry.maxPos.z *= z), 
            geometry.boundingRadius = Math.max(Math.max(x, y), z), geometry;
        },
        wireframed: function wireframed(geometry) {
            var indices = geometry.indices;
            if (!indices) return geometry;
            if (geometry.primitiveMode && geometry.primitiveMode !== exports.GFXPrimitiveMode.TRIANGLE_LIST) return geometry;
            for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
                var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i2 < i1 ? i2 << 16 | i1 : i1 << 16 | i2;
                void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
            }
            return geometry.indices = lines, geometry.primitiveMode = exports.GFXPrimitiveMode.LINE_LIST, 
            geometry;
        },
        wireframe: function wireframe(indices) {
            for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
                var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i2 < i1 ? i2 << 16 | i1 : i1 << 16 | i2;
                void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
            }
            return lines;
        },
        invWinding: function invWinding(indices) {
            for (var newIB = [], i = 0; i < indices.length; i += 3) newIB.push(indices[i], indices[i + 2], indices[i + 1]);
            return newIB;
        },
        toWavefrontOBJ: function toWavefrontOBJ(primitive) {
            var scale = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
            if (!primitive.indices || !primitive.uvs || !primitive.normals || void 0 !== primitive.primitiveMode && primitive.primitiveMode !== exports.GFXPrimitiveMode.TRIANGLE_LIST) return "";
            for (var v = primitive.positions, t = primitive.uvs, n = primitive.normals, IB = primitive.indices, V = function V(i) {
                return "".concat(IB[i] + 1, "/").concat(IB[i] + 1, "/").concat(IB[i] + 1);
            }, content = "", i = 0; i < v.length; i += 3) content += "v ".concat(v[i] * scale, " ").concat(v[i + 1] * scale, " ").concat(v[i + 2] * scale, "\n");
            for (var _i = 0; _i < t.length; _i += 2) content += "vt ".concat(t[_i], " ").concat(t[_i + 1], "\n");
            for (var _i2 = 0; _i2 < n.length; _i2 += 3) content += "vn ".concat(n[_i2], " ").concat(n[_i2 + 1], " ").concat(n[_i2 + 2], "\n");
            for (var _i3 = 0; _i3 < IB.length; _i3 += 3) content += "f ".concat(V(_i3), " ").concat(V(_i3 + 1), " ").concat(V(_i3 + 2), "\n");
            return content;
        },
        normals: function normals(positions, normals) {
            for (var length = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1, verts = new Array(2 * positions.length), i = 0; i < positions.length / 3; ++i) {
                var i3 = 3 * i, i6 = 6 * i;
                verts[i6 + 0] = positions[i3 + 0], verts[i6 + 1] = positions[i3 + 1], verts[i6 + 2] = positions[i3 + 2], 
                verts[i6 + 3] = positions[i3 + 0] + normals[i3 + 0] * length, verts[i6 + 4] = positions[i3 + 1] + normals[i3 + 1] * length, 
                verts[i6 + 5] = positions[i3 + 2] + normals[i3 + 2] * length;
            }
            return verts;
        },
        applyDefaultGeometryOptions: applyDefaultGeometryOptions
    }), _vec2a = new Vec2(), _vec2b = new Vec2(), _mat4_temp = new Mat4(), _matrix = new Mat4(), _worldMatrix = new Mat4(), UITransformComponent = (_dec$18 = ccclass("cc.UITransformComponent"), 
    _dec2$N = executionOrder(110), _dec3$A = menu("UI/UITransform"), _dec4$s = property({
        displayOrder: 0
    }), _dec5$n = property({
        displayOrder: 1
    }), _dec$18(_class$1a = _dec2$N(_class$1a = _dec3$A(_class$1a = executeInEditMode((_temp$16 = _class3$j = function(_Component) {
        function UITransformComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UITransformComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UITransformComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_contentSize", _descriptor$Z, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_anchorPoint", _descriptor2$O, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(UITransformComponent, Component), _createClass(UITransformComponent, [ {
            key: "__preload",
            value: function __preload() {
                (this.node.uiTransfromComp = this).node.layer = cc.Layers.UI;
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.node.uiTransfromComp = null;
            }
        }, {
            key: "setContentSize",
            value: function setContentSize(size, height) {
                var locContentSize = this._contentSize;
                if (void 0 === height) {
                    if ((size = size).width === locContentSize.width && size.height === locContentSize.height) return;
                    0, locContentSize.width = size.width, locContentSize.height = size.height;
                } else {
                    if (size === locContentSize.width && height === locContentSize.height) return;
                    0, locContentSize.width = size, locContentSize.height = height;
                }
                this.node.emit(exports.SystemEventType.SIZE_CHANGED);
            }
        }, {
            key: "setAnchorPoint",
            value: function setAnchorPoint(point, y) {
                var locAnchorPoint = this._anchorPoint;
                if (void 0 === y) {
                    if ((point = point).x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
                    locAnchorPoint.x = point.x, locAnchorPoint.y = point.y;
                } else {
                    if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
                    locAnchorPoint.x = point, locAnchorPoint.y = y;
                }
                this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
            }
        }, {
            key: "isHit",
            value: function isHit(point, listener) {
                var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _vec2a, testPt = _vec2b, visibility = -1, renderComp = this.node.getComponent(cc.UIRenderComponent);
                visibility = renderComp ? renderComp.visibility : this._getVisibility();
                var canvas = cc.director.root.ui.getScreen(visibility);
                if (canvas) {
                    canvas.node.getWorldRT(_mat4_temp);
                    var m12 = _mat4_temp.m12, m13 = _mat4_temp.m13, center = cc.visibleRect.center;
                    if (_mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13), _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13), 
                    mat4.invert(_mat4_temp, _mat4_temp), vec2.transformMat4(cameraPt, point, _mat4_temp), 
                    this.node.getWorldMatrix(_worldMatrix), mat4.invert(_mat4_temp, _worldMatrix), vec2.transformMat4(testPt, cameraPt, _mat4_temp), 
                    testPt.x += this._anchorPoint.x * w, testPt.y += this._anchorPoint.y * h, 0 <= testPt.x && 0 <= testPt.y && testPt.x <= w && testPt.y <= h) {
                        if (listener && listener.mask) {
                            for (var mask = listener.mask, parent = this.node, i = 0; parent && i < mask.index; ++i, 
                            parent = parent.parent) ;
                            if (parent !== mask.node) return !(listener.mask = null);
                            var comp = parent.getComponent(cc.MaskComponent);
                            return !comp || !comp.enabledInHierarchy || comp.isHit(cameraPt);
                        }
                        return !0;
                    }
                    return !1;
                }
            }
        }, {
            key: "convertToNodeSpaceAR",
            value: function convertToNodeSpaceAR(worldPoint, out) {
                return this.node.getWorldMatrix(_worldMatrix), mat4.invert(_mat4_temp, _worldMatrix), 
                out || (out = new Vec3()), vec3.transformMat4(out, worldPoint, _mat4_temp);
            }
        }, {
            key: "convertToWorldSpaceAR",
            value: function convertToWorldSpaceAR(nodePoint, out) {
                return this.node.getWorldMatrix(_worldMatrix), out || (out = new Vec3()), vec3.transformMat4(out, nodePoint, _worldMatrix);
            }
        }, {
            key: "getBoundingBox",
            value: function getBoundingBox() {
                mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                return rect.transformMat4(rect, _matrix);
            }
        }, {
            key: "getBoundingBoxToWorld",
            value: function getBoundingBoxToWorld() {
                return this.node.parent ? (this.node.parent.getWorldMatrix(_worldMatrix), this.getBoundingBoxTo(_worldMatrix)) : this.getBoundingBox();
            }
        }, {
            key: "getBoundingBoxTo",
            value: function getBoundingBoxTo(parentMat) {
                mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                if (mat4.multiply(_worldMatrix, parentMat, _matrix), rect.transformMat4(rect, _worldMatrix), 
                !this.node.children) return rect;
                var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var child = _ref;
                    if (child && child.active) {
                        var uiTransform = child.getComponent(UITransformComponent);
                        if (uiTransform) {
                            var childRect = uiTransform.getBoundingBoxTo(parentMat);
                            childRect && rect.union(rect, childRect);
                        }
                    }
                }
                return rect;
            }
        }, {
            key: "getComputeAABB",
            value: function getComputeAABB(out) {
                var rectWorld = this.getBoundingBoxToWorld(), px = rectWorld.center.x, py = rectWorld.center.y, pz = this.node.worldPosition.z, w = rectWorld.width / 2, h = rectWorld.height / 2;
                if (null == out) return new aabb(px, py, pz, w, h, .01);
                aabb.set(out, px, py, pz, w, h, .01);
            }
        }, {
            key: "_getVisibility",
            value: function _getVisibility() {
                for (var visibility = -1, parent = this.node; parent; ) {
                    if (parent) {
                        var canvasComp = parent.getComponent("cc.CanvasComponent");
                        if (canvasComp) {
                            visibility = canvasComp.visibility;
                            break;
                        }
                    }
                    parent = parent.parent;
                }
                return visibility;
            }
        }, {
            key: "contentSize",
            get: function get() {
                return this._contentSize;
            },
            set: function set(value) {
                this._contentSize.equals(value) || (this._contentSize.set(value), this.node.emit(exports.SystemEventType.SIZE_CHANGED));
            }
        }, {
            key: "width",
            get: function get() {
                return this._contentSize.width;
            },
            set: function set(value) {
                this._contentSize.width !== value && (this._contentSize.width = value, this.node.emit(exports.SystemEventType.SIZE_CHANGED));
            }
        }, {
            key: "height",
            get: function get() {
                return this._contentSize.height;
            },
            set: function set(value) {
                this.contentSize.height !== value && (this._contentSize.height = value, this.node.emit(exports.SystemEventType.SIZE_CHANGED));
            }
        }, {
            key: "anchorPoint",
            get: function get() {
                return this._anchorPoint;
            },
            set: function set(value) {
                this._anchorPoint.equals(value) || (this._anchorPoint.set(value), this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
            }
        }, {
            key: "anchorX",
            get: function get() {
                return this._anchorPoint.x;
            },
            set: function set(value) {
                this._anchorPoint.x !== value && (this._anchorPoint.x = value, this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
            }
        }, {
            key: "anchorY",
            get: function get() {
                return this._anchorPoint.y;
            },
            set: function set(value) {
                this._anchorPoint.y !== value && (this._anchorPoint.y = value, this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
            }
        } ]), UITransformComponent;
    }(), _class3$j.EventType = exports.SystemEventType, _applyDecoratedDescriptor((_class2$_ = _temp$16).prototype, "contentSize", [ _dec4$s ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "contentSize"), _class2$_.prototype), 
    _applyDecoratedDescriptor(_class2$_.prototype, "anchorPoint", [ _dec5$n ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "anchorPoint"), _class2$_.prototype), 
    _descriptor$Z = _applyDecoratedDescriptor(_class2$_.prototype, "_contentSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Size(100, 100);
        }
    }), _descriptor2$O = _applyDecoratedDescriptor(_class2$_.prototype, "_anchorPoint", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(.5, .5);
        }
    }), _class$1a = _class2$_)) || _class$1a) || _class$1a) || _class$1a) || _class$1a);
    cc.UITransformComponent = UITransformComponent;
    var _class$1c, _worldPos = new Vec3(), CanvasComponent = (_dec$19 = ccclass("cc.CanvasComponent"), 
    _dec2$O = executionOrder(100), _dec3$B = requireComponent(UITransformComponent), 
    _dec4$t = menu("UI/Canvas"), _dec5$o = property(), _dec$19(_class$1b = _dec2$O(_class$1b = _dec3$B(_class$1b = _dec4$t(_class$1b = executeInEditMode((_applyDecoratedDescriptor((_class2$10 = function(_Component) {
        function CanvasComponent() {
            var _this;
            return _classCallCheck(this, CanvasComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasComponent).call(this)), "_priority", _descriptor$_, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._thisOnResized = void 0, _this._camera = null, _this._pos = new Vec3(), _this._thisOnResized = _this.alignWithScreen.bind(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(CanvasComponent, Component), _createClass(CanvasComponent, [ {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(val) {
                this._priority = val, this._camera && (this._camera.priority = val);
            }
        }, {
            key: "visibility",
            get: function get() {
                return this._camera ? this._camera.view.visibility : -1;
            }
        }, {
            key: "camera",
            get: function get() {
                return this._camera;
            }
        } ]), _createClass(CanvasComponent, [ {
            key: "__preload",
            value: function __preload() {
                var cameraNode = new cc.Node("UICamera_" + this.node.name);
                cameraNode.setPosition(0, 0, 999), this._camera = cc.director.root.ui.renderScene.createCamera({
                    name: "ui_" + this.node.name,
                    node: cameraNode,
                    projection: cc.CameraComponent.ProjectionType.ORTHO,
                    targetDisplay: 0,
                    priority: this._priority,
                    isUI: !0,
                    flows: [ "UIFlow" ]
                }), this._camera.fov = 45, this._camera.clearFlag = GFXClearFlag.COLOR | GFXClearFlag.DEPTH | GFXClearFlag.STENCIL;
                var device = cc.director.root.device;
                this._camera.resize(device.width, device.height), cc.view.on("design-resolution-changed", this._thisOnResized), 
                this.alignWithScreen(), cc.director.root.ui.addScreen(this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._camera && cc.director.root.ui.renderScene.destroyCamera(this._camera), cc.view.off("design-resolution-changed", this._thisOnResized), 
                cc.director.root.ui.removeScreen(this);
            }
        }, {
            key: "alignWithScreen",
            value: function alignWithScreen() {
                var nodeSize, designSize;
                this.node.getPosition(this._pos);
                var canvasSize = cc.visibleRect;
                nodeSize = canvasSize, designSize = cc.view.getDesignResolutionSize();
                var offsetX = 0, offsetY = 0;
                if (cc.view.getResolutionPolicy() === cc.ResolutionPolicy.NO_BORDER && (offsetX = .5 * (designSize.width - canvasSize.width), 
                offsetY = .5 * (designSize.height - canvasSize.height)), vec3.set(_worldPos, .5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY, 0), 
                this._pos.equals(_worldPos) || this.node.setPosition(_worldPos), this.node.width !== nodeSize.width && (this.node.width = nodeSize.width), 
                this.node.height !== nodeSize.height && (this.node.height = nodeSize.height), this.node.getWorldPosition(_worldPos), 
                this._camera) {
                    var size = cc.view.getVisibleSize();
                    this._camera.resize(size.width, size.height), this._camera.orthoHeight = this._camera.height / 2, 
                    this._camera.node.setPosition(_worldPos.x, _worldPos.y, 999), this._camera.update();
                }
            }
        } ]), CanvasComponent;
    }()).prototype, "priority", [ _dec5$o ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "priority"), _class2$10.prototype), 
    _descriptor$_ = _applyDecoratedDescriptor(_class2$10.prototype, "_priority", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$1b = _class2$10)) || _class$1b) || _class$1b) || _class$1b) || _class$1b) || _class$1b);
    cc.CanvasComponent = CanvasComponent;
    var _class$1d, _class2$11, _descriptor$10, _worldPos$1 = new Vec3(), DebugCanvasComponent = ccclass("cc.DebugCanvasComponent")(_class$1c = executionOrder(100)(_class$1c = requireComponent(UITransformComponent)(_class$1c = function(_CanvasComponent) {
        function DebugCanvasComponent() {
            var _this;
            return _classCallCheck(this, DebugCanvasComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(DebugCanvasComponent).call(this)))._thisOnResized = _this.alignWithScreen.bind(_assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(DebugCanvasComponent, CanvasComponent), _createClass(DebugCanvasComponent, [ {
            key: "__preload",
            value: function __preload() {
                var cameraNode = new cc.Node("UICamera_Debug");
                cameraNode.setPosition(0, 0, 1e3), this._camera = cc.director.root.ui.renderScene.createCamera({
                    name: "ui_Debug",
                    node: cameraNode,
                    projection: cc.CameraComponent.ProjectionType.ORTHO,
                    targetDisplay: 0,
                    priority: this._priority,
                    isUI: !0,
                    flows: [ "UIFlow" ]
                }), this._camera.fov = 45, this._camera.clearFlag = GFXClearFlag.COLOR | GFXClearFlag.DEPTH | GFXClearFlag.STENCIL;
                var device = cc.director.root.device;
                this._camera.resize(device.width, device.height), cc.view.on("design-resolution-changed", this._thisOnResized), 
                this.alignWithScreen(), cc.director.root && cc.director.root.ui && (cc.director.root.ui.debugScreen = this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {}
        }, {
            key: "onDisable",
            value: function onDisable() {}
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._camera && this._getRenderScene().destroyCamera(this._camera), cc.view.off("design-resolution-changed", this._thisOnResized), 
                cc.director.root && cc.director.root.ui && (cc.director.root.ui.debugScreen = null);
            }
        }, {
            key: "alignWithScreen",
            value: function alignWithScreen() {
                var canvasSize = cc.visibleRect, nodeSize = canvasSize, designSize = cc.view.getDesignResolutionSize(), offsetX = 0, offsetY = 0;
                if (cc.view.getResolutionPolicy() === cc.ResolutionPolicy.NO_BORDER && (offsetX = .5 * (designSize.width - canvasSize.width), 
                offsetY = .5 * (designSize.height - canvasSize.height)), this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY, 1), 
                this.node.width !== nodeSize.width && (this.node.width = nodeSize.width), this.node.height !== nodeSize.height && (this.node.height = nodeSize.height), 
                this.node.getWorldPosition(_worldPos$1), this._camera) {
                    var size = cc.view.getVisibleSize();
                    this._camera.resize(size.width, size.height), this._camera.orthoHeight = this._camera.height / 2, 
                    this._camera.node.setPosition(_worldPos$1.x, _worldPos$1.y, 1e3), this._camera.update();
                }
            }
        }, {
            key: "applySettings",
            value: function applySettings() {}
        } ]), DebugCanvasComponent;
    }()) || _class$1c) || _class$1c) || _class$1c;
    cc.DebugCanvasComponent = DebugCanvasComponent;
    var _dec$1c, _dec2$R, _dec3$D, _dec4$u, _dec5$p, _dec6$l, _dec7$f, _class$1e, _class2$12, _descriptor$11, _descriptor2$P, _descriptor3$D, _descriptor4$w, _class3$k, _temp$19, InstanceMaterialType, UIComponent = ccclass("cc.UIComponent")(_class$1d = executionOrder(110)(_class$1d = executeInEditMode((_applyDecoratedDescriptor((_class2$11 = function(_Component) {
        function UIComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_priority", _descriptor$10, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._visibility = -1, _this._lastParent = null, _this;
        }
        return _inherits(UIComponent, Component), _createClass(UIComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._lastParent = this.node.parent, this._updateVisibility(), this._lastParent && this.node.on(exports.SystemEventType.CHILD_REMOVED, this._parentChanged, this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._cancelEventFromParent();
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {}
        }, {
            key: "postUpdateAssembler",
            value: function postUpdateAssembler(render) {}
        }, {
            key: "setVisibility",
            value: function setVisibility(value) {
                this._visibility = value;
            }
        }, {
            key: "_parentChanged",
            value: function _parentChanged(node) {
                return node === this.node && (this._updateVisibility(), this._cancelEventFromParent(), 
                this._lastParent = this.node.parent, !0);
            }
        }, {
            key: "_updateVisibility",
            value: function _updateVisibility() {
                for (var parent = this.node; parent; ) {
                    if (parent) {
                        var canvasComp = parent.getComponent(CanvasComponent);
                        if (canvasComp) {
                            this._visibility = canvasComp.visibility;
                            break;
                        }
                    }
                    parent = parent.parent;
                }
            }
        }, {
            key: "_cancelEventFromParent",
            value: function _cancelEventFromParent() {
                this._lastParent && (this._lastParent.off(exports.SystemEventType.CHILD_REMOVED, this._parentChanged, this), 
                this._lastParent = null), this._visibility = -1;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(value) {
                this._priority !== value && (this._priority = value);
            }
        }, {
            key: "visibility",
            get: function get() {
                return this._visibility;
            }
        } ]), UIComponent;
    }()).prototype, "priority", [ property ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "priority"), _class2$11.prototype), 
    _descriptor$10 = _applyDecoratedDescriptor(_class2$11.prototype, "_priority", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _class$1d = _class2$11)) || _class$1d) || _class$1d) || _class$1d, BaseRenderData = function BaseRenderData() {
        _classCallCheck(this, BaseRenderData), this.material = null, this.vertexCount = 0, 
        this.indiceCount = 0;
    }, RenderData = function(_BaseRenderData) {
        function RenderData() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, RenderData);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderData)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).uvDirty = !0, 
            _this.vertDirty = !0, _this._datas = [], _this._indices = [], _this._pivotX = 0, 
            _this._pivotY = 0, _this._width = 0, _this._height = 0, _this;
        }
        return _inherits(RenderData, BaseRenderData), _createClass(RenderData, [ {
            key: "updateSizeNPivot",
            value: function updateSizeNPivot(width, height, pivotX, pivotY) {
                width === this._width && height === this._height && pivotX === this._pivotX && pivotY === this._pivotY || (this._width = width, 
                this._height = height, this._pivotX = pivotX, this._pivotY = pivotY, this.vertDirty = !0);
            }
        }, {
            key: "clear",
            value: function clear() {
                this._datas.length = 0, this._indices.length = 0, this._pivotX = 0, this._pivotY = 0, 
                this._width = 0, this._height = 0, this.uvDirty = !0, this.vertDirty = !0, this.material = null, 
                this.vertexCount = 0, this.indiceCount = 0;
            }
        }, {
            key: "dataLength",
            get: function get() {
                return this._datas.length;
            },
            set: function set(length) {
                var data = this._datas;
                if (data.length !== length) {
                    var value = data.length, i = 0;
                    for (i = length; i < value; i++) _dataPool.free(data[i]);
                    for (i = value; i < length; i++) data[i] = _dataPool.alloc();
                    data.length = length;
                }
            }
        }, {
            key: "datas",
            get: function get() {
                return this._datas;
            }
        } ], [ {
            key: "add",
            value: function add() {
                var data = _pool$1.add();
                return {
                    pooID: _pool$1.length - 1,
                    data: data
                };
            }
        }, {
            key: "remove",
            value: function remove(idx) {
                _pool$1.data[idx].clear(), _pool$1.removeAt(idx);
            }
        } ]), RenderData;
    }(), IARenderData = function(_BaseRenderData2) {
        function IARenderData() {
            var _getPrototypeOf3, _this2;
            _classCallCheck(this, IARenderData);
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
            return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(IARenderData)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).vData = new Float32Array(2304 * Float32Array.BYTES_PER_ELEMENT), 
            _this2.iData = new Uint16Array(1536), _this2.vertexStart = 0, _this2.indiceStart = 0, 
            _this2.byteStart = 0, _this2.byteCount = 0, _this2._formatByte = 9 * Float32Array.BYTES_PER_ELEMENT, 
            _this2;
        }
        return _inherits(IARenderData, BaseRenderData), _createClass(IARenderData, [ {
            key: "request",
            value: function request(vertexCount, indiceCount) {
                var byteOffset = this.byteCount + vertexCount * this._formatByte, indiceOffset = this.indiceCount + indiceCount;
                if (65535 < vertexCount + this.vertexCount) return !1;
                var byteLength = this.vData.byteLength, indiceLength = this.iData.length, vCount = this.vData.length, iCount = this.iData.length;
                if (byteLength < byteOffset || indiceLength < indiceOffset) {
                    for (;byteLength < byteOffset || indiceLength < indiceOffset; ) byteLength = 4 * (vCount *= 2), 
                    indiceLength = iCount *= 2;
                    var oldvData = new Float32Array(this.vData.buffer);
                    this.vData = new Float32Array(vCount), this.vData.set(oldvData, 0);
                    var oldiData = new Uint16Array(this.iData.buffer);
                    this.iData = new Uint16Array(iCount), this.iData.set(oldiData, 0);
                }
                return this.vertexCount += vertexCount, this.indiceCount += indiceCount, this.byteCount = byteOffset, 
                !0;
            }
        }, {
            key: "reset",
            value: function reset() {
                this.vertexCount = 0, this.indiceCount = 0, this.byteCount = 0, this.vertexStart = 0, 
                this.indiceStart = 0, this.byteStart = 0;
            }
        } ]), IARenderData;
    }(), _dataPool = new Pool$1(function() {
        return {
            x: 0,
            y: 0,
            z: 0,
            u: 0,
            v: 0,
            color: Color.WHITE
        };
    }, 128), _pool$1 = new RecyclePool(function() {
        return new RenderData();
    }, 32);
    ccenum(GFXBlendFactor), function(InstanceMaterialType) {
        InstanceMaterialType[InstanceMaterialType.ADDCOLOR = 0] = "ADDCOLOR", InstanceMaterialType[InstanceMaterialType.ADDCOLORANDTEXTURE = 1] = "ADDCOLORANDTEXTURE";
    }(InstanceMaterialType || (InstanceMaterialType = {}));
    var _dec$1d, _dec2$S, _dec3$E, _dec4$v, _dec5$q, _dec6$m, _dec7$g, _dec8$b, _dec9$b, _class$1f, _class2$13, _descriptor$12, _descriptor2$Q, _descriptor3$E, _descriptor4$x, _descriptor5$r, _descriptor6$k, _descriptor7$g, _descriptor8$c, _descriptor9$9, _class3$l, _temp$1a, SpriteType, FillType, SizeMode, UIRenderComponent = (_dec$1c = ccclass("cc.UIRenderComponent"), 
    _dec2$R = executionOrder(110), _dec3$D = requireComponent(UITransformComponent), 
    _dec4$u = property({
        type: GFXBlendFactor,
        displayOrder: 0
    }), _dec5$p = property({
        type: GFXBlendFactor,
        displayOrder: 1
    }), _dec6$l = property({
        displayOrder: 2
    }), _dec7$f = property({
        type: Material,
        displayOrder: 3
    }), _dec$1c(_class$1e = _dec2$R(_class$1e = _dec3$D(_class$1e = executeInEditMode((_temp$19 = _class3$k = function(_UIComponent) {
        function UIRenderComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIRenderComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIRenderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_srcBlendFactor", _descriptor$11, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor2$P, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_color", _descriptor3$D, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_sharedMaterial", _descriptor4$w, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._assembler = null, _this._postAssembler = null, _this._renderDataPoolID = -1, 
            _this._renderData = null, _this._renderDataDirty = !1, _this._renderPermit = !0, 
            _this._material = null, _this._instanceMaterialType = InstanceMaterialType.ADDCOLORANDTEXTURE, 
            _this._blendTemplate = {
                blendState: {
                    targets: [ {
                        blendSrc: GFXBlendFactor.SRC_ALPHA,
                        blendDst: GFXBlendFactor.ONE_MINUS_SRC_ALPHA
                    } ]
                },
                depthStencilState: {},
                rasterizerState: {}
            }, _this;
        }
        return _inherits(UIRenderComponent, UIComponent), _createClass(UIRenderComponent, [ {
            key: "__preload",
            value: function __preload() {
                this._instanceMaterial(), this._flushAssembler && this._flushAssembler();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "onEnable", this).call(this), 
                this.node.on(exports.SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), 
                this.node.on(exports.SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
                this._renderDataDirty = !0;
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(UIRenderComponent.prototype), "onDisable", this).call(this), 
                this.node.off(exports.SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), 
                this.node.off(exports.SystemEventType.SIZE_CHANGED, this._nodeStateChange, this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this.destroyRenderData(), this._material && (this._material.destroy(), cc.director.root.ui._removeUIMaterial(this._material.hash)), 
                this._updateMaterial(null), this._renderData = null;
            }
        }, {
            key: "markForUpdateRenderData",
            value: function markForUpdateRenderData() {
                var enable = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0];
                if (enable && this._canRender()) {
                    var renderData = this._renderData;
                    renderData && (renderData.uvDirty = !0, renderData.vertDirty = !0), this._renderDataDirty = enable;
                } else enable || (this._renderDataDirty = enable);
            }
        }, {
            key: "requestRenderData",
            value: function requestRenderData() {
                var data = RenderData.add();
                return this._renderData = data.data, this._renderDataPoolID = data.pooID, this._renderData;
            }
        }, {
            key: "destroyRenderData",
            value: function destroyRenderData() {
                -1 !== this._renderDataPoolID && (RenderData.remove(this._renderDataPoolID), this._renderDataPoolID = -1, 
                this._renderData = null);
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                return !!this._canRender() && (this._checkAndUpdateRenderData(), !0);
            }
        }, {
            key: "_checkAndUpdateRenderData",
            value: function _checkAndUpdateRenderData() {
                this._renderDataDirty && (this._assembler.updateRenderData(this), this._renderDataDirty = !1);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                return null !== this.material && this._renderPermit;
            }
        }, {
            key: "_updateColor",
            value: function _updateColor() {
                var material = this._material;
                material && material.setProperty("color", this._color);
            }
        }, {
            key: "_updateMaterial",
            value: function _updateMaterial(material) {
                this._material = material, this._updateBlendFunc();
            }
        }, {
            key: "_updateBlendFunc",
            value: function _updateBlendFunc() {
                if (this._material) {
                    var target = this._blendTemplate.blendState.targets[0];
                    target.blendDst === this._dstBlendFactor && target.blendSrc === this._srcBlendFactor || (target.blendDst = this._dstBlendFactor, 
                    target.blendSrc = this._srcBlendFactor, this._blendTemplate.depthStencilState = this._material.passes[0].depthStencilState, 
                    this._blendTemplate.rasterizerState = this._material.passes[0].rasterizerState, 
                    this._material.overridePipelineStates(this._blendTemplate, 0));
                }
            }
        }, {
            key: "_nodeStateChange",
            value: function _nodeStateChange() {
                this._renderData && this.markForUpdateRenderData();
                var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var renderComp = _ref.getComponent(UIRenderComponent);
                    renderComp && renderComp.markForUpdateRenderData();
                }
            }
        }, {
            key: "_instanceMaterial",
            value: function _instanceMaterial() {
                var mat = null;
                if (this._sharedMaterial) mat = Material.getInstantiatedMaterial(this._sharedMaterial, new RenderableComponent(), !1); else switch (this._instanceMaterialType) {
                  case InstanceMaterialType.ADDCOLOR:
                    mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-base-material"), new RenderableComponent(), !1);
                    break;

                  case InstanceMaterialType.ADDCOLORANDTEXTURE:
                    mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-sprite-material"), new RenderableComponent(), !1);
                }
                this._updateMaterial(mat);
            }
        }, {
            key: "srcBlendFactor",
            get: function get$$1() {
                return this._srcBlendFactor;
            },
            set: function set(value) {
                this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "dstBlendFactor",
            get: function get$$1() {
                return this._dstBlendFactor;
            },
            set: function set(value) {
                this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "color",
            get: function get$$1() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this.markForUpdateRenderData());
            }
        }, {
            key: "sharedMaterial",
            get: function get$$1() {
                return this._sharedMaterial;
            },
            set: function set(value) {
                this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
            }
        }, {
            key: "material",
            get: function get$$1() {
                return this._material || this._instanceMaterial && this._instanceMaterial(), this._material;
            }
        }, {
            key: "renderData",
            get: function get$$1() {
                return this._renderData;
            }
        } ]), UIRenderComponent;
    }(), _class3$k.BlendState = GFXBlendFactor, _class3$k.Assembler = null, _class3$k.PostAssembler = null, 
    _applyDecoratedDescriptor((_class2$12 = _temp$19).prototype, "srcBlendFactor", [ _dec4$u ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "srcBlendFactor"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "dstBlendFactor", [ _dec5$p ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "dstBlendFactor"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "color", [ _dec6$l ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "color"), _class2$12.prototype), 
    _applyDecoratedDescriptor(_class2$12.prototype, "sharedMaterial", [ _dec7$f ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "sharedMaterial"), _class2$12.prototype), 
    _descriptor$11 = _applyDecoratedDescriptor(_class2$12.prototype, "_srcBlendFactor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return GFXBlendFactor.SRC_ALPHA;
        }
    }), _descriptor2$P = _applyDecoratedDescriptor(_class2$12.prototype, "_dstBlendFactor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return GFXBlendFactor.ONE_MINUS_SRC_ALPHA;
        }
    }), _descriptor3$D = _applyDecoratedDescriptor(_class2$12.prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE;
        }
    }), _descriptor4$w = _applyDecoratedDescriptor(_class2$12.prototype, "_sharedMaterial", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1e = _class2$12)) || _class$1e) || _class$1e) || _class$1e) || _class$1e);
    cc.UIRenderComponent = UIRenderComponent, function(SpriteType) {
        SpriteType[SpriteType.SIMPLE = 0] = "SIMPLE", SpriteType[SpriteType.SLICED = 1] = "SLICED", 
        SpriteType[SpriteType.FILLED = 3] = "FILLED";
    }(SpriteType || (SpriteType = {})), ccenum(SpriteType), function(FillType) {
        FillType[FillType.HORIZONTAL = 0] = "HORIZONTAL", FillType[FillType.VERTICAL = 1] = "VERTICAL", 
        FillType[FillType.RADIAL = 2] = "RADIAL";
    }(FillType || (FillType = {})), ccenum(FillType), function(SizeMode) {
        SizeMode[SizeMode.CUSTOM = 0] = "CUSTOM", SizeMode[SizeMode.TRIMMED = 1] = "TRIMMED", 
        SizeMode[SizeMode.RAW = 2] = "RAW";
    }(SizeMode || (SizeMode = {})), ccenum(SizeMode);
    var _dec$1e, _dec2$T, _dec3$F, _dec4$w, _dec5$r, _dec6$n, _dec7$h, _dec8$c, _dec9$c, _dec10$9, _dec11$9, _dec12$8, _class$1g, _class2$14, _descriptor$13, _descriptor2$R, _descriptor3$F, _descriptor4$y, _descriptor5$s, _descriptor6$l, _descriptor7$h, _descriptor8$d, _descriptor9$a, _descriptor10$7, _descriptor11$6, _descriptor12$6, _descriptor13$6, _descriptor14$2, _class3$m, _temp$1b, Transition, State, SpriteComponent = (_dec$1d = ccclass("cc.SpriteComponent"), 
    _dec2$S = executionOrder(110), _dec3$E = menu("UI/Render/Sprite"), _dec4$v = property({
        type: SpriteAtlas,
        displayOrder: 4
    }), _dec5$q = property({
        type: SpriteFrame,
        displayOrder: 5
    }), _dec6$m = property({
        type: SpriteType,
        displayOrder: 6
    }), _dec7$g = property({
        type: FillType
    }), _dec8$b = property({
        displayOrder: 8
    }), _dec9$b = property({
        type: SizeMode,
        displayOrder: 7
    }), _dec$1d(_class$1f = _dec2$S(_class$1f = _dec3$E((_temp$1a = _class3$l = function(_UIRenderComponent) {
        function SpriteComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SpriteComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_spriteFrame", _descriptor$12, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_type", _descriptor2$Q, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fillType", _descriptor3$E, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_sizeMode", _descriptor4$x, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fillCenter", _descriptor5$r, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fillStart", _descriptor6$k, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fillRange", _descriptor7$g, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_atlas", _descriptor9$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(SpriteComponent, UIRenderComponent), _createClass(SpriteComponent, [ {
            key: "__preload",
            value: function __preload() {
                _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this) && _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this).call(this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(SpriteComponent.prototype), "onEnable", this).call(this), this._activateMaterial();
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                return !(!_get(_getPrototypeOf(SpriteComponent.prototype), "updateAssembler", this).call(this, render) || !this._spriteFrame) && (render.commitComp(this, this._spriteFrame.getGFXTextureView(), this._assembler), 
                !0);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(SpriteComponent.prototype), "onDestroy", this).call(this), 
                this.destroyRenderData();
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                if (!_get(_getPrototypeOf(SpriteComponent.prototype), "_canRender", this).call(this)) return !1;
                var spriteFrame = this._spriteFrame;
                return !(!spriteFrame || !spriteFrame.textureLoaded());
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = SpriteComponent.Assembler.getAssembler(this);
                this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                this._renderData.material = this._material, this.markForUpdateRenderData());
            }
        }, {
            key: "_applySpriteSize",
            value: function _applySpriteSize() {
                if (this._spriteFrame) {
                    if (SizeMode.RAW === this._sizeMode) {
                        var size = this._spriteFrame.getOriginalSize();
                        this.node.setContentSize(size);
                    } else if (SizeMode.TRIMMED === this._sizeMode) {
                        var rect = this._spriteFrame.getRect();
                        this.node.setContentSize(rect.width, rect.height);
                    }
                    this._activateMaterial();
                }
            }
        }, {
            key: "_resized",
            value: function _resized() {
            }
        }, {
            key: "_activateMaterial",
            value: function _activateMaterial() {
                var spriteFrame = this._spriteFrame, material = this._material;
                cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS ? (spriteFrame && material && (material.setProperty("mainTexture", spriteFrame), 
                this.markForUpdateRenderData()), this._renderData && (this._renderData.material = material)) : this.markForUpdateRenderData(!0);
            }
        }, {
            key: "_applyAtlas",
            value: function _applyAtlas(spriteFrame) {
            }
        }, {
            key: "_applySpriteFrame",
            value: function _applySpriteFrame(oldFrame) {
                var spriteFrame = this._spriteFrame;
                spriteFrame && (oldFrame && spriteFrame === oldFrame || this._activateMaterial());
            }
        }, {
            key: "spriteAtlas",
            get: function get$$1() {
                return this._atlas;
            },
            set: function set(value) {
                this._atlas !== value && (this._atlas = value, this.spriteFrame = null);
            }
        }, {
            key: "spriteFrame",
            get: function get$$1() {
                return this._spriteFrame;
            },
            set: function set(value) {
                if (this._spriteFrame !== value) {
                    var lastSprite = this._spriteFrame;
                    this._spriteFrame = value, this.markForUpdateRenderData(!1), this._applySpriteFrame(lastSprite);
                }
            }
        }, {
            key: "type",
            get: function get$$1() {
                return this._type;
            },
            set: function set(value) {
                this._type !== value && (this._type = value, this._flushAssembler());
            }
        }, {
            key: "fillType",
            get: function get$$1() {
                return this._fillType;
            },
            set: function set(value) {
                this._fillType !== value && (value === FillType.RADIAL || this._fillType === FillType.RADIAL ? (this.destroyRenderData(), 
                this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), 
                this._fillType = value, this._flushAssembler();
            }
        }, {
            key: "fillCenter",
            get: function get$$1() {
                return this._fillCenter;
            },
            set: function set(value) {
                this._fillCenter.x = value.x, this._fillCenter.y = value.y, this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
            }
        }, {
            key: "fillStart",
            get: function get$$1() {
                return this._fillStart;
            },
            set: function set(value) {
                this._fillStart = clampf(value, -1, 1), this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
            }
        }, {
            key: "fillRange",
            get: function get$$1() {
                return this._fillRange;
            },
            set: function set(value) {
                this._fillRange = clampf(value, 0, 1), this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
            }
        }, {
            key: "trim",
            get: function get$$1() {
                return this._isTrimmedMode;
            },
            set: function set(value) {
                this._isTrimmedMode !== value && (this._isTrimmedMode = value, this._type === SpriteType.SIMPLE && this._renderData && this.markForUpdateRenderData(!0));
            }
        }, {
            key: "sizeMode",
            get: function get$$1() {
                return this._sizeMode;
            },
            set: function set(value) {
                this._sizeMode !== value && (this._sizeMode = value) !== SizeMode.CUSTOM && this._applySpriteSize();
            }
        } ]), SpriteComponent;
    }(), _class3$l.FillType = FillType, _class3$l.Type = SpriteType, _class3$l.SizeMode = SizeMode, 
    _applyDecoratedDescriptor((_class2$13 = _temp$1a).prototype, "spriteAtlas", [ _dec4$v ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "spriteAtlas"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "spriteFrame", [ _dec5$q ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "spriteFrame"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "type", [ _dec6$m ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "type"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "fillType", [ _dec7$g ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "fillType"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "fillCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "fillCenter"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "fillStart", [ property ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "fillStart"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "fillRange", [ property ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "fillRange"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "trim", [ _dec8$b ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "trim"), _class2$13.prototype), 
    _applyDecoratedDescriptor(_class2$13.prototype, "sizeMode", [ _dec9$b ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "sizeMode"), _class2$13.prototype), 
    _descriptor$12 = _applyDecoratedDescriptor(_class2$13.prototype, "_spriteFrame", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$Q = _applyDecoratedDescriptor(_class2$13.prototype, "_type", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return SpriteType.SIMPLE;
        }
    }), _descriptor3$E = _applyDecoratedDescriptor(_class2$13.prototype, "_fillType", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return FillType.HORIZONTAL;
        }
    }), _descriptor4$x = _applyDecoratedDescriptor(_class2$13.prototype, "_sizeMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return SizeMode.TRIMMED;
        }
    }), _descriptor5$r = _applyDecoratedDescriptor(_class2$13.prototype, "_fillCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Vec2(0, 0);
        }
    }), _descriptor6$k = _applyDecoratedDescriptor(_class2$13.prototype, "_fillStart", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$g = _applyDecoratedDescriptor(_class2$13.prototype, "_fillRange", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$c = _applyDecoratedDescriptor(_class2$13.prototype, "_isTrimmedMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$13.prototype, "_atlas", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1f = _class2$13)) || _class$1f) || _class$1f) || _class$1f);
    cc.SpriteComponent = SpriteComponent, function(Transition) {
        Transition[Transition.NONE = 0] = "NONE", Transition[Transition.COLOR = 1] = "COLOR", 
        Transition[Transition.SPRITE = 2] = "SPRITE", Transition[Transition.SCALE = 3] = "SCALE";
    }(Transition || (Transition = {})), ccenum(Transition), function(State) {
        State.NORMAL = "normal", State.HOVER = "hover", State.PRESSED = "pressed", State.DISABLED = "disabled";
    }(State || (State = {}));
    var ButtonComponent = (_dec$1e = ccclass("cc.ButtonComponent"), _dec2$T = executionOrder(110), 
    _dec3$F = menu("UI/Button"), _dec4$w = property({
        displayOrder: 1
    }), _dec5$r = property({
        type: Transition,
        displayOrder: 2
    }), _dec6$n = property({
        min: 0,
        max: 10
    }), _dec7$h = property({
        type: SpriteFrame
    }), _dec8$c = property({
        type: SpriteFrame
    }), _dec9$c = property({
        type: SpriteFrame
    }), _dec10$9 = property({
        type: SpriteFrame
    }), _dec11$9 = property({
        type: Node$1,
        displayOrder: 0
    }), _dec12$8 = property({
        type: EventHandler,
        displayOrder: 3
    }), _dec$1e(_class$1g = _dec2$T(_class$1g = _dec3$F(_class$1g = executeInEditMode((_temp$1b = _class3$m = function(_Component) {
        function ButtonComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ButtonComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ButtonComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "clickEvents", _descriptor$13, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_interactable", _descriptor2$R, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_transition", _descriptor3$F, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_normalColor", _descriptor4$y, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_hoverColor", _descriptor5$s, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_pressColor", _descriptor6$l, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_disabledColor", _descriptor7$h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_normalSprite", _descriptor8$d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_duration", _descriptor12$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_zoomScale", _descriptor13$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_target", _descriptor14$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._pressed = !1, _this._hovered = !1, _this._fromColor = new Color(), _this._toColor = new Color(), 
            _this._time = 0, _this._transitionFinished = !0, _this._fromScale = new Vec3(), 
            _this._toScale = new Vec3(), _this._originalScale = new Vec3(), _this._sprite = null, 
            _this._targetScale = new Vec3(), _this;
        }
        return _inherits(ButtonComponent, Component), _createClass(ButtonComponent, [ {
            key: "__preload",
            value: function __preload() {
                this.target || (this.target = this.node);
                var sprite = this.node.getComponent(SpriteComponent);
                sprite && (this._normalSprite = sprite.spriteFrame), this._applyTarget(), this._updateState();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._registerEvent();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._resetState(), this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), 
                this.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMove, this), this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), 
                this.node.off(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
                this.node.off(exports.SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.off(exports.SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            }
        }, {
            key: "update",
            value: function update(dt) {
                var target = this._target ? this._target : this.node;
                if (!this._transitionFinished && (this._transition === Transition.COLOR || this._transition === Transition.SCALE)) {
                    this._time += dt;
                    var ratio = 1;
                    0 < this._duration && (ratio = this._time / this._duration), 1 <= ratio && (ratio = 1, 
                    this._transitionFinished = !0);
                    var renderComp = target.getComponent(UIRenderComponent);
                    renderComp && (this._transition === Transition.COLOR ? renderComp.color = this._fromColor.lerp(this._toColor, ratio) : this.transition === Transition.SCALE && (target.getScale(this._targetScale), 
                    this._targetScale.x = lerp$1(this._fromScale.x, this._toScale.x, ratio), this._targetScale.y = lerp$1(this._fromScale.y, this._toScale.y, ratio), 
                    target.setScale(this._targetScale)));
                }
            }
        }, {
            key: "_resizeNodeToTargetNode",
            value: function _resizeNodeToTargetNode() {
                0;
            }
        }, {
            key: "_resetState",
            value: function _resetState() {
                this._pressed = !1, this._hovered = !1;
                var target = this._target;
                if (target) {
                    var renderComp = target.getComponent(UIRenderComponent);
                    if (renderComp) {
                        var transition = this._transition;
                        transition === Transition.COLOR && this._interactable ? renderComp.color = this._normalColor : transition === Transition.SCALE && target.setScale(this._originalScale), 
                        this._transitionFinished = !0;
                    }
                }
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMove, this), 
                this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.on(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
                this.node.on(exports.SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(exports.SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            }
        }, {
            key: "_getTargetSprite",
            value: function _getTargetSprite(target) {
                var sprite = null;
                return target && (sprite = target.getComponent(SpriteComponent)), sprite;
            }
        }, {
            key: "_applyTarget",
            value: function _applyTarget() {
                this._sprite = this._getTargetSprite(this._target), this._target && vec3.copy(this._originalScale, this._target.getScale());
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event) {
                this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), 
                event && (event.propagationStopped = !0));
            }
        }, {
            key: "_onTouchMove",
            value: function _onTouchMove(event) {
                if (this._interactable && this.enabledInHierarchy && this._pressed) {
                    if (!event) return !1;
                    var touch = event.touch;
                    if (!touch) return !1;
                    var state, hit = this.node.uiTransfromComp.isHit(touch.getUILocation());
                    if (this._transition === Transition.SCALE && this._target) hit ? (vec3.copy(this._fromScale, this._originalScale), 
                    vec3.scale(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, 
                    this._transitionFinished = !0, this._target && this._target.setScale(this._originalScale)); else state = hit ? State.PRESSED : State.NORMAL, 
                    this._applyTransition(state);
                    event && (event.propagationStopped = !0);
                }
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                this._interactable && this.enabledInHierarchy && (this._pressed && (EventHandler.emitEvents(this.clickEvents, event), 
                this.node.emit("click", this)), this._pressed = !1, this._updateState(), event && (event.propagationStopped = !0));
            }
        }, {
            key: "_onTouchCancel",
            value: function _onTouchCancel(event) {
                this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState());
            }
        }, {
            key: "_onMouseMoveIn",
            value: function _onMouseMoveIn(event) {
                !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition !== Transition.SPRITE || this._hoverSprite) && (this._hovered || (this._hovered = !0, 
                this._updateState()));
            }
        }, {
            key: "_onMouseMoveOut",
            value: function _onMouseMoveOut(event) {
                this._hovered && (this._hovered = !1, this._updateState());
            }
        }, {
            key: "_updateState",
            value: function _updateState() {
                var state = this._getButtonState();
                this._applyTransition(state);
            }
        }, {
            key: "_getButtonState",
            value: function _getButtonState() {
                var state = State.NORMAL;
                return this._interactable ? this._pressed ? state = State.PRESSED : this._hovered && (state = State.HOVER) : state = State.DISABLED, 
                state.toString();
            }
        }, {
            key: "_updateColorTransition",
            value: function _updateColorTransition(state) {
                var color = this[state + "Color"], target = this._target;
                if (target) {
                    var renderComp = target.getComponent(UIRenderComponent);
                    renderComp && (state === State.DISABLED ? renderComp.color = color : (this._fromColor = renderComp.color.clone(), 
                    this._toColor = color, this._time = 0, this._transitionFinished = !1));
                }
            }
        }, {
            key: "_updateSpriteTransition",
            value: function _updateSpriteTransition(state) {
                var sprite = this[state + "Sprite"];
                this._sprite && sprite && (this._sprite.spriteFrame = sprite);
            }
        }, {
            key: "_updateScaleTransition",
            value: function _updateScaleTransition(state) {
                this._interactable && (state === State.PRESSED ? this._zoomUp() : this._zoomBack());
            }
        }, {
            key: "_zoomUp",
            value: function _zoomUp() {
                vec3.copy(this._fromScale, this._originalScale), vec3.scale(this._toScale, this._originalScale, this._zoomScale), 
                this._time = 0, this._transitionFinished = !1;
            }
        }, {
            key: "_zoomBack",
            value: function _zoomBack() {
                this._target && (vec3.copy(this._fromScale, this._target.getScale()), vec3.copy(this._toScale, this._originalScale), 
                this._time = 0, this._transitionFinished = !1);
            }
        }, {
            key: "_applyTransition",
            value: function _applyTransition(state) {
                var transition = this._transition;
                transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
            }
        }, {
            key: "interactable",
            get: function get() {
                return this._interactable;
            },
            set: function set(value) {
                this._interactable = value, this._updateState(), this._interactable || this._resetState();
            }
        }, {
            key: "_resizeToTarget",
            set: function set(value) {
                value && this._resizeNodeToTargetNode();
            }
        }, {
            key: "transition",
            get: function get() {
                return this._transition;
            },
            set: function set(value) {
                this._transition !== value && (this._transition = value);
            }
        }, {
            key: "normalColor",
            get: function get() {
                return this._normalColor;
            },
            set: function set(value) {
                this._normalColor !== value && (this._normalColor.set(value), this._updateState());
            }
        }, {
            key: "pressedColor",
            get: function get() {
                return this._pressColor;
            },
            set: function set(value) {
                this._pressColor !== value && this._pressColor.set(value);
            }
        }, {
            key: "hoverColor",
            get: function get() {
                return this._hoverColor;
            },
            set: function set(value) {
                this._hoverColor !== value && this._hoverColor.set(value);
            }
        }, {
            key: "disabledColor",
            get: function get() {
                return this._disabledColor;
            },
            set: function set(value) {
                this._disabledColor !== value && (this._disabledColor.set(value), this._updateState());
            }
        }, {
            key: "duration",
            get: function get() {
                return this._duration;
            },
            set: function set(value) {
                this._duration !== value && (this._duration = value);
            }
        }, {
            key: "zoomScale",
            get: function get() {
                return this._zoomScale;
            },
            set: function set(value) {
                this._zoomScale !== value && (this._zoomScale = value);
            }
        }, {
            key: "normalSprite",
            get: function get() {
                return this._normalSprite;
            },
            set: function set(value) {
                if (this._normalSprite !== value) {
                    this._normalSprite = value;
                    var sprite = this.node.getComponent(SpriteComponent);
                    sprite && (sprite.spriteFrame = value), this._updateState();
                }
            }
        }, {
            key: "pressedSprite",
            get: function get() {
                return this._pressedSprite;
            },
            set: function set(value) {
                this._pressedSprite !== value && (this._pressedSprite = value, this._updateState());
            }
        }, {
            key: "hoverSprite",
            get: function get() {
                return this._hoverSprite;
            },
            set: function set(value) {
                this._hoverSprite !== value && (this._hoverSprite = value, this._updateState());
            }
        }, {
            key: "disabledSprite",
            get: function get() {
                return this._disabledSprite;
            },
            set: function set(value) {
                this._disabledSprite !== value && (this._disabledSprite = value, this._updateState());
            }
        }, {
            key: "target",
            get: function get() {
                return this._target;
            },
            set: function set(value) {
                this._target !== value && (this._target = value, this._applyTarget());
            }
        } ]), ButtonComponent;
    }(), _class3$m.Transition = Transition, _applyDecoratedDescriptor((_class2$14 = _temp$1b).prototype, "interactable", [ _dec4$w ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "interactable"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "transition", [ _dec5$r ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "transition"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "normalColor", [ property ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "normalColor"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "pressedColor", [ property ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "pressedColor"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "hoverColor", [ property ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "hoverColor"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "disabledColor", [ property ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "disabledColor"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "duration", [ _dec6$n ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "duration"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "zoomScale", [ property ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "zoomScale"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "normalSprite", [ _dec7$h ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "normalSprite"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "pressedSprite", [ _dec8$c ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "pressedSprite"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "hoverSprite", [ _dec9$c ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "hoverSprite"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "disabledSprite", [ _dec10$9 ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "disabledSprite"), _class2$14.prototype), 
    _applyDecoratedDescriptor(_class2$14.prototype, "target", [ _dec11$9 ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "target"), _class2$14.prototype), 
    _descriptor$13 = _applyDecoratedDescriptor(_class2$14.prototype, "clickEvents", [ _dec12$8 ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$R = _applyDecoratedDescriptor(_class2$14.prototype, "_interactable", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$F = _applyDecoratedDescriptor(_class2$14.prototype, "_transition", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Transition.NONE;
        }
    }), _descriptor4$y = _applyDecoratedDescriptor(_class2$14.prototype, "_normalColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(214, 214, 214, 255);
        }
    }), _descriptor5$s = _applyDecoratedDescriptor(_class2$14.prototype, "_hoverColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(211, 211, 211, 255);
        }
    }), _descriptor6$l = _applyDecoratedDescriptor(_class2$14.prototype, "_pressColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE;
        }
    }), _descriptor7$h = _applyDecoratedDescriptor(_class2$14.prototype, "_disabledColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(124, 124, 124, 255);
        }
    }), _descriptor8$d = _applyDecoratedDescriptor(_class2$14.prototype, "_normalSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor9$a = _applyDecoratedDescriptor(_class2$14.prototype, "_hoverSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$14.prototype, "_pressedSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$14.prototype, "_disabledSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$14.prototype, "_duration", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor13$6 = _applyDecoratedDescriptor(_class2$14.prototype, "_zoomScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1.2;
        }
    }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$14.prototype, "_target", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1g = _class2$14)) || _class$1g) || _class$1g) || _class$1g) || _class$1g);
    cc.ButtonComponent = ButtonComponent;
    var _dec$1f, _dec2$U, _dec3$G, _dec4$x, _dec5$s, _dec6$o, _dec7$i, _dec8$d, _dec9$d, _dec10$a, _dec11$a, _dec12$9, _dec13$7, _dec14$6, _dec15$5, _dec16$4, _dec17$3, _dec18$3, _class$1h, _class2$15, _descriptor$14, _descriptor2$S, _descriptor3$G, _descriptor4$z, _descriptor5$t, _descriptor6$m, _descriptor7$i, _descriptor8$e, _descriptor9$b, _descriptor10$8, _descriptor11$7, _descriptor12$7, _descriptor13$7, _descriptor14$3, _descriptor15$2, _descriptor16$2, _class3$n, _temp$1c, HorizontalTextAlignment, CacheMode, CanvasPool = function() {
        function CanvasPool() {
            _classCallCheck(this, CanvasPool), this.pool = [];
        }
        return _createClass(CanvasPool, [ {
            key: "get",
            value: function get() {
                var data = this.pool.pop();
                if (!data) {
                    var _canvas = document.createElement("canvas"), _context = _canvas.getContext("2d");
                    data = {
                        canvas: _canvas,
                        context: _context
                    };
                }
                return data;
            }
        }, {
            key: "put",
            value: function put(canvas) {
                32 <= this.pool.length || this.pool.push(canvas);
            }
        } ]), CanvasPool;
    }();
    (HorizontalTextAlignment = exports.HorizontalTextAlignment || (exports.HorizontalTextAlignment = {}))[HorizontalTextAlignment.LEFT = 0] = "LEFT", 
    HorizontalTextAlignment[HorizontalTextAlignment.CENTER = 1] = "CENTER", HorizontalTextAlignment[HorizontalTextAlignment.RIGHT = 2] = "RIGHT", 
    ccenum(exports.HorizontalTextAlignment), function(VerticalTextAlignment) {
        VerticalTextAlignment[VerticalTextAlignment.TOP = 0] = "TOP", VerticalTextAlignment[VerticalTextAlignment.CENTER = 1] = "CENTER", 
        VerticalTextAlignment[VerticalTextAlignment.BOTTOM = 2] = "BOTTOM";
    }(exports.VerticalTextAlignment || (exports.VerticalTextAlignment = {})), ccenum(exports.VerticalTextAlignment), 
    function(Overflow) {
        Overflow[Overflow.NONE = 0] = "NONE", Overflow[Overflow.CLAMP = 1] = "CLAMP", Overflow[Overflow.SHRINK = 2] = "SHRINK", 
        Overflow[Overflow.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT";
    }(exports.Overflow || (exports.Overflow = {})), ccenum(exports.Overflow), function(CacheMode) {
        CacheMode[CacheMode.NONE = 0] = "NONE", CacheMode[CacheMode.BITMAP = 1] = "BITMAP", 
        CacheMode[CacheMode.CHAR = 2] = "CHAR";
    }(CacheMode || (CacheMode = {})), ccenum(CacheMode);
    var KeyboardReturnType, InputMode, InputFlag, _class$1i, LabelComponent = (_dec$1f = ccclass("cc.LabelComponent"), 
    _dec2$U = executionOrder(110), _dec3$G = menu("UI/Render/Label"), _dec4$x = property({
        displayOrder: 4
    }), _dec5$s = property({
        type: exports.HorizontalTextAlignment,
        displayOrder: 5
    }), _dec6$o = property({
        type: exports.VerticalTextAlignment,
        displayOrder: 6
    }), _dec7$i = property({
        readonly: !0,
        displayName: "Actual Font Size",
        visible: !1
    }), _dec8$d = property({
        displayOrder: 7
    }), _dec9$d = property({
        displayOrder: 8
    }), _dec10$a = property({
        displayOrder: 8
    }), _dec11$a = property({
        type: exports.Overflow,
        displayOrder: 9
    }), _dec12$9 = property({
        displayOrder: 10
    }), _dec13$7 = property({
        type: Font,
        displayOrder: 11
    }), _dec14$6 = property({
        displayOrder: 12
    }), _dec15$5 = property({
        type: CacheMode,
        displayOrder: 13
    }), _dec16$4 = property({
        displayOrder: 15
    }), _dec17$3 = property({
        displayOrder: 16
    }), _dec18$3 = property({
        displayOrder: 17
    }), _dec$1f(_class$1h = _dec2$U(_class$1h = _dec3$G((_temp$1c = _class3$n = function(_UIRenderComponent) {
        function LabelComponent() {
            var _this;
            return _classCallCheck(this, LabelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LabelComponent).call(this)), "_useOriginalSize", _descriptor$14, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_string", _descriptor2$S, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$G, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$z, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_actualFontSize", _descriptor5$t, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fontSize", _descriptor6$m, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fontFamily", _descriptor7$i, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_lineHeight", _descriptor8$e, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_overflow", _descriptor9$b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_enableWrapText", _descriptor10$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_font", _descriptor11$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor12$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._spacingX = 0, _initializerDefineProperty(_this, "_isItalic", _descriptor13$7, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isBold", _descriptor14$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isUnderline", _descriptor15$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_cacheMode", _descriptor16$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._N$file = null, _this._texture = null, _this._ttfTexture = null, _this._userDefinedFont = null, 
            _this._assemblerData = null, _this._fontAtlas = null, _this._letterTexture = null, 
            _this._ttfTexture = null, _this;
        }
        return _inherits(LabelComponent, UIRenderComponent), _createClass(LabelComponent, [ {
            key: "string",
            get: function get$$1() {
                return this._string;
            },
            set: function set(value) {
                value = value.toString(), this._string !== value && (this._string = value, this._checkStringEmpty(), 
                this.updateRenderData());
            }
        }, {
            key: "horizontalAlign",
            get: function get$$1() {
                return this._horizontalAlign;
            },
            set: function set(value) {
                this._horizontalAlign !== value && (this._horizontalAlign = value, this.updateRenderData());
            }
        }, {
            key: "verticalAlign",
            get: function get$$1() {
                return this._verticalAlign;
            },
            set: function set(value) {
                this._verticalAlign !== value && (this._verticalAlign = value, this.updateRenderData());
            }
        }, {
            key: "actualFontSize",
            get: function get$$1() {
                return this._actualFontSize;
            },
            set: function set(value) {
                this._actualFontSize = value;
            }
        }, {
            key: "fontSize",
            get: function get$$1() {
                return this._fontSize;
            },
            set: function set(value) {
                this._fontSize !== value && (this._fontSize = value, this.updateRenderData());
            }
        }, {
            key: "fontFamily",
            get: function get$$1() {
                return this._fontFamily;
            },
            set: function set(value) {
                this._fontFamily !== value && (this._fontFamily = value, this.updateRenderData());
            }
        }, {
            key: "lineHeight",
            get: function get$$1() {
                return this._lineHeight;
            },
            set: function set(value) {
                this._lineHeight !== value && (this._lineHeight = value, this.updateRenderData());
            }
        }, {
            key: "overflow",
            get: function get$$1() {
                return this._overflow;
            },
            set: function set(value) {
                this._overflow !== value && (this._overflow = value, this.updateRenderData());
            }
        }, {
            key: "enableWrapText",
            get: function get$$1() {
                return this._enableWrapText;
            },
            set: function set(value) {
                this._enableWrapText !== value && (this._enableWrapText = value, this.updateRenderData());
            }
        }, {
            key: "font",
            get: function get$$1() {
                return this._font;
            },
            set: function set(value) {
                this._font !== value && (this._isSystemFontUsed = !value, "string" == typeof (this._font = value) && cc.warnID(4e3), 
                this._renderData && (this.destroyRenderData(), this._renderData = null), this._flushAssembler(), 
                this._applyFontTexture(!0), this.updateRenderData());
            }
        }, {
            key: "useSystemFont",
            get: function get$$1() {
                return this._isSystemFontUsed;
            },
            set: function set(value) {
                this._isSystemFontUsed !== value && (this.destroyRenderData(), this._renderData = null, 
                this._isSystemFontUsed = !!value, value && (this.font = null, this._flushAssembler(), 
                this.updateRenderData(), this._checkStringEmpty()));
            }
        }, {
            key: "cacheMode",
            get: function get$$1() {
                return this._cacheMode;
            },
            set: function set(value) {
                this._cacheMode !== value && (this._cacheMode === CacheMode.CHAR && (this._ttfTexture = null), 
                this._cacheMode = value, this.updateRenderData(!0));
            }
        }, {
            key: "spriteFrame",
            get: function get$$1() {
                return this._texture;
            }
        }, {
            key: "isBold",
            get: function get$$1() {
                return this._isBold;
            },
            set: function set(value) {
                this._isBold !== value && (this._isBold = value, this.updateRenderData());
            }
        }, {
            key: "isItalic",
            get: function get$$1() {
                return this._isItalic;
            },
            set: function set(value) {
                this._isItalic !== value && (this._isItalic = value, this.updateRenderData());
            }
        }, {
            key: "isUnderline",
            get: function get$$1() {
                return this._isUnderline;
            },
            set: function set(value) {
                this._isUnderline !== value && (this._isUnderline = value, this.updateRenderData());
            }
        }, {
            key: "assemblerData",
            get: function get$$1() {
                return this._assemblerData;
            }
        }, {
            key: "fontAtlas",
            get: function get$$1() {
                return this._fontAtlas;
            },
            set: function set(value) {
                this._fontAtlas = value;
            }
        }, {
            key: "spacingX",
            get: function get$$1() {
                return this._spacingX;
            },
            set: function set(value) {
                this._spacingX !== value && (this._spacingX = value, this.updateRenderData());
            }
        }, {
            key: "_bmFontOriginalSize",
            get: function get$$1() {
                return this._font instanceof BitmapFont ? this._font.fontSize : -1;
            }
        } ]), _createClass(LabelComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(LabelComponent.prototype), "onEnable", this).call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), 
                this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this._checkStringEmpty(), 
                this.updateRenderData(!0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(LabelComponent.prototype), "onDisable", this).call(this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), 
                this._assemblerData = null, this._ttfTexture && (this._ttfTexture.destroy(), this._ttfTexture = null), 
                _get(_getPrototypeOf(LabelComponent.prototype), "onDestroy", this).call(this);
            }
        }, {
            key: "updateRenderData",
            value: function updateRenderData() {
                var force = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                this.markForUpdateRenderData(!0), force && (this._flushAssembler(), this._applyFontTexture(force));
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                return !(!_get(_getPrototypeOf(LabelComponent.prototype), "updateAssembler", this).call(this, render) || !this._texture) && (render.commitComp(this, this._texture.getGFXTextureView(), this._assembler), 
                !0);
            }
        }, {
            key: "_updateColor",
            value: function _updateColor() {
                this._font instanceof BitmapFont ? _get(_getPrototypeOf(LabelComponent.prototype), "_updateColor", this).call(this) : this.updateRenderData(!1);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                if (!_get(_getPrototypeOf(LabelComponent.prototype), "_canRender", this).call(this)) return !1;
                var font = this._font;
                if (font && font instanceof BitmapFont) {
                    var spriteFrame = font.spriteFrame;
                    if (!spriteFrame || !spriteFrame.textureLoaded()) return !1;
                }
                return !0;
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = LabelComponent.Assembler.getAssembler(this);
                this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                this._renderData.material = this._material);
            }
        }, {
            key: "_checkStringEmpty",
            value: function _checkStringEmpty() {
                this._renderPermit = !!this.string;
            }
        }, {
            key: "_flushMaterial",
            value: function _flushMaterial() {
                var material = this._material;
                material && material.setProperty("mainTexture", this._texture), this._updateMaterial(material);
            }
        }, {
            key: "_applyFontTexture",
            value: function _applyFontTexture(force) {
                var font = this._font;
                if (font instanceof BitmapFont) {
                    var spriteFrame = font.spriteFrame, self = this;
                    spriteFrame && function onBMFontTextureLoaded() {
                        self._texture = spriteFrame, self._flushMaterial();
                    }();
                } else {
                    if (this.cacheMode === CacheMode.CHAR && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) this._letterTexture = this._assembler.getAssemblerData(), 
                    this._texture = this._letterTexture; else if (!this._ttfTexture) {
                        this._ttfTexture = new SpriteFrame(), this._assemblerData = this._assembler.getAssemblerData();
                        var image = new ImageAsset(this._assemblerData.canvas);
                        this._ttfTexture.image = image;
                    }
                    this.cacheMode !== CacheMode.CHAR && (this._texture = this._ttfTexture), this._flushMaterial();
                }
                force && this._assembler && this._assembler.updateRenderData && this._assembler.updateRenderData(this);
            }
        } ]), LabelComponent;
    }(), _class3$n.HorizontalAlign = exports.HorizontalTextAlignment, _class3$n.VerticalAlign = exports.VerticalTextAlignment, 
    _class3$n.Overflow = exports.Overflow, _class3$n.CacheMode = CacheMode, _class3$n.CanvasPool = new CanvasPool(), 
    _applyDecoratedDescriptor((_class2$15 = _temp$1c).prototype, "string", [ _dec4$x ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "string"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "horizontalAlign", [ _dec5$s ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "horizontalAlign"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "verticalAlign", [ _dec6$o ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "verticalAlign"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "actualFontSize", [ _dec7$i ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "actualFontSize"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "fontSize", [ _dec8$d ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "fontSize"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "fontFamily", [ _dec9$d ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "fontFamily"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "lineHeight", [ _dec10$a ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "lineHeight"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "overflow", [ _dec11$a ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "overflow"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "enableWrapText", [ _dec12$9 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "enableWrapText"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "font", [ _dec13$7 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "font"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "useSystemFont", [ _dec14$6 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "useSystemFont"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "cacheMode", [ _dec15$5 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "cacheMode"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "isBold", [ _dec16$4 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "isBold"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "isItalic", [ _dec17$3 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "isItalic"), _class2$15.prototype), 
    _applyDecoratedDescriptor(_class2$15.prototype, "isUnderline", [ _dec18$3 ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "isUnderline"), _class2$15.prototype), 
    _descriptor$14 = _applyDecoratedDescriptor(_class2$15.prototype, "_useOriginalSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor2$S = _applyDecoratedDescriptor(_class2$15.prototype, "_string", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "label";
        }
    }), _descriptor3$G = _applyDecoratedDescriptor(_class2$15.prototype, "_horizontalAlign", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.HorizontalTextAlignment.LEFT;
        }
    }), _descriptor4$z = _applyDecoratedDescriptor(_class2$15.prototype, "_verticalAlign", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.VerticalTextAlignment.TOP;
        }
    }), _descriptor5$t = _applyDecoratedDescriptor(_class2$15.prototype, "_actualFontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$m = _applyDecoratedDescriptor(_class2$15.prototype, "_fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor7$i = _applyDecoratedDescriptor(_class2$15.prototype, "_fontFamily", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "Arial";
        }
    }), _descriptor8$e = _applyDecoratedDescriptor(_class2$15.prototype, "_lineHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor9$b = _applyDecoratedDescriptor(_class2$15.prototype, "_overflow", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.Overflow.NONE;
        }
    }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$15.prototype, "_enableWrapText", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$15.prototype, "_font", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor12$7 = _applyDecoratedDescriptor(_class2$15.prototype, "_isSystemFontUsed", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor13$7 = _applyDecoratedDescriptor(_class2$15.prototype, "_isItalic", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$15.prototype, "_isBold", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$15.prototype, "_isUnderline", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$15.prototype, "_cacheMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return CacheMode.NONE;
        }
    }), _class$1h = _class2$15)) || _class$1h) || _class$1h) || _class$1h);
    cc.LabelComponent = LabelComponent, function(KeyboardReturnType) {
        KeyboardReturnType[KeyboardReturnType.DEFAULT = 0] = "DEFAULT", KeyboardReturnType[KeyboardReturnType.DONE = 1] = "DONE", 
        KeyboardReturnType[KeyboardReturnType.SEND = 2] = "SEND", KeyboardReturnType[KeyboardReturnType.SEARCH = 3] = "SEARCH", 
        KeyboardReturnType[KeyboardReturnType.GO = 4] = "GO", KeyboardReturnType[KeyboardReturnType.NEXT = 5] = "NEXT";
    }(KeyboardReturnType || (KeyboardReturnType = {})), Enum(KeyboardReturnType), function(InputMode) {
        InputMode[InputMode.ANY = 0] = "ANY", InputMode[InputMode.EMAIL_ADDR = 1] = "EMAIL_ADDR", 
        InputMode[InputMode.NUMERIC = 2] = "NUMERIC", InputMode[InputMode.PHONE_NUMBER = 3] = "PHONE_NUMBER", 
        InputMode[InputMode.URL = 4] = "URL", InputMode[InputMode.DECIMAL = 5] = "DECIMAL", 
        InputMode[InputMode.SINGLE_LINE = 6] = "SINGLE_LINE";
    }(InputMode || (InputMode = {})), Enum(InputMode), function(InputFlag) {
        InputFlag[InputFlag.PASSWORD = 0] = "PASSWORD", InputFlag[InputFlag.SENSITIVE = 1] = "SENSITIVE", 
        InputFlag[InputFlag.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", InputFlag[InputFlag.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", 
        InputFlag[InputFlag.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", 
        InputFlag[InputFlag.DEFAULT = 5] = "DEFAULT";
    }(InputFlag || (InputFlag = {})), Enum(InputFlag);
    var _matrix$1 = new Mat4(), _matrix_temp = new Mat4(), _vec3 = new Vec3(), _currentEditBoxImpl = null, polyfill = {
        zoomInvalid: !1
    };
    cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = !0);
    var _dec$1g, _dec2$V, _dec3$H, _dec4$y, _dec5$t, _dec6$p, _dec7$j, _dec8$e, _dec9$e, _dec10$b, _dec11$b, _dec12$a, _class$1j, _class2$16, _descriptor$15, _descriptor2$T, _descriptor3$H, _descriptor4$A, _descriptor5$u, _descriptor6$n, _descriptor7$j, _descriptor8$f, _descriptor9$c, _descriptor10$9, _descriptor11$8, _descriptor12$8, _descriptor13$8, _descriptor14$4, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$2, _descriptor19$2, _class3$o, _temp$1e, EditBoxImpl = ccclass(_class$1i = function() {
        function EditBoxImpl() {
            _classCallCheck(this, EditBoxImpl), this._delegate = null, this._inputMode = -1, 
            this._inputFlag = -1, this._returnType = KeyboardReturnType.DEFAULT, this._maxLength = 50, 
            this._text = "", this._placeholderText = "", this._alwaysOnTop = !1, this._size = cc.size(), 
            this._node = null, this._editing = !1, this.__eventListeners = {}, this.__fullscreen = !1, 
            this.__autoResize = !1, this.__rotateScreen = !1, this.__orientationChanged = void 0, 
            this._edTxt = null, this._textColor = Color.WHITE, this._edFontSize = 14;
        }
        return _createClass(EditBoxImpl, [ {
            key: "onEnable",
            value: function onEnable() {
                this._edTxt && (this._alwaysOnTop ? this._edTxt.style.display = "" : this._edTxt.style.display = "none");
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._edTxt && (this._edTxt.style.display = "none");
            }
        }, {
            key: "setTabIndex",
            value: function setTabIndex(index) {
                this._edTxt && (this._edTxt.tabIndex = index);
            }
        }, {
            key: "setFocus",
            value: function setFocus() {
                this._beginEditing();
            }
        }, {
            key: "isFocused",
            value: function isFocused() {
                return this._edTxt ? document.activeElement === this._edTxt : (cc.warnID(4700), 
                !1);
            }
        }, {
            key: "stayOnTop",
            value: function stayOnTop(flag) {
                this._alwaysOnTop !== flag && this._edTxt && (this._alwaysOnTop = flag, this._edTxt.style.display = flag ? "" : "none");
            }
        }, {
            key: "setMaxLength",
            value: function setMaxLength(maxLength) {
                isNaN(maxLength) || (maxLength < 0 && (maxLength = 65535), this._maxLength = maxLength, 
                this._edTxt && (this._edTxt.maxLength = maxLength));
            }
        }, {
            key: "setString",
            value: function setString(text) {
                this._text = text, this._edTxt && (this._edTxt.value = text);
            }
        }, {
            key: "getString",
            value: function getString() {
                return this._text;
            }
        }, {
            key: "setPlaceholderText",
            value: function setPlaceholderText(text) {
                this._placeholderText = text;
            }
        }, {
            key: "getPlaceholderText",
            value: function getPlaceholderText() {
                return this._placeholderText;
            }
        }, {
            key: "setDelegate",
            value: function setDelegate(delegate) {
                this._delegate = delegate;
            }
        }, {
            key: "setInputMode",
            value: function setInputMode(inputMode) {
                this._inputMode !== inputMode && (this._inputMode = inputMode, this.createInput(), 
                this._updateDomInputType(), this._updateSize(this._size.width, this._size.height));
            }
        }, {
            key: "setInputFlag",
            value: function setInputFlag(inputFlag) {
                if (this._inputFlag !== inputFlag) {
                    this._inputFlag = inputFlag, this._updateDomInputType();
                    var textTransform = "none";
                    inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                    this._edTxt && (this._edTxt.style.textTransform = textTransform, this._edTxt.value = this._text);
                }
            }
        }, {
            key: "setReturnType",
            value: function setReturnType(returnType) {
                this._returnType = returnType, this._updateDomInputType();
            }
        }, {
            key: "setFontSize",
            value: function setFontSize(fontSize) {
                this._edFontSize = fontSize || this._edFontSize, this._edTxt && (this._edTxt.style.fontSize = this._edFontSize + "px");
            }
        }, {
            key: "setFontColor",
            value: function setFontColor(color) {
                this._textColor = color, this._edTxt && (this._edTxt.style.color = color.toCSS("rgba"));
            }
        }, {
            key: "setSize",
            value: function setSize(width, height) {
                this._size.width = width, this._size.height = height, this._updateSize(width, height);
            }
        }, {
            key: "setNode",
            value: function setNode(node) {
                this._node = node;
            }
        }, {
            key: "update",
            value: function update() {
                this._updateMatrix();
            }
        }, {
            key: "clear",
            value: function clear() {
                this._node = null, this.setDelegate(null), this.removeDom();
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(touch) {}
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded() {
                this._beginEditing();
            }
        }, {
            key: "_beginEditing",
            value: function _beginEditing() {
                if (cc.sys.isMobile && !this._editing && this._beginEditingOnMobile(), this._edTxt) {
                    var startFocus = function startFocus() {
                        self._edTxt.focus();
                    };
                    this._edTxt.style.display = "";
                    var self = this;
                    cc.sys.browserType === cc.sys.BROWSER_TYPE_UC ? setTimeout(startFocus, 400) : cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX ? setTimeout(startFocus, 0) : startFocus();
                }
                this._editing = !0;
            }
        }, {
            key: "_endEditing",
            value: function _endEditing() {
                var self = this, hideDomInputAndShowLabel = function hideDomInputAndShowLabel() {
                    !self._alwaysOnTop && self._edTxt && (self._edTxt.style.display = "none"), self._delegate && self._delegate.editBoxEditingDidEnded && self._delegate.editBoxEditingDidEnded();
                };
                this._editing && (cc.sys.isMobile ? setTimeout(function() {
                    self._endEditingOnMobile(), hideDomInputAndShowLabel();
                }, 400) : hideDomInputAndShowLabel()), this._editing = !1;
            }
        }, {
            key: "_updateDomInputType",
            value: function _updateDomInputType() {
                var inputMode = this._inputMode, edTxt = this._edTxt;
                if (edTxt) if (this._inputFlag !== InputFlag.PASSWORD) {
                    var type = edTxt.type;
                    inputMode === InputMode.EMAIL_ADDR ? type = "email" : inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL ? type = "number" : inputMode === InputMode.PHONE_NUMBER ? (type = "number", 
                    edTxt.pattern = "[0-9]*") : inputMode === InputMode.URL ? type = "url" : (type = "text", 
                    this._returnType === KeyboardReturnType.SEARCH && (type = "search")), edTxt.type = type;
                } else edTxt.type = "password";
            }
        }, {
            key: "_updateSize",
            value: function _updateSize(newWidth, newHeight) {
                var edTxt = this._edTxt;
                edTxt && (edTxt.style.width = newWidth + "px", edTxt.style.height = newHeight + "px");
            }
        }, {
            key: "_updateMatrix",
            value: function _updateMatrix() {
                if (this._edTxt) {
                    var node = this._node, scaleX = cc.view._scaleX, scaleY = cc.view._scaleY, viewport = cc.view._viewportRect, dpr = cc.view._devicePixelRatio;
                    node.getWorldMatrix(_matrix$1);
                    var transform = node.uiTransfromComp;
                    transform && vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z), 
                    mat4.translate(_matrix$1, _matrix$1, _vec3);
                    var renderComp = node.getComponent(UIRenderComponent);
                    if (!renderComp) return !1;
                    var canvas = cc.director.root.ui.getScreen(renderComp.visibility);
                    if (canvas) {
                        canvas.node.getWorldRT(_matrix_temp);
                        var m12 = _matrix_temp.m12, m13 = _matrix_temp.m13, center = cc.visibleRect.center;
                        _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13), 
                        _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13), 
                        mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1), scaleX /= dpr, scaleY /= dpr;
                        var container = cc.game.container, a = _matrix_temp.m00 * scaleX, b = _matrix$1.m01, c = _matrix$1.m04, d = _matrix_temp.m05 * scaleY, offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
                        offsetX += viewport.x / dpr;
                        var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
                        offsetY += viewport.y / dpr;
                        var tx = _matrix_temp.m12 * scaleX + offsetX, ty = _matrix_temp.m13 * scaleY + offsetY;
                        polyfill.zoomInvalid && (this._updateSize(this._size.width * a, this._size.height * d), 
                        d = a = 1);
                        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                        this._edTxt.style.transform = matrix, this._edTxt.style["-webkit-transform"] = matrix, 
                        this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
                    }
                }
            }
        }, {
            key: "_adjustEditBoxPosition",
            value: function _adjustEditBoxPosition() {
                this._node.getWorldMatrix(_matrix$1);
                var y = _matrix$1.m13, windowHeight = cc.visibleRect.height, windowWidth = cc.visibleRect.width, factor = .5;
                windowHeight < windowWidth && (factor = .7), setTimeout(function() {
                    if (window.scrollY < 40 && y < windowHeight * factor) {
                        var scrollOffset = windowHeight * factor - y - window.scrollY;
                        scrollOffset < 35 && (scrollOffset = 35), 320 < scrollOffset && (scrollOffset = 320), 
                        window.scrollTo(0, scrollOffset);
                    }
                }, 400);
            }
        }, {
            key: "createInput",
            value: function createInput() {
                this._inputMode === InputMode.ANY ? this._createDomTextArea() : this._createDomInput();
            }
        }, {
            key: "_beginEditingOnMobile",
            value: function _beginEditingOnMobile() {
                var self = this;
                this.__orientationChanged = function() {
                    self._adjustEditBoxPosition();
                }, window.addEventListener("orientationchange", this.__orientationChanged), cc.view.isAutoFullScreenEnabled() ? (this.__fullscreen = !0, 
                cc.view.enableAutoFullScreen(!1), cc.screen.exitFullScreen()) : this.__fullscreen = !1, 
                this.__autoResize = cc.view._resizeWithBrowserSize, cc.view.resizeWithBrowserSize(!1), 
                _currentEditBoxImpl = this;
            }
        }, {
            key: "_endEditingOnMobile",
            value: function _endEditingOnMobile() {
                if (this.__rotateScreen) {
                    cc.game.container.style["-webkit-transform"] = "rotate(90deg)", cc.game.container.style.transform = "rotate(90deg)";
                    var view = cc.view, width = view._originalDesignResolutionSize.width, height = view._originalDesignResolutionSize.height;
                    0 < width && view.setDesignResolutionSize(width, height, view._resolutionPolicy), 
                    this.__rotateScreen = !1;
                }
                this.__orientationChanged && window.removeEventListener("orientationchange", this.__orientationChanged), 
                this.__fullscreen && cc.view.enableAutoFullScreen(!0), this.__autoResize && _currentEditBoxImpl === this && cc.view.resizeWithBrowserSize(!0);
            }
        }, {
            key: "_createDomInput",
            value: function _createDomInput() {
                this.removeDom();
                var tmpEdTxt = this._edTxt = document.createElement("input");
                return tmpEdTxt.type = "text", tmpEdTxt.style.fontSize = this._edFontSize + "px", 
                tmpEdTxt.style.color = "#000000", tmpEdTxt.style.border = "0px", tmpEdTxt.style.background = "transparent", 
                tmpEdTxt.style.width = "100%", tmpEdTxt.style.height = "100%", tmpEdTxt.style.outline = "medium", 
                tmpEdTxt.style.padding = "0", tmpEdTxt.style.textTransform = "uppercase", tmpEdTxt.style.display = "none", 
                tmpEdTxt.style.position = "absolute", tmpEdTxt.style.bottom = "0px", tmpEdTxt.style.left = "2px", 
                tmpEdTxt.style["-moz-appearance"] = "textfield", tmpEdTxt.className = "cocosEditBox", 
                tmpEdTxt.style.fontFamily = "Arial", registerInputEventListener(tmpEdTxt, this), 
                tmpEdTxt;
            }
        }, {
            key: "_createDomTextArea",
            value: function _createDomTextArea() {
                this.removeDom();
                var tmpEdTxt = this._edTxt = document.createElement("textarea");
                return tmpEdTxt.style.fontSize = this._edFontSize + "px", tmpEdTxt.style.color = "#000000", 
                tmpEdTxt.style.border = "0", tmpEdTxt.style.background = "transparent", tmpEdTxt.style.width = "100%", 
                tmpEdTxt.style.height = "100%", tmpEdTxt.style.outline = "medium", tmpEdTxt.style.padding = "0", 
                tmpEdTxt.style.resize = "none", tmpEdTxt.style.textTransform = "uppercase", tmpEdTxt.style.overflowY = "scroll", 
                tmpEdTxt.style.display = "none", tmpEdTxt.style.position = "absolute", tmpEdTxt.style.bottom = "0px", 
                tmpEdTxt.style.left = "2px", tmpEdTxt.className = "cocosEditBox", tmpEdTxt.style.fontFamily = "Arial", 
                registerInputEventListener(tmpEdTxt, this, !0), tmpEdTxt;
            }
        }, {
            key: "_addDomToGameContainer",
            value: function _addDomToGameContainer() {
                cc.game.container.appendChild(this._edTxt);
            }
        }, {
            key: "removeDom",
            value: function removeDom() {
                var edTxt = this._edTxt;
                if (edTxt) {
                    var cbs = this.__eventListeners;
                    edTxt.removeEventListener("compositionstart", cbs.compositionstart), edTxt.removeEventListener("compositionend", cbs.compositionend), 
                    edTxt.removeEventListener("input", cbs.input), edTxt.removeEventListener("focus", cbs.focus), 
                    edTxt.removeEventListener("keypress", cbs.keypress), edTxt.removeEventListener("blur", cbs.blur), 
                    cbs.compositionstart = null, cbs.compositionend = null, cbs.input = null, cbs.focus = null, 
                    cbs.keypress = null, cbs.blur = null, contains$1(cc.game.container, edTxt) && cc.game.container.removeChild(edTxt);
                }
                this._edTxt = null;
            }
        }, {
            key: "text",
            get: function get() {
                return this._text;
            },
            set: function set(value) {
                this._text = value;
            }
        }, {
            key: "textColor",
            get: function get() {
                return this._textColor;
            }
        }, {
            key: "fontSize",
            get: function get() {
                return this._edFontSize;
            }
        }, {
            key: "returnType",
            set: function set(value) {
                this._returnType = value;
            }
        }, {
            key: "alwayOnTop",
            get: function get() {
                return this._alwaysOnTop;
            }
        }, {
            key: "editing",
            get: function get() {
                return this._editing;
            },
            set: function set(value) {
                this._editing = value;
            }
        }, {
            key: "delegate",
            get: function get() {
                return this._delegate;
            }
        }, {
            key: "eventListeners",
            get: function get() {
                return this.__eventListeners;
            }
        } ]), EditBoxImpl;
    }()) || _class$1i;
    function _inputValueHandle(input, editBoxImpl) {
        input.value.length > editBoxImpl._maxLength && (input.value = input.value.slice(0, editBoxImpl._maxLength)), 
        editBoxImpl._delegate && editBoxImpl._delegate.editBoxTextChanged && editBoxImpl._text !== input.value && (editBoxImpl._text = input.value, 
        editBoxImpl._delegate.editBoxTextChanged(editBoxImpl._text));
    }
    function registerInputEventListener(tmpEdTxt, editBoxImpl) {
        var isTextarea = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], inputLock = !1, cbs = editBoxImpl.eventListeners;
        cbs.compositionstart = function() {
            inputLock = !0;
        }, tmpEdTxt.addEventListener("compositionstart", cbs.compositionstart), cbs.compositionend = function() {
            inputLock = !1, _inputValueHandle(this, editBoxImpl);
        }, tmpEdTxt.addEventListener("compositionend", cbs.compositionend), cbs.input = function() {
            inputLock || _inputValueHandle(this, editBoxImpl);
        }, tmpEdTxt.addEventListener("input", cbs.input), cbs.focus = function() {
            this.style.fontSize = editBoxImpl.fontSize + "px", this.style.color = editBoxImpl.textColor.toCSS("rgba"), 
            editBoxImpl.alwayOnTop && (editBoxImpl.editing = !0), cc.sys.isMobile && editBoxImpl._beginEditingOnMobile(), 
            editBoxImpl.delegate && editBoxImpl.delegate.editBoxEditingDidBegan && editBoxImpl.delegate.editBoxEditingDidBegan();
        }, tmpEdTxt.addEventListener("focus", cbs.focus), cbs.keypress = function(e) {
            e.keyCode === macro.KEY.enter && (e.propagationStopped = !0, editBoxImpl.delegate && editBoxImpl.delegate.editBoxEditingReturn && editBoxImpl.delegate.editBoxEditingReturn(), 
            isTextarea || (editBoxImpl.text = this.value, editBoxImpl._endEditing(), cc.game.canvas.focus()));
        }, tmpEdTxt.addEventListener("keypress", cbs.keypress), cbs.blur = function() {
            editBoxImpl.text = this.value, editBoxImpl._endEditing();
        }, tmpEdTxt.addEventListener("blur", cbs.blur), editBoxImpl._addDomToGameContainer();
    }
    var _dec$1h, _dec2$W, _dec3$I, _dec4$z, _dec5$u, _dec6$q, _dec7$k, _dec8$f, _class$1k, _class2$17, _descriptor$16, _descriptor2$U, _descriptor3$I, _descriptor4$B, _descriptor5$v, _descriptor6$o, _descriptor7$k, _descriptor8$g, _descriptor9$d, _descriptor10$a, _descriptor11$9, _descriptor12$9, _descriptor13$9, _descriptor14$5, _class3$p, _temp$1f, EditBoxComponent = (_dec$1g = ccclass("cc.EditBoxComponent"), 
    _dec2$V = executionOrder(100), _dec3$H = menu("UI/EditBox"), _dec4$y = property({
        type: SpriteFrame
    }), _dec5$t = property({
        type: KeyboardReturnType
    }), _dec6$p = property({
        type: InputFlag
    }), _dec7$j = property({
        type: InputMode
    }), _dec8$e = property({
        type: Color
    }), _dec9$e = property({
        type: EventHandler
    }), _dec10$b = property({
        type: EventHandler
    }), _dec11$b = property({
        type: EventHandler
    }), _dec12$a = property({
        type: EventHandler
    }), _dec$1g(_class$1j = _dec2$V(_class$1j = _dec3$H(_class$1j = executeInEditMode((_temp$1e = _class3$o = function(_Component) {
        function EditBoxComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, EditBoxComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "editingDidBegan", _descriptor$15, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "textChanged", _descriptor2$T, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$H, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "editingReturn", _descriptor4$A, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._impl = null, _this._textLabel = null, _this._placeholderLabel = null, _this._background = null, 
            _initializerDefineProperty(_this, "_returnType", _descriptor5$u, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_useOriginalSize", _descriptor6$n, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_string", _descriptor7$j, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_tabIndex", _descriptor8$f, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_backgroundImage", _descriptor9$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_inputFlag", _descriptor10$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_inputMode", _descriptor11$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fontSize", _descriptor12$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_lineHeight", _descriptor13$8, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_maxLength", _descriptor14$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fontColor", _descriptor15$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_placeholder", _descriptor16$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_placeholderFontSize", _descriptor17$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_placeholderFontColor", _descriptor18$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_stayOnTop", _descriptor19$2, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(EditBoxComponent, Component), _createClass(EditBoxComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this._impl && this._impl.onEnable();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._impl && this._impl.onDisable();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._impl && this._impl.clear();
            }
        }, {
            key: "_init",
            value: function _init() {
                this._createBackgroundSprite(), this._createLabels(), this.node.on(exports.SystemEventType.SIZE_CHANGED, this._resizeChildNodes, this);
                var impl = this._impl = new EditBoxImpl();
                impl.setDelegate(this), impl.setNode(this.node), impl.setInputMode(this._inputMode), 
                impl.setMaxLength(this._maxLength), impl.setInputFlag(this._inputFlag), impl.setReturnType(this._returnType), 
                impl.setTabIndex(this._tabIndex), impl.setFontColor(this._fontColor), impl.setFontSize(this._fontSize), 
                impl.setPlaceholderText(this._placeholder), this._updateStayOnTop(), this._updateString(this._string), 
                this._syncSize();
            }
        }, {
            key: "__preload",
            value: function __preload() {
                this._registerEvent(), this._init();
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_updateStayOnTop",
            value: function _updateStayOnTop() {
                this.stayOnTop ? this._hideLabels() : this._showLabels(), this._impl && this._impl.stayOnTop(this.stayOnTop);
            }
        }, {
            key: "_syncSize",
            value: function _syncSize() {
                var size = this.node.getContentSize();
                this._background && (this._background.node.setAnchorPoint(this.node.getAnchorPoint()), 
                this._background.node.setContentSize(size)), this._updateLabelPosition(size), this._impl && this._impl.setSize(size.width, size.height);
            }
        }, {
            key: "_updateLabelPosition",
            value: function _updateLabelPosition(size) {
                var node = this.node, offx = -node.anchorX * node.width, offy = -node.anchorY * node.height, placeholderLabel = this._placeholderLabel, textLabel = this._textLabel;
                textLabel && (textLabel.node.setContentSize(size.width - 2, size.height), textLabel.node.setPosition(offx + 2, offy + size.height, textLabel.node.getPosition().z), 
                textLabel.verticalAlign = this._inputMode === InputMode.ANY ? exports.VerticalTextAlignment.TOP : exports.VerticalTextAlignment.CENTER, 
                textLabel.enableWrapText = this._inputMode === InputMode.ANY), placeholderLabel && (placeholderLabel.node.setContentSize(size.width - 2, size.height), 
                placeholderLabel.lineHeight = size.height, placeholderLabel.node.setPosition(offx + 2, offy + size.height, placeholderLabel.node.getPosition().z), 
                placeholderLabel.verticalAlign = this._inputMode === InputMode.ANY ? exports.VerticalTextAlignment.TOP : exports.VerticalTextAlignment.CENTER, 
                placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY);
            }
        }, {
            key: "_createBackgroundSprite",
            value: function _createBackgroundSprite() {
                this._background || (this._background = this.node.getComponent(cc.SpriteComponent), 
                this._background || (this._background = this.node.addComponent(cc.SpriteComponent))), 
                this._background.type = cc.SpriteComponent.Type.SLICED, this._background.spriteFrame = this._backgroundImage;
            }
        }, {
            key: "_createLabels",
            value: function _createLabels() {
                if (!this._textLabel) {
                    var node = this.node.getChildByName("TEXT_LABEL");
                    node || (node = new cc.Node("TEXT_LABEL"));
                    var textLabel = node.getComponent(LabelComponent);
                    node.parent = this.node, textLabel || (textLabel = node.addComponent(LabelComponent)), 
                    node.getComponent(UITransformComponent).setAnchorPoint(0, 1), textLabel.color = this._fontColor, 
                    textLabel.overflow = LabelComponent.Overflow.CLAMP, textLabel.fontSize = this._fontSize, 
                    textLabel.lineHeight = this.lineHeight, this._textLabel = textLabel;
                }
                if (!this._placeholderLabel) {
                    var _node = this.node.getChildByName("PLACEHOLDER_LABEL");
                    _node || (_node = new Node$1("PLACEHOLDER_LABEL"));
                    var placeholderLabel = _node.getComponent(LabelComponent);
                    placeholderLabel || (placeholderLabel = _node.addComponent(LabelComponent));
                    var transform = _node.getComponent(UITransformComponent);
                    _node.parent = this.node, placeholderLabel.color = this._placeholderFontColor, transform.setAnchorPoint(0, 1), 
                    placeholderLabel.overflow = LabelComponent.Overflow.CLAMP, placeholderLabel.fontSize = this._placeholderFontSize, 
                    placeholderLabel.string = this._placeholder, this._placeholderLabel = placeholderLabel;
                }
            }
        }, {
            key: "_resizeChildNodes",
            value: function _resizeChildNodes() {
                var textLabelNode = this._textLabel && this._textLabel.node;
                textLabelNode && (textLabelNode.setPosition(-this.node.width / 2, this.node.height / 2, textLabelNode.getPosition().z), 
                textLabelNode.width = this.node.width, textLabelNode.height = this.node.height);
                var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
                placeholderLabelNode && (placeholderLabelNode.setPosition(-this.node.width / 2, this.node.height / 2, placeholderLabelNode.getPosition().z), 
                placeholderLabelNode.width = this.node.width, placeholderLabelNode.height = this.node.height);
                var backgroundNode = this._background && this._background.node;
                backgroundNode && (backgroundNode.width = this.node.width, backgroundNode.height = this.node.height);
            }
        }, {
            key: "_showLabels",
            value: function _showLabels() {
                if (this._textLabel) {
                    var displayText = this._textLabel.string;
                    this._textLabel.node.active = "" !== displayText, this._placeholderLabel && (this._placeholderLabel.node.active = "" === displayText);
                }
            }
        }, {
            key: "_hideLabels",
            value: function _hideLabels() {
                this._textLabel && (this._textLabel.node.active = !1), this._placeholderLabel && (this._placeholderLabel.node.active = !1);
            }
        }, {
            key: "_updateString",
            value: function _updateString(text) {
                var textLabel = this._textLabel;
                if (textLabel) {
                    var displayText = text;
                    displayText && (displayText = this._updateLabelStringStyle(displayText)), textLabel.string = displayText, 
                    this._impl && (this._impl.setString(text), this._impl.editing || this.stayOnTop || this._showLabels());
                }
            }
        }, {
            key: "_updateLabelStringStyle",
            value: function _updateLabelStringStyle(text) {
                var ignorePassword = 1 < arguments.length && void 0 !== arguments[1] && arguments[1], inputFlag = this._inputFlag;
                if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = function capitalize(string) {
                    return string.replace(/(?:^|\s)\S/g, function(a) {
                        return a.toUpperCase();
                    });
                }(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = function capitalizeFirstLetter(string) {
                    return string.charAt(0).toUpperCase() + string.slice(1);
                }(text)); else {
                    for (var passwordString = "", len = text.length, i = 0; i < len; ++i) passwordString += "●";
                    text = passwordString;
                }
                return text;
            }
        }, {
            key: "editBoxEditingDidBegan",
            value: function editBoxEditingDidBegan() {
                this._hideLabels(), EventHandler.emitEvents(this.editingDidBegan, this), this.node.emit("editing-did-began", this);
            }
        }, {
            key: "editBoxEditingDidEnded",
            value: function editBoxEditingDidEnded() {
                this.stayOnTop || this._showLabels(), EventHandler.emitEvents(this.editingDidEnded, this), 
                this.node.emit("editing-did-ended", this);
            }
        }, {
            key: "editBoxTextChanged",
            value: function editBoxTextChanged(text) {
                text = this._updateLabelStringStyle(text, !0), this.string = text, EventHandler.emitEvents(this.textChanged, text, this), 
                this.node.emit("text-changed", this);
            }
        }, {
            key: "editBoxEditingReturn",
            value: function editBoxEditingReturn() {
                EventHandler.emitEvents(this.editingReturn, this), this.node.emit("editing-return", this);
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event) {
                this._impl && this._impl._onTouchBegan(event.touch), event.propagationStopped = !0;
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                this._impl && this._impl._onTouchEnded(), event.propagationStopped = !0;
            }
        }, {
            key: "setFocus",
            value: function setFocus() {
                this._impl && this._impl.setFocus();
            }
        }, {
            key: "isFocused",
            value: function isFocused() {
                var isFocused = !1;
                return this._impl && (isFocused = this._impl.isFocused()), isFocused;
            }
        }, {
            key: "update",
            value: function update() {
                this._impl && this._impl.update();
            }
        }, {
            key: "string",
            get: function get() {
                return this._string;
            },
            set: function set(value) {
                0 <= this._maxLength && value.length >= this._maxLength && (value = value.slice(0, this._maxLength)), 
                this._string = value, this._impl && this._updateString(value);
            }
        }, {
            key: "backgroundImage",
            get: function get() {
                return this._backgroundImage;
            },
            set: function set(value) {
                this._backgroundImage !== value && (this._backgroundImage = value, this._createBackgroundSprite());
            }
        }, {
            key: "returnType",
            get: function get() {
                return this._returnType;
            },
            set: function set(value) {
                this._returnType = value, this._impl && (this._impl.returnType = this._returnType);
            }
        }, {
            key: "inputFlag",
            get: function get() {
                return this._inputFlag;
            },
            set: function set(value) {
                this._inputFlag = value, this._impl && (this._impl.setInputFlag(this._inputFlag), 
                this._updateString(this._string));
            }
        }, {
            key: "inputMode",
            get: function get() {
                return this._inputMode;
            },
            set: function set(value) {
                this._inputMode = value, this._impl && this._impl.setInputMode(this._inputMode);
            }
        }, {
            key: "fontSize",
            get: function get() {
                return this._fontSize;
            },
            set: function set(value) {
                this._fontSize !== value && (this._fontSize = value, this._textLabel && (this._textLabel.fontSize = this._fontSize), 
                this._impl && this._impl.setFontSize(this._fontSize));
            }
        }, {
            key: "lineHeight",
            get: function get() {
                return this._lineHeight;
            },
            set: function set(value) {
                this._lineHeight !== value && (this._lineHeight = value, this._textLabel && (this._textLabel.lineHeight = this._lineHeight));
            }
        }, {
            key: "fontColor",
            get: function get() {
                return this._fontColor;
            },
            set: function set(value) {
                if (this._fontColor !== value) {
                    if (this._fontColor.set(value), this._textLabel) {
                        var renderComp = this._textLabel.node.getComponent(UIRenderComponent);
                        renderComp && (renderComp.color = this._fontColor);
                    }
                    this._impl && this._impl.setFontColor(this._fontColor);
                }
            }
        }, {
            key: "placeholder",
            get: function get() {
                return this._placeholder;
            },
            set: function set(value) {
                this._placeholder !== value && (this._placeholder = value, this._placeholderLabel && (this._placeholderLabel.string = this._placeholder), 
                this._impl && this._impl.setPlaceholderText(this._placeholder));
            }
        }, {
            key: "placeholderFontSize",
            get: function get() {
                return this._placeholderFontSize;
            },
            set: function set(value) {
                this._placeholderFontSize !== value && (this._placeholderFontSize = value, this._placeholderLabel && (this._placeholderLabel.fontSize = this._placeholderFontSize));
            }
        }, {
            key: "placeholderFontColor",
            get: function get() {
                return this._placeholderFontColor;
            },
            set: function set(value) {
                if (this._placeholderFontColor !== value && (this._placeholderFontColor = value, 
                this._placeholderLabel)) {
                    var comp = this._placeholderLabel.node.getComponent(UIRenderComponent);
                    comp && (comp.color = this._placeholderFontColor);
                }
            }
        }, {
            key: "maxLength",
            get: function get() {
                return this._maxLength;
            },
            set: function set(value) {
                this._maxLength !== value && (this._maxLength = value, this._impl && this._impl.setMaxLength(this._maxLength));
            }
        }, {
            key: "stayOnTop",
            get: function get() {
                return this._stayOnTop;
            },
            set: function set(value) {
                this._stayOnTop = value, this._impl && this._updateStayOnTop();
            }
        }, {
            key: "tabIndex",
            get: function get() {
                return this._tabIndex;
            },
            set: function set(value) {
                this._tabIndex = value, this._impl && this._impl.setTabIndex(value);
            }
        } ]), EditBoxComponent;
    }(), _class3$o._EditBoxImpl = EditBoxImpl, _class3$o.KeyboardReturnType = KeyboardReturnType, 
    _class3$o.InputFlag = InputFlag, _class3$o.InputMode = InputMode, _applyDecoratedDescriptor((_class2$16 = _temp$1e).prototype, "string", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "string"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "backgroundImage", [ _dec4$y ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "backgroundImage"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "returnType", [ _dec5$t ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "returnType"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "inputFlag", [ _dec6$p ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "inputFlag"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "inputMode", [ _dec7$j ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "inputMode"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "fontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "fontSize"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "lineHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "lineHeight"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "fontColor", [ _dec8$e ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "fontColor"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "placeholder", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "placeholder"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "placeholderFontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "placeholderFontSize"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "placeholderFontColor", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "placeholderFontColor"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "maxLength", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "maxLength"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "stayOnTop", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "stayOnTop"), _class2$16.prototype), 
    _applyDecoratedDescriptor(_class2$16.prototype, "tabIndex", [ property ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "tabIndex"), _class2$16.prototype), 
    _descriptor$15 = _applyDecoratedDescriptor(_class2$16.prototype, "editingDidBegan", [ _dec9$e ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$T = _applyDecoratedDescriptor(_class2$16.prototype, "textChanged", [ _dec10$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor3$H = _applyDecoratedDescriptor(_class2$16.prototype, "editingDidEnded", [ _dec11$b ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor4$A = _applyDecoratedDescriptor(_class2$16.prototype, "editingReturn", [ _dec12$a ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor5$u = _applyDecoratedDescriptor(_class2$16.prototype, "_returnType", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return KeyboardReturnType.DEFAULT;
        }
    }), _descriptor6$n = _applyDecoratedDescriptor(_class2$16.prototype, "_useOriginalSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor7$j = _applyDecoratedDescriptor(_class2$16.prototype, "_string", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _descriptor8$f = _applyDecoratedDescriptor(_class2$16.prototype, "_tabIndex", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$c = _applyDecoratedDescriptor(_class2$16.prototype, "_backgroundImage", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$16.prototype, "_inputFlag", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return InputFlag.DEFAULT;
        }
    }), _descriptor11$8 = _applyDecoratedDescriptor(_class2$16.prototype, "_inputMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return InputMode.ANY;
        }
    }), _descriptor12$8 = _applyDecoratedDescriptor(_class2$16.prototype, "_fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 20;
        }
    }), _descriptor13$8 = _applyDecoratedDescriptor(_class2$16.prototype, "_lineHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor14$4 = _applyDecoratedDescriptor(_class2$16.prototype, "_maxLength", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 20;
        }
    }), _descriptor15$3 = _applyDecoratedDescriptor(_class2$16.prototype, "_fontColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE;
        }
    }), _descriptor16$3 = _applyDecoratedDescriptor(_class2$16.prototype, "_placeholder", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "Enter text here...";
        }
    }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$16.prototype, "_placeholderFontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 20;
        }
    }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$16.prototype, "_placeholderFontColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.GRAY;
        }
    }), _descriptor19$2 = _applyDecoratedDescriptor(_class2$16.prototype, "_stayOnTop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$1j = _class2$16)) || _class$1j) || _class$1j) || _class$1j) || _class$1j);
    cc.EditBoxComponent = EditBoxComponent;
    var Type, ResizeMode, AxisDirection, VerticalDirection, HorizontalDirection, NodeEvent = Node$1.EventType;
    !function(Type) {
        Type[Type.NONE = 0] = "NONE", Type[Type.HORIZONTAL = 1] = "HORIZONTAL", Type[Type.VERTICAL = 2] = "VERTICAL", 
        Type[Type.GRID = 3] = "GRID";
    }(Type || (Type = {})), ccenum(Type), function(ResizeMode) {
        ResizeMode[ResizeMode.NONE = 0] = "NONE", ResizeMode[ResizeMode.CONTAINER = 1] = "CONTAINER", 
        ResizeMode[ResizeMode.CHILDREN = 2] = "CHILDREN";
    }(ResizeMode || (ResizeMode = {})), ccenum(ResizeMode), function(AxisDirection) {
        AxisDirection[AxisDirection.HORIZONTAL = 0] = "HORIZONTAL", AxisDirection[AxisDirection.VERTICAL = 1] = "VERTICAL";
    }(AxisDirection || (AxisDirection = {})), ccenum(AxisDirection), function(VerticalDirection) {
        VerticalDirection[VerticalDirection.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", VerticalDirection[VerticalDirection.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM";
    }(VerticalDirection || (VerticalDirection = {})), ccenum(VerticalDirection), function(HorizontalDirection) {
        HorizontalDirection[HorizontalDirection.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", HorizontalDirection[HorizontalDirection.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT";
    }(HorizontalDirection || (HorizontalDirection = {})), ccenum(HorizontalDirection);
    var LineCap, LineJoin, PointFlags, _dec$1i, _dec2$X, _dec3$J, _dec4$A, _dec5$v, _dec6$r, _class$1l, _class2$18, _descriptor$17, _descriptor2$V, _descriptor3$J, _descriptor4$C, _descriptor5$w, _descriptor6$p, _class3$q, _temp$1g, _tempPos = new Vec3(), _tempScale = new Vec3(), LayoutComponent = (_dec$1h = ccclass("cc.LayoutComponent"), 
    _dec2$W = executionOrder(110), _dec3$I = menu("UI/Layout"), _dec4$z = property({
        type: Type
    }), _dec5$u = property({
        type: ResizeMode
    }), _dec6$q = property({
        type: AxisDirection
    }), _dec7$k = property({
        type: VerticalDirection
    }), _dec8$f = property({
        type: HorizontalDirection
    }), _dec$1h(_class$1k = _dec2$W(_class$1k = _dec3$I(_class$1k = executeInEditMode((_temp$1f = _class3$p = function(_Component) {
        function LayoutComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, LayoutComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LayoutComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._layoutDirty = !0, 
            _initializerDefineProperty(_this, "_resizeMode", _descriptor$16, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_N$layoutType", _descriptor2$U, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_N$padding", _descriptor3$I, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_cellSize", _descriptor4$B, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_startAxis", _descriptor5$v, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_paddingLeft", _descriptor6$o, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_paddingRight", _descriptor7$k, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_paddingTop", _descriptor8$g, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_paddingBottom", _descriptor9$d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_spacingX", _descriptor10$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_spacingY", _descriptor11$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._layoutSize = cc.size(300, 200), _initializerDefineProperty(_this, "_verticalDirection", _descriptor12$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_horizontalDirection", _descriptor13$9, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_affectedByScale", _descriptor14$5, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(LayoutComponent, Component), _createClass(LayoutComponent, [ {
            key: "updateLayout",
            value: function updateLayout() {
                this._layoutDirty && 0 < this.node.children.length && (this._doLayout(), this._layoutDirty = !1);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._addEventListeners(), this.node.getContentSize().equals(cc.size(0, 0)) && this.node.setContentSize(this._layoutSize), 
                0 !== this._N$padding && this._migratePaddingData(), this._doLayoutDirty();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._removeEventListeners();
            }
        }, {
            key: "_migratePaddingData",
            value: function _migratePaddingData() {
                this._paddingLeft = this._N$padding, this._paddingRight = this._N$padding, this._paddingTop = this._N$padding, 
                this._paddingBottom = this._N$padding, this._N$padding = 0;
            }
        }, {
            key: "_addEventListeners",
            value: function _addEventListeners() {
                cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this), 
                this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this), 
                this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._addChildrenEventListeners();
            }
        }, {
            key: "_removeEventListeners",
            value: function _removeEventListeners() {
                cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this), 
                this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this), 
                this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._removeChildrenEventListeners();
            }
        }, {
            key: "_addChildrenEventListeners",
            value: function _addChildrenEventListeners() {
                var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var child = _ref;
                    child.on(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                    child.on(NodeEvent.POSITION_PART, this._doLayoutDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                    child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
                }
            }
        }, {
            key: "_removeChildrenEventListeners",
            value: function _removeChildrenEventListeners() {
                var _iterator2 = this.node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var child = _ref2;
                    child.off(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                    child.off(NodeEvent.POSITION_PART, this._doLayoutDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                    child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
                }
            }
        }, {
            key: "_childAdded",
            value: function _childAdded(child) {
                child.on(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.on(NodeEvent.POSITION_PART, this._doLayoutDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.on("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
            }
        }, {
            key: "_childRemoved",
            value: function _childRemoved(child) {
                child.off(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.off(NodeEvent.POSITION_PART, this._doLayoutDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.off("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
            }
        }, {
            key: "_resized",
            value: function _resized() {
                this._layoutSize = this.node.getContentSize(), this._doLayoutDirty();
            }
        }, {
            key: "_doLayoutHorizontally",
            value: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
                var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign$$1 = 1, paddingX = this._paddingLeft, startPos = -layoutAnchor.x * baseWidth;
                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign$$1 = -1, 
                startPos = (1 - layoutAnchor.x) * baseWidth, paddingX = this._paddingRight);
                var nextX = startPos + sign$$1 * paddingX - sign$$1 * this._spacingX, rowMaxHeight = 0, tempMaxHeight = 0, secondMaxHeight = 0, row = 0, containerResizeBoundary = 0, maxHeightChildAnchorY = 0, activeChildCount = 0, _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.activeInHierarchy && activeChildCount++;
                }
                var newChildWidth = this._cellSize.width;
                this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this._paddingLeft + this._paddingRight) - (activeChildCount - 1) * this._spacingX) / activeChildCount);
                var _iterator4 = children, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var _child = _ref4;
                    if (_child.activeInHierarchy) {
                        _child.getScale(_tempScale);
                        var childScaleX = this._getUsedScaleValue(_tempScale.x), childScaleY = this._getUsedScaleValue(_tempScale.y);
                        this._resizeMode === ResizeMode.CHILDREN && (_child.width = newChildWidth / childScaleX, 
                        this._N$layoutType === Type.GRID && (_child.height = this._cellSize.height / childScaleY));
                        var anchorX = _child.anchorX, childBoundingBoxWidth = _child.width * childScaleX, childBoundingBoxHeight = _child.height * childScaleY;
                        tempMaxHeight < secondMaxHeight && (tempMaxHeight = secondMaxHeight), tempMaxHeight <= childBoundingBoxHeight && (secondMaxHeight = tempMaxHeight, 
                        tempMaxHeight = childBoundingBoxHeight, maxHeightChildAnchorY = _child.getAnchorPoint().y), 
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - _child.anchorX), 
                        nextX = nextX + sign$$1 * anchorX * childBoundingBoxWidth + sign$$1 * this._spacingX;
                        var rightBoundaryOfChild = sign$$1 * (1 - anchorX) * childBoundingBoxWidth;
                        if (rowBreak) {
                            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign$$1 * (0 < sign$$1 ? this._paddingRight : this._paddingLeft), leftToRightRowBreak = !1;
                            this._horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth && (leftToRightRowBreak = !0);
                            var rightToLeftRowBreak = !1;
                            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth && (rightToLeftRowBreak = !0), 
                            (leftToRightRowBreak || rightToLeftRowBreak) && (tempMaxHeight <= childBoundingBoxHeight ? (0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight), 
                            rowMaxHeight += secondMaxHeight, secondMaxHeight = tempMaxHeight) : (rowMaxHeight += tempMaxHeight, 
                            secondMaxHeight = childBoundingBoxHeight, tempMaxHeight = 0), nextX = startPos + sign$$1 * (paddingX + anchorX * childBoundingBoxWidth), 
                            row++);
                        }
                        var finalPositionY = fnPositionY(_child, rowMaxHeight, row);
                        baseWidth >= childBoundingBoxWidth + this._paddingLeft + this._paddingRight && applyChildren && (_child.getPosition(_tempPos), 
                        _child.setPosition(nextX, finalPositionY, _tempPos.z));
                        var signX = 1, tempFinalPositionY = void 0, topMarign = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM ? (containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().height, 
                        (tempFinalPositionY = finalPositionY + (signX = -1) * (topMarign * maxHeightChildAnchorY + this._paddingBottom)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().height) < (tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this._paddingTop)) && (containerResizeBoundary = tempFinalPositionY), 
                        nextX += rightBoundaryOfChild;
                    }
                }
                return containerResizeBoundary;
            }
        }, {
            key: "_doLayoutVertically",
            value: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
                var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign$$1 = 1, paddingY = this._paddingBottom, bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign$$1 = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight, 
                paddingY = this._paddingTop);
                var nextY = bottomBoundaryOfLayout + sign$$1 * paddingY - sign$$1 * this._spacingY, columnMaxWidth = 0, tempMaxWidth = 0, secondMaxWidth = 0, column = 0, containerResizeBoundary = 0, maxWidthChildAnchorX = 0, activeChildCount = 0, _iterator5 = children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.activeInHierarchy && activeChildCount++;
                }
                var newChildHeight = this._cellSize.height;
                this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this._paddingTop + this._paddingBottom) - (activeChildCount - 1) * this._spacingY) / activeChildCount);
                var _iterator6 = children, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    var _child2 = _ref6;
                    if (_child2) {
                        var scale = _child2.getScale(), childScaleX = this._getUsedScaleValue(scale.x), childScaleY = this._getUsedScaleValue(scale.y);
                        if (_child2.activeInHierarchy) {
                            this._resizeMode === ResizeMode.CHILDREN && (_child2.height = newChildHeight / childScaleY, 
                            this._N$layoutType === Type.GRID && (_child2.width = this._cellSize.width / childScaleX));
                            var anchorY = _child2.anchorY, childBoundingBoxWidth = _child2.width * childScaleX, childBoundingBoxHeight = _child2.height * childScaleY;
                            tempMaxWidth < secondMaxWidth && (tempMaxWidth = secondMaxWidth), tempMaxWidth <= childBoundingBoxWidth && (secondMaxWidth = tempMaxWidth, 
                            tempMaxWidth = childBoundingBoxWidth, maxWidthChildAnchorX = _child2.getAnchorPoint().x), 
                            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - _child2.anchorY), 
                            nextY = nextY + sign$$1 * anchorY * childBoundingBoxHeight + sign$$1 * this._spacingY;
                            var topBoundaryOfChild = sign$$1 * (1 - anchorY) * childBoundingBoxHeight;
                            if (columnBreak) {
                                var columnBreakBoundary = nextY + topBoundaryOfChild + sign$$1 * (0 < sign$$1 ? this._paddingTop : this._paddingBottom), bottomToTopColumnBreak = !1;
                                this._verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight && (bottomToTopColumnBreak = !0);
                                var topToBottomColumnBreak = !1;
                                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight && (topToBottomColumnBreak = !0), 
                                (bottomToTopColumnBreak || topToBottomColumnBreak) && (tempMaxWidth <= childBoundingBoxWidth ? (0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth), 
                                columnMaxWidth += secondMaxWidth, secondMaxWidth = tempMaxWidth) : (columnMaxWidth += tempMaxWidth, 
                                secondMaxWidth = childBoundingBoxWidth, tempMaxWidth = 0), nextY = bottomBoundaryOfLayout + sign$$1 * (paddingY + anchorY * childBoundingBoxHeight), 
                                column++);
                            }
                            var finalPositionX = fnPositionX(_child2, columnMaxWidth, column);
                            baseHeight >= childBoundingBoxHeight + (this._paddingTop + this._paddingBottom) && applyChildren && (_child2.getPosition(_tempPos), 
                            _child2.setPosition(finalPositionX, nextY, _tempPos.z));
                            var signX = 1, tempFinalPositionX = void 0, rightMarign = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
                            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT ? (signX = -1, containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().width, 
                            (tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this._paddingLeft)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().width) < (tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this._paddingRight)) && (containerResizeBoundary = tempFinalPositionX), 
                            nextY += topBoundaryOfChild;
                        }
                    }
                }
                return containerResizeBoundary;
            }
        }, {
            key: "_doLayoutBasic",
            value: function _doLayoutBasic() {
                var allChildrenBoundingBox = null, _iterator7 = this.node.children, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) break;
                        _ref7 = _i7.value;
                    }
                    var child = _ref7, childTransform = child.getComponent(UITransformComponent);
                    childTransform && (child.activeInHierarchy && (allChildrenBoundingBox ? allChildrenBoundingBox.union(allChildrenBoundingBox, childTransform.getBoundingBoxToWorld()) : allChildrenBoundingBox = childTransform.getBoundingBoxToWorld()));
                }
                if (allChildrenBoundingBox) {
                    var parentTransform = this.node.parent.getComponent(UITransformComponent);
                    if (!parentTransform) return;
                    vec3.set(_tempPos, allChildrenBoundingBox.x, allChildrenBoundingBox.y, 0);
                    var leftBottomInParentSpace = new Vec3();
                    parentTransform.convertToNodeSpaceAR(_tempPos, leftBottomInParentSpace), vec3.set(leftBottomInParentSpace, leftBottomInParentSpace.x - this._paddingLeft, leftBottomInParentSpace.y - this._paddingBottom, leftBottomInParentSpace.z), 
                    vec3.set(_tempPos, allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height, 0);
                    var rightTopInParentSpace = new Vec3();
                    parentTransform.convertToNodeSpaceAR(_tempPos, rightTopInParentSpace), vec3.set(rightTopInParentSpace, rightTopInParentSpace.x + this._paddingRight, rightTopInParentSpace.y + this._paddingTop, rightTopInParentSpace.z);
                    var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
                    if (this.node.getPosition(_tempPos), 0 !== newSize.width) {
                        var newAnchorX = (_tempPos.x - leftBottomInParentSpace.x) / newSize.width;
                        this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
                    }
                    if (0 !== newSize.height) {
                        var newAnchorY = (_tempPos.y - leftBottomInParentSpace.y) / newSize.height;
                        this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
                    }
                    this.node.setContentSize(newSize);
                }
            }
        }, {
            key: "_doLayoutGridAxisHorizontal",
            value: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
                var _this2 = this, baseWidth = layoutSize.width, sign$$1 = 1, bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height, paddingY = this._paddingBottom;
                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign$$1 = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height, 
                paddingY = this._paddingTop);
                var self = this, fnPositionY = function fnPositionY(child, topOffset, row) {
                    return bottomBoundaryOfLayout + sign$$1 * (topOffset + child.anchorY * child.height * self._getUsedScaleValue(child.getScale().y) + paddingY + row * _this2._spacingY);
                }, newHeight = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var boundary = this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !1);
                    (newHeight = bottomBoundaryOfLayout - boundary) < 0 && (newHeight *= -1), bottomBoundaryOfLayout = -layoutAnchor.y * newHeight, 
                    this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign$$1 = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight);
                }
                this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
            }
        }, {
            key: "_doLayoutGridAxisVertical",
            value: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
                var _this3 = this, baseHeight = layoutSize.height, sign$$1 = 1, leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width, paddingX = this._paddingLeft;
                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign$$1 = -1, 
                leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width, paddingX = this._paddingRight);
                var self = this, fnPositionX = function fnPositionX(child, leftOffset, column) {
                    return leftBoundaryOfLayout + sign$$1 * (leftOffset + child.anchorX * child.width * self._getUsedScaleValue(child.getScale().x) + paddingX + column * _this3._spacingX);
                }, newWidth = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var boundary = this._doLayoutVertically(baseHeight, !0, fnPositionX, !1);
                    (newWidth = leftBoundaryOfLayout - boundary) < 0 && (newWidth *= -1), leftBoundaryOfLayout = -layoutAnchor.x * newWidth, 
                    this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign$$1 = -1, 
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth);
                }
                this._doLayoutVertically(baseHeight, !0, fnPositionX, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
            }
        }, {
            key: "_doLayoutGrid",
            value: function _doLayoutGrid() {
                var layoutAnchor = this.node.getAnchorPoint(), layoutSize = this.node.getContentSize();
                this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
            }
        }, {
            key: "_getHorizontalBaseWidth",
            value: function _getHorizontalBaseWidth(children) {
                var newWidth = 0, activeChildCount = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var _iterator8 = children, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                    for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray8) {
                            if (_i8 >= _iterator8.length) break;
                            _ref8 = _iterator8[_i8++];
                        } else {
                            if ((_i8 = _iterator8.next()).done) break;
                            _ref8 = _i8.value;
                        }
                        var child = _ref8;
                        child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newWidth += child.width * this._getUsedScaleValue(_tempScale.x));
                    }
                    newWidth += (activeChildCount - 1) * this._spacingX + this._paddingLeft + this._paddingRight;
                } else newWidth = this.node.getContentSize().width;
                return newWidth;
            }
        }, {
            key: "_getVerticalBaseHeight",
            value: function _getVerticalBaseHeight(children) {
                var newHeight = 0, activeChildCount = 0;
                if (this._resizeMode === ResizeMode.CONTAINER) {
                    var _iterator9 = children, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                    for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray9) {
                            if (_i9 >= _iterator9.length) break;
                            _ref9 = _iterator9[_i9++];
                        } else {
                            if ((_i9 = _iterator9.next()).done) break;
                            _ref9 = _i9.value;
                        }
                        var child = _ref9;
                        child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newHeight += child.height * this._getUsedScaleValue(_tempScale.y));
                    }
                    newHeight += (activeChildCount - 1) * this._spacingY + this._paddingBottom + this._paddingTop;
                } else newHeight = this.node.getContentSize().height;
                return newHeight;
            }
        }, {
            key: "_doLayout",
            value: function _doLayout() {
                if (this._N$layoutType === Type.HORIZONTAL) {
                    var newWidth = this._getHorizontalBaseWidth(this.node.children);
                    this._doLayoutHorizontally(newWidth, !1, function fnPositionY(child) {
                        return child.getPosition(_tempPos), _tempPos.y;
                    }, !0), this.node.width = newWidth;
                } else if (this._N$layoutType === Type.VERTICAL) {
                    var newHeight = this._getVerticalBaseHeight(this.node.children);
                    this._doLayoutVertically(newHeight, !1, function fnPositionX(child) {
                        return child.getPosition(_tempPos), _tempPos.x;
                    }, !0), this.node.height = newHeight;
                } else this._N$layoutType === Type.NONE ? this._resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this._N$layoutType === Type.GRID && this._doLayoutGrid();
            }
        }, {
            key: "_getUsedScaleValue",
            value: function _getUsedScaleValue(value) {
                return this._affectedByScale ? Math.abs(value) : 1;
            }
        }, {
            key: "_doLayoutDirty",
            value: function _doLayoutDirty() {
                this._layoutDirty = !0;
            }
        }, {
            key: "_doScaleDirty",
            value: function _doScaleDirty() {
                this._layoutDirty = this._layoutDirty || this._affectedByScale;
            }
        }, {
            key: "type",
            get: function get() {
                return this._N$layoutType;
            },
            set: function set(value) {
                this._N$layoutType = value, this._doLayoutDirty();
            }
        }, {
            key: "resizeMode",
            get: function get() {
                return this._resizeMode;
            },
            set: function set(value) {
                this._N$layoutType === Type.NONE && value === ResizeMode.CHILDREN || (this._resizeMode = value, 
                this._doLayoutDirty());
            }
        }, {
            key: "cellSize",
            get: function get() {
                return this._cellSize;
            },
            set: function set(value) {
                this._cellSize !== value && (this._cellSize = value, this._doLayoutDirty());
            }
        }, {
            key: "startAxis",
            get: function get() {
                return this._startAxis;
            },
            set: function set(value) {
                this._startAxis !== value && (this._startAxis = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingLeft",
            get: function get() {
                return this._paddingLeft;
            },
            set: function set(value) {
                this._paddingLeft !== value && (this._paddingLeft = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingRight",
            get: function get() {
                return this._paddingRight;
            },
            set: function set(value) {
                this._paddingRight !== value && (this._paddingRight = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingTop",
            get: function get() {
                return this._paddingTop;
            },
            set: function set(value) {
                this._paddingTop !== value && (this._paddingTop = value, this._doLayoutDirty());
            }
        }, {
            key: "paddingBottom",
            get: function get() {
                return this._paddingBottom;
            },
            set: function set(value) {
                this._paddingBottom !== value && (this._paddingBottom = value, this._doLayoutDirty());
            }
        }, {
            key: "spacingX",
            get: function get() {
                return this._spacingX;
            },
            set: function set(value) {
                this._spacingX !== value && (this._spacingX = value, this._doLayoutDirty());
            }
        }, {
            key: "spacingY",
            get: function get() {
                return this._spacingY;
            },
            set: function set(value) {
                this._spacingY !== value && (this._spacingY = value, this._doLayoutDirty());
            }
        }, {
            key: "verticalDirection",
            get: function get() {
                return this._verticalDirection;
            },
            set: function set(value) {
                this._verticalDirection !== value && (this._verticalDirection = value, this._doLayoutDirty());
            }
        }, {
            key: "horizontalDirection",
            get: function get() {
                return this._horizontalDirection;
            },
            set: function set(value) {
                this._horizontalDirection !== value && (this._horizontalDirection = value, this._doLayoutDirty());
            }
        }, {
            key: "padding",
            get: function get() {
                return this._paddingLeft;
            },
            set: function set(value) {
                this._N$padding = value, this._migratePaddingData(), this._doLayoutDirty();
            }
        }, {
            key: "affectedByScale",
            get: function get() {
                return this._affectedByScale;
            },
            set: function set(value) {
                this._affectedByScale = value, this._doLayoutDirty();
            }
        } ]), LayoutComponent;
    }(), _class3$p.Type = Type, _class3$p.VerticalDirection = VerticalDirection, _class3$p.HorizontalDirection = HorizontalDirection, 
    _class3$p.ResizeMode = ResizeMode, _class3$p.AxisDirection = AxisDirection, _applyDecoratedDescriptor((_class2$17 = _temp$1f).prototype, "type", [ _dec4$z ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "type"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "resizeMode", [ _dec5$u ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "resizeMode"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "cellSize", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "cellSize"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "startAxis", [ _dec6$q ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "startAxis"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "paddingLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "paddingLeft"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "paddingRight", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "paddingRight"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "paddingTop", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "paddingTop"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "paddingBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "paddingBottom"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "spacingX", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "spacingX"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "spacingY", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "spacingY"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "verticalDirection", [ _dec7$k ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "verticalDirection"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "horizontalDirection", [ _dec8$f ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "horizontalDirection"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "padding", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "padding"), _class2$17.prototype), 
    _applyDecoratedDescriptor(_class2$17.prototype, "affectedByScale", [ property ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "affectedByScale"), _class2$17.prototype), 
    _descriptor$16 = _applyDecoratedDescriptor(_class2$17.prototype, "_resizeMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return ResizeMode.NONE;
        }
    }), _descriptor2$U = _applyDecoratedDescriptor(_class2$17.prototype, "_N$layoutType", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Type.NONE;
        }
    }), _descriptor3$I = _applyDecoratedDescriptor(_class2$17.prototype, "_N$padding", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor4$B = _applyDecoratedDescriptor(_class2$17.prototype, "_cellSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return cc.size(40, 40);
        }
    }), _descriptor5$v = _applyDecoratedDescriptor(_class2$17.prototype, "_startAxis", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return AxisDirection.HORIZONTAL;
        }
    }), _descriptor6$o = _applyDecoratedDescriptor(_class2$17.prototype, "_paddingLeft", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$k = _applyDecoratedDescriptor(_class2$17.prototype, "_paddingRight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$g = _applyDecoratedDescriptor(_class2$17.prototype, "_paddingTop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$d = _applyDecoratedDescriptor(_class2$17.prototype, "_paddingBottom", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor10$a = _applyDecoratedDescriptor(_class2$17.prototype, "_spacingX", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor11$9 = _applyDecoratedDescriptor(_class2$17.prototype, "_spacingY", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor12$9 = _applyDecoratedDescriptor(_class2$17.prototype, "_verticalDirection", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return VerticalDirection.TOP_TO_BOTTOM;
        }
    }), _descriptor13$9 = _applyDecoratedDescriptor(_class2$17.prototype, "_horizontalDirection", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return HorizontalDirection.LEFT_TO_RIGHT;
        }
    }), _descriptor14$5 = _applyDecoratedDescriptor(_class2$17.prototype, "_affectedByScale", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$1k = _class2$17)) || _class$1k) || _class$1k) || _class$1k) || _class$1k);
    !function(LineCap) {
        LineCap[LineCap.BUTT = 0] = "BUTT", LineCap[LineCap.ROUND = 1] = "ROUND", LineCap[LineCap.SQUARE = 2] = "SQUARE";
    }(LineCap || (LineCap = {})), ccenum(LineCap), function(LineJoin) {
        LineJoin[LineJoin.BEVEL = 0] = "BEVEL", LineJoin[LineJoin.ROUND = 1] = "ROUND", 
        LineJoin[LineJoin.MITER = 2] = "MITER";
    }(LineJoin || (LineJoin = {})), ccenum(LineJoin), function(PointFlags) {
        PointFlags[PointFlags.PT_CORNER = 1] = "PT_CORNER", PointFlags[PointFlags.PT_LEFT = 2] = "PT_LEFT", 
        PointFlags[PointFlags.PT_BEVEL = 4] = "PT_BEVEL", PointFlags[PointFlags.PT_INNERBEVEL = 8] = "PT_INNERBEVEL";
    }(PointFlags || (PointFlags = {})), ccenum(PointFlags);
    var _dec$1j, _dec2$Y, _dec3$K, _dec4$B, _dec5$w, _dec6$s, _dec7$l, _class$1m, _class2$19, _descriptor$18, _descriptor2$W, _class3$r, _temp$1h, GraphicsComponent = (_dec$1i = ccclass("cc.GraphicsComponent"), 
    _dec2$X = executionOrder(110), _dec3$J = menu("UI/Render/Graphics"), _dec4$A = property({
        type: LineJoin
    }), _dec5$v = property({
        type: LineCap
    }), _dec6$r = property({
        override: !0,
        visible: !1
    }), _dec$1i(_class$1l = _dec2$X(_class$1l = _dec3$J((_temp$1g = _class3$q = function(_UIRenderComponent) {
        function GraphicsComponent() {
            var _this;
            return _classCallCheck(this, GraphicsComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GraphicsComponent).call(this))).impl = null, 
            _this.model = null, _initializerDefineProperty(_this, "_lineWidth", _descriptor$17, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_strokeColor", _descriptor2$V, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_lineJoin", _descriptor3$J, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_lineCap", _descriptor4$C, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fillColor", _descriptor5$w, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_miterLimit", _descriptor6$p, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._instanceMaterialType = InstanceMaterialType.ADDCOLOR, _this;
        }
        return _inherits(GraphicsComponent, UIRenderComponent), _createClass(GraphicsComponent, [ {
            key: "lineWidth",
            get: function get$$1() {
                return this._lineWidth;
            },
            set: function set(value) {
                this._lineWidth = value, this.impl && (this.impl.lineWidth = value);
            }
        }, {
            key: "lineJoin",
            get: function get$$1() {
                return this._lineJoin;
            },
            set: function set(value) {
                this._lineJoin = value, this.impl && (this.impl.lineJoin = value);
            }
        }, {
            key: "lineCap",
            get: function get$$1() {
                return this._lineCap;
            },
            set: function set(value) {
                this._lineCap = value, this.impl && (this.impl.lineCap = value);
            }
        }, {
            key: "strokeColor",
            get: function get$$1() {
                return this._strokeColor;
            },
            set: function set(value) {
                this.impl && (this._strokeColor.set(value), this.impl.strokeColor = this._strokeColor);
            }
        }, {
            key: "fillColor",
            get: function get$$1() {
                return this._fillColor;
            },
            set: function set(value) {
                this.impl && (this._fillColor.set(value), this.impl.fillColor = this._fillColor);
            }
        }, {
            key: "miterLimit",
            get: function get$$1() {
                return this._miterLimit;
            },
            set: function set(value) {
                this._miterLimit = value;
            }
        }, {
            key: "color",
            get: function get$$1() {
                return this._color;
            }
        } ]), _createClass(GraphicsComponent, [ {
            key: "onRestore",
            value: function onRestore() {
                this.impl || this._flushAssembler();
            }
        }, {
            key: "__preload",
            value: function __preload() {
                _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this).call(this), 
                this.impl = this._assembler && this._assembler.createImpl(this);
            }
        }, {
            key: "onLoad",
            value: function onLoad() {
                this._sceneGetter = cc.director.root.ui.getRenderSceneGetter();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this).call(this), 
                this.model && (this.model.enabled = !0), this._activateMaterial();
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.model && (this.model.enabled = !1);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this).call(this), 
                this._sceneGetter = null, this.model && (this._getRenderScene().destroyModel(this.model), 
                this.model = null), this.impl && (this.impl.clear(), this.impl = null);
            }
        }, {
            key: "_activateMaterial",
            value: function _activateMaterial() {
                this._material && this._updateMaterial(this._material);
            }
        }, {
            key: "moveTo",
            value: function moveTo(x, y) {
                this.impl && this.impl.moveTo(x, y);
            }
        }, {
            key: "lineTo",
            value: function lineTo(x, y) {
                this.impl && this.impl.lineTo(x, y);
            }
        }, {
            key: "bezierCurveTo",
            value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                this.impl && this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
            }
        }, {
            key: "quadraticCurveTo",
            value: function quadraticCurveTo(cx, cy, x, y) {
                this.impl && this.impl.quadraticCurveTo(cx, cy, x, y);
            }
        }, {
            key: "arc",
            value: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                this.impl && this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
            }
        }, {
            key: "ellipse",
            value: function ellipse(cx, cy, rx, ry) {
                this.impl && this.impl.ellipse(cx, cy, rx, ry);
            }
        }, {
            key: "circle",
            value: function circle(cx, cy, r) {
                this.impl && this.impl.circle(cx, cy, r);
            }
        }, {
            key: "rect",
            value: function rect(x, y, w, h) {
                this.impl && this.impl.rect(x, y, w, h);
            }
        }, {
            key: "roundRect",
            value: function roundRect(x, y, w, h, r) {
                this.impl && this.impl.roundRect(x, y, w, h, r);
            }
        }, {
            key: "fillRect",
            value: function fillRect(x, y, w, h) {
                this.rect(x, y, w, h), this.fill();
            }
        }, {
            key: "clear",
            value: function clear() {
                this.impl && this.impl.clear();
            }
        }, {
            key: "close",
            value: function close() {
                this.impl && this.impl.close();
            }
        }, {
            key: "stroke",
            value: function stroke() {
                this._assembler.stroke(this);
            }
        }, {
            key: "fill",
            value: function fill() {
                this._assembler.fill(this);
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                return !!_get(_getPrototypeOf(GraphicsComponent.prototype), "updateAssembler", this).call(this, render) && (render.commitModel(this, this.model, this._material), 
                !0);
            }
        }, {
            key: "helpInstanceMaterial",
            value: function helpInstanceMaterial() {
                var mat = null;
                this._sharedMaterial ? mat = Material.getInstantiatedMaterial(this._sharedMaterial, new RenderableComponent(), !1) : ((mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-base-material"), new RenderableComponent(), !1)).recompileShaders({
                    USE_LOCAL: !0
                }), mat.onLoaded()), this._updateMaterial(mat), this.impl || (this._flushAssembler(), 
                this.impl = this._assembler && this._assembler.createImpl(this));
            }
        }, {
            key: "_instanceMaterial",
            value: function _instanceMaterial() {
                this.helpInstanceMaterial();
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = GraphicsComponent.Assembler.getAssembler(this);
                this._assembler !== assembler && (this._assembler = assembler);
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                return !!_get(_getPrototypeOf(GraphicsComponent.prototype), "_canRender", this).call(this) && !!this.model;
            }
        } ]), GraphicsComponent;
    }(), _class3$q.LineJoin = LineJoin, _class3$q.LineCap = LineCap, _applyDecoratedDescriptor((_class2$18 = _temp$1g).prototype, "lineJoin", [ _dec4$A ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "lineJoin"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "lineCap", [ _dec5$v ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "lineCap"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "strokeColor", [ property ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "strokeColor"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "fillColor", [ property ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "fillColor"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "miterLimit", [ property ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "miterLimit"), _class2$18.prototype), 
    _applyDecoratedDescriptor(_class2$18.prototype, "color", [ _dec6$r ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "color"), _class2$18.prototype), 
    _descriptor$17 = _applyDecoratedDescriptor(_class2$18.prototype, "_lineWidth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor2$V = _applyDecoratedDescriptor(_class2$18.prototype, "_strokeColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.BLACK;
        }
    }), _descriptor3$J = _applyDecoratedDescriptor(_class2$18.prototype, "_lineJoin", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return LineJoin.MITER;
        }
    }), _descriptor4$C = _applyDecoratedDescriptor(_class2$18.prototype, "_lineCap", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return LineCap.BUTT;
        }
    }), _descriptor5$w = _applyDecoratedDescriptor(_class2$18.prototype, "_fillColor", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Color.WHITE;
        }
    }), _descriptor6$p = _applyDecoratedDescriptor(_class2$18.prototype, "_miterLimit", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 10;
        }
    }), _class$1l = _class2$18)) || _class$1l) || _class$1l) || _class$1l);
    cc.GraphicsComponent = GraphicsComponent;
    var MaskType, _worldMatrix$1 = new Mat4(), _vec2_temp = new Vec2(), _mat4_temp$1 = new Mat4(), _circlepoints = [];
    !function(MaskType) {
        MaskType[MaskType.RECT = 0] = "RECT", MaskType[MaskType.ELLIPSE = 1] = "ELLIPSE";
    }(MaskType || (MaskType = {})), ccenum(MaskType);
    var _dec$1k, _dec2$Z, _dec3$L, _dec4$C, _dec5$x, _dec6$t, _class$1n, _class2$1a, _descriptor$19, _descriptor2$X, _descriptor3$K, _descriptor4$D, _descriptor5$x, _class3$s, _temp$1i, Mode$4, MaskComponent = (_dec$1j = ccclass("cc.MaskComponent"), 
    _dec2$Y = executionOrder(110), _dec3$K = menu("UI/Render/Mask"), _dec4$B = property({
        type: MaskType,
        displayOrder: 4
    }), _dec5$w = property({
        visible: !1,
        override: !0
    }), _dec6$s = property({
        visible: !1,
        override: !0
    }), _dec7$l = property({
        visible: !1,
        override: !0
    }), _dec$1j(_class$1m = _dec2$Y(_class$1m = _dec3$K((_temp$1h = _class3$r = function(_UIRenderComponent) {
        function MaskComponent() {
            var _this;
            return _classCallCheck(this, MaskComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MaskComponent).call(this)), "_type", _descriptor$18, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_segments", _descriptor2$W, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._graphics = null, _this._clearGraphics = null, _this._lastVisibleSize = new Size(), 
            _this._instanceMaterialType = InstanceMaterialType.ADDCOLOR, _this;
        }
        return _inherits(MaskComponent, UIRenderComponent), _createClass(MaskComponent, [ {
            key: "type",
            get: function get$$1() {
                return this._type;
            },
            set: function set(value) {
                this._type !== value && (this._type = value, this._updateGraphics(), this._renderData && (this.destroyRenderData(), 
                this._renderData = null), this._activateMaterial());
            }
        }, {
            key: "segments",
            get: function get$$1() {
                return this._segments;
            },
            set: function set(value) {
                this._segments = clamp(value, 3, 1e4), this._updateGraphics();
            }
        }, {
            key: "graphics",
            get: function get$$1() {
                return this._graphics;
            }
        }, {
            key: "clearGraphics",
            get: function get$$1() {
                return this._clearGraphics;
            }
        }, {
            key: "dstBlendFactor",
            get: function get$$1() {
                return this._dstBlendFactor;
            },
            set: function set(value) {
                this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "srcBlendFactor",
            get: function get$$1() {
                return this._srcBlendFactor;
            },
            set: function set(value) {
                this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
            }
        }, {
            key: "color",
            get: function get$$1() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this.markForUpdateRenderData());
            }
        } ]), _createClass(MaskComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._createGraphics();
            }
        }, {
            key: "onRestore",
            value: function onRestore() {
                this._createGraphics(), this._updateGraphics();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(MaskComponent.prototype), "onEnable", this).call(this), this._flushVisibility(), 
                this._clearGraphics && this._clearGraphics.onEnable(), this._updateGraphics(), this._activateMaterial(), 
                this.node.on(exports.SystemEventType.ROTATION_PART, this._nodeStateChange, this), 
                this.node.on(exports.SystemEventType.SCALE_PART, this._nodeStateChange, this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(MaskComponent.prototype), "onDisable", this).call(this), this._disableGraphics(), 
                this.node.off(exports.SystemEventType.ROTATION_PART, this._nodeStateChange, this), 
                this.node.off(exports.SystemEventType.SCALE_PART, this._nodeStateChange, this);
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                _get(_getPrototypeOf(MaskComponent.prototype), "onDestroy", this).call(this), this._removeGraphics();
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                if (_get(_getPrototypeOf(MaskComponent.prototype), "updateAssembler", this).call(this, render)) {
                    var size = cc.visibleRect;
                    return size.width === this._lastVisibleSize.width && size.height === this._lastVisibleSize.height || this._updateClearGraphics(), 
                    render.commitComp(this, null, this._assembler), !0;
                }
                return !1;
            }
        }, {
            key: "postUpdateAssembler",
            value: function postUpdateAssembler(render) {
                this._canRender() && this._postAssembler && render.commitComp(this, null, this._postAssembler);
            }
        }, {
            key: "isHit",
            value: function isHit(cameraPt) {
                var node = this.node, size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
                this.node.getWorldMatrix(_worldMatrix$1), mat4.invert(_mat4_temp$1, _worldMatrix$1), 
                vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
                var ap = node.getAnchorPoint();
                testPt.x += ap.x * w, testPt.y += ap.y * h;
                var result = !1;
                if (this.type === MaskType.RECT) result = 0 <= testPt.x && 0 <= testPt.y && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
                    var rx = w / 2, ry = h / 2, px = testPt.x - .5 * w, py = testPt.y - .5 * h;
                    result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
                }
                return result;
            }
        }, {
            key: "_resizeNodeToTargetNode",
            value: function _resizeNodeToTargetNode() {}
        }, {
            key: "_nodeStateChange",
            value: function _nodeStateChange() {
                _get(_getPrototypeOf(MaskComponent.prototype), "_nodeStateChange", this).call(this), 
                this._updateGraphics();
            }
        }, {
            key: "_canRender",
            value: function _canRender() {
                return !!_get(_getPrototypeOf(MaskComponent.prototype), "_canRender", this).call(this) && (null !== this._clearGraphics && null !== this._graphics && this._renderPermit);
            }
        }, {
            key: "_flushAssembler",
            value: function _flushAssembler() {
                var assembler = MaskComponent.Assembler.getAssembler(this), posAssembler = MaskComponent.PostAssembler.getAssembler(this);
                this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
                this._postAssembler !== posAssembler && (this._postAssembler = posAssembler), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
                this._renderData.material = this.sharedMaterial, this.markForUpdateRenderData());
            }
        }, {
            key: "_parentChanged",
            value: function _parentChanged(node) {
                return !!_get(_getPrototypeOf(MaskComponent.prototype), "_parentChanged", this).call(this, node) && (this._flushVisibility(), 
                !0);
            }
        }, {
            key: "_onTextureLoaded",
            value: function _onTextureLoaded() {
                this._renderData && (this._renderData.uvDirty = !0, this._renderData.vertDirty = !0), 
                this.enabledInHierarchy && this._activateMaterial();
            }
        }, {
            key: "_applySpriteFrame",
            value: function _applySpriteFrame(oldFrame) {}
        }, {
            key: "_createGraphics",
            value: function _createGraphics() {
                if (!this._clearGraphics) {
                    var clearGraphics = this._clearGraphics = new GraphicsComponent();
                    clearGraphics.node = new Node$1("clear-graphics"), clearGraphics.helpInstanceMaterial(), 
                    clearGraphics._activateMaterial(), clearGraphics.lineWidth = 0;
                    var size = cc.visibleRect;
                    this._lastVisibleSize.width = size.width, this._lastVisibleSize.height = size.height, 
                    clearGraphics.node.setWorldPosition(size.width / 2, size.height / 2, 0), clearGraphics.rect(-size.width / 2, -size.height / 2, size.width, size.height);
                    var color = Color.WHITE;
                    color.a = 0, this._clearGraphics.fillColor = color, clearGraphics.fill();
                }
                if (!this._graphics) {
                    var graphics = this._graphics = new GraphicsComponent();
                    graphics.node = this.node, graphics.helpInstanceMaterial(), graphics.lineWidth = 0;
                    var _color = Color.WHITE;
                    _color.a = 0, graphics.fillColor = _color;
                }
            }
        }, {
            key: "_updateClearGraphics",
            value: function _updateClearGraphics() {
                if (this._clearGraphics) {
                    var size = cc.visibleRect;
                    this._clearGraphics.node.setWorldPosition(size.width / 2, size.height / 2, 0), this._clearGraphics.clear(), 
                    this._lastVisibleSize.width = size.width, this._lastVisibleSize.height = size.height, 
                    this._clearGraphics.rect(-size.width / 2, -size.height / 2, size.width, size.height), 
                    this._clearGraphics.fill();
                }
            }
        }, {
            key: "_updateGraphics",
            value: function _updateGraphics() {
                if (this._graphics) {
                    var node = this.node, graphics = this._graphics;
                    graphics.clear();
                    var size = node.getContentSize(), width = size.width, height = size.height, ap = node.getAnchorPoint(), x = -width * ap.x, y = -height * ap.y;
                    if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
                        for (var points = function _calculateCircle(center, radius, segements) {
                            _circlepoints.length = 0;
                            for (var anglePerStep = 2 * Math.PI / segements, step = 0; step < segements; ++step) _circlepoints.push(cc.v3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
                            return _circlepoints;
                        }(cc.v3(x + width / 2, y + height / 2, 0), cc.v3(width / 2, height / 2, 0), this._segments), i = 0; i < points.length; ++i) {
                            var point = points[i];
                            0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
                        }
                        graphics.close();
                    }
                    graphics.fill();
                }
            }
        }, {
            key: "_disableGraphics",
            value: function _disableGraphics() {
                this._graphics && this._graphics.onDisable(), this._clearGraphics && this._clearGraphics.onDisable();
            }
        }, {
            key: "_removeGraphics",
            value: function _removeGraphics() {
                this._graphics && this._graphics.destroy(), this._clearGraphics && this._clearGraphics.destroy();
            }
        }, {
            key: "_flushVisibility",
            value: function _flushVisibility() {
                this._clearGraphics && this._clearGraphics.setVisibility(this._visibility), this._graphics && this._graphics.setVisibility(this._visibility);
            }
        }, {
            key: "_activateMaterial",
            value: function _activateMaterial() {}
        } ]), MaskComponent;
    }(), _class3$r.Type = MaskType, _applyDecoratedDescriptor((_class2$19 = _temp$1h).prototype, "type", [ _dec4$B ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "type"), _class2$19.prototype), 
    _applyDecoratedDescriptor(_class2$19.prototype, "segments", [ property ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "segments"), _class2$19.prototype), 
    _applyDecoratedDescriptor(_class2$19.prototype, "dstBlendFactor", [ _dec5$w ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "dstBlendFactor"), _class2$19.prototype), 
    _applyDecoratedDescriptor(_class2$19.prototype, "srcBlendFactor", [ _dec6$s ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "srcBlendFactor"), _class2$19.prototype), 
    _applyDecoratedDescriptor(_class2$19.prototype, "color", [ _dec7$l ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "color"), _class2$19.prototype), 
    _descriptor$18 = _applyDecoratedDescriptor(_class2$19.prototype, "_type", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return MaskType.RECT;
        }
    }), _descriptor2$W = _applyDecoratedDescriptor(_class2$19.prototype, "_segments", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 64;
        }
    }), _class$1m = _class2$19)) || _class$1m) || _class$1m) || _class$1m);
    cc.MaskComponent = MaskComponent, function(Mode) {
        Mode[Mode.HORIZONTAL = 0] = "HORIZONTAL", Mode[Mode.VERTICAL = 1] = "VERTICAL", 
        Mode[Mode.FILLED = 2] = "FILLED";
    }(Mode$4 || (Mode$4 = {})), Enum(Mode$4);
    var _class$1o, _class2$1b, _descriptor$1a, _descriptor2$Y, ProgressBarComponent = (_dec$1k = ccclass("cc.ProgressBarComponent"), 
    _dec2$Z = executionOrder(110), _dec3$L = menu("UI/ProgressBar"), _dec4$C = property({
        type: SpriteComponent
    }), _dec5$x = property({
        type: Mode$4
    }), _dec6$t = property({
        range: [ 0, 1, .1 ],
        slide: !0
    }), _dec$1k(_class$1n = _dec2$Z(_class$1n = _dec3$L((_temp$1i = _class3$s = function(_Component) {
        function ProgressBarComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ProgressBarComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProgressBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_barSprite", _descriptor$19, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_mode", _descriptor2$X, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_totalLength", _descriptor3$K, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_progress", _descriptor4$D, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_reverse", _descriptor5$x, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(ProgressBarComponent, Component), _createClass(ProgressBarComponent, [ {
            key: "_initBarSprite",
            value: function _initBarSprite() {
                if (this._barSprite) {
                    var entity = this._barSprite.node;
                    if (!entity) return;
                    var nodeSize = this.node.getContentSize(), nodeAnchor = this.node.getAnchorPoint(), barSpriteSize = entity.getContentSize();
                    if (this._barSprite.fillType === SpriteComponent.FillType.RADIAL && (this._mode = Mode$4.FILLED), 
                    this._mode === Mode$4.HORIZONTAL ? this.totalLength = barSpriteSize.width : this._mode === Mode$4.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this._barSprite.fillRange, 
                    entity.parent === this.node) {
                        var x = -nodeSize.width * nodeAnchor.x;
                        entity.setPosition(x, 0, 0);
                    }
                }
            }
        }, {
            key: "_updateBarStatus",
            value: function _updateBarStatus() {
                if (this._barSprite) {
                    var entity = this._barSprite.node;
                    if (!entity) return;
                    var entityAnchorPoint = entity.getAnchorPoint(), entitySize = entity.getContentSize(), entityPosition = entity.getPosition(), anchorPoint = new Vec2(0, .5), progress = clamp01$1(this._progress), actualLenth = this._totalLength * progress, finalContentSize = entitySize, totalWidth = 0, totalHeight = 0;
                    switch (this._mode) {
                      case Mode$4.HORIZONTAL:
                        this._reverse && (anchorPoint = new Vec2(1, .5)), finalContentSize = new Size(actualLenth, entitySize.height), 
                        totalWidth = this._totalLength, totalHeight = entitySize.height;
                        break;

                      case Mode$4.VERTICAL:
                        anchorPoint = this._reverse ? new Vec2(.5, 1) : new Vec2(.5, 0), finalContentSize = new Size(entitySize.width, actualLenth), 
                        totalWidth = entitySize.width, totalHeight = this._totalLength;
                    }
                    if (this._mode === Mode$4.FILLED) this._barSprite.type !== cc.SpriteComponent.Type.FILLED ? cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (actualLenth *= -1), 
                    this._barSprite.fillRange = actualLenth); else if (this._barSprite.type !== cc.SpriteComponent.Type.FILLED) {
                        var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x, anchorOffsetY = anchorPoint.y - entityAnchorPoint.y, finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                        entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z), 
                        entity.setAnchorPoint(anchorPoint), entity.setContentSize(finalContentSize);
                    } else cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
                }
            }
        }, {
            key: "barSprite",
            get: function get() {
                return this._barSprite;
            },
            set: function set(value) {
                this._barSprite !== value && (this._barSprite = value, this._initBarSprite());
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(value) {
                if (this._mode !== value && (this._mode = value, this._barSprite)) {
                    var entity = this._barSprite.node;
                    if (!entity) return;
                    var entitySize = entity.getContentSize();
                    this._mode === Mode$4.HORIZONTAL ? this.totalLength = entitySize.width : this._mode === Mode$4.VERTICAL ? this.totalLength = entitySize.height : this._mode === Mode$4.FILLED && (this.totalLength = this._barSprite.fillRange);
                }
            }
        }, {
            key: "totalLength",
            get: function get() {
                return this._totalLength;
            },
            set: function set(value) {
                this._mode === Mode$4.FILLED && (value = clamp01$1(value)), this._totalLength = value, 
                this._updateBarStatus();
            }
        }, {
            key: "progress",
            get: function get() {
                return this._progress;
            },
            set: function set(value) {
                this._progress !== value && (this._progress = value, this._updateBarStatus());
            }
        }, {
            key: "reverse",
            get: function get() {
                return this._reverse;
            },
            set: function set(value) {
                this._reverse !== value && (this._reverse = value, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), 
                this._updateBarStatus());
            }
        } ]), ProgressBarComponent;
    }(), _class3$s.Mode = Mode$4, _applyDecoratedDescriptor((_class2$1a = _temp$1i).prototype, "barSprite", [ _dec4$C ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "barSprite"), _class2$1a.prototype), 
    _applyDecoratedDescriptor(_class2$1a.prototype, "mode", [ _dec5$x ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "mode"), _class2$1a.prototype), 
    _applyDecoratedDescriptor(_class2$1a.prototype, "totalLength", [ property ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "totalLength"), _class2$1a.prototype), 
    _applyDecoratedDescriptor(_class2$1a.prototype, "progress", [ _dec6$t ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "progress"), _class2$1a.prototype), 
    _applyDecoratedDescriptor(_class2$1a.prototype, "reverse", [ property ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "reverse"), _class2$1a.prototype), 
    _descriptor$19 = _applyDecoratedDescriptor(_class2$1a.prototype, "_barSprite", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$X = _applyDecoratedDescriptor(_class2$1a.prototype, "_mode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Mode$4.HORIZONTAL;
        }
    }), _descriptor3$K = _applyDecoratedDescriptor(_class2$1a.prototype, "_totalLength", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor4$D = _applyDecoratedDescriptor(_class2$1a.prototype, "_progress", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _descriptor5$x = _applyDecoratedDescriptor(_class2$1a.prototype, "_reverse", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _class$1n = _class2$1a)) || _class$1n) || _class$1n) || _class$1n);
    cc.ProgressBarComponent = ProgressBarComponent;
    var _dec$1m, _dec2$10, _dec3$N, _dec4$D, _dec5$y, _dec6$u, _dec7$m, _class$1p, _class2$1c, _descriptor$1b, _descriptor2$Z, _descriptor3$L, _descriptor4$E, _descriptor5$y, _descriptor6$q, _descriptor7$l, _descriptor8$h, _class3$t, _temp$1k, LabelOutlineComponent = ccclass("cc.LabelOutlineComponent")(_class$1o = executionOrder(110)(_class$1o = menu("UI/Render/LabelOutline")((_descriptor$1a = _applyDecoratedDescriptor((_class2$1b = function(_Component) {
        function LabelOutlineComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, LabelOutlineComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LabelOutlineComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$1a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_width", _descriptor2$Y, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(LabelOutlineComponent, Component), _createClass(LabelOutlineComponent, [ {
            key: "_updateRenderData",
            value: function _updateRenderData() {
                var label = this.node.getComponent(LabelComponent);
                label && label.updateRenderData(!0);
            }
        }, {
            key: "color",
            get: function get() {
                return this._color;
            },
            set: function set(value) {
                this._color !== value && (this._color.set(value), this._updateRenderData());
            }
        }, {
            key: "width",
            get: function get() {
                return this._width;
            },
            set: function set(value) {
                this._width !== value && (this._width = value, this._updateRenderData());
            }
        } ]), LabelOutlineComponent;
    }()).prototype, "_color", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new Color(255, 255, 255, 255);
        }
    }), _descriptor2$Y = _applyDecoratedDescriptor(_class2$1b.prototype, "_width", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _applyDecoratedDescriptor(_class2$1b.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "color"), _class2$1b.prototype), 
    _applyDecoratedDescriptor(_class2$1b.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "width"), _class2$1b.prototype), 
    _class$1o = _class2$1b)) || _class$1o) || _class$1o) || _class$1o;
    cc.LabelOutlineComponent = LabelOutlineComponent;
    var _htmlTextParser = new HtmlTextParser();
    var pool = new Pool(function(labelSeg) {
        return !!cc.isValid(labelSeg.node) && !labelSeg.node.getComponent(cc.LabelOutlineComponent);
    }, 20);
    pool.get = function(string, richtext) {
        var labelSeg = this._get();
        labelSeg || (labelSeg = {
            node: new PrivateNode("RICHTEXT_CHILD"),
            comp: null,
            lineCount: 0,
            styleIndex: 0,
            clickHandler: ""
        });
        var labelNode = labelSeg.node;
        labelNode || (labelNode = new PrivateNode("RICHTEXT_CHILD"));
        var labelComponent = labelNode.getComponent(LabelComponent);
        return labelComponent || (labelComponent = labelNode.addComponent(LabelComponent)), 
        labelComponent = labelComponent, labelNode.setPosition(0, 0, 0), labelNode.setAnchorPoint(.5, .5), 
        labelNode.setContentSize(128, 128), "string" != typeof string && (string = "" + string), 
        richtext.font instanceof Font ? labelComponent.font = richtext.font : labelComponent.fontFamily = "Arial", 
        labelComponent.string = string, labelComponent.horizontalAlign = exports.HorizontalTextAlignment.LEFT, 
        labelComponent.verticalAlign = exports.VerticalTextAlignment.TOP, labelComponent.fontSize = richtext.fontSize || 40, 
        labelComponent.overflow = 0, labelComponent.enableWrapText = !0, labelComponent.lineHeight = 40, 
        labelComponent.isBold = !1, labelComponent.isItalic = !1, labelComponent.isUnderline = !1, 
        {
            node: labelNode,
            comp: labelComponent,
            lineCount: 0,
            clickHandler: "",
            styleIndex: 0
        };
    };
    var _dec$1n, _dec2$11, _dec3$O, _dec4$E, _dec5$z, _class$1q, _class2$1d, _descriptor$1c, _descriptor2$_, _descriptor3$M, _descriptor4$F, _descriptor5$z, _class3$u, _temp$1l, RichTextComponent = (_dec$1m = ccclass("cc.RichTextComponent"), 
    _dec2$10 = executionOrder(110), _dec3$N = menu("UI/Render/RichText"), _dec4$D = property({
        multiline: !0
    }), _dec5$y = property({
        type: exports.HorizontalTextAlignment
    }), _dec6$u = property({
        type: TTFFont
    }), _dec7$m = property({
        type: SpriteAtlas
    }), _dec$1m(_class$1p = _dec2$10(_class$1p = _dec3$N(_class$1p = executeInEditMode((_temp$1k = _class3$t = function(_UIComponent) {
        function RichTextComponent() {
            var _this;
            return _classCallCheck(this, RichTextComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RichTextComponent).call(this)), "_lineHeight", _descriptor$1b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_string", _descriptor2$Z, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$L, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_fontSize", _descriptor4$E, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_maxWidth", _descriptor5$y, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_font", _descriptor6$q, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_imageAtlas", _descriptor7$l, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor8$h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._textArray = [], _this._labelSegments = [], _this._labelSegmentsCache = [], 
            _this._linesWidth = [], _this._lineCount = 1, _this._labelWidth = 0, _this._labelHeight = 0, 
            _this._layoutDirty = !0, _this._lineOffsetX = 0, _this._updateRichTextStatus = void 0, 
            _this._updateRichTextStatus = _this._updateRichText, _this;
        }
        return _inherits(RichTextComponent, UIComponent), _createClass(RichTextComponent, [ {
            key: "string",
            get: function get() {
                return this._string;
            },
            set: function set(value) {
                this._string !== value && (this._string = value, this._updateRichTextStatus());
            }
        }, {
            key: "horizontalAlign",
            get: function get() {
                return this._horizontalAlign;
            },
            set: function set(value) {
                this.horizontalAlign !== value && (this._horizontalAlign = value, this._layoutDirty = !0, 
                this._updateRichTextStatus());
            }
        }, {
            key: "fontSize",
            get: function get() {
                return this._fontSize;
            },
            set: function set(value) {
                this._fontSize !== value && (this._fontSize = value, this._layoutDirty = !0, this._updateRichTextStatus());
            }
        }, {
            key: "font",
            get: function get() {
                return this._font;
            },
            set: function set(value) {
                this._font !== value && (this._font = value, this._layoutDirty = !0, this._font && this._onTTFLoaded(), 
                this._updateRichTextStatus());
            }
        }, {
            key: "maxWidth",
            get: function get() {
                return this._maxWidth;
            },
            set: function set(value) {
                this._maxWidth !== value && (this._maxWidth = value, this._layoutDirty = !0, this._updateRichTextStatus());
            }
        }, {
            key: "lineHeight",
            get: function get() {
                return this._lineHeight;
            },
            set: function set(value) {
                this._lineHeight !== value && (this._lineHeight = value, this._layoutDirty = !0, 
                this._updateRichTextStatus());
            }
        }, {
            key: "imageAtlas",
            get: function get() {
                return this._imageAtlas;
            },
            set: function set(value) {
                this._imageAtlas !== value && (this._imageAtlas = value, this._layoutDirty = !0, 
                this._updateRichTextStatus());
            }
        }, {
            key: "handleTouchEvent",
            get: function get() {
                return this._handleTouchEvent;
            },
            set: function set(value) {
                this._handleTouchEvent !== value && (this._handleTouchEvent = value, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()));
            }
        } ]), _createClass(RichTextComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1);
            }
        }, {
            key: "start",
            value: function start() {
                this._onTTFLoaded();
            }
        }, {
            key: "onRestore",
            value: function onRestore() {
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                var _iterator = this._labelSegments, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var seg = _ref;
                    seg.node.removeFromParent(), pool.put(seg);
                }
            }
        }, {
            key: "_addEventListeners",
            value: function _addEventListeners() {
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_removeEventListeners",
            value: function _removeEventListeners() {
                this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
            }
        }, {
            key: "_updateLabelSegmentTextAttributes",
            value: function _updateLabelSegmentTextAttributes() {
                var _this2 = this;
                this._labelSegments.forEach(function(item) {
                    _this2._applyTextAttribute(item);
                });
            }
        }, {
            key: "_createFontLabel",
            value: function _createFontLabel(string) {
                return pool.get(string, this);
            }
        }, {
            key: "_onTTFLoaded",
            value: function _onTTFLoaded() {
                if (this._font instanceof TTFFont) if (this._font._nativeAsset) this._layoutDirty = !0, 
                this._updateRichText(); else {
                    var self = this;
                    cc.loader.load(this._font.nativeUrl, function(err, fontFamily) {
                        self._layoutDirty = !0, self._updateRichText();
                    });
                } else this._layoutDirty = !0, this._updateRichText();
            }
        }, {
            key: "_measureText",
            value: function _measureText(styleIndex, string) {
                var self = this, func = function func(s) {
                    var label;
                    return 0 === self._labelSegmentsCache.length ? (label = self._createFontLabel(s), 
                    self._labelSegmentsCache.push(label)) : (label = self._labelSegmentsCache[0]).node.getComponent(LabelComponent).string = s, 
                    label.styleIndex = styleIndex, self._applyTextAttribute(label), label.node.getContentSize().width;
                };
                return string ? func(string) : func;
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                var _this3 = this, components = this.node.getComponents(UIComponent), self = this, _loop = function _loop() {
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) return "break";
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) return "break";
                        _ref2 = _i2.value;
                    }
                    var seg = _ref2, clickHandler = seg.clickHandler;
                    clickHandler && _this3._containsTouchLocation(seg, event.touch.getUILocation()) && (components.forEach(function(component) {
                        var func = component[clickHandler];
                        component.enabledInHierarchy && func && func.call(self, event);
                    }), event.propagationStopped = !0);
                }, _iterator2 = this._labelSegments, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if ("break" === _loop()) break;
                }
            }
        }, {
            key: "_containsTouchLocation",
            value: function _containsTouchLocation(label, point) {
                var comp = label.node.getComponent(UITransformComponent);
                return !!comp && comp.getBoundingBoxToWorld().contains(point);
            }
        }, {
            key: "_resetState",
            value: function _resetState() {
                for (var _this4 = this, children = this.node.children, _loop2 = function _loop2(i) {
                    var child = children[i];
                    if (("RICHTEXT_CHILD" === child.name || "RICHTEXT_Image_CHILD" === child.name) && (child.parent === _this4.node ? child.parent = null : children.splice(i, 1), 
                    "RICHTEXT_CHILD" === child.name)) {
                        var index = _this4._labelSegments.findIndex(function(seg) {
                            return seg.node === child;
                        });
                        -1 !== index && pool.put(_this4._labelSegments[index]);
                    }
                }, i = children.length - 1; 0 <= i; i--) _loop2(i);
                this._labelSegments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, 
                this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, 
                this._layoutDirty = !0;
            }
        }, {
            key: "_activateChildren",
            value: function _activateChildren(active) {
                for (var i = this.node.children.length - 1; 0 <= i; i--) {
                    var child = this.node.children[i];
                    "RICHTEXT_CHILD" !== child.name && "RICHTEXT_Image_CHILD" !== child.name || (child.active = active);
                }
            }
        }, {
            key: "_addLabelSegment",
            value: function _addLabelSegment(stringToken, styleIndex) {
                var labelSegment;
                if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
                    var label = (labelSegment = this._labelSegmentsCache.pop()).node.getComponent(LabelComponent);
                    label && (label.string = stringToken);
                }
                return labelSegment.styleIndex = styleIndex, labelSegment.lineCount = this._lineCount, 
                labelSegment.node.setAnchorPoint(0, 0), this._applyTextAttribute(labelSegment), 
                this.node.addChild(labelSegment.node), this._labelSegments.push(labelSegment), labelSegment;
            }
        }, {
            key: "_updateRichTextWithMaxWidth",
            value: function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
                var fragmentWidth = labelWidth;
                if (0 < this._lineOffsetX && fragmentWidth + this._lineOffsetX > this.maxWidth) for (var checkStartIndex = 0; this._lineOffsetX <= this.maxWidth; ) {
                    var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length), checkString = labelString.substr(checkStartIndex, checkEndIndex), checkStringWidth = this._measureText(styleIndex, checkString);
                    if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
                        if (0 < checkStartIndex) {
                            var remainingString = labelString.substr(0, checkStartIndex);
                            this._addLabelSegment(remainingString, styleIndex), labelString = labelString.substr(checkStartIndex, labelString.length), 
                            fragmentWidth = this._measureText(styleIndex, labelString);
                        }
                        this._updateLineInfo();
                        break;
                    }
                    this._lineOffsetX += checkStringWidth, checkStartIndex += checkEndIndex;
                }
                if (fragmentWidth > this.maxWidth) for (var fragments = fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex)), k = 0; k < fragments.length; ++k) {
                    var splitString = fragments[k], labelSize = this._addLabelSegment(splitString, styleIndex).node.getContentSize();
                    this._lineOffsetX += labelSize.width, 1 < fragments.length && k < fragments.length - 1 && this._updateLineInfo();
                } else this._lineOffsetX += fragmentWidth, this._addLabelSegment(labelString, styleIndex);
            }
        }, {
            key: "_isLastComponentCR",
            value: function _isLastComponentCR(stringToken) {
                return stringToken.length - 1 === stringToken.lastIndexOf("\n");
            }
        }, {
            key: "_updateLineInfo",
            value: function _updateLineInfo() {
                this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++;
            }
        }, {
            key: "_needsUpdateTextLayout",
            value: function _needsUpdateTextLayout(newTextArray) {
                if (this._layoutDirty || !this._textArray || !newTextArray) return !0;
                if (this._textArray.length !== newTextArray.length) return !0;
                for (var i = 0; i < this._textArray.length; i++) {
                    var oldItem = this._textArray[i], newItem = newTextArray[i];
                    if (oldItem.text !== newItem.text) return !0;
                    if (oldItem.style) {
                        if (newItem.style) {
                            if (!!newItem.style.outline != !!oldItem.style.outline) return !0;
                            if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) return !0;
                            if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) return !0;
                        } else if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage || oldItem.style.outline) return !0;
                    } else if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage || newItem.style.outline)) return !0;
                }
                return !1;
            }
        }, {
            key: "_addRichTextImageElement",
            value: function _addRichTextImageElement(richTextElement) {
                if (richTextElement.style) {
                    var spriteFrameName = richTextElement.style.src, spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
                    if (spriteFrame) {
                        var spriteNode = new PrivateNode("RICHTEXT_Image_CHILD"), spriteComponent = spriteNode.addComponent(SpriteComponent);
                        spriteNode.setAnchorPoint(0, 0), spriteComponent.type = cc.SpriteComponent.Type.SLICED, 
                        spriteComponent.sizeMode = cc.SpriteComponent.SizeMode.CUSTOM, this.node.addChild(spriteNode);
                        var obj = {
                            node: spriteNode,
                            comp: spriteComponent,
                            lineCount: 0,
                            clickHandler: "",
                            styleIndex: 0
                        };
                        this._labelSegments.push(obj);
                        var spriteRect = spriteFrame.getRect(), scaleFactor = 1, spriteWidth = spriteRect.width, spriteHeight = spriteRect.height, expectWidth = richTextElement.style.imageWidth, expectHeight = richTextElement.style.imageHeight;
                        if (void 0 !== expectHeight && 0 < expectHeight && expectHeight < this.lineHeight ? spriteWidth *= scaleFactor = expectHeight / spriteHeight : spriteWidth *= scaleFactor = this.lineHeight / spriteHeight, 
                        spriteHeight *= scaleFactor, void 0 !== expectWidth && 0 < expectWidth && (spriteWidth = expectWidth), 
                        0 < this.maxWidth ? (this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo(), 
                        this._lineOffsetX += spriteWidth) : (this._lineOffsetX += spriteWidth, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), 
                        spriteComponent.spriteFrame = spriteFrame, spriteNode.setContentSize(spriteWidth, spriteHeight), 
                        obj.lineCount = this._lineCount, richTextElement.style.event) {
                            var c = "click";
                            richTextElement.style.event[c] && (obj.clickHandler = richTextElement.style.event[c]);
                        }
                    } else cc.warnID(4400);
                }
            }
        }, {
            key: "_updateRichText",
            value: function _updateRichText() {
                if (this.enabled) {
                    var newTextArray = _htmlTextParser.parse(this._string);
                    if (!this._needsUpdateTextLayout(newTextArray)) return this._textArray = newTextArray.slice(), 
                    void this._updateLabelSegmentTextAttributes();
                    this._textArray = newTextArray.slice(), this._resetState();
                    for (var labelSize, lastEmptyLine = !1, i = 0; i < this._textArray.length; ++i) {
                        var richTextElement = this._textArray[i], text = richTextElement.text;
                        if (void 0 !== text) {
                            if ("" === text) {
                                if (richTextElement.style && richTextElement.style.isNewLine) {
                                    this._updateLineInfo();
                                    continue;
                                }
                                if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
                                    this._addRichTextImageElement(richTextElement);
                                    continue;
                                }
                            }
                            for (var multilineTexts = text.split("\n"), j = 0; j < multilineTexts.length; ++j) {
                                var labelString = multilineTexts[j];
                                if ("" !== labelString) if (lastEmptyLine = !1, 0 < this.maxWidth) {
                                    var labelWidth = this._measureText(i, labelString);
                                    this._updateRichTextWithMaxWidth(labelString, labelWidth, i), 1 < multilineTexts.length && j < multilineTexts.length - 1 && this._updateLineInfo();
                                } else labelSize = this._addLabelSegment(labelString, i).node.getContentSize(), 
                                this._lineOffsetX += labelSize.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), 
                                1 < multilineTexts.length && j < multilineTexts.length - 1 && this._updateLineInfo(); else {
                                    if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
                                    this._updateLineInfo(), lastEmptyLine = !0;
                                }
                            }
                        }
                    }
                    lastEmptyLine || this._linesWidth.push(this._lineOffsetX), 0 < this.maxWidth && (this._labelWidth = this.maxWidth), 
                    this._labelHeight = this._lineCount * this.lineHeight, this.node.setContentSize(this._labelWidth, this._labelHeight), 
                    this._updateRichTextPosition(), this._layoutDirty = !1;
                }
            }
        }, {
            key: "_getFirstWordLen",
            value: function _getFirstWordLen(text, startIndex, textLen) {
                var character = text.charAt(startIndex);
                if (isUnicodeCJK(character) || isUnicodeSpace(character)) return 1;
                for (var len = 1, index = startIndex + 1; index < textLen && (!isUnicodeSpace(character = text.charAt(index)) && !isUnicodeCJK(character)); ++index) len++;
                return len;
            }
        }, {
            key: "_updateRichTextPosition",
            value: function _updateRichTextPosition() {
                var nextTokenX = 0, nextLineIndex = 1, totalLineCount = this._lineCount, _iterator3 = this._labelSegments, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var label = _ref3, _lineCount = label.lineCount;
                    nextLineIndex < _lineCount && (nextTokenX = 0, nextLineIndex = _lineCount);
                    var lineOffsetX = 0;
                    switch (this.horizontalAlign) {
                      case exports.HorizontalTextAlignment.LEFT:
                        lineOffsetX = -this._labelWidth / 2;
                        break;

                      case exports.HorizontalTextAlignment.CENTER:
                        lineOffsetX = -this._linesWidth[_lineCount - 1] / 2;
                        break;

                      case exports.HorizontalTextAlignment.RIGHT:
                        lineOffsetX = this._labelWidth / 2 - this._linesWidth[_lineCount - 1];
                    }
                    var labelSize = label.node.getContentSize(), pos = label.node.getPosition();
                    label.node.setPosition(nextTokenX + lineOffsetX, this.lineHeight * (totalLineCount - _lineCount) - this._labelHeight / 2, pos.x), 
                    _lineCount === nextLineIndex && (nextTokenX += labelSize.width);
                }
            }
        }, {
            key: "_convertLiteralColorValue",
            value: function _convertLiteralColorValue(color) {
                var colorValue = color.toUpperCase();
                return Color[colorValue] ? Color[colorValue] : new Color().fromHEX(color);
            }
        }, {
            key: "_applyTextAttribute",
            value: function _applyTextAttribute(labelSeg) {
                var labelComponent = labelSeg.node.getComponent(LabelComponent);
                if (labelComponent) {
                    var textStyle, index = labelSeg.styleIndex;
                    labelComponent.lineHeight = this.lineHeight, labelComponent.horizontalAlign = exports.HorizontalTextAlignment.LEFT, 
                    labelComponent.verticalAlign = exports.VerticalTextAlignment.CENTER, this._textArray[index] && (textStyle = this._textArray[index].style);
                    var labelComp = labelSeg.node.getComponent(LabelComponent);
                    if (labelComp && (textStyle && textStyle.color ? labelComp.color = this._convertLiteralColorValue(textStyle.color) : labelComp.color = this._convertLiteralColorValue("white")), 
                    labelComponent.isBold = !(!textStyle || !textStyle.bold), labelComponent.isItalic = !(!textStyle || !textStyle.italic), 
                    labelComponent.isUnderline = !(!textStyle || !textStyle.underline), textStyle && textStyle.outline) {
                        var labelOutlineComponent = labelSeg.node.getComponent(LabelOutlineComponent);
                        labelOutlineComponent || (labelOutlineComponent = labelSeg.node.addComponent(LabelOutlineComponent)), 
                        labelOutlineComponent.color = this._convertLiteralColorValue(textStyle.outline.color), 
                        labelOutlineComponent.width = textStyle.outline.width;
                    }
                    if (textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this._fontSize, 
                    labelComponent.updateRenderData(!0), textStyle && textStyle.event) {
                        var c = "click";
                        textStyle.event[c] && (labelSeg.clickHandler = textStyle.event[c]);
                    }
                }
            }
        } ]), RichTextComponent;
    }(), _class3$t.HorizontalAlign = exports.HorizontalTextAlignment, _class3$t.VerticalAlign = exports.VerticalTextAlignment, 
    _applyDecoratedDescriptor((_class2$1c = _temp$1k).prototype, "string", [ _dec4$D ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "string"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "horizontalAlign", [ _dec5$y ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "horizontalAlign"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "fontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "fontSize"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "font", [ _dec6$u ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "font"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "maxWidth", [ property ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "maxWidth"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "lineHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "lineHeight"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "imageAtlas", [ _dec7$m ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "imageAtlas"), _class2$1c.prototype), 
    _applyDecoratedDescriptor(_class2$1c.prototype, "handleTouchEvent", [ property ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "handleTouchEvent"), _class2$1c.prototype), 
    _descriptor$1b = _applyDecoratedDescriptor(_class2$1c.prototype, "_lineHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor2$Z = _applyDecoratedDescriptor(_class2$1c.prototype, "_string", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "<color=#00ff00>Rich</c><color=#0fffff>Text</color>";
        }
    }), _descriptor3$L = _applyDecoratedDescriptor(_class2$1c.prototype, "_horizontalAlign", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return exports.HorizontalTextAlignment.LEFT;
        }
    }), _descriptor4$E = _applyDecoratedDescriptor(_class2$1c.prototype, "_fontSize", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 40;
        }
    }), _descriptor5$y = _applyDecoratedDescriptor(_class2$1c.prototype, "_maxWidth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$q = _applyDecoratedDescriptor(_class2$1c.prototype, "_font", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor7$l = _applyDecoratedDescriptor(_class2$1c.prototype, "_imageAtlas", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor8$h = _applyDecoratedDescriptor(_class2$1c.prototype, "_handleTouchEvent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _class$1p = _class2$1c)) || _class$1p) || _class$1p) || _class$1p) || _class$1p);
    cc.RichTextComponent = RichTextComponent;
    var Direction, ZERO = new Vec3(), _tempPos_1 = new Vec3(), _tempPos_2 = new Vec3(), defaultAnchor = new Vec2(), _tempColor = new Color();
    !function(Direction) {
        Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
    }(Direction || (Direction = {})), ccenum(Direction);
    var _class$1r, ScrollBarComponent = (_dec$1n = ccclass("cc.ScrollBarComponent"), 
    _dec2$11 = executionOrder(110), _dec3$O = menu("UI/ScrollBar"), _dec4$E = property({
        type: SpriteComponent
    }), _dec5$z = property({
        type: Direction
    }), _dec$1n(_class$1q = _dec2$11(_class$1q = _dec3$O((_temp$1l = _class3$u = function(_Component) {
        function ScrollBarComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ScrollBarComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_scrollView", _descriptor$1c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_handle", _descriptor2$_, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_direction", _descriptor3$M, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$F, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$z, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._touching = !1, _this._opacity = 255, _this._autoHideRemainingTime = 0, _this;
        }
        return _inherits(ScrollBarComponent, Component), _createClass(ScrollBarComponent, [ {
            key: "hide",
            value: function hide() {
                this._autoHideRemainingTime = 0, this._setOpacity(0);
            }
        }, {
            key: "show",
            value: function show() {
                this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity);
            }
        }, {
            key: "onScroll",
            value: function onScroll(outOfBoundary) {
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize(), barSize = this.node.getContentSize();
                        if (!this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                            this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                            var contentMeasure = 0, scrollViewMeasure = 0, outOfBoundaryValue = 0, contentPosition = 0, handleNodeMeasure = 0;
                            this._direction === Direction.HORIZONTAL ? (contentMeasure = contentSize.width, 
                            scrollViewMeasure = scrollViewSize.width, handleNodeMeasure = barSize.width, outOfBoundaryValue = outOfBoundary.x, 
                            contentPosition = -this._convertToScrollViewSpace(content).x) : this._direction === Direction.VERTICAL && (contentMeasure = contentSize.height, 
                            scrollViewMeasure = scrollViewSize.height, handleNodeMeasure = barSize.height, outOfBoundaryValue = outOfBoundary.y, 
                            contentPosition = -this._convertToScrollViewSpace(content).y);
                            var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue), position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
                            this._updateLength(length), this._updateHanlderPosition(position);
                        }
                    }
                }
            }
        }, {
            key: "setScrollView",
            value: function setScrollView(scrollView) {
                this._scrollView = scrollView;
            }
        }, {
            key: "onTouchBegan",
            value: function onTouchBegan() {
                this._enableAutoHide && (this._touching = !0);
            }
        }, {
            key: "onTouchEnded",
            value: function onTouchEnded() {
                if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
                    if (this._scrollView) {
                        var content = this._scrollView.content;
                        if (content) {
                            var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize();
                            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
                        }
                    }
                    this._autoHideRemainingTime = this._autoHideTime;
                }
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                var renderComp = this.node.getComponent(SpriteComponent);
                renderComp && (this._opacity = renderComp.color.a);
            }
        }, {
            key: "start",
            value: function start() {
                this._enableAutoHide && this._setOpacity(0);
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._processAutoHide(dt);
            }
        }, {
            key: "_convertToScrollViewSpace",
            value: function _convertToScrollViewSpace(content) {
                if (!this._scrollView) return ZERO;
                var ap = content.getAnchorPoint(), contentSize = content.getContentSize(), scrollViewSpacePos = new Vec3(-ap.x * contentSize.width, -ap.y * contentSize.height, 0);
                return content.uiTransfromComp.convertToWorldSpaceAR(scrollViewSpacePos, scrollViewSpacePos), 
                ap = this._scrollView.node.getAnchorPoint(), contentSize = this._scrollView.node.getContentSize(), 
                scrollViewSpacePos.x += ap.x * contentSize.width, scrollViewSpacePos.y += ap.y * contentSize.height, 
                this._scrollView.node.uiTransfromComp.convertToNodeSpaceAR(scrollViewSpacePos, scrollViewSpacePos), 
                scrollViewSpacePos;
            }
        }, {
            key: "_setOpacity",
            value: function _setOpacity(opacity) {
                if (this._handle) {
                    var renderComp = this.node.getComponent(SpriteComponent);
                    renderComp && (_tempColor.set(renderComp.color), _tempColor.a = opacity, renderComp.color = _tempColor), 
                    (renderComp = this._handle.getComponent(SpriteComponent)) && (_tempColor.set(renderComp.color), 
                    _tempColor.a = opacity, renderComp.color = _tempColor);
                }
            }
        }, {
            key: "_updateHanlderPosition",
            value: function _updateHanlderPosition(position) {
                if (this._handle) {
                    var oldPosition = this._fixupHandlerPosition();
                    this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
                }
            }
        }, {
            key: "_fixupHandlerPosition",
            value: function _fixupHandlerPosition() {
                var barSize = this.node.getContentSize(), barAnchor = this.node.getAnchorPoint(), handleSize = this.handle.node.getContentSize(), handleParent = this.handle.node.parent;
                vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
                var leftBottomWorldPosition = this.node.uiTransfromComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2), fixupPosition = new Vec3();
                return handleParent.uiTransfromComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition), 
                this.direction === Direction.HORIZONTAL ? fixupPosition = new Vec3(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, 0) : this.direction === Direction.VERTICAL && (fixupPosition = new Vec3(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, 0)), 
                this.handle.node.setPosition(fixupPosition), fixupPosition;
            }
        }, {
            key: "_conditionalDisableScrollBar",
            value: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
                return contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL || contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL;
            }
        }, {
            key: "_calculateLength",
            value: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                var denominatorValue = contentMeasure;
                return outOfBoundary && (denominatorValue += 20 * (0 < outOfBoundary ? outOfBoundary : -outOfBoundary)), 
                handleNodeMeasure * (scrollViewMeasure / denominatorValue);
            }
        }, {
            key: "_calculatePosition",
            value: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                var denominatorValue = contentMeasure - scrollViewMeasure;
                outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
                var positionRatio = 0;
                denominatorValue && (positionRatio = clamp01$1(positionRatio = contentPosition / denominatorValue));
                var position = (handleNodeMeasure - actualLenth) * positionRatio;
                return this._direction === Direction.VERTICAL ? new Vec3(0, position, 0) : new Vec3(position, 0, 0);
            }
        }, {
            key: "_updateLength",
            value: function _updateLength(length) {
                if (this._handle) {
                    var handleNode = this._handle.node, handleNodeSize = handleNode.getContentSize(), anchor = handleNode.getAnchorPoint();
                    anchor.x === defaultAnchor.x && anchor.y === defaultAnchor.y || handleNode.setAnchorPoint(defaultAnchor), 
                    this._direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
                }
            }
        }, {
            key: "_processAutoHide",
            value: function _processAutoHide(deltaTime) {
                if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= deltaTime, 
                this._autoHideRemainingTime <= this._autoHideTime)) {
                    this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                    var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
                    this._setOpacity(opacity);
                }
            }
        }, {
            key: "handle",
            get: function get() {
                return this._handle;
            },
            set: function set(value) {
                this._handle !== value && (this._handle = value, this.onScroll(cc.v2(0, 0)));
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction !== value && (this._direction = value, this.onScroll(new Vec3()));
            }
        }, {
            key: "enableAutoHide",
            get: function get() {
                return this._enableAutoHide;
            },
            set: function set(value) {
                this._enableAutoHide !== value && (this._enableAutoHide = value, this._enableAutoHide && this._setOpacity(0));
            }
        }, {
            key: "autoHideTime",
            get: function get() {
                return this._autoHideTime;
            },
            set: function set(value) {
                this._autoHideTime !== value && (this._autoHideTime = value);
            }
        } ]), ScrollBarComponent;
    }(), _class3$u.Direction = Direction, _applyDecoratedDescriptor((_class2$1d = _temp$1l).prototype, "handle", [ _dec4$E ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "handle"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "direction", [ _dec5$z ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "direction"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "enableAutoHide", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "enableAutoHide"), _class2$1d.prototype), 
    _applyDecoratedDescriptor(_class2$1d.prototype, "autoHideTime", [ property ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "autoHideTime"), _class2$1d.prototype), 
    _descriptor$1c = _applyDecoratedDescriptor(_class2$1d.prototype, "_scrollView", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor2$_ = _applyDecoratedDescriptor(_class2$1d.prototype, "_handle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$M = _applyDecoratedDescriptor(_class2$1d.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Direction.HORIZONTAL;
        }
    }), _descriptor4$F = _applyDecoratedDescriptor(_class2$1d.prototype, "_enableAutoHide", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _descriptor5$z = _applyDecoratedDescriptor(_class2$1d.prototype, "_autoHideTime", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _class$1q = _class2$1d)) || _class$1q) || _class$1q) || _class$1q);
    cc.ScrollBarComponent = ScrollBarComponent;
    var _dec$1p, _dec2$13, _dec3$P, _dec4$F, _dec5$A, _dec6$v, _dec7$n, _dec8$g, _dec9$f, _class$1s, _class2$1e, _descriptor$1d, _descriptor2$10, _descriptor3$N, _descriptor4$G, _descriptor5$A, _descriptor6$r, _descriptor7$m, _descriptor8$i, _descriptor9$e, _descriptor10$b, _descriptor11$a, _class3$v, _temp$1m, ViewGroupComponent = ccclass("cc.ViewGroupComponent")(_class$1r = executionOrder(110)(_class$1r = function(_Component) {
        function ViewGroupComponent() {
            return _classCallCheck(this, ViewGroupComponent), _possibleConstructorReturn(this, _getPrototypeOf(ViewGroupComponent).apply(this, arguments));
        }
        return _inherits(ViewGroupComponent, Component), ViewGroupComponent;
    }()) || _class$1r) || _class$1r;
    cc.ViewGroupComponent = ViewGroupComponent;
    var EventType$1, NodeEvent$1 = Node$1.EventType, ZERO$1 = new Vec3(), _tempPos$1 = new Vec3(), getTimeInMilliseconds = function getTimeInMilliseconds() {
        return new Date().getMilliseconds();
    };
    !function(EventType) {
        EventType[EventType.SCROLL_TO_TOP = 0] = "SCROLL_TO_TOP", EventType[EventType.SCROLL_TO_BOTTOM = 1] = "SCROLL_TO_BOTTOM", 
        EventType[EventType.SCROLL_TO_LEFT = 2] = "SCROLL_TO_LEFT", EventType[EventType.SCROLL_TO_RIGHT = 3] = "SCROLL_TO_RIGHT", 
        EventType[EventType.SCROLLING = 4] = "SCROLLING", EventType[EventType.BOUNCE_TOP = 5] = "BOUNCE_TOP", 
        EventType[EventType.BOUNCE_BOTTOM = 6] = "BOUNCE_BOTTOM", EventType[EventType.BOUNCE_LEFT = 7] = "BOUNCE_LEFT", 
        EventType[EventType.BOUNCE_RIGHT = 8] = "BOUNCE_RIGHT", EventType[EventType.SCROLL_ENDED = 9] = "SCROLL_ENDED", 
        EventType[EventType.TOUCH_UP = 10] = "TOUCH_UP", EventType[EventType.AUTOSCROLL_ENDED_WITH_THRESHOLD = 11] = "AUTOSCROLL_ENDED_WITH_THRESHOLD", 
        EventType[EventType.SCROLL_BEGAN = 12] = "SCROLL_BEGAN";
    }(EventType$1 || (EventType$1 = {})), ccenum(EventType$1);
    var _dec$1q, _dec2$14, _dec3$Q, _dec4$G, _dec5$B, _dec6$w, _dec7$o, _class$1t, _class2$1f, _descriptor$1e, _descriptor2$11, _descriptor3$O, _descriptor4$H, _class3$w, _temp$1n, eventMap = {
        "scroll-to-top": EventType$1.SCROLL_TO_TOP,
        "scroll-to-bottom": EventType$1.SCROLL_TO_BOTTOM,
        "scroll-to-left": EventType$1.SCROLL_TO_LEFT,
        "scroll-to-right": EventType$1.SCROLL_TO_RIGHT,
        scrolling: EventType$1.SCROLLING,
        "bounce-bottom": EventType$1.BOUNCE_BOTTOM,
        "bounce-left": EventType$1.BOUNCE_LEFT,
        "bounce-right": EventType$1.BOUNCE_RIGHT,
        "bounce-top": EventType$1.BOUNCE_TOP,
        "scroll-ended": EventType$1.SCROLL_ENDED,
        "touch-up": EventType$1.TOUCH_UP,
        "scroll-ended-with-threshold": EventType$1.AUTOSCROLL_ENDED_WITH_THRESHOLD,
        "scroll-began": EventType$1.SCROLL_BEGAN
    }, ScrollViewComponent = (_dec$1p = ccclass("cc.ScrollViewComponent"), _dec2$13 = executionOrder(110), 
    _dec3$P = menu("UI/ScrollView"), _dec4$F = property({
        type: Node$1
    }), _dec5$A = property({
        type: ScrollBarComponent
    }), _dec6$v = property({
        type: ScrollBarComponent
    }), _dec7$n = property({
        range: [ 0, 1, .1 ]
    }), _dec8$g = property({
        range: [ 0, 10 ]
    }), _dec9$f = property({
        type: EventHandler
    }), _dec$1p(_class$1s = _dec2$13(_class$1s = _dec3$P((_temp$1m = _class3$v = function(_ViewGroupComponent) {
        function ScrollViewComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ScrollViewComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "horizontal", _descriptor$1d, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "vertical", _descriptor2$10, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "inertia", _descriptor3$N, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "brake", _descriptor4$G, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "elastic", _descriptor5$A, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "bounceDuration", _descriptor6$r, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "scrollEvents", _descriptor7$m, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor8$i, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_content", _descriptor9$e, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._topBoundary = 0, _this._bottomBoundary = 0, _this._leftBoundary = 0, _this._rightBoundary = 0, 
            _this._touchMoveDisplacements = [], _this._touchMoveTimeDeltas = [], _this._touchMovePreviousTimestamp = 0, 
            _this._touchMoved = !1, _this._autoScrolling = !1, _this._autoScrollAttenuate = !1, 
            _this._autoScrollStartPosition = new Vec3(), _this._autoScrollTargetDelta = new Vec3(), 
            _this._autoScrollTotalTime = 0, _this._autoScrollAccumulatedTime = 0, _this._autoScrollCurrentlyOutOfBoundary = !1, 
            _this._autoScrollBraking = !1, _this._autoScrollBrakingStartPosition = new Vec3(), 
            _this._outOfBoundaryAmount = new Vec3(), _this._outOfBoundaryAmountDirty = !0, _this._stopMouseWheel = !1, 
            _this._mouseWheelEventElapsedTime = 0, _this._isScrollEndedWithThresholdEventFired = !1, 
            _this._scrollEventEmitMask = 0, _this._isBouncing = !1, _this._scrolling = !1, _this._contentPos = new Vec3(), 
            _this._deltaPos = new Vec3(), _this;
        }
        return _inherits(ScrollViewComponent, ViewGroupComponent), _createClass(ScrollViewComponent, [ {
            key: "scrollToBottom",
            value: function scrollToBottom(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 0),
                    applyToHorizontal: !1,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta, !0);
            }
        }, {
            key: "scrollToTop",
            value: function scrollToTop(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 1),
                    applyToHorizontal: !1,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToLeft",
            value: function scrollToLeft(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !1
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToRight",
            value: function scrollToRight(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(1, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !1
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToTopLeft",
            value: function scrollToTopLeft(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 1),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToTopRight",
            value: function scrollToTopRight(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(1, 1),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToBottomLeft",
            value: function scrollToBottomLeft(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToBottomRight",
            value: function scrollToBottomRight(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(1, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToOffset",
            value: function scrollToOffset(offset, timeInSecond, attenuated) {
                var maxScrollOffset = this.getMaxScrollOffset(), anchor = new Vec2(0, 0);
                0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x, 
                0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y, 
                this.scrollTo(anchor, timeInSecond, attenuated);
            }
        }, {
            key: "getScrollOffset",
            value: function getScrollOffset() {
                var topDelta = this._getContentTopBoundary() - this._topBoundary, leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                return new Vec3(leftDeta, topDelta, 0);
            }
        }, {
            key: "getMaxScrollOffset",
            value: function getMaxScrollOffset() {
                var scrollSize = this.node.getContentSize(), contentSize = this._content.getContentSize(), horizontalMaximizeOffset = contentSize.width - scrollSize.width, verticalMaximizeOffset = contentSize.height - scrollSize.height;
                return new Vec3(horizontalMaximizeOffset = 0 <= horizontalMaximizeOffset ? horizontalMaximizeOffset : 0, verticalMaximizeOffset = 0 <= verticalMaximizeOffset ? verticalMaximizeOffset : 0, 0);
            }
        }, {
            key: "scrollToPercentHorizontal",
            value: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(percent, 0),
                    applyToHorizontal: !0,
                    applyToVertical: !1
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollTo",
            value: function scrollTo(anchor, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(anchor),
                    applyToHorizontal: !0,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "scrollToPercentVertical",
            value: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: new Vec2(0, percent),
                    applyToHorizontal: !1,
                    applyToVertical: !0
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
            }
        }, {
            key: "stopAutoScroll",
            value: function stopAutoScroll() {
                this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
            }
        }, {
            key: "setContentPosition",
            value: function setContentPosition(position) {
                position.fuzzyEquals(this.getContentPosition(), 1e-4) || (this._content.setPosition(position), 
                this._outOfBoundaryAmountDirty = !0);
            }
        }, {
            key: "getContentPosition",
            value: function getContentPosition() {
                return this._content ? (this._content.getPosition(this._contentPos), this._contentPos) : ZERO$1;
            }
        }, {
            key: "isScrolling",
            value: function isScrolling() {
                return this._scrolling;
            }
        }, {
            key: "isAutoScrolling",
            value: function isAutoScrolling() {
                return this._autoScrolling;
            }
        }, {
            key: "getScrollEndedEventTiming",
            value: function getScrollEndedEventTiming() {
                return 1e-4;
            }
        }, {
            key: "start",
            value: function start() {
                this._calculateBoundary(), this._content && cc.director.once(cc.Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._registerEvent(), this.content && (this.content.on(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this), 
                this.content.on(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view && (this.view.on(NodeEvent$1.POSITION_PART, this._calculateBoundary, this), 
                this.view.on(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view.on(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this))), 
                this._showScrollbar();
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._autoScrolling && this._processAutoScrolling(dt);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._unregisterEvent(), this.content && (this.content.off(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this), 
                this.content.off(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view && (this.view.off(NodeEvent$1.POSITION_PART, this._calculateBoundary, this), 
                this.view.off(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view.off(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this))), 
                this._hideScrollbar(), this.stopAutoScroll();
            }
        }, {
            key: "_registerEvent",
            value: function _registerEvent() {
                this.node.on(NodeEvent$1.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(NodeEvent$1.TOUCH_MOVE, this._onTouchMoved, this, !0), 
                this.node.on(NodeEvent$1.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(NodeEvent$1.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
                this.node.on(NodeEvent$1.MOUSE_WHEEL, this._onMouseWheel, this, !0);
            }
        }, {
            key: "_unregisterEvent",
            value: function _unregisterEvent() {
                this.node.off(NodeEvent$1.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(NodeEvent$1.TOUCH_MOVE, this._onTouchMoved, this, !0), 
                this.node.off(NodeEvent$1.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(NodeEvent$1.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
                this.node.off(NodeEvent$1.MOUSE_WHEEL, this._onMouseWheel, this, !0);
            }
        }, {
            key: "_onMouseWheel",
            value: function _onMouseWheel(event, captureListeners) {
                if (this.enabledInHierarchy && !this._hasNestedViewGroup(event, captureListeners)) {
                    var deltaMove = new Vec3(), wheelPrecision = -.1;
                    0, this.vertical ? deltaMove = new Vec3(0, event.getScrollY() * wheelPrecision, 0) : this.horizontal && (deltaMove = new Vec3(event.getScrollY() * wheelPrecision, 0, 0)), 
                    this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(deltaMove), this._stopMouseWheel || (this._handlePressLogic(), 
                    this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), 
                    this._stopPropagationIfTargetIsMe(event);
                }
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event, captureListeners) {
                this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(event, captureListeners) || (this._content && this._handlePressLogic(), 
                this._touchMoved = !1, this._stopPropagationIfTargetIsMe(event)));
            }
        }, {
            key: "_onTouchMoved",
            value: function _onTouchMoved(event, captureListeners) {
                if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners) && event && event.touch) {
                    var touch = event.touch;
                    if (this._content && this._handleMoveLogic(touch), this.cancelInnerEvents) {
                        if (7 < touch.getUILocation().sub(touch.getStartLocation()).mag() && !this._touchMoved && event.target !== this.node) {
                            var cancelEvent = new EventTouch(event.getTouches(), event.bubbles);
                            cancelEvent.type = NodeEvent$1.TOUCH_CANCEL, cancelEvent.touch = event.touch, cancelEvent.simulate = !0, 
                            event.target.dispatchEvent(cancelEvent), this._touchMoved = !0;
                        }
                        this._stopPropagationIfTargetIsMe(event);
                    }
                }
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event, captureListeners) {
                if (this.enabledInHierarchy && this._content && event && !this._hasNestedViewGroup(event, captureListeners)) {
                    this._dispatchEvent("touch-up");
                    var touch = event.touch;
                    this._content && this._handleReleaseLogic(touch), this._touchMoved ? event.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(event);
                }
            }
        }, {
            key: "_onTouchCancelled",
            value: function _onTouchCancelled(event, captureListeners) {
                if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                    if (event && !event.simulate) {
                        var touch = event.touch;
                        this._content && this._handleReleaseLogic(touch);
                    }
                    this._stopPropagationIfTargetIsMe(event);
                }
            }
        }, {
            key: "_calculateBoundary",
            value: function _calculateBoundary() {
                if (this.content) {
                    var layout = this.content.getComponent(LayoutComponent);
                    layout && layout.enabledInHierarchy && layout.updateLayout();
                    var viewSize = this.view.getContentSize(), anchorX = viewSize.width * this.view.anchorX, anchorY = viewSize.height * this.view.anchorY;
                    this._leftBoundary = -anchorX, this._bottomBoundary = -anchorY, this._rightBoundary = this._leftBoundary + viewSize.width, 
                    this._topBoundary = this._bottomBoundary + viewSize.height, this._moveContentToTopLeft(viewSize);
                }
            }
        }, {
            key: "_hasNestedViewGroup",
            value: function _hasNestedViewGroup(event, captureListeners) {
                if (event && event.eventPhase === cc.Event.CAPTURING_PHASE) {
                    if (captureListeners) {
                        var _iterator = captureListeners, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            var item = _ref;
                            if (this.node === item) return !(!event.target || !event.target.getComponent(ViewGroupComponent));
                            if (item.getComponent(ViewGroupComponent)) return !0;
                        }
                    }
                    return !1;
                }
            }
        }, {
            key: "_startInertiaScroll",
            value: function _startInertiaScroll(touchMoveVelocity) {
                var inertiaTotalMovement = touchMoveVelocity.mul(.7);
                this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
            }
        }, {
            key: "_calculateAttenuatedFactor",
            value: function _calculateAttenuatedFactor(distance) {
                return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
            }
        }, {
            key: "_startAttenuatingAutoScroll",
            value: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
                var time = this._calculateAutoScrollTimeByInitalSpeed(initialVelocity.mag()), targetDelta = deltaMove.normalize(), contentSize = this._content.getContentSize(), scrollviewSize = this.node.getContentSize(), totalMoveWidth = contentSize.width - scrollviewSize.width, totalMoveHeight = contentSize.height - scrollviewSize.height, attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth), attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
                targetDelta = new Vec3(targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake), 0);
                var originalMoveLength = deltaMove.mag(), factor = targetDelta.mag() / originalMoveLength;
                targetDelta = targetDelta.add(deltaMove), 0 < this.brake && 7 < factor && (factor = Math.sqrt(factor), 
                targetDelta = deltaMove.mul(factor).add(deltaMove)), 0 < this.brake && 3 < factor && (time *= factor = 3), 
                0 === this.brake && 1 < factor && (time *= factor), this._startAutoScroll(targetDelta, time, !0);
            }
        }, {
            key: "_calculateAutoScrollTimeByInitalSpeed",
            value: function _calculateAutoScrollTimeByInitalSpeed(initalSpeed) {
                return Math.sqrt(Math.sqrt(initalSpeed / 5));
            }
        }, {
            key: "_startAutoScroll",
            value: function _startAutoScroll(deltaMove, timeInSecond) {
                var attenuated = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
                this._autoScrolling = !0, this._autoScrollTargetDelta = adjustedDeltaMove, this._autoScrollAttenuate = attenuated, 
                vec3.copy(this._autoScrollStartPosition, this.getContentPosition()), this._autoScrollTotalTime = timeInSecond, 
                this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, 
                this._autoScrollBrakingStartPosition = new Vec3(), this._getHowMuchOutOfBoundary().fuzzyEquals(ZERO$1, 1e-4) || (this._autoScrollCurrentlyOutOfBoundary = !0);
            }
        }, {
            key: "_calculateTouchMoveVelocity",
            value: function _calculateTouchMoveVelocity() {
                var totalTime = 0;
                if ((totalTime = this._touchMoveTimeDeltas.reduce(function(a, b) {
                    return a + b;
                }, totalTime)) <= 0 || .5 <= totalTime) return new Vec3();
                var totalMovement = new Vec3();
                return totalMovement = this._touchMoveDisplacements.reduce(function(a, b) {
                    return a.add(b);
                }, totalMovement), new Vec3(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, 0);
            }
        }, {
            key: "_flattenVectorByDirection",
            value: function _flattenVectorByDirection(vector) {
                var result = vector;
                return result.x = this.horizontal ? result.x : 0, result.y = this.vertical ? result.y : 0, 
                result;
            }
        }, {
            key: "_moveContent",
            value: function _moveContent(deltaMove, canStartBounceBack) {
                var adjustedMove = this._flattenVectorByDirection(deltaMove);
                this.getContentPosition().add(adjustedMove, _tempPos$1), this.setContentPosition(_tempPos$1);
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                this._updateScrollBar(outOfBoundary), this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
            }
        }, {
            key: "_getContentLeftBoundary",
            value: function _getContentLeftBoundary() {
                return this.getContentPosition().x - this._content.getAnchorPoint().x * this._content.getContentSize().width;
            }
        }, {
            key: "_getContentRightBoundary",
            value: function _getContentRightBoundary() {
                var contentSize = this._content.getContentSize();
                return this._getContentLeftBoundary() + contentSize.width;
            }
        }, {
            key: "_getContentTopBoundary",
            value: function _getContentTopBoundary() {
                var contentSize = this._content.getContentSize();
                return this._getContentBottomBoundary() + contentSize.height;
            }
        }, {
            key: "_getContentBottomBoundary",
            value: function _getContentBottomBoundary() {
                return this.getContentPosition().y - this._content.getAnchorPoint().y * this._content.getContentSize().height;
            }
        }, {
            key: "_getHowMuchOutOfBoundary",
            value: function _getHowMuchOutOfBoundary(addition) {
                if ((addition = addition || new Vec3()).fuzzyEquals(ZERO$1, 1e-4) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
                var outOfBoundaryAmount = new Vec3();
                return this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x)), 
                this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y)), 
                addition.fuzzyEquals(ZERO$1, 1e-4) && (this._outOfBoundaryAmount = outOfBoundaryAmount, 
                this._outOfBoundaryAmountDirty = !1), outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
            }
        }, {
            key: "_updateScrollBar",
            value: function _updateScrollBar(outOfBoundary) {
                this._horizontalScrollBar && this._horizontalScrollBar.onScroll(outOfBoundary), 
                this.verticalScrollBar && this.verticalScrollBar.onScroll(outOfBoundary);
            }
        }, {
            key: "_onScrollBarTouchBegan",
            value: function _onScrollBarTouchBegan() {
                this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan();
            }
        }, {
            key: "_onScrollBarTouchEnded",
            value: function _onScrollBarTouchEnded() {
                this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded();
            }
        }, {
            key: "_dispatchEvent",
            value: function _dispatchEvent(event) {
                if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
                    var flag = 1 << eventMap[event];
                    if (this._scrollEventEmitMask & flag) return;
                    this._scrollEventEmitMask |= flag;
                }
                cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]), 
                this.node.emit(event, this);
            }
        }, {
            key: "_adjustContentOutOfBoundary",
            value: function _adjustContentOutOfBoundary() {
                if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
                    var outOfBoundary = this._getHowMuchOutOfBoundary(new Vec3()), newPosition = this.getContentPosition().add(outOfBoundary);
                    this._content && (this._content.setPosition(newPosition), this._updateScrollBar(ZERO$1));
                }
            }
        }, {
            key: "_hideScrollbar",
            value: function _hideScrollbar() {
                this._horizontalScrollBar && this._horizontalScrollBar.hide(), this.verticalScrollBar && this.verticalScrollBar.hide();
            }
        }, {
            key: "_showScrollbar",
            value: function _showScrollbar() {
                this._horizontalScrollBar && this._horizontalScrollBar.show(), this.verticalScrollBar && this.verticalScrollBar.show();
            }
        }, {
            key: "_stopPropagationIfTargetIsMe",
            value: function _stopPropagationIfTargetIsMe(event) {
                event && event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && (event.propagationStopped = !0);
            }
        }, {
            key: "_processDeltaMove",
            value: function _processDeltaMove(deltaMove) {
                this._scrollChildren(deltaMove), this._gatherTouchMove(deltaMove);
            }
        }, {
            key: "_handleMoveLogic",
            value: function _handleMoveLogic(touch) {
                var delta = touch.getUIDelta();
                vec3.set(this._deltaPos, delta.x, delta.y, 0), this._processDeltaMove(this._deltaPos);
            }
        }, {
            key: "_scrollChildren",
            value: function _scrollChildren(deltaMove) {
                var outOfBoundary, realMove = deltaMove = this._clampDelta(deltaMove);
                this.elastic && (outOfBoundary = this._getHowMuchOutOfBoundary(), realMove.x *= 0 === outOfBoundary.x ? 1 : .5, 
                realMove.y *= 0 === outOfBoundary.y ? 1 : .5), this.elastic || (outOfBoundary = this._getHowMuchOutOfBoundary(realMove), 
                realMove = realMove.add(outOfBoundary));
                var scrollEventType = "", pos = new Vec3();
                if (this._content.getPosition(pos), 0 < realMove.y) pos.y - this._content.anchorY * this._content.height + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom"); else if (realMove.y < 0) {
                    pos.y - this._content.anchorY * this._content.height + this._content.height + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
                } else if (realMove.x < 0) {
                    pos.x - this._content.anchorX * this._content.width + this._content.width + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
                } else if (0 < realMove.x) {
                    pos.x - this._content.anchorX * this._content.width + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
                }
                this._moveContent(realMove, !1), 0 === realMove.x && 0 === realMove.y || (this._scrolling || (this._scrolling = !0, 
                this._dispatchEvent("scroll-began")), this._dispatchEvent("scrolling")), 0 < scrollEventType.length && this._dispatchEvent(scrollEventType);
            }
        }, {
            key: "_handlePressLogic",
            value: function _handlePressLogic() {
                this._autoScrolling && this._dispatchEvent("scroll-ended"), this._autoScrolling = !1, 
                this._isBouncing = !1, this._touchMovePreviousTimestamp = getTimeInMilliseconds(), 
                this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan();
            }
        }, {
            key: "_clampDelta",
            value: function _clampDelta(delta) {
                var contentSize = this._content.getContentSize(), scrollViewSize = this.node.getContentSize();
                return contentSize.width < scrollViewSize.width && (delta.x = 0), contentSize.height < scrollViewSize.height && (delta.y = 0), 
                delta;
            }
        }, {
            key: "_gatherTouchMove",
            value: function _gatherTouchMove(delta) {
                for (delta = this._clampDelta(delta); 5 <= this._touchMoveDisplacements.length; ) this._touchMoveDisplacements.shift(), 
                this._touchMoveTimeDeltas.shift();
                this._touchMoveDisplacements.push(delta);
                var timeStamp = getTimeInMilliseconds();
                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3), 
                this._touchMovePreviousTimestamp = timeStamp;
            }
        }, {
            key: "_startBounceBackIfNeeded",
            value: function _startBounceBackIfNeeded() {
                if (!this.elastic) return !1;
                var bounceBackAmount = this._getHowMuchOutOfBoundary();
                if ((bounceBackAmount = this._clampDelta(bounceBackAmount)).fuzzyEquals(_tempPos$1, 1e-4)) return !1;
                var bounceBackTime = Math.max(this.bounceDuration, 0);
                return this._startAutoScroll(bounceBackAmount, bounceBackTime, !0), this._isBouncing || (0 < bounceBackAmount.y && this._dispatchEvent("bounce-top"), 
                bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom"), 0 < bounceBackAmount.x && this._dispatchEvent("bounce-right"), 
                bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left"), this._isBouncing = !0), 
                !0;
            }
        }, {
            key: "_processInertiaScroll",
            value: function _processInertiaScroll() {
                if (!this._startBounceBackIfNeeded() && this.inertia) {
                    var touchMoveVelocity = this._calculateTouchMoveVelocity();
                    !touchMoveVelocity.fuzzyEquals(_tempPos$1, 1e-4) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
                }
                this._onScrollBarTouchEnded();
            }
        }, {
            key: "_handleReleaseLogic",
            value: function _handleReleaseLogic(touch) {
                var delta = touch.getUIDelta();
                vec3.set(this._deltaPos, delta.x, delta.y, 0), this._gatherTouchMove(this._deltaPos), 
                this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent("scroll-ended"));
            }
        }, {
            key: "_isOutOfBoundary",
            value: function _isOutOfBoundary() {
                return !this._getHowMuchOutOfBoundary().fuzzyEquals(ZERO$1, 1e-4);
            }
        }, {
            key: "_isNecessaryAutoScrollBrake",
            value: function _isNecessaryAutoScrollBrake() {
                if (this._autoScrollBraking) return !0;
                if (this._isOutOfBoundary()) {
                    if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, 
                    this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = this.getContentPosition(), 
                    !0;
                } else this._autoScrollCurrentlyOutOfBoundary = !1;
                return !1;
            }
        }, {
            key: "_processAutoScrolling",
            value: function _processAutoScrolling(dt) {
                var isAutoScrollBrake = this._isNecessaryAutoScrollBrake(), brakingFactor = isAutoScrollBrake ? .05 : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
                this._autoScrollAttenuate && (percentage = function quintEaseOut(time) {
                    return (time -= 1) * time * time * time * time + 1;
                }(percentage));
                var newPosition = this._autoScrollStartPosition.add(this._autoScrollTargetDelta.mul(percentage)), reachedEnd = Math.abs(percentage - 1) <= 1e-4;
                if (Math.abs(percentage - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent("scroll-ended-with-threshold"), 
                this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
                    var brakeOffsetPosition = newPosition.sub(this._autoScrollBrakingStartPosition);
                    isAutoScrollBrake && (brakeOffsetPosition = brakeOffsetPosition.mul(brakingFactor)), 
                    newPosition = this._autoScrollBrakingStartPosition.add(brakeOffsetPosition);
                } else {
                    var moveDelta = newPosition.sub(this.getContentPosition()), outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                    outOfBoundary.fuzzyEquals(ZERO$1, 1e-4) || (newPosition = newPosition.add(outOfBoundary), 
                    reachedEnd = !0);
                }
                reachedEnd && (this._autoScrolling = !1);
                var deltaMove = newPosition.sub(this.getContentPosition());
                this._moveContent(this._clampDelta(deltaMove), reachedEnd), this._dispatchEvent("scrolling"), 
                this._autoScrolling || (this._isBouncing = !1, this._scrolling = !1, this._dispatchEvent("scroll-ended"));
            }
        }, {
            key: "_checkMouseWheel",
            value: function _checkMouseWheel(dt) {
                if (!this._getHowMuchOutOfBoundary().fuzzyEquals(ZERO$1, 1e-4)) return this._processInertiaScroll(), 
                this.unschedule(this._checkMouseWheel), void (this._stopMouseWheel = !1);
                this._mouseWheelEventElapsedTime += dt, .1 < this._mouseWheelEventElapsedTime && (this._onScrollBarTouchEnded(), 
                this.unschedule(this._checkMouseWheel), this._stopMouseWheel = !1);
            }
        }, {
            key: "_calculateMovePercentDelta",
            value: function _calculateMovePercentDelta(options) {
                var anchor = options.anchor, applyToHorizontal = options.applyToHorizontal, applyToVertical = options.applyToVertical;
                this._calculateBoundary(), anchor = anchor.clampf(new Vec2(0, 0), new Vec2(1, 1));
                var scrollSize = this.node.getContentSize(), contentSize = this._content.getContentSize(), bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
                bottomDeta = -bottomDeta;
                var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                leftDeta = -leftDeta;
                var moveDelta = new Vec3(), totalScrollDelta = 0;
                return applyToHorizontal && (totalScrollDelta = contentSize.width - scrollSize.width, 
                moveDelta.x = leftDeta - totalScrollDelta * anchor.x), applyToVertical && (totalScrollDelta = contentSize.height - scrollSize.height, 
                moveDelta.y = bottomDeta - totalScrollDelta * anchor.y), moveDelta;
            }
        }, {
            key: "_moveContentToTopLeft",
            value: function _moveContentToTopLeft(scrollViewSize) {
                var contentSize = this._content.getContentSize(), bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
                bottomDeta = -bottomDeta;
                var moveDelta = new Vec3(), totalScrollDelta = 0, leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                leftDeta = -leftDeta, contentSize.height < scrollViewSize.height ? (totalScrollDelta = contentSize.height - scrollViewSize.height, 
                moveDelta.y = bottomDeta - totalScrollDelta, this.verticalScrollBar && this.verticalScrollBar.hide()) : this.verticalScrollBar && this.verticalScrollBar.show(), 
                contentSize.width < scrollViewSize.width ? (totalScrollDelta = contentSize.width - scrollViewSize.width, 
                moveDelta.x = leftDeta, this._horizontalScrollBar && this._horizontalScrollBar.hide()) : this._horizontalScrollBar && this._horizontalScrollBar.show(), 
                this._moveContent(moveDelta), this._adjustContentOutOfBoundary();
            }
        }, {
            key: "content",
            get: function get() {
                return this._content;
            },
            set: function set(value) {
                this._content !== value && (this._content = value, this._calculateBoundary());
            }
        }, {
            key: "horizontalScrollBar",
            get: function get() {
                return this._horizontalScrollBar;
            },
            set: function set(value) {
                this._horizontalScrollBar !== value && (this._horizontalScrollBar = value, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), 
                this._updateScrollBar(ZERO$1)));
            }
        }, {
            key: "verticalScrollBar",
            get: function get() {
                return this._verticalScrollBar;
            },
            set: function set(value) {
                this._verticalScrollBar !== value && (this._verticalScrollBar = value, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), 
                this._updateScrollBar(ZERO$1)));
            }
        }, {
            key: "view",
            get: function get() {
                return this._content ? this._content.parent : null;
            }
        } ]), ScrollViewComponent;
    }(), _class3$v.EventType = EventType$1, _applyDecoratedDescriptor((_class2$1e = _temp$1m).prototype, "content", [ _dec4$F ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "content"), _class2$1e.prototype), 
    _applyDecoratedDescriptor(_class2$1e.prototype, "horizontalScrollBar", [ _dec5$A ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "horizontalScrollBar"), _class2$1e.prototype), 
    _applyDecoratedDescriptor(_class2$1e.prototype, "verticalScrollBar", [ _dec6$v ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "verticalScrollBar"), _class2$1e.prototype), 
    _descriptor$1d = _applyDecoratedDescriptor(_class2$1e.prototype, "horizontal", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor2$10 = _applyDecoratedDescriptor(_class2$1e.prototype, "vertical", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$N = _applyDecoratedDescriptor(_class2$1e.prototype, "inertia", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor4$G = _applyDecoratedDescriptor(_class2$1e.prototype, "brake", [ _dec7$n ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .5;
        }
    }), _descriptor5$A = _applyDecoratedDescriptor(_class2$1e.prototype, "elastic", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor6$r = _applyDecoratedDescriptor(_class2$1e.prototype, "bounceDuration", [ _dec8$g ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 1;
        }
    }), _descriptor7$m = _applyDecoratedDescriptor(_class2$1e.prototype, "scrollEvents", [ _dec9$f ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor8$i = _applyDecoratedDescriptor(_class2$1e.prototype, "cancelInnerEvents", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor9$e = _applyDecoratedDescriptor(_class2$1e.prototype, "_content", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor10$b = _applyDecoratedDescriptor(_class2$1e.prototype, "_horizontalScrollBar", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor11$a = _applyDecoratedDescriptor(_class2$1e.prototype, "_verticalScrollBar", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1s = _class2$1e)) || _class$1s) || _class$1s) || _class$1s);
    cc.ScrollViewComponent = ScrollViewComponent;
    var Direction$1, _tempPos$2 = new Vec3();
    !function(Direction) {
        Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
    }(Direction$1 || (Direction$1 = {})), ccenum(Direction$1);
    var _dec$1r, _dec2$15, _dec3$R, _dec4$H, _class$1u, _class2$1g, _descriptor$1f, _descriptor2$12, SliderComponent = (_dec$1q = ccclass("cc.SliderComponent"), 
    _dec2$14 = executionOrder(110), _dec3$Q = menu("UI/Slider"), _dec4$G = property({
        type: SpriteComponent
    }), _dec5$B = property({
        type: Direction$1
    }), _dec6$w = property({
        slide: !0,
        range: [ 0, 1, .01 ]
    }), _dec7$o = property({
        type: EventHandler
    }), _dec$1q(_class$1t = _dec2$14(_class$1t = _dec3$Q((_temp$1n = _class3$w = function(_Component) {
        function SliderComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, SliderComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SliderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "slideEvents", _descriptor$1e, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_handle", _descriptor2$11, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_direction", _descriptor3$O, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_progress", _descriptor4$H, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._offset = new Vec3(), _this._dragging = !1, _this._touchHandle = !1, _this._handlelocalPos = new Vec3(), 
            _this._touchPos = new Vec3(), _this;
        }
        return _inherits(SliderComponent, Component), _createClass(SliderComponent, [ {
            key: "__preload",
            value: function __preload() {
                this._updateHandlePosition();
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._updateHandlePosition(), this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), 
                this.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), 
                this.node.on(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
                this._handle && this._handle.isValid && (this._handle.node.on(exports.SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
                this._handle.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                this._handle.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this));
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.off(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
                this._handle && this._handle.isValid && (this._handle.node.off(exports.SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
                this._handle.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
                this._handle.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this));
            }
        }, {
            key: "_onHandleDragStart",
            value: function _onHandleDragStart(event) {
                if (event && this._handle && this._handle.node.uiTransfromComp) {
                    this._dragging = !0, this._touchHandle = !0;
                    var touhPos = event.touch.getUILocation();
                    vec3.set(this._touchPos, touhPos.x, touhPos.y, 0), this._handle.node.uiTransfromComp.convertToNodeSpaceAR(this._touchPos, this._offset), 
                    event.propagationStopped = !0;
                }
            }
        }, {
            key: "_onTouchBegan",
            value: function _onTouchBegan(event) {
                this._handle && event && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(event.touch), 
                event.propagationStopped = !0);
            }
        }, {
            key: "_onTouchMoved",
            value: function _onTouchMoved(event) {
                this._dragging && event && (this._handleSliderLogic(event.touch), event.propagationStopped = !0);
            }
        }, {
            key: "_onTouchEnded",
            value: function _onTouchEnded(event) {
                this._dragging = !1, this._touchHandle = !1, this._offset = cc.v2(), event && (event.propagationStopped = !0);
            }
        }, {
            key: "_onTouchCancelled",
            value: function _onTouchCancelled(event) {
                this._dragging = !1, event && (event.propagationStopped = !0);
            }
        }, {
            key: "_handleSliderLogic",
            value: function _handleSliderLogic(touch) {
                this._updateProgress(touch), this._emitSlideEvent();
            }
        }, {
            key: "_emitSlideEvent",
            value: function _emitSlideEvent() {
                cc.Component.EventHandler.emitEvents(this.slideEvents, this), this.node.emit("slide", this);
            }
        }, {
            key: "_updateProgress",
            value: function _updateProgress(touch) {
                if (this._handle && touch) {
                    var touchPos = touch.getUILocation();
                    vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                    var localTouchPos = this.node.uiTransfromComp.convertToNodeSpaceAR(this._touchPos, _tempPos$2);
                    this.direction === Direction$1.Horizontal ? this.progress = clamp01$1(.5 + (localTouchPos.x - this._offset.x) / this.node.width) : this.progress = clamp01$1(.5 + (localTouchPos.y - this._offset.y) / this.node.height);
                }
            }
        }, {
            key: "_updateHandlePosition",
            value: function _updateHandlePosition() {
                this._handle && (this._handlelocalPos.set(this._handle.node.getPosition()), this._direction === Direction$1.Horizontal ? this._handlelocalPos.x = -this.node.width * this.node.anchorX + this.progress * this.node.width : this._handlelocalPos.y = -this.node.height * this.node.anchorY + this.progress * this.node.height, 
                this._handle.node.setPosition(this._handlelocalPos));
            }
        }, {
            key: "handle",
            get: function get() {
                return this._handle;
            },
            set: function set(value) {
                this._handle !== value && (this._handle = value);
            }
        }, {
            key: "direction",
            get: function get() {
                return this._direction;
            },
            set: function set(value) {
                this._direction !== value && (this._direction = value);
            }
        }, {
            key: "progress",
            get: function get() {
                return this._progress;
            },
            set: function set(value) {
                this._progress !== value && (this._progress = value, this._updateHandlePosition());
            }
        } ]), SliderComponent;
    }(), _class3$w.Direction = Direction$1, _applyDecoratedDescriptor((_class2$1f = _temp$1n).prototype, "handle", [ _dec4$G ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "handle"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "direction", [ _dec5$B ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "direction"), _class2$1f.prototype), 
    _applyDecoratedDescriptor(_class2$1f.prototype, "progress", [ _dec6$w ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "progress"), _class2$1f.prototype), 
    _descriptor$1e = _applyDecoratedDescriptor(_class2$1f.prototype, "slideEvents", [ _dec7$o ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$11 = _applyDecoratedDescriptor(_class2$1f.prototype, "_handle", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$O = _applyDecoratedDescriptor(_class2$1f.prototype, "_direction", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return Direction$1.Horizontal;
        }
    }), _descriptor4$H = _applyDecoratedDescriptor(_class2$1f.prototype, "_progress", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return .1;
        }
    }), _class$1t = _class2$1f)) || _class$1t) || _class$1t) || _class$1t);
    cc.SliderComponent = SliderComponent;
    var _dec$1s, _dec2$16, _dec3$S, _dec4$I, _dec5$C, _dec6$x, _class$1v, _class2$1h, _descriptor$1g, _descriptor2$13, _descriptor3$P, _descriptor4$I, ToggleContainerComponent = (_dec$1r = ccclass("cc.ToggleContainerComponent"), 
    _dec2$15 = executionOrder(110), _dec3$R = menu("UI/ToggleContainer"), _dec4$H = property({
        type: EventHandler
    }), _dec$1r(_class$1u = _dec2$15(_class$1u = _dec3$R(_class$1u = executeInEditMode((_descriptor$1f = _applyDecoratedDescriptor((_class2$1g = function(_Component) {
        function ToggleContainerComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ToggleContainerComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleContainerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$1f, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor2$12, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._toggleItems = [], _this;
        }
        return _inherits(ToggleContainerComponent, Component), _createClass(ToggleContainerComponent, [ {
            key: "start",
            value: function start() {
                this._makeAtLeastOneToggleChecked();
            }
        }, {
            key: "updateToggles",
            value: function updateToggles(toggle) {
                this.enabledInHierarchy && toggle.isChecked && (this.toggleItems.forEach(function(item) {
                    item !== toggle && item.isChecked && item.enabled && (item.isChecked = !1);
                }), this.checkEvents && EventHandler.emitEvents(this.checkEvents, toggle));
            }
        }, {
            key: "addToggle",
            value: function addToggle(toggle) {
                -1 === this._toggleItems.indexOf(toggle) && this._toggleItems.push(toggle), this._allowOnlyOneToggleChecked();
            }
        }, {
            key: "removeToggle",
            value: function removeToggle(toggle) {
                var index = this._toggleItems.indexOf(toggle);
                -1 < index && this._toggleItems.splice(index, 1), this._makeAtLeastOneToggleChecked();
            }
        }, {
            key: "_allowOnlyOneToggleChecked",
            value: function _allowOnlyOneToggleChecked() {
                var isChecked = !1;
                return this._toggleItems.forEach(function(item) {
                    isChecked && item.enabled && (item.isChecked = !1), item.isChecked && item.enabled && (isChecked = !0);
                }), isChecked;
            }
        }, {
            key: "_makeAtLeastOneToggleChecked",
            value: function _makeAtLeastOneToggleChecked() {
                this._allowOnlyOneToggleChecked() || this._allowSwitchOff || 0 < this._toggleItems.length && (this._toggleItems[0].isChecked = !0);
            }
        }, {
            key: "allowSwitchOff",
            get: function get() {
                return this._allowSwitchOff;
            },
            set: function set(value) {
                this._allowSwitchOff = value;
            }
        }, {
            key: "toggleItems",
            get: function get() {
                return this._toggleItems;
            }
        } ]), ToggleContainerComponent;
    }()).prototype, "checkEvents", [ _dec4$H ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$12 = _applyDecoratedDescriptor(_class2$1g.prototype, "_allowSwitchOff", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !1;
        }
    }), _applyDecoratedDescriptor(_class2$1g.prototype, "allowSwitchOff", [ property ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "allowSwitchOff"), _class2$1g.prototype), 
    _class$1u = _class2$1g)) || _class$1u) || _class$1u) || _class$1u) || _class$1u);
    cc.ToggleContainerComponent = ToggleContainerComponent;
    var _class$1w, ToggleComponent = (_dec$1s = ccclass("cc.ToggleComponent"), _dec2$16 = executionOrder(110), 
    _dec3$S = menu("UI/Toggle"), _dec4$I = property({
        type: ToggleContainerComponent
    }), _dec5$C = property({
        type: SpriteComponent
    }), _dec6$x = property({
        type: EventHandler
    }), _dec$1s(_class$1v = _dec2$16(_class$1v = _dec3$S(_class$1v = executeInEditMode((_applyDecoratedDescriptor((_class2$1h = function(_ButtonComponent) {
        function ToggleComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, ToggleComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$1g, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isChecked", _descriptor2$13, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_toggleGroup", _descriptor3$P, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_checkMark", _descriptor4$I, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(ToggleComponent, ButtonComponent), _createClass(ToggleComponent, [ {
            key: "onEnable",
            value: function onEnable() {
                _get(_getPrototypeOf(ToggleComponent.prototype), "onEnable", this).call(this), this._registerToggleEvent(), 
                this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                _get(_getPrototypeOf(ToggleComponent.prototype), "onDisable", this).call(this), 
                this._unregisterToggleEvent(), this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.removeToggle(this);
            }
        }, {
            key: "toggle",
            value: function toggle() {
                var group = this.toggleGroup || this._toggleContainer;
                group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !this.isChecked, 
                group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
            }
        }, {
            key: "check",
            value: function check() {
                var group = this.toggleGroup || this._toggleContainer;
                group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !0, 
                group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
            }
        }, {
            key: "uncheck",
            value: function uncheck() {
                var group = this.toggleGroup || this._toggleContainer;
                group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !1, 
                this._emitToggleEvents());
            }
        }, {
            key: "_updateCheckMark",
            value: function _updateCheckMark() {
                this._checkMark && (this._checkMark.node.active = !!this.isChecked);
            }
        }, {
            key: "_registerToggleEvent",
            value: function _registerToggleEvent() {
                this.node.on("click", this.toggle, this);
            }
        }, {
            key: "_unregisterToggleEvent",
            value: function _unregisterToggleEvent() {
                this.node.off("click", this.toggle, this);
            }
        }, {
            key: "_emitToggleEvents",
            value: function _emitToggleEvents() {
                this.node.emit("toggle", this), this.checkEvents && EventHandler.emitEvents(this.checkEvents, this);
            }
        }, {
            key: "isChecked",
            get: function get$$1() {
                return this._isChecked;
            },
            set: function set(value) {
                this._isChecked !== value && (this._isChecked = value, this._updateCheckMark());
            }
        }, {
            key: "toggleGroup",
            get: function get$$1() {
                return this._toggleGroup;
            },
            set: function set(value) {
                this._toggleGroup !== value && (this._toggleGroup && this._toggleGroup.removeToggle(this), 
                this._toggleGroup = value, this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this));
            }
        }, {
            key: "checkMark",
            get: function get$$1() {
                return this._checkMark;
            },
            set: function set(value) {
                this._checkMark !== value && (this._checkMark = value);
            }
        }, {
            key: "_resizeToTarget",
            set: function set(value) {
                value && this._resizeNodeToTargetNode();
            }
        }, {
            key: "_toggleContainer",
            get: function get$$1() {
                this.node.parent;
                return null;
            }
        } ]), ToggleComponent;
    }()).prototype, "isChecked", [ property ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "isChecked"), _class2$1h.prototype), 
    _applyDecoratedDescriptor(_class2$1h.prototype, "toggleGroup", [ _dec4$I ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "toggleGroup"), _class2$1h.prototype), 
    _applyDecoratedDescriptor(_class2$1h.prototype, "checkMark", [ _dec5$C ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "checkMark"), _class2$1h.prototype), 
    _descriptor$1g = _applyDecoratedDescriptor(_class2$1h.prototype, "checkEvents", [ _dec6$x ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$13 = _applyDecoratedDescriptor(_class2$1h.prototype, "_isChecked", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor3$P = _applyDecoratedDescriptor(_class2$1h.prototype, "_toggleGroup", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor4$I = _applyDecoratedDescriptor(_class2$1h.prototype, "_checkMark", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _class$1v = _class2$1h)) || _class$1v) || _class$1v) || _class$1v) || _class$1v);
    cc.ToggleComponent = ToggleComponent;
    var _class$1x, _class2$1i, _temp$1r, WebViewEventType, UIModelComponent = ccclass("cc.UIModelComponent")(_class$1w = executionOrder(110)(_class$1w = menu("UI/Model")(_class$1w = function(_UIComponent) {
        function UIModelComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, UIModelComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._modelComponent = null, 
            _this;
        }
        return _inherits(UIModelComponent, UIComponent), _createClass(UIModelComponent, [ {
            key: "onLoad",
            value: function onLoad() {
                this._modelComponent = this.getComponent(cc.RenderableComponent), this._modelComponent._sceneGetter = cc.director.root.ui.getRenderSceneGetter(), 
                this._modelComponent.recreateModel();
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._modelComponent = this.getComponent(cc.RenderableComponent), this._modelComponent._sceneGetter = null, 
                this._modelComponent.recreateModel();
            }
        }, {
            key: "updateAssembler",
            value: function updateAssembler(render) {
                return !!this._modelComponent && (render.commitModel.call(render, this, this._modelComponent._model, this._modelComponent.material), 
                !0);
            }
        }, {
            key: "update",
            value: function update() {
                this._fitUIRenderQueue();
            }
        }, {
            key: "_fitUIRenderQueue",
            value: function _fitUIRenderQueue() {
                if (this._modelComponent) {
                    for (var matNum = this._modelComponent.sharedMaterials.length, i = 0; i < matNum; i++) {
                        var material = this._modelComponent.getMaterial(i, !1);
                        if (null != material) {
                            for (var passes = material.passes, ea = material.effectAsset, techIdx = material.technique, passNum = passes.length, needReconstruct = !1, j = 0; j < passNum; j++) {
                                if (!passes[j].blendState.targets[0].blend) needReconstruct = !0, passes[j].blendState.targets[0].blend = !0, 
                                passes[j].overridePipelineStates(ea.techniques[techIdx].passes[j], {
                                    blendState: passes[j].blendState
                                });
                            }
                            needReconstruct && material._onPassesChange();
                        }
                    }
                    for (var _i = 0; _i < matNum; _i++) {
                        var _material = this._modelComponent.getMaterial(_i, !1);
                        if (null != _material) {
                            var _iterator = _material.passes, _isArray = Array.isArray(_iterator), _i2 = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i2 >= _iterator.length) break;
                                    _ref = _iterator[_i2++];
                                } else {
                                    if ((_i2 = _iterator.next()).done) break;
                                    _ref = _i2.value;
                                }
                                _ref._priority = RenderPriority.MAX - 11;
                            }
                        }
                    }
                }
            }
        }, {
            key: "modelComponent",
            get: function get() {
                return this._modelComponent;
            }
        } ]), UIModelComponent;
    }()) || _class$1w) || _class$1w) || _class$1w, _mat4_temp$2 = mat4.create();
    !function(WebViewEventType) {
        WebViewEventType[WebViewEventType.LOADING = 0] = "LOADING", WebViewEventType[WebViewEventType.LOADED = 1] = "LOADED", 
        WebViewEventType[WebViewEventType.ERROR = 2] = "ERROR", WebViewEventType[WebViewEventType.JS_EVALUATED = 3] = "JS_EVALUATED";
    }(WebViewEventType || (WebViewEventType = {}));
    var polyfill$1 = {
        devicePixelRatio: !1,
        enableDiv: !1
    };
    sys.os === sys.OS_IOS && (polyfill$1.enableDiv = !0), sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill$1.enableBG = !0) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill$1.closeHistory = !0);
    var _dec$1v, _dec2$18, _dec3$U, _dec4$J, _class$1y, _class2$1j, _descriptor$1h, _descriptor2$14, _class3$x, _temp$1s, WebViewImpl = ccclass("cc.WebviewImpl")((_temp$1r = _class2$1i = function() {
        function WebViewImpl() {
            _classCallCheck(this, WebViewImpl), this._EventList = new Map(), this._visible = !1, 
            this._div = null, this._iframe = null, this._forceUpdate = !0, this._m00 = 0, this._m01 = 0, 
            this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._w = 0, this._h = 0, 
            this._eventListeners = {
                load: function load() {},
                error: function error() {}
            };
        }
        return _createClass(WebViewImpl, [ {
            key: "createDomElementIfNeeded",
            value: function createDomElementIfNeeded(w, h) {
                this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
            }
        }, {
            key: "removeDom",
            value: function removeDom() {
                var div = this._div;
                div && (contains$1(cc.game.container, div) && cc.game.container.removeChild(div), 
                this._div = null);
                var iframe = this._iframe;
                if (iframe) {
                    var cbs = this._eventListeners;
                    iframe.removeEventListener("load", cbs.load), iframe.removeEventListener("error", cbs.error), 
                    cbs.load = null, cbs.error = null, this._iframe = null;
                }
            }
        }, {
            key: "loadURL",
            value: function loadURL(url) {
                var iframe = this._iframe;
                if (iframe) {
                    iframe.src = url;
                    var self = this;
                    iframe.addEventListener("load", function cb() {
                        self._updateVisibility(), iframe.removeEventListener("load", cb);
                    }), this._dispatchEvent(WebViewImpl.EventType.LOADING);
                }
            }
        }, {
            key: "stopLoading",
            value: function stopLoading() {
                cc.logID(7800);
            }
        }, {
            key: "reload",
            value: function reload() {
                var iframe = this._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.location.reload();
                }
            }
        }, {
            key: "canGoBack",
            value: function canGoBack() {
                return cc.logID(7801), !0;
            }
        }, {
            key: "canGoForward",
            value: function canGoForward() {
                return cc.logID(7802), !0;
            }
        }, {
            key: "goBack",
            value: function goBack() {
                try {
                    if (WebViewImpl.Polyfill.closeHistory) return cc.logID(7803);
                    var iframe = this._iframe;
                    if (iframe) {
                        var win = iframe.contentWindow;
                        win && win.location && win.history.back.call(win);
                    }
                } catch (err) {
                    cc.log(err);
                }
            }
        }, {
            key: "goForward",
            value: function goForward() {
                try {
                    if (WebViewImpl.Polyfill.closeHistory) return cc.logID(7804);
                    var iframe = this._iframe;
                    if (iframe) {
                        var win = iframe.contentWindow;
                        win && win.location && win.history.forward.call(win);
                    }
                } catch (err) {
                    cc.log(err);
                }
            }
        }, {
            key: "evaluateJS",
            value: function evaluateJS(str) {
                var iframe = this._iframe;
                if (iframe) iframe.contentWindow;
            }
        }, {
            key: "setScalesPageToFit",
            value: function setScalesPageToFit() {
                cc.logID(7805);
            }
        }, {
            key: "setEventListener",
            value: function setEventListener(event, callback) {
                this._EventList[event] = callback;
            }
        }, {
            key: "removeEventListener",
            value: function removeEventListener(event) {
                this._EventList[event] = null;
            }
        }, {
            key: "_dispatchEvent",
            value: function _dispatchEvent(event) {
                var callback = this._EventList[event];
                callback && this._iframe && callback.call(this, this, this._iframe.src);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.removeDom();
            }
        }, {
            key: "setVisible",
            value: function setVisible(visible) {
                this._visible !== visible && (this._visible = !!visible, this._updateVisibility());
            }
        }, {
            key: "updateMatrix",
            value: function updateMatrix(node) {
                if (this._div && this._visible) {
                    node.getWorldMatrix(_mat4_temp$2);
                    var contentSize = node.getContentSize();
                    if (this._forceUpdate || this._m00 !== _mat4_temp$2.m00 || this._m01 !== _mat4_temp$2.m01 || this._m04 !== _mat4_temp$2.m04 || this._m05 !== _mat4_temp$2.m05 || this._m12 !== _mat4_temp$2.m12 || this._m13 !== _mat4_temp$2.m13 || this._w !== contentSize.width || this._h !== contentSize.height) {
                        this._m00 = _mat4_temp$2.m00, this._m01 = _mat4_temp$2.m01, this._m04 = _mat4_temp$2.m04, 
                        this._m05 = _mat4_temp$2.m05, this._m12 = _mat4_temp$2.m12, this._m13 = _mat4_temp$2.m13, 
                        this._w = contentSize.width, this._h = contentSize.height;
                        var scaleX = cc.view._scaleX, scaleY = cc.view._scaleY, dpr = cc.view._devicePixelRatio;
                        scaleX /= dpr, scaleY /= dpr;
                        var container = cc.game.container, a = _mat4_temp$2.m00 * scaleX, b = _mat4_temp$2.m01, c = _mat4_temp$2.m04, d = _mat4_temp$2.m05 * scaleY, offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0, offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                        this._updateSize(this._w, this._h);
                        var w = this._div.clientWidth * scaleX, h = this._div.clientHeight * scaleY, ap = node.getAnchorPoint(), appx = w * _mat4_temp$2.m00 * ap.x, appy = h * _mat4_temp$2.m05 * ap.y, matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + (_mat4_temp$2.m12 * scaleX - appx + offsetX) + "," + -(_mat4_temp$2.m13 * scaleY - appy + offsetY) + ")";
                        this._div.style.transform = matrix, this._div.style["-webkit-transform"] = matrix, 
                        this._div.style["transform-origin"] = "0px 100% 0px", this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
                        var renderComp = node.getComponent(UIRenderComponent);
                        renderComp && this._setOpacity(renderComp.color.a);
                    }
                }
            }
        }, {
            key: "setOnJSCallback",
            value: function setOnJSCallback(callback) {}
        }, {
            key: "setJavascriptInterfaceScheme",
            value: function setJavascriptInterfaceScheme(scheme) {}
        }, {
            key: "loadData",
            value: function loadData(data, MIMEType, encoding, baseURL) {}
        }, {
            key: "loadHTMLString",
            value: function loadHTMLString(string, baseURL) {}
        }, {
            key: "_updateVisibility",
            value: function _updateVisibility() {
                if (this._div) {
                    var div = this._div;
                    this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden", 
                    this._forceUpdate = !0;
                }
            }
        }, {
            key: "_updateSize",
            value: function _updateSize(w, h) {
                var div = this._div;
                div && (div.style.width = w + "px", div.style.height = h + "px");
            }
        }, {
            key: "_initEvent",
            value: function _initEvent() {
                var iframe = this._iframe;
                if (iframe) {
                    var cbs = this._eventListeners, self = this;
                    cbs.load = function() {
                        self._dispatchEvent(WebViewImpl.EventType.LOADED);
                    }, cbs.error = function() {
                        self._dispatchEvent(WebViewImpl.EventType.ERROR);
                    }, iframe.addEventListener("load", cbs.load), iframe.addEventListener("error", cbs.error);
                }
            }
        }, {
            key: "_initStyle",
            value: function _initStyle() {
                if (this._div) {
                    var div = this._div;
                    div.style.position = "absolute", div.style.bottom = "0px", div.style.left = "0px";
                }
            }
        }, {
            key: "_setOpacity",
            value: function _setOpacity(opacity) {
                var iframe = this._iframe;
                iframe && iframe.style && (iframe.style.opacity = (opacity / 255).toString());
            }
        }, {
            key: "_createDom",
            value: function _createDom(w, h) {
                WebViewImpl.Polyfill.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", 
                this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), 
                this._div.appendChild(this._iframe), this._iframe.style.width = "100%", this._iframe.style.height = "100%") : this._div = this._iframe = document.createElement("iframe"), 
                WebViewImpl.Polyfill.enableBG && (this._div.style.background = "#FFF"), this._div.style.background = "#FFF", 
                this._div.style.height = h + "px", this._div.style.width = w + "px", this._div.style.overflow = "scroll", 
                this._iframe.style.border = "none", cc.game.container.appendChild(this._div), this._updateVisibility();
            }
        }, {
            key: "_createNativeControl",
            value: function _createNativeControl(w, h) {
                this._createDom(w, h), this._initStyle(), this._initEvent();
            }
        } ]), WebViewImpl;
    }(), _class2$1i.Polyfill = polyfill$1, _class2$1i.EventType = WebViewEventType, 
    _class$1x = _temp$1r)) || _class$1x, EventType$2 = WebViewEventType;
    function emptyCallback() {}
    var _dec$1w, _dec2$19, _dec3$V, _dec4$K, _dec5$D, _dec6$y, _dec7$p, _dec8$h, _class$1z, _class2$1k, _descriptor$1i, _descriptor2$15, _descriptor3$Q, _descriptor4$J, _descriptor5$B, _descriptor6$s, _descriptor7$n, _descriptor8$j, _descriptor9$f, _descriptor10$c, _descriptor11$b, _descriptor12$a, _descriptor13$a, _descriptor14$6, _descriptor15$4, _descriptor16$4, _descriptor17$3, _class3$y, _temp$1t, AlignMode, AlignFlags, WebviewComponent = (_dec$1v = ccclass("cc.WebviewComponent"), 
    _dec2$18 = menu("UI/WebView"), _dec3$U = executionOrder(100), _dec4$J = property({
        type: EventHandler
    }), _dec$1v(_class$1y = _dec2$18(_class$1y = _dec3$U((_temp$1s = _class3$x = function(_UIComponent) {
        function WebviewComponent() {
            var _this;
            return _classCallCheck(this, WebviewComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(WebviewComponent).call(this)), "webviewEvents", _descriptor$1h, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_url", _descriptor2$14, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this._impl = null, _this._impl = new WebViewImpl(), _this;
        }
        return _inherits(WebviewComponent, UIComponent), _createClass(WebviewComponent, [ {
            key: "url",
            get: function get() {
                return this._url;
            },
            set: function set(url) {
                this._url = url;
                var impl = this._impl;
                impl && impl.loadURL(url);
            }
        } ]), _createClass(WebviewComponent, [ {
            key: "onRestore",
            value: function onRestore() {
                this._impl || (this._impl = new WebViewImpl());
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                if (this._impl) {
                    var impl = this._impl;
                    impl.createDomElementIfNeeded(this.node.width, this.node.height), impl.loadURL(this._url), 
                    impl.setVisible(!0), impl.setEventListener(EventType$2.LOADED, this._onWebViewLoaded.bind(this)), 
                    impl.setEventListener(EventType$2.LOADING, this._onWebViewLoading.bind(this)), impl.setEventListener(EventType$2.ERROR, this._onWebViewLoadError.bind(this));
                }
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                if (this._impl) {
                    var impl = this._impl;
                    impl.setVisible(!1), impl.setEventListener(EventType$2.LOADED, emptyCallback), impl.setEventListener(EventType$2.LOADING, emptyCallback), 
                    impl.setEventListener(EventType$2.ERROR, emptyCallback);
                }
            }
        }, {
            key: "onDestroy",
            value: function onDestroy() {
                this._impl && (this._impl.destroy(), this._impl = null);
            }
        }, {
            key: "update",
            value: function update(dt) {
                this._impl && this._impl.updateMatrix(this.node);
            }
        }, {
            key: "setJavascriptInterfaceScheme",
            value: function setJavascriptInterfaceScheme(scheme) {
                this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
            }
        }, {
            key: "setOnJSCallback",
            value: function setOnJSCallback(callback) {
                this._impl && this._impl.setOnJSCallback(callback);
            }
        }, {
            key: "evaluateJS",
            value: function evaluateJS(str) {
                this._impl && this._impl.evaluateJS(str);
            }
        }, {
            key: "_onWebViewLoaded",
            value: function _onWebViewLoaded() {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$2.LOADED), this.node.emit("loaded", this);
            }
        }, {
            key: "_onWebViewLoading",
            value: function _onWebViewLoading() {
                return EventHandler.emitEvents(this.webviewEvents, this, EventType$2.LOADING), this.node.emit("loading", this), 
                !0;
            }
        }, {
            key: "_onWebViewLoadError",
            value: function _onWebViewLoadError() {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$2.ERROR), this.node.emit("error", this);
            }
        } ]), WebviewComponent;
    }(), _class3$x.EventType = EventType$2, _applyDecoratedDescriptor((_class2$1j = _temp$1s).prototype, "url", [ property ], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "url"), _class2$1j.prototype), 
    _descriptor$1h = _applyDecoratedDescriptor(_class2$1j.prototype, "webviewEvents", [ _dec4$J ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return [];
        }
    }), _descriptor2$14 = _applyDecoratedDescriptor(_class2$1j.prototype, "_url", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return "";
        }
    }), _class$1y = _class2$1j)) || _class$1y) || _class$1y) || _class$1y);
    cc.WebviewComponent = WebviewComponent, function(AlignMode) {
        AlignMode[AlignMode.ONCE = 0] = "ONCE", AlignMode[AlignMode.ALWAYS = 1] = "ALWAYS";
    }(AlignMode || (AlignMode = {})), ccenum(AlignMode), function(AlignFlags) {
        AlignFlags[AlignFlags.TOP = 1] = "TOP", AlignFlags[AlignFlags.MID = 2] = "MID", 
        AlignFlags[AlignFlags.BOT = 4] = "BOT", AlignFlags[AlignFlags.LEFT = 8] = "LEFT", 
        AlignFlags[AlignFlags.CENTER = 16] = "CENTER", AlignFlags[AlignFlags.RIGHT = 32] = "RIGHT", 
        AlignFlags[AlignFlags.HORIZONTAL = 56] = "HORIZONTAL", AlignFlags[AlignFlags.VERTICAL = 7] = "VERTICAL";
    }(AlignFlags || (AlignFlags = {}));
    var TOP_BOT = AlignFlags.TOP | AlignFlags.BOT, LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT, WidgetComponent = (_dec$1w = ccclass("cc.WidgetComponent"), 
    _dec2$19 = executionOrder(110), _dec3$V = menu("UI/Widget"), _dec4$K = requireComponent(UITransformComponent), 
    _dec5$D = property({
        type: Node$1
    }), _dec6$y = property({
        visible: !1
    }), _dec7$p = property({
        visible: !1
    }), _dec8$h = property({
        type: AlignMode
    }), _dec$1w(_class$1z = _dec2$19(_class$1z = _dec3$V(_class$1z = _dec4$K(_class$1z = executeInEditMode((_temp$1t = _class3$y = function(_Component) {
        function WidgetComponent() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, WidgetComponent);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WidgetComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastPos = new Vec3(), 
            _this._lastSize = new Size(), _this._dirty = !0, _initializerDefineProperty(_this, "_alignFlags", _descriptor$1i, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_target", _descriptor2$15, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_left", _descriptor3$Q, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_right", _descriptor4$J, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_top", _descriptor5$B, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_bottom", _descriptor6$s, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$n, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$j, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$f, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$c, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$b, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$a, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$6, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_originalWidth", _descriptor15$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_originalHeight", _descriptor16$4, _assertThisInitialized(_assertThisInitialized(_this))), 
            _initializerDefineProperty(_this, "_alignMode", _descriptor17$3, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(WidgetComponent, Component), _createClass(WidgetComponent, [ {
            key: "updateAlignment",
            value: function updateAlignment() {
                cc._widgetManager.updateAlignment(this.node);
            }
        }, {
            key: "_validateTargetInDEV",
            value: function _validateTargetInDEV() {
            }
        }, {
            key: "setDirty",
            value: function setDirty() {
                this._recursiveDirty();
            }
        }, {
            key: "onLoad",
            value: function onLoad() {}
        }, {
            key: "onEnable",
            value: function onEnable() {
                this.node.getPosition(this._lastPos), this.node.getContentSize(this._lastSize), 
                cc._widgetManager.add(this);
            }
        }, {
            key: "update",
            value: function update() {
                if (!this._dirty) return this.node.hasChanged ? (this._recursiveDirty(), void cc._widgetManager.updateTransform(this)) : void (this.target && this.target.hasChanged && this._recursiveDirty());
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                cc._widgetManager.remove(this);
            }
        }, {
            key: "_setAlign",
            value: function _setAlign(flag, isAlign) {
                if (isAlign !== 0 < (this._alignFlags & flag)) {
                    var isHorizontal = 0 < (flag & LEFT_RIGHT);
                    isAlign ? (this._alignFlags |= flag, isHorizontal ? (this.isAlignHorizontalCenter = !1, 
                    this.isStretchWidth && (this._originalWidth = this.node.width)) : (this.isAlignVerticalCenter = !1, 
                    this.isStretchHeight && (this._originalHeight = this.node.height))) : (isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight), 
                    this._alignFlags &= ~flag);
                }
            }
        }, {
            key: "_recursiveDirty",
            value: function _recursiveDirty() {
                this._dirty || this.node.getComponentsInChildren(WidgetComponent).forEach(function(widget) {
                    widget._dirty = !0;
                });
            }
        }, {
            key: "target",
            get: function get() {
                return this._target;
            },
            set: function set(value) {
                this._target !== value && (this._target = value, this._recursiveDirty());
            }
        }, {
            key: "isAlignTop",
            get: function get() {
                return 0 < (this._alignFlags & AlignFlags.TOP);
            },
            set: function set(value) {
                this._setAlign(AlignFlags.TOP, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignBottom",
            get: function get() {
                return 0 < (this._alignFlags & AlignFlags.BOT);
            },
            set: function set(value) {
                this._setAlign(AlignFlags.BOT, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignLeft",
            get: function get() {
                return 0 < (this._alignFlags & AlignFlags.LEFT);
            },
            set: function set(value) {
                this._setAlign(AlignFlags.LEFT, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignRight",
            get: function get() {
                return 0 < (this._alignFlags & AlignFlags.RIGHT);
            },
            set: function set(value) {
                this._setAlign(AlignFlags.RIGHT, value), this._recursiveDirty();
            }
        }, {
            key: "isAlignVerticalCenter",
            get: function get() {
                return 0 < (this._alignFlags & AlignFlags.MID);
            },
            set: function set(value) {
                value ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= AlignFlags.MID) : this._alignFlags &= ~AlignFlags.MID, 
                this._recursiveDirty();
            }
        }, {
            key: "isAlignHorizontalCenter",
            get: function get() {
                return 0 < (this._alignFlags & AlignFlags.CENTER);
            },
            set: function set(value) {
                value ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= AlignFlags.CENTER) : this._alignFlags &= ~AlignFlags.CENTER, 
                this._recursiveDirty();
            }
        }, {
            key: "isStretchWidth",
            get: function get() {
                return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
            }
        }, {
            key: "isStretchHeight",
            get: function get() {
                return (this._alignFlags & TOP_BOT) === TOP_BOT;
            }
        }, {
            key: "top",
            get: function get() {
                return this._top;
            },
            set: function set(value) {
                this._top = value, this._recursiveDirty();
            }
        }, {
            key: "bottom",
            get: function get() {
                return this._bottom;
            },
            set: function set(value) {
                this._bottom = value, this._recursiveDirty();
            }
        }, {
            key: "left",
            get: function get() {
                return this._left;
            },
            set: function set(value) {
                this._left = value, this._recursiveDirty();
            }
        }, {
            key: "right",
            get: function get() {
                return this._right;
            },
            set: function set(value) {
                this._right = value, this._recursiveDirty();
            }
        }, {
            key: "horizontalCenter",
            get: function get() {
                return this._horizontalCenter;
            },
            set: function set(value) {
                this._horizontalCenter = value, this._recursiveDirty();
            }
        }, {
            key: "verticalCenter",
            get: function get() {
                return this._verticalCenter;
            },
            set: function set(value) {
                this._verticalCenter = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteTop",
            get: function get() {
                return this._isAbsTop;
            },
            set: function set(value) {
                this._isAbsTop = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteBottom",
            get: function get() {
                return this._isAbsBottom;
            },
            set: function set(value) {
                this._isAbsBottom = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteLeft",
            get: function get() {
                return this._isAbsLeft;
            },
            set: function set(value) {
                this._isAbsLeft = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteRight",
            get: function get() {
                return this._isAbsRight;
            },
            set: function set(value) {
                this._isAbsRight = value, this._recursiveDirty();
            }
        }, {
            key: "alignMode",
            get: function get() {
                return this._alignMode;
            },
            set: function set(value) {
                this._alignMode = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteHorizontalCenter",
            get: function get() {
                return this._isAbsHorizontalCenter;
            },
            set: function set(value) {
                this._isAbsHorizontalCenter = value, this._recursiveDirty();
            }
        }, {
            key: "isAbsoluteVerticalCenter",
            get: function get() {
                return this._isAbsVerticalCenter;
            },
            set: function set(value) {
                this._isAbsVerticalCenter = value, this._recursiveDirty();
            }
        }, {
            key: "alignFlags",
            get: function get() {
                return this._alignFlags;
            },
            set: function set(value) {
                this._alignFlags !== value && (this._alignFlags = value, this._recursiveDirty());
            }
        } ]), WidgetComponent;
    }(), _class3$y.AlignMode = AlignMode, _applyDecoratedDescriptor((_class2$1k = _temp$1t).prototype, "target", [ _dec5$D ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "target"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAlignTop", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAlignTop"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAlignBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAlignBottom"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAlignLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAlignLeft"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAlignRight", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAlignRight"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAlignVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAlignVerticalCenter"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAlignHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAlignHorizontalCenter"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isStretchWidth", [ _dec6$y ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isStretchWidth"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isStretchHeight", [ _dec7$p ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isStretchHeight"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "top", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "top"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "bottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "bottom"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "left", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "left"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "right", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "right"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "horizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "horizontalCenter"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "verticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "verticalCenter"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAbsoluteTop", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAbsoluteTop"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAbsoluteBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAbsoluteBottom"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAbsoluteLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAbsoluteLeft"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAbsoluteRight", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAbsoluteRight"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "alignMode", [ _dec8$h ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "alignMode"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAbsoluteHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAbsoluteHorizontalCenter"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "isAbsoluteVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "isAbsoluteVerticalCenter"), _class2$1k.prototype), 
    _applyDecoratedDescriptor(_class2$1k.prototype, "alignFlags", [ property ], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "alignFlags"), _class2$1k.prototype), 
    _descriptor$1i = _applyDecoratedDescriptor(_class2$1k.prototype, "_alignFlags", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1k.prototype, "_target", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return null;
        }
    }), _descriptor3$Q = _applyDecoratedDescriptor(_class2$1k.prototype, "_left", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor4$J = _applyDecoratedDescriptor(_class2$1k.prototype, "_right", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor5$B = _applyDecoratedDescriptor(_class2$1k.prototype, "_top", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor6$s = _applyDecoratedDescriptor(_class2$1k.prototype, "_bottom", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor7$n = _applyDecoratedDescriptor(_class2$1k.prototype, "_horizontalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor8$j = _applyDecoratedDescriptor(_class2$1k.prototype, "_verticalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor9$f = _applyDecoratedDescriptor(_class2$1k.prototype, "_isAbsLeft", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor10$c = _applyDecoratedDescriptor(_class2$1k.prototype, "_isAbsRight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor11$b = _applyDecoratedDescriptor(_class2$1k.prototype, "_isAbsTop", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor12$a = _applyDecoratedDescriptor(_class2$1k.prototype, "_isAbsBottom", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor13$a = _applyDecoratedDescriptor(_class2$1k.prototype, "_isAbsHorizontalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor14$6 = _applyDecoratedDescriptor(_class2$1k.prototype, "_isAbsVerticalCenter", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return !0;
        }
    }), _descriptor15$4 = _applyDecoratedDescriptor(_class2$1k.prototype, "_originalWidth", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor16$4 = _applyDecoratedDescriptor(_class2$1k.prototype, "_originalHeight", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return 0;
        }
    }), _descriptor17$3 = _applyDecoratedDescriptor(_class2$1k.prototype, "_alignMode", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return AlignMode.ALWAYS;
        }
    }), _class$1z = _class2$1k)) || _class$1z) || _class$1z) || _class$1z) || _class$1z) || _class$1z);
    cc.WidgetComponent = WidgetComponent;
    var _tempPos$3 = new Vec3(), _zeroVec3 = new Vec3(), _defaultAnchor = new Vec2();
    function getReadonlyNodeSize(parent) {
        return parent instanceof cc.Scene ? cc.visibleRect : parent.getContentSize();
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
        for (var scale = widgetNode.parent ? widgetNode.parent.getScale() : _zeroVec3, scaleX = scale.x, scaleY = scale.y, translateX = 0, translateY = 0, node = widgetNode.parent; ;) {
            if (!node) return out_inverseTranslate.x = out_inverseTranslate.y = 0, void (out_inverseScale.x = out_inverseScale.y = 1);
            var pos = node.getPosition();
            if (translateX += pos.x, translateY += pos.y, (node = node.parent) === target) break;
            var sx = (scale = node ? node.getScale() : _zeroVec3).x, sy = scale.y;
            translateX *= sx, translateY *= sy, scaleX *= sx, scaleY *= sy;
        }
        out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1, out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1, 
        out_inverseTranslate.x = -translateX, out_inverseTranslate.y = -translateY;
    }
    var tInverseTranslate = new Vec3(), tInverseScale = new Vec3(1, 1, 1);
    function align(node, widget) {
        var target, hasTarget = widget.target, inverseTranslate = tInverseTranslate, inverseScale = tInverseScale;
        hasTarget ? computeInverseTransForTarget(node, target = hasTarget, inverseTranslate, inverseScale) : target = node.parent;
        var targetSize = getReadonlyNodeSize(target), isScene = target instanceof cc.Scene, targetAnchor = isScene ? _defaultAnchor : target.getAnchorPoint(), isRoot = isScene;
        node.getPosition(_tempPos$3);
        var x = _tempPos$3.x, y = _tempPos$3.y, anchor = node.getAnchorPoint(), scale = node.getScale();
        if (widget.alignFlags & AlignFlags.HORIZONTAL) {
            var localLeft = 0, localRight = 0, targetWidth = targetSize.width;
            localRight = isRoot ? (localLeft = cc.visibleRect.left.x, cc.visibleRect.right.x) : (localLeft = -targetAnchor.x * targetWidth) + targetWidth, 
            localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth, localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth, 
            hasTarget && (localLeft += inverseTranslate.x, localLeft *= inverseScale.x, localRight += inverseTranslate.x, 
            localRight *= inverseScale.x);
            var width = 0, anchorX = anchor.x, scaleX = scale.x;
            if (scaleX < 0 && (anchorX = 1 - anchorX, scaleX = -scaleX), widget.isStretchWidth) width = localRight - localLeft, 
            0 !== scaleX && (node.width = width / scaleX), x = localLeft + anchorX * width; else if (width = node.width * scaleX, 
            widget.isAlignHorizontalCenter) {
                var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth, targetCenter = (.5 - targetAnchor.x) * targetSize.width;
                hasTarget && (localHorizontalCenter *= inverseScale.x, targetCenter += inverseTranslate.x, 
                targetCenter *= inverseScale.x), x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
            } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        }
        if (widget.alignFlags & AlignFlags.VERTICAL) {
            var localTop = 0, localBottom = 0, targetHeight = targetSize.height;
            localTop = isRoot ? (localBottom = cc.visibleRect.bottom.y, cc.visibleRect.top.y) : (localBottom = -targetAnchor.y * targetHeight) + targetHeight, 
            localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight, 
            localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight, hasTarget && (localBottom += inverseTranslate.y, 
            localBottom *= inverseScale.y, localTop += inverseTranslate.y, localTop *= inverseScale.y);
            var height = 0, anchorY = anchor.y, scaleY = scale.y;
            if (scaleY < 0 && (anchorY = 1 - anchorY, scaleY = -scaleY), widget.isStretchHeight) height = localTop - localBottom, 
            0 !== scaleY && (node.height = height / scaleY), y = localBottom + anchorY * height; else if (height = node.height * scaleY, 
            widget.isAlignVerticalCenter) {
                var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight, targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
                hasTarget && (localVerticalCenter *= inverseScale.y, targetMiddle += inverseTranslate.y, 
                targetMiddle *= inverseScale.y), y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
            } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        }
        node.setPosition(x, y, _tempPos$3.z);
    }
    function refreshScene() {
        var scene = cc.director.getScene();
        if (scene) {
            if (widgetManager.isAligning = !0, widgetManager._nodesOrderDirty) activeWidgets.length = 0, 
            function visitNode$1(node) {
                var widget = node.getComponent(WidgetComponent);
                widget && (align(node, widget), widget.alignMode !== AlignMode.ALWAYS ? widget.enabled = !1 : activeWidgets.push(widget));
                var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var child = _ref;
                    child.active && visitNode$1(child);
                }
            }(scene), widgetManager._nodesOrderDirty = !1; else {
                var widget = null, iterator = widgetManager._activeWidgetsIterator;
                for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) (widget = activeWidgets[iterator.i])._dirty && (align(widget.node, widget), 
                widget._dirty = !1);
            }
            widgetManager.isAligning = !1;
        }
    }
    function adjustWidgetToAllowResizingInEditor() {
        if (!widgetManager.isAligning) {
            this.setDirty();
            var newSize = this.node.getContentSize(), oldSize = this._lastSize, delta = new Vec3(newSize.width - oldSize.width, newSize.height - oldSize.height, 0);
            oldSize.set(newSize);
            var target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
            this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3(), inverseScale));
            var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3();
            0 !== targetSize.width && 0 !== targetSize.height && vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z);
            var anchor = this.node.getAnchorPoint();
            this.isAlignTop && (this.top -= (this.isAbsoluteTop ? delta.y : deltaInPercent.y) * (1 - anchor.y) * inverseScale.y), 
            this.isAlignBottom && (this.bottom -= (this.isAbsoluteBottom ? delta.y : deltaInPercent.y) * anchor.y * inverseScale.y), 
            this.isAlignLeft && (this.left -= (this.isAbsoluteLeft ? delta.x : deltaInPercent.x) * anchor.x * inverseScale.x), 
            this.isAlignRight && (this.right -= (this.isAbsoluteRight ? delta.x : deltaInPercent.x) * (1 - anchor.x) * inverseScale.x);
        }
    }
    var activeWidgets = [];
    var canvasList = [], widgetManager = cc._widgetManager = {
        isAligning: !1,
        _nodesOrderDirty: !1,
        _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
        animationState: null,
        init: function init(director) {
            director.on(cc.Director.EVENT_AFTER_UPDATE, refreshScene), cc.sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : cc.view.on("design-resolution-changed", this.onResized, this);
        },
        add: function add(widget) {
            this._nodesOrderDirty = !0;
            var renderComp = widget.node.getComponent(UIRenderComponent);
            if (renderComp) {
                var canvasComp = cc.director.root.ui.getScreen(renderComp.visibility);
                canvasComp && -1 === canvasList.indexOf(canvasComp) && (canvasList.push(canvasComp), 
                canvasComp.node.on("design-resolution-changed", this.onResized, this));
            }
            widget.node.on(exports.SystemEventType.SIZE_CHANGED, adjustWidgetToAllowResizingInEditor, widget);
        },
        updateTransform: function updateTransform(widget) {
            (function adjustWidgetToAllowMovingInEditor() {
                if (!widgetManager.isAligning) {
                    var newPos = this.node.getPosition(), oldPos = this._lastPos, delta = newPos.sub(oldPos);
                    oldPos.set(newPos);
                    var target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                    this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3(), inverseScale));
                    var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3();
                    0 !== targetSize.width && 0 !== targetSize.height && vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z), 
                    this.isAlignTop && (this.top -= (this.isAbsoluteTop ? delta.y : deltaInPercent.y) * inverseScale.y), 
                    this.isAlignBottom && (this.bottom += (this.isAbsoluteBottom ? delta.y : deltaInPercent.y) * inverseScale.y), 
                    this.isAlignLeft && (this.left += (this.isAbsoluteLeft ? delta.x : deltaInPercent.x) * inverseScale.x), 
                    this.isAlignRight && (this.right -= (this.isAbsoluteRight ? delta.x : deltaInPercent.x) * inverseScale.x), 
                    this.isAlignHorizontalCenter && (this.horizontalCenter += (this.isAbsoluteHorizontalCenter ? delta.x : deltaInPercent.x) * inverseScale.x), 
                    this.isAlignVerticalCenter && (this.verticalCenter += (this.isAbsoluteVerticalCenter ? delta.y : deltaInPercent.y) * inverseScale.y);
                }
            }).call(widget);
        },
        remove: function remove(widget) {
            this._activeWidgetsIterator.remove(widget), widget.node.off(exports.SystemEventType.SIZE_CHANGED, adjustWidgetToAllowResizingInEditor, widget);
        },
        onResized: function onResized() {
            var scene = cc.director.getScene();
            scene && this.refreshWidgetOnResized(scene);
        },
        refreshWidgetOnResized: function refreshWidgetOnResized(node) {
            if (Node$1.isNode(node)) {
                var widget = node.getComponent(WidgetComponent);
                if (widget && widget.alignFlags === AlignMode.ALWAYS) return;
            }
            var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var child = _ref2;
                this.refreshWidgetOnResized(child);
            }
        },
        updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
            function i(t, c) {
                return 1e-10 < Math.abs(t - c) ? c : t;
            }
            var widgetNode = widget.node, widgetParent = widgetNode.parent;
            if (widgetParent) {
                var zero = new Vec3(), one = new Vec3(1, 1, 1);
                if (widget.target && computeInverseTransForTarget(widgetNode, widgetParent = widget.target, zero, one), 
                !e) return;
                var parentAP = widgetParent.getAnchorPoint(), matchSize = getReadonlyNodeSize(widgetParent), myAP = widgetNode.getAnchorPoint(), pos = widgetNode.getPosition(), alignFlags = AlignFlags, widgetNodeScale = widgetNode.getScale(), temp = 0;
                if (e & alignFlags.LEFT) {
                    var l = -parentAP.x * matchSize.width;
                    l += zero.x, l *= one.x, temp = pos.x - myAP.x * widgetNode.width * widgetNodeScale.x - l, 
                    widget.isAbsoluteLeft || (temp /= matchSize.width), temp /= one.x, widget.left = i(widget.left, temp);
                }
                if (e & alignFlags.RIGHT) {
                    var r = (1 - parentAP.x) * matchSize.width;
                    r += zero.x, temp = (r *= one.x) - (pos.x + (1 - myAP.x) * widgetNode.width * widgetNodeScale.x), 
                    widget.isAbsoluteRight || (temp /= matchSize.width), temp /= one.x, widget.right = i(widget.right, temp);
                }
                if (e & alignFlags.TOP) {
                    var t = (1 - parentAP.y) * matchSize.height;
                    t += zero.y, temp = (t *= one.y) - (pos.y + (1 - myAP.y) * widgetNode.height * widgetNodeScale.y), 
                    widget.isAbsoluteTop || (temp /= matchSize.height), temp /= one.y, widget.top = i(widget.top, temp);
                }
                if (e & alignFlags.BOT) {
                    var b = -parentAP.y * matchSize.height;
                    b += zero.y, b *= one.y, temp = pos.y - myAP.y * widgetNode.height * widgetNodeScale.y - b, 
                    widget.isAbsoluteBottom || (temp /= matchSize.height), temp /= one.y, widget.bottom = i(widget.bottom, temp);
                }
            }
        },
        updateAlignment: function updateAlignment(node) {
            var parent = node.parent;
            parent && Node$1.isNode(parent) && updateAlignment(parent);
            var widget = node.getComponent(WidgetComponent);
            widget && parent && align(node, widget);
        },
        AlignMode: AlignMode,
        AlignFlags: AlignFlags
    }, UIBatchModel = function(_Model) {
        function UIBatchModel(scene) {
            var _this;
            return _classCallCheck(this, UIBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIBatchModel).call(this, scene, null)))._subModel = void 0, 
            _this._subModel = new UISubModel(), _this;
        }
        return _inherits(UIBatchModel, Model), _createClass(UIBatchModel, [ {
            key: "updateTransform",
            value: function updateTransform() {}
        }, {
            key: "updateUBOs",
            value: function updateUBOs() {}
        }, {
            key: "initialize",
            value: function initialize(ia, batch) {
                this._subModel.directInitialize(ia, batch.material, batch.pipelineState), this._subModels[0] = this._subModel;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._subModel.destroy();
            }
        } ]), UIBatchModel;
    }(), UISubModel = function(_SubModel) {
        function UISubModel() {
            var _this2;
            return _classCallCheck(this, UISubModel), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(UISubModel).call(this))).psos = [], 
            _this2;
        }
        return _inherits(UISubModel, SubModel), _createClass(UISubModel, [ {
            key: "directInitialize",
            value: function directInitialize(ia, mat, pso) {
                this._inputAssembler = ia, this.psos[0] = pso, this.material = mat;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                0 < this.commandBuffers.length && this.commandBuffers[0].destroy();
            }
        } ]), UISubModel;
    }(), UIMaterial = function() {
        function UIMaterial() {
            _classCallCheck(this, UIMaterial), this._material = null, this._pass = null, this._psos = void 0, 
            this._psos = null;
        }
        return _createClass(UIMaterial, [ {
            key: "material",
            get: function get() {
                return this._material;
            }
        }, {
            key: "pass",
            get: function get() {
                return this._pass;
            }
        } ]), _createClass(UIMaterial, [ {
            key: "initialize",
            value: function initialize(info) {
                var _this = this;
                return !!info.material && (this._material = info.material, this._pass = this._material.passes[0], 
                this._psos = new Pool$1(function() {
                    return _this._pass.createPipelineState();
                }, 1), !0);
            }
        }, {
            key: "getPipelineState",
            value: function getPipelineState() {
                return this._psos.alloc();
            }
        }, {
            key: "revertPipelineState",
            value: function revertPipelineState(pso) {
                this._psos.free(pso);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _this2 = this;
                this._material = null, this._psos && this._psos.clear(function(obj) {
                    _this2._pass.destroyPipelineState(obj);
                });
            }
        } ]), UIMaterial;
    }(), vfmt = [ {
        name: exports.GFXAttributeName.ATTR_POSITION,
        format: exports.GFXFormat.RGB32F
    }, {
        name: exports.GFXAttributeName.ATTR_TEX_COORD,
        format: exports.GFXFormat.RG32F
    }, {
        name: exports.GFXAttributeName.ATTR_COLOR,
        format: exports.GFXFormat.RGBA32F
    } ], UIDrawBatch = function() {
        function UIDrawBatch() {
            _classCallCheck(this, UIDrawBatch), this.camera = null, this.bufferBatch = null, 
            this.model = null, this.material = null, this.texView = null, this.firstIdx = 0, 
            this.idxCount = 0, this.pipelineState = null, this.bindingLayout = null, this.useLocalData = null;
        }
        return _createClass(UIDrawBatch, [ {
            key: "destroy",
            value: function destroy(ui) {
                this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
                this.pipelineState = null), this.bindingLayout && (this.bindingLayout = null);
            }
        }, {
            key: "clear",
            value: function clear(ui) {
                this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
                this.pipelineState = null), this.camera = null, this.bufferBatch = null, this.material = null, 
                this.texView = null, this.firstIdx = 0, this.idxCount = 0, this.model = null;
            }
        } ]), UIDrawBatch;
    }(), UI = function() {
        function UI(_root) {
            var _this = this;
            _classCallCheck(this, UI), this._root = _root, this.device = void 0, this._screens = [], 
            this._debugScreen = null, this._bufferBatchPool = new RecyclePool(function() {
                return new MeshBuffer(_this);
            }, 128), this._drawBatchPool = new Pool$1(function() {
                return new UIDrawBatch();
            }, 128), this._cmdBuff = null, this._scene = void 0, this._attributes = [], this._meshBuffers = [], 
            this._meshBufferUseCount = 0, this._uiMaterials = new Map(), this._batches = void 0, 
            this._sortChildList = new Pool$1(function() {
                return [];
            }, 128), this._uiModelPool = null, this._modelInUse = void 0, this._emptyMaterial = Material.getInstantiatedMaterial(new Material(), new cc.RenderableComponent(), !1), 
            this._currMeshBuffer = null, this._currMaterial = this._emptyMaterial, this._currTexView = null, 
            this._currCanvas = -1, this.device = _root.device, this._scene = this._root.createScene({
                name: "GUIScene"
            }), this._uiModelPool = new Pool$1(function() {
                return _this._scene.createModel(UIBatchModel, null);
            }, 2), this._modelInUse = new CachedArray(10), this._batches = new CachedArray(64), 
            cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.update, this);
        }
        return _createClass(UI, [ {
            key: "renderScene",
            get: function get() {
                return this._scene;
            }
        }, {
            key: "currBufferBatch",
            get: function get() {
                return this._currMeshBuffer;
            }
        }, {
            key: "debugScreen",
            get: function get() {
                return this._debugScreen;
            },
            set: function set(value) {
                this._debugScreen = value, this._debugScreen && this._debugScreen.camera && (this._debugScreen.camera.view.visibility = this._screens.length + 1);
            }
        } ]), _createClass(UI, [ {
            key: "initialize",
            value: function initialize() {
                return this._attributes = vfmt, this._requireBufferBatch(), this._cmdBuff = this.device.createCommandBuffer({
                    allocator: this.device.commandAllocator,
                    type: GFXCommandBufferType.PRIMARY
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._destroyUIMaterials();
                var _iterator = this._batches.array, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.destroy(this);
                }
                var _iterator2 = this._meshBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.destroy();
                }
                this._meshBuffers.splice(0);
                for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                    result.value.destroy(), result = matIter.next();
                }
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "getRenderSceneGetter",
            value: function getRenderSceneGetter() {
                return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "renderScene").get.bind(this);
            }
        }, {
            key: "_getUIMaterial",
            value: function _getUIMaterial(mat) {
                if (this._uiMaterials.has(mat.hash)) return this._uiMaterials.get(mat.hash);
                var uiMat = new UIMaterial();
                return uiMat.initialize({
                    material: mat
                }), this._uiMaterials.set(mat.hash, uiMat), uiMat;
            }
        }, {
            key: "_removeUIMaterial",
            value: function _removeUIMaterial(hash) {
                this._uiMaterials.has(hash) && this._uiMaterials.delete(hash);
            }
        }, {
            key: "addScreen",
            value: function addScreen(comp) {
                this._screens.push(comp), comp.camera && (comp.camera.view.visibility = this._screens.length), 
                this._debugScreen && this._debugScreen.camera && (this._debugScreen.camera.view.visibility = this._screens.length + 1);
            }
        }, {
            key: "getScreen",
            value: function getScreen(visibility) {
                var _iterator3 = this._screens, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var screen = _ref3;
                    if (screen.camera && screen.camera.view.visibility === visibility) return screen;
                }
                return this._debugScreen && this._debugScreen.camera && this._debugScreen.camera.view.visibility === visibility ? this._debugScreen : null;
            }
        }, {
            key: "removeScreen",
            value: function removeScreen(comp) {
                var idx = this._screens.indexOf(comp);
                if (-1 !== idx) {
                    var camera;
                    this._screens.splice(idx, 1), this._debugScreen && this._debugScreen.camera && (this._debugScreen.camera.view.visibility = this._screens.length + 1);
                    for (var i = idx; i < this._screens.length; i++) (camera = this._screens[i].camera) && (camera.view.visibility = i);
                }
            }
        }, {
            key: "update",
            value: function update(dt) {
                if (this._renderScreens(), 0 < this._batches.length) {
                    var _iterator4 = this._meshBuffers, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        var bufferBatch = _ref4;
                        bufferBatch.uploadData(), bufferBatch.reset();
                    }
                }
                this.render(), this._reset();
            }
        }, {
            key: "render",
            value: function render() {
                for (var batchPriority = 0, i = 0; i < this._modelInUse.length; i++) this._modelInUse.get(i).enabled = !1, 
                this._uiModelPool.free(this._modelInUse.get(i));
                if (this._modelInUse.clear(), this._batches.length) for (var _i5 = 0; _i5 < this._batches.length; ++_i5) {
                    var batch = this._batches.array[_i5];
                    if (batch.model) {
                        batch.camera && (batch.model.viewID = batch.camera.view.visibility);
                        for (var j = 0; j < batch.model.subModelNum; j++) batch.model.getSubModel(j).priority = batchPriority++;
                    } else {
                        var bindingLayout = batch.bindingLayout;
                        bindingLayout.bindTextureView(0, batch.texView), bindingLayout.update();
                        var ia = batch.bufferBatch.ia;
                        ia.firstIndex = batch.firstIdx, ia.indexCount = batch.idxCount;
                        var uiModel = this._uiModelPool.alloc();
                        uiModel.initialize(ia, batch), uiModel.enabled = !0, uiModel.getSubModel(0).priority = batchPriority++, 
                        batch.camera && (uiModel.viewID = batch.camera.view.visibility), this._modelInUse.push(uiModel);
                    }
                }
            }
        }, {
            key: "commitComp",
            value: function commitComp(comp) {
                var frame = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null, assembler = 2 < arguments.length ? arguments[2] : void 0, renderComp = comp, texView = frame;
                this._currMaterial.hash === renderComp.material.hash && this._currTexView === texView && this._currCanvas === renderComp.visibility || (this.autoMergeBatches(), 
                this._currMaterial = renderComp.material, this._currTexView = texView, this._currCanvas = renderComp.visibility), 
                assembler && assembler.fillBuffers(renderComp, this);
            }
        }, {
            key: "commitModel",
            value: function commitModel(comp, model, mat) {
                if ((this._currMaterial !== this._emptyMaterial && this.autoMergeBatches(), mat) && (StencilManager.sharedManager.handleMaterial(mat) && model)) for (var i = 0; i < model.subModelNum; i++) model.setSubModelMaterial(i, mat);
                var uiCanvas = this.getScreen(comp.visibility), curDrawBatch = this._drawBatchPool.alloc();
                curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.model = model, curDrawBatch.bufferBatch = null, 
                curDrawBatch.material = mat, curDrawBatch.texView = null, curDrawBatch.firstIdx = 0, 
                curDrawBatch.idxCount = 0, curDrawBatch.pipelineState = null, curDrawBatch.bindingLayout = null, 
                this._currMaterial = this._emptyMaterial, this._currTexView = null, this._currCanvas = comp.visibility, 
                this._batches.push(curDrawBatch);
            }
        }, {
            key: "autoMergeBatches",
            value: function autoMergeBatches() {
                var mat = this._currMaterial, buffer = this._currMeshBuffer, indicsStart = buffer.indiceStart, vCount = buffer.indiceOffset - indicsStart;
                if (vCount && mat) {
                    var uiCanvas = this.getScreen(this._currCanvas);
                    StencilManager.sharedManager.handleMaterial(mat);
                    var curDrawBatch = this._drawBatchPool.alloc();
                    curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.bufferBatch = this._currMeshBuffer, 
                    curDrawBatch.material = mat, curDrawBatch.texView = this._currTexView, curDrawBatch.firstIdx = indicsStart, 
                    curDrawBatch.idxCount = vCount, curDrawBatch.pipelineState = this._getUIMaterial(mat).getPipelineState(), 
                    curDrawBatch.bindingLayout = curDrawBatch.pipelineState.pipelineLayout.layouts[0], 
                    this._batches.push(curDrawBatch), buffer.vertexStart = buffer.vertexOffset, buffer.indiceStart = buffer.indiceOffset, 
                    buffer.byteStart = buffer.byteOffset;
                }
            }
        }, {
            key: "forceMergeBatches",
            value: function forceMergeBatches(material, sprite) {
                this._currMaterial = material, this._currTexView = sprite, this.autoMergeBatches();
            }
        }, {
            key: "_deleteUIMaterial",
            value: function _deleteUIMaterial(mat) {
                this._uiMaterials.has(mat.hash) && (this._uiMaterials.get(mat.hash).destroy(), this._uiMaterials.delete(mat.hash));
            }
        }, {
            key: "_destroyUIMaterials",
            value: function _destroyUIMaterials() {
                for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                    console.log("111111111"), result.value.destroy(), result = matIter.next();
                }
                this._uiMaterials.clear();
            }
        }, {
            key: "_walk",
            value: function _walk(node, fn1, fn2) {
                var resortNodeList, level = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0, len = node.childrenCount;
                if (fn1(node), 0 < len) {
                    var _iterator5 = resortNodeList = this._defineNodeOrder(node), _isArray5 = Array.isArray(_iterator5), _i6 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i6 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i6++];
                        } else {
                            if ((_i6 = _iterator5.next()).done) break;
                            _ref5 = _i6.value;
                        }
                        var comp = _ref5;
                        this._walk(comp, fn1, fn2, level);
                    }
                    this._sortChildList.free(resortNodeList);
                }
                fn2(node), level += 1;
            }
        }, {
            key: "_defineNodeOrder",
            value: function _defineNodeOrder(node) {
                var sortList = this._sortChildList.alloc();
                return (sortList = node.children.slice()).sort(function(a, b) {
                    var aComp = a.getComponent(UIComponent), bComp = b.getComponent(UIComponent);
                    return (aComp ? aComp.priority : 0) - (bComp ? bComp.priority : 0);
                }), sortList;
            }
        }, {
            key: "_renderScreens",
            value: function _renderScreens() {
                var _iterator6 = this._screens, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i7 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i7++];
                    } else {
                        if ((_i7 = _iterator6.next()).done) break;
                        _ref6 = _i7.value;
                    }
                    var screen = _ref6;
                    screen.enabledInHierarchy && this._recursiveScreenNode(screen.node);
                }
                this._debugScreen && this._debugScreen.enabledInHierarchy && this._recursiveScreenNode(this._debugScreen.node);
            }
        }, {
            key: "_recursiveScreenNode",
            value: function _recursiveScreenNode(screen) {
                var _this2 = this;
                this._walk(screen, function(c) {
                    var render = c.getComponent(UIComponent);
                    render && render.enabledInHierarchy && render.updateAssembler(_this2);
                }, function(c) {
                    var render = c.getComponent(UIComponent);
                    render && render.enabledInHierarchy && render.postUpdateAssembler(_this2);
                }), this.autoMergeBatches();
            }
        }, {
            key: "_reset",
            value: function _reset() {
                for (var i = 0; i < this._batches.length; ++i) {
                    var batch = this._batches.array[i];
                    batch.clear(this), this._drawBatchPool.free(batch);
                }
                this._batches.clear(), this._currMaterial = this._emptyMaterial, this._currCanvas = -1, 
                this._currTexView = null, this._meshBufferUseCount = 0, this._requireBufferBatch(), 
                StencilManager.sharedManager.reset();
            }
        }, {
            key: "_createMeshBuffer",
            value: function _createMeshBuffer() {
                var batch = this._bufferBatchPool.add();
                return batch.initialize(this._attributes, this._requireBufferBatch.bind(this)), 
                this._meshBuffers.push(batch), batch;
            }
        }, {
            key: "_requireBufferBatch",
            value: function _requireBufferBatch() {
                this._meshBufferUseCount >= this._meshBuffers.length ? this._currMeshBuffer = this._createMeshBuffer() : this._currMeshBuffer = this._meshBuffers[this._meshBufferUseCount], 
                this._meshBufferUseCount++, 2 === arguments.length && this._currMeshBuffer.request(arguments[0], arguments[1]);
            }
        } ]), UI;
    }(), Aim = function Aim(i, x, y) {
        _classCallCheck(this, Aim), this.i = void 0, this.x = void 0, this.y = void 0, this.prev = null, 
        this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, 
        this.i = i, this.x = x, this.y = y;
    };
    function linkedList(datas, start, end, dim, clockwise) {
        var i = 0, last = null;
        if (clockwise === 0 < function signedArea(datas, start, end, dim) {
            for (var sum = 0, i = start, j = end - dim; i < end; i += dim) sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]), 
            j = i;
            return sum;
        }(datas, start, end, dim)) for (i = start; i < end; i += dim) last = insertNode(i, datas[i], datas[i + 1], last); else for (i = end - dim; start <= i; i -= dim) last = insertNode(i, datas[i], datas[i + 1], last);
        return last && equals$1(last, last.next) && (removeNode(last), last = last.next), 
        last;
    }
    function filterPoints(start) {
        var end = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
        if (!start) return start;
        end || (end = start);
        var p = start, again = !1;
        do {
            if (again = !1, p.steiner || !equals$1(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
                if (removeNode(p), (p = end = p.prev) === p.next) return null;
                again = !0;
            }
        } while (again || p !== end);
        return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, size) {
        var pass = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0;
        if (ear) {
            !pass && size && function indexCurve(start, minX, minY, size) {
                var p = start;
                for (;null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size)), p.prevZ = p.prev, 
                p.nextZ = p.next, p = p.next, p !== start; ) ;
                p.prevZ.nextZ = null, p.prevZ = null, function sortLinked(list) {
                    var i = 0, p = null, q = null, e = null, tail = null, numMerges = 0, pSize = 0, qSize = 0, inSize = 1;
                    do {
                        for (p = list, tail = list = null, numMerges = 0; p; ) {
                            for (numMerges++, q = p, i = pSize = 0; i < inSize && (pSize++, q = q.nextZ); i++) ;
                            for (qSize = inSize; 0 < pSize || 0 < qSize && q; ) 0 === pSize ? (q = (e = q).nextZ, 
                            qSize--) : 0 !== qSize && q ? p.z <= q.z ? (p = (e = p).nextZ, pSize--) : (q = (e = q).nextZ, 
                            qSize--) : (p = (e = p).nextZ, pSize--), tail ? tail.nextZ = e : list = e, e.prevZ = tail, 
                            tail = e;
                            p = q;
                        }
                        tail.nextZ = null, inSize *= 2;
                    } while (1 < numMerges);
                    return list;
                }(p);
            }(ear, minX, minY, size);
            for (var stop = ear, prev = null, next = null; ear.prev !== ear.next; ) if (prev = ear.prev, 
            next = ear.next, size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) triangles.push(prev.i / dim), 
            triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, 
            stop = next.next; else if ((ear = next) === stop) {
                pass ? 1 === pass ? earcutLinked(ear = cureLocalIntersections(ear, triangles, dim), triangles, dim, minX, minY, size, 2) : 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                break;
            }
        }
    }
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (0 <= area(a, b, c)) return !1;
        for (var p = ear.next.next; p !== ear.prev; ) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
            p = p.next;
        }
        return !0;
    }
    function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev, b = ear, c = ear.next;
        if (0 <= area(a, b, c)) return !1;
        for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size), p = ear.nextZ; p && p.z <= maxZ; ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
            p = p.nextZ;
        }
        for (p = ear.prevZ; p && p.z >= minZ; ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && 0 <= area(p.prev, p, p.next)) return !1;
            p = p.prevZ;
        }
        return !0;
    }
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            !equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), 
            triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), 
            p = start = b), p = p.next;
        } while (p !== start);
        return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, size) {
        var a = start;
        do {
            for (var b = a.next.next; b !== a.prev; ) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, size), 
                    void earcutLinked(c, triangles, dim, minX, minY, size);
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
        if (outerNode = function findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -1 / 0, m = null;
            do {
                if (hy <= p.y && hy >= p.next.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && qx < x) {
                        if ((qx = x) === hx) {
                            if (hy === p.y) return p;
                            if (hy === p.next.y) return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m) return null;
            if (hx === qx) return m.prev;
            var tan, stop = m, mx = m.x, my = m.y, tanMin = 1 / 0;
            p = m.next;
            for (;p !== stop; ) hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole) && (m = p, 
            tanMin = tan), p = p.next;
            return m;
        }(hole, outerNode)) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    function zOrder(x, y, minX, minY, size) {
        return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) / size) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) / size) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
    }
    function getLeftmost(start) {
        for (var p = start, leftmost = start; p.x < leftmost.x && (leftmost = p), (p = p.next) !== start; ) ;
        return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return 0 <= (cx - px) * (ay - py) - (ax - px) * (cy - py) && 0 <= (ax - px) * (by - py) - (bx - px) * (ay - py) && 0 <= (bx - px) * (cy - py) - (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !function intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
                p = p.next;
            } while (p !== a);
            return !1;
        }(a, b) && locallyInside(a, b) && locallyInside(b, a) && function middleInside(a, b) {
            var p = a, inside = !1, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            for (;p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), 
            p = p.next, p !== a; ) ;
            return inside;
        }(a, b);
    }
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals$1(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
        return !!(equals$1(p1, q1) && equals$1(p2, q2) || equals$1(p1, q2) && equals$1(p2, q1)) || 0 < area(p1, q1, p2) != 0 < area(p1, q1, q2) && 0 < area(p2, q2, p1) != 0 < area(p2, q2, q1);
    }
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? 0 <= area(a, b, a.next) && 0 <= area(a, a.prev, b) : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function splitPolygon(a, b) {
        var a2 = new Aim(a.i, a.x, a.y), b2 = new Aim(b.i, b.x, b.y), an = a.next, bp = b.prev;
        return (a.next = b).prev = a, (a2.next = an).prev = a2, (b2.next = a2).prev = b2, 
        (bp.next = b2).prev = bp, b2;
    }
    function insertNode(i, x, y, last) {
        var p = new Aim(i, x, y);
        return last ? (p.next = last.next, (p.prev = last).next.prev = p, last.next = p) : (p.prev = p).next = p, 
        p;
    }
    function removeNode(p) {
        p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), 
        p.nextZ && (p.nextZ.prevZ = p.prevZ);
    }
    function earcut(datas, holeIndices, dim) {
        dim = dim || 3;
        var hasHoles = holeIndices ? holeIndices.length : 0, outerLen = hasHoles ? holeIndices[0] * dim : datas.length, outerNode = linkedList(datas, 0, outerLen, dim, !0), triangles = [];
        if (!outerNode) return triangles;
        var minX = 0, minY = 0, maxX = 0, maxY = 0, x = 0, y = 0, size = 0;
        if (hasHoles && (outerNode = function eliminateHoles(datas, holeIndices, outerNode, dim) {
            var len, queue = [], i = 0, list = null;
            for (i = 0, len = holeIndices.length; i < len; i++) (list = linkedList(datas, holeIndices[i] * dim, i < len - 1 ? holeIndices[i + 1] * dim : datas.length, dim, !1)) && (list === list.next && (list.steiner = !0), 
            queue.push(getLeftmost(list)));
            if (queue.sort(compareX), !outerNode) return outerNode;
            for (i = 0; i < queue.length; i++) eliminateHole(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next);
            return outerNode;
        }(datas, holeIndices, outerNode, dim)), datas.length > 80 * dim) {
            minX = maxX = datas[0], minY = maxY = datas[1];
            for (var i = dim; i < outerLen; i += dim) (x = datas[i]) < minX && (minX = x), (y = datas[i + 1]) < minY && (minY = y), 
            maxX < x && (maxX = x), maxY < y && (maxY = y);
            size = Math.max(maxX - minX, maxY - minY);
        }
        return earcutLinked(outerNode, triangles, dim, minX, minY, size), triangles;
    }
    var PI = Math.PI, min$2 = Math.min, max$3 = Math.max, cos$1 = Math.cos, sin = Math.sin, abs$1 = Math.abs, sign$1 = Math.sign, KAPPA90 = .5522847493;
    function ellipse(ctx, cx, cy, rx, ry) {
        ctx.moveTo(cx - rx, cy), ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry), 
        ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy), 
        ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry), 
        ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy), 
        ctx.close();
    }
    for (var Point = function(_Vec) {
        function Point(x, y) {
            var _this;
            return _classCallCheck(this, Point), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this, x, y))).dx = 0, 
            _this.dy = 0, _this.dmx = 0, _this.dmy = 0, _this.flags = 0, _this.len = 0, _this.reset(), 
            _this;
        }
        return _inherits(Point, Vec2), _createClass(Point, [ {
            key: "reset",
            value: function reset() {
                this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0;
            }
        } ]), Point;
    }(), Path = function() {
        function Path() {
            _classCallCheck(this, Path), this.closed = !1, this.nbevel = 0, this.complex = !0, 
            this.points = [], this.reset();
        }
        return _createClass(Path, [ {
            key: "reset",
            value: function reset() {
                this.closed = !1, this.nbevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = [];
            }
        } ]), Path;
    }(), Impl = function() {
        function Impl() {
            _classCallCheck(this, Impl), this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, 
            this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = Color.WHITE, 
            this.lineCap = LineCap.BUTT, this.strokeColor = Color.BLACK, this.lineJoin = LineJoin.MITER, 
            this.lineWidth = 0, this.pointsOffset = 0, this._commandx = 0, this._commandy = 0, 
            this._points = [], this._renderDatasPool = new RecyclePool(function() {
                return new IARenderData();
            }, 16), this._renderDatas = [], this._curPath = null;
        }
        return _createClass(Impl, [ {
            key: "moveTo",
            value: function moveTo(x, y) {
                this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), 
                this._addPath(), this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, 
                this._commandy = y;
            }
        }, {
            key: "lineTo",
            value: function lineTo(x, y) {
                this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, this._commandy = y;
            }
        }, {
            key: "bezierCurveTo",
            value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                var path = this._curPath, last = path.points[path.points.length - 1];
                last && (last.x !== c1x || last.y !== c1y || c2x !== x || c2y !== y ? (!function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
                    var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234, dx, dy, d2, d3;
                    10 < level || (x34 = .5 * (x3 + x4), y34 = .5 * (y3 + y4), x123 = .5 * ((x12 = .5 * (x1 + x2)) + (x23 = .5 * (x2 + x3))), 
                    y123 = .5 * ((y12 = .5 * (y1 + y2)) + (y23 = .5 * (y2 + y3))), ((d2 = abs$1((x2 - x4) * (dy = y4 - y1) - (y2 - y4) * (dx = x4 - x1))) + (d3 = abs$1((x3 - x4) * dy - (y3 - y4) * dx))) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy) ? ctx.addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type) : (tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234 = .5 * (x123 + (x234 = .5 * (x23 + x34))), y1234 = .5 * (y123 + (y234 = .5 * (y23 + y34))), level + 1, 0), 
                    tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type)));
                }(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER), this._commandx = x, 
                this._commandy = y) : this.lineTo(x, y));
            }
        }, {
            key: "quadraticCurveTo",
            value: function quadraticCurveTo(cx, cy, x, y) {
                var x0 = this._commandx, y0 = this._commandy;
                this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
            }
        }, {
            key: "arc",
            value: function arc$$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
                !function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
                    var hda, ndivs, a = 0, da = 0, kappa = 0, dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0, px = 0, py = 0, ptanx = 0, ptany = 0, i = 0;
                    if (da = endAngle - startAngle, counterclockwise = counterclockwise || !1) if (abs$1(da) >= 2 * PI) da = 2 * PI; else for (;da < 0; ) da += 2 * PI; else if (abs$1(da) >= 2 * PI) da = 2 * -PI; else for (;0 < da; ) da -= 2 * PI;
                    for (ndivs = 0 | max$3(1, min$2(abs$1(da) / (.5 * PI) + .5, 5)), kappa = abs$1(4 / 3 * (1 - cos$1(hda = da / ndivs / 2)) / sin(hda)), 
                    counterclockwise || (kappa = -kappa), i = 0; i <= ndivs; i++) x = cx + (dx = cos$1(a = startAngle + da * (i / ndivs))) * r, 
                    y = cy + (dy = sin(a)) * r, tanx = -dy * r * kappa, tany = dx * r * kappa, 0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y), 
                    px = x, py = y, ptanx = tanx, ptany = tany;
                }(this, cx, cy, r, startAngle, endAngle, counterclockwise);
            }
        }, {
            key: "ellipse",
            value: function ellipse$$1(cx, cy, rx, ry) {
                ellipse(this, cx, cy, rx, ry), this._curPath.complex = !1;
            }
        }, {
            key: "circle",
            value: function circle(cx, cy, r) {
                ellipse(this, cx, cy, r, r), this._curPath.complex = !1;
            }
        }, {
            key: "rect",
            value: function rect(x, y, w, h) {
                this.moveTo(x, y), this.lineTo(x + w, y), this.lineTo(x + w, y + h), this.lineTo(x, y + h), 
                this.close(), this._curPath.complex = !1;
            }
        }, {
            key: "roundRect",
            value: function roundRect$$1(x, y, w, h, r) {
                !function roundRect(ctx, x, y, w, h, r) {
                    if (r < .1) ctx.rect(x, y, w, h); else {
                        var rx = min$2(r, .5 * abs$1(w)) * sign$1(w), ry = min$2(r, .5 * abs$1(h)) * sign$1(h);
                        ctx.moveTo(x, y + ry), ctx.lineTo(x, y + h - ry), ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h), 
                        ctx.lineTo(x + w - rx, y + h), ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry), 
                        ctx.lineTo(x + w, y + ry), ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y), 
                        ctx.lineTo(x + rx, y), ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry), 
                        ctx.close();
                    }
                }(this, x, y, w, h, r), this._curPath.complex = !1;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, 
                this._curPath = null, this.paths.length = 0, this._points.length = 0, this._renderDatasPool.reset();
                for (var datas = this._renderDatas, i = 0, l = datas.length; i < l; i++) {
                    var data = datas[i];
                    data && data.reset();
                }
            }
        }, {
            key: "close",
            value: function close() {
                this._curPath.closed = !0;
            }
        }, {
            key: "requestRenderData",
            value: function requestRenderData() {
                var renderData = this._renderDatasPool.add();
                return this._renderDatas.push(renderData), renderData;
            }
        }, {
            key: "getRenderDatas",
            value: function getRenderDatas() {
                return 0 === this._renderDatas.length && this.requestRenderData(), this._renderDatas;
            }
        }, {
            key: "addPoint",
            value: function addPoint(x, y, flags) {
                var path = this._curPath;
                if (path) {
                    var points = this._points, pathPoints = path.points, pt = points[this.pointsOffset++];
                    pt ? (pt.x = x, pt.y = y) : (pt = new Point(x, y), points.push(pt)), pt.flags = flags, 
                    pathPoints.push(pt);
                }
            }
        }, {
            key: "_addPath",
            value: function _addPath() {
                var offset = this.pathLength, path = this.paths[offset];
                return path ? path.reset() : (path = new Path(), this.paths.push(path)), this.pathLength++, 
                this._curPath = path;
            }
        } ]), Impl;
    }(), PI$1 = Math.PI, min$3 = Math.min, max$4 = Math.max, ceil = Math.ceil, acos$1 = Math.acos, cos$2 = Math.cos, sin$1 = Math.sin, atan2 = Math.atan2, attrs = vfmt, positions = [], uvs = [], colors = [], indices = [], _renderData = null, _impl = null, _curColor = new Color(), vec3_temps = [], i$2 = 0; i$2 < 4; i$2++) vec3_temps.push(new Vec3());
    function clamp$1(v, minNum, maxNum) {
        return v < minNum ? minNum : maxNum < v ? maxNum : v;
    }
    var graphicsAssembler = {
        useModel: !0,
        createImpl: function createImpl(graphics) {
            return new Impl();
        },
        updateRenderData: function updateRenderData(graphics) {
            for (var datas = graphics.impl ? graphics.impl.getRenderDatas() : [], _i = 0, l = datas.length; _i < l; _i++) datas[_i].material = graphics.material;
        },
        fillBuffers: function fillBuffers(graphics, renderer) {},
        renderIA: function renderIA(graphics, renderer) {},
        getRenderData: function getRenderData(graphics, cverts) {
            if (!_impl) return null;
            var renderDatas = _impl.getRenderDatas(), renderData = renderDatas[_impl.dataOffset];
            if (!renderData) return null;
            var meshbuffer = renderData, maxVertsCount = meshbuffer ? meshbuffer.vertexCount + cverts : 0;
            return (65535 < maxVertsCount || 131070 < 3 * maxVertsCount) && (++_impl.dataOffset, 
            _impl.dataOffset < renderDatas.length ? renderData = renderDatas[_impl.dataOffset] : (renderData = _impl.requestRenderData(), 
            renderDatas[_impl.dataOffset] = renderData), renderData.material = graphics.material, 
            meshbuffer = renderData), meshbuffer && meshbuffer.vertexCount < maxVertsCount && meshbuffer.request(cverts, 3 * cverts), 
            renderData;
        },
        stroke: function stroke(graphics) {
            color4.copy(_curColor, graphics.strokeColor), graphics.impl && (this._flattenPaths(graphics.impl), 
            this._expandStroke(graphics), graphics.impl.updatePathOffset = !0, this.end(graphics));
        },
        fill: function fill(graphics) {
            color4.copy(_curColor, graphics.fillColor), this._expandFill(graphics), graphics.impl && (graphics.impl.updatePathOffset = !0), 
            this.end(graphics);
        },
        end: function end(graphics) {
            var scene = cc.director.root.ui.renderScene;
            graphics.model && (graphics.model.destroy(), scene.destroyModel(graphics.model), 
            graphics.model = null);
            var impl = graphics.impl, primitiveMode = exports.GFXPrimitiveMode.TRIANGLE_LIST, renderDatas = impl && impl.getRenderDatas();
            renderDatas || (renderDatas = []);
            var i = 0;
            positions.length = 0, uvs.length = 0, colors.length = 0, indices.length = 0;
            var _iterator = renderDatas, _isArray = Array.isArray(_iterator), _i2 = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i2 >= _iterator.length) break;
                    _ref = _iterator[_i2++];
                } else {
                    if ((_i2 = _iterator.next()).done) break;
                    _ref = _i2.value;
                }
                var renderData = _ref, len = renderData.byteCount >> 2, vData = renderData.vData;
                for (i = 0; i < len; ) positions.push(vData[i++]), positions.push(vData[i++]), positions.push(vData[i++]), 
                uvs.push(vData[i++]), uvs.push(vData[i++]), colors.push(vData[i++]), colors.push(vData[i++]), 
                colors.push(vData[i++]), colors.push(vData[i++]);
                len = renderData.indiceCount;
                var iData = renderData.iData;
                for (i = 0; i < len; ) indices.push(iData[i++]);
            }
            var mesh = createMesh({
                primitiveMode: primitiveMode,
                positions: positions,
                uvs: uvs,
                colors: colors,
                attributes: attrs,
                indices: indices
            }, void 0, {
                calculateBounds: !1
            });
            graphics.model = scene.createModel(Model, graphics.node), graphics.model.initSubModel(0, mesh.getSubMesh(0), graphics.material), 
            graphics.model.enabled = !0;
        },
        _expandStroke: function _expandStroke(graphics) {
            var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
            if (_impl = graphics.impl) {
                var ncap = function curveDivs(r, arc, tol) {
                    var da = 2 * acos$1(r / (r + tol));
                    return max$4(2, ceil(arc / da));
                }(w, PI$1, _impl.tessTol);
                this._calculateJoins(_impl, w, lineJoin, miterLimit);
                for (var paths = _impl.paths, cverts = 0, _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
                    var path = paths[_i3], pointsLength = path.points.length;
                    lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1), 
                    path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
                }
                var meshbuffer = _renderData = this.getRenderData(graphics, cverts);
                if (meshbuffer) {
                    for (var vData = meshbuffer.vData, iData = meshbuffer.iData, _i4 = _impl.pathOffset, _l = _impl.pathLength; _i4 < _l; _i4++) {
                        var _path = paths[_i4], pts = _path.points, _pointsLength = pts.length, offset = meshbuffer.vertexStart, p0 = void 0, p1 = void 0, start = 0, end = 0, loop = _path.closed;
                        if (end = loop ? (p0 = pts[_pointsLength - 1], p1 = pts[0], start = 0, _pointsLength) : (p0 = pts[0], 
                        p1 = pts[1], _pointsLength - (start = 1)), !loop) {
                            var dPos = p1.sub(p0);
                            dPos.normalizeSelf();
                            var dx = dPos.x, dy = dPos.y;
                            lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
                        }
                        for (var j = start; j < end; ++j) lineJoin === LineJoin.ROUND ? this._roundJoin(p0, p1, w, w, ncap) : 0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) ? this._bevelJoin(p0, p1, w, w) : (this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w), 
                        this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w)), p0 = p1, p1 = pts[j + 1];
                        if (loop) {
                            var vDataoOfset = 9 * offset, data = vData.slice(vDataoOfset, vDataoOfset + 9);
                            vData.set(data, 9 * meshbuffer.vertexStart), vDataoOfset += 9, meshbuffer.vertexStart++, 
                            data = vData.slice(vDataoOfset, vDataoOfset + 9), vData.set(data, 9 * meshbuffer.vertexStart), 
                            meshbuffer.vertexStart++;
                        } else {
                            var _dPos = p1.sub(p0);
                            _dPos.normalizeSelf();
                            var _dx = _dPos.x, _dy = _dPos.y;
                            lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
                        }
                        for (var indicesOffset = meshbuffer.indiceStart, begin = offset + 2, over = meshbuffer.vertexStart; begin < over; begin++) iData[indicesOffset++] = begin - 2, 
                        iData[indicesOffset++] = begin - 1, iData[indicesOffset++] = begin;
                        if ((meshbuffer.indiceStart = indicesOffset) !== meshbuffer.indiceCount) {
                            var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                            meshbuffer.iData.set(arr, indicesOffset);
                        }
                    }
                    _impl = _renderData = null;
                }
            }
        },
        _expandFill: function _expandFill(graphics) {
            if (_impl = graphics.impl) {
                for (var paths = _impl.paths, cverts = 0, _i5 = _impl.pathOffset, l = _impl.pathLength; _i5 < l; _i5++) {
                    cverts += paths[_i5].points.length;
                }
                var renderData = _renderData = this.getRenderData(graphics, cverts);
                if (renderData) {
                    for (var meshbuffer = renderData, vData = meshbuffer.vData, iData = meshbuffer.iData, _i6 = _impl.pathOffset, _l2 = _impl.pathLength; _i6 < _l2; _i6++) {
                        var _path2 = paths[_i6], pts = _path2.points, _pointsLength2 = pts.length;
                        if (0 !== _pointsLength2) {
                            for (var vertexOffset = renderData.vertexStart, j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
                            var indicesOffset = renderData.indiceStart;
                            if (_path2.complex) {
                                for (var earcutData = [], _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                                    var vDataOffset = 9 * _j;
                                    earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]);
                                }
                                var newIndices = earcut(earcutData, null, 3);
                                if (!newIndices || 0 === newIndices.length) continue;
                                for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                            } else for (var first = vertexOffset, start = vertexOffset + 2, _end = meshbuffer.vertexStart; start < _end; start++) iData[indicesOffset++] = first, 
                            iData[indicesOffset++] = start - 1, iData[indicesOffset++] = start;
                            if ((meshbuffer.indiceStart = indicesOffset) !== meshbuffer.indiceCount) {
                                var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                                meshbuffer.iData.set(arr, indicesOffset);
                            }
                        }
                    }
                    _impl = _renderData = null;
                }
            }
        },
        _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
            var iw = 0;
            0 < w && (iw = 1 / w);
            for (var paths = impl.paths, _i7 = impl.pathOffset, l = impl.pathLength; _i7 < l; _i7++) for (var path = paths[_i7], pts = path.points, ptsLength = pts.length, p0 = pts[ptsLength - 1], p1 = pts[0], j = path.nbevel = 0; j < ptsLength; j++) {
                var dmr2, limit, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
                if (p1.dmx = .5 * (dlx0 + dlx1), p1.dmy = .5 * (dly0 + dly1), 1e-6 < (dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy)) {
                    var scale = 1 / dmr2;
                    600 < scale && (scale = 600), p1.dmx *= scale, p1.dmy *= scale;
                }
                0 < p1.dx * p0.dy - p0.dx * p1.dy && (p1.flags |= PointFlags.PT_LEFT), dmr2 * (limit = max$4(11, min$3(p0.len, p1.len) * iw)) * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL), 
                p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL), 
                0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++, 
                p0 = p1, p1 = pts[j + 1];
            }
        },
        _flattenPaths: function _flattenPaths(impl) {
            for (var paths = impl.paths, _i8 = impl.pathOffset, l = impl.pathLength; _i8 < l; _i8++) {
                var path = paths[_i8], pts = path.points, p0 = pts[pts.length - 1], p1 = pts[0];
                p0.equals(p1) && (path.closed = !0, pts.pop(), p0 = pts[pts.length - 1]);
                for (var j = 0, size = pts.length; j < size; j++) {
                    var dPos = p1.sub(p0);
                    p0.len = dPos.mag(), (dPos.x || dPos.y) && dPos.normalizeSelf(), p0.dx = dPos.x, 
                    p0.dy = dPos.y, p0 = p1, p1 = pts[j + 1];
                }
            }
        },
        _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
            var x = p1.x, y = p1.y, x0 = 0, y0 = 0, x1 = 0, y1 = 0;
            return 0 !== bevel ? (x0 = x + p0.dy * w, y0 = y - p0.dx * w, x1 = x + p1.dy * w, 
            y1 = y - p1.dx * w) : (x0 = x1 = x + p1.dmx * w, y0 = y1 = y + p1.dmy * w), [ x0, y0, x1, y1 ];
        },
        _buttCap: function _buttCap(p, dx, dy, w, d) {
            var px = p.x - dx * d, py = p.y - dy * d, dlx = dy, dly = -dx;
            this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
        },
        _roundCapStart: function _roundCapStart(p, dx, dy, w, ncap) {
            for (var px = p.x, py = p.y, dlx = dy, dly = -dx, _i9 = 0; _i9 < ncap; _i9++) {
                var a = _i9 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
                this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay), this._vset(px, py);
            }
            this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
        },
        _roundCapEnd: function _roundCapEnd(p, dx, dy, w, ncap) {
            var px = p.x, py = p.y, dlx = dy, dly = -dx;
            this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
            for (var _i10 = 0; _i10 < ncap; _i10++) {
                var a = _i10 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
                this._vset(px, py), this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
            }
        },
        _roundJoin: function _roundJoin(p0, p1, lw, rw, ncap) {
            var dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx, p1x = p1.x, p1y = p1.y;
            if (0 != (p1.flags & PointFlags.PT_LEFT)) {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw), lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], a0 = atan2(-dly0, -dlx0), a1 = atan2(-dly1, -dlx1);
                a0 < a1 && (a1 -= 2 * PI$1), this._vset(lx0, ly0), this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
                for (var n = clamp$1(ceil((a0 - a1) / PI$1) * ncap, 2, ncap), _i11 = 0; _i11 < n; _i11++) {
                    var a = a0 + _i11 / (n - 1) * (a1 - a0), rx = p1x + cos$2(a) * rw, ry = p1y + sin$1(a) * rw;
                    this._vset(p1x, p1y), this._vset(rx, ry);
                }
                this._vset(lx1, ly1), this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
            } else {
                var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw), rx0 = _out[0], ry0 = _out[1], rx1 = _out[2], ry1 = _out[3], _a = atan2(dly0, dlx0), _a2 = atan2(dly1, dlx1);
                _a2 < _a && (_a2 += 2 * PI$1), this._vset(p1x + dlx0 * rw, p1y + dly0 * rw, 0), 
                this._vset(rx0, ry0, 0);
                for (var _n = clamp$1(ceil((_a2 - _a) / PI$1) * ncap, 2, ncap), _i12 = 0; _i12 < _n; _i12++) {
                    var _a3 = _a + _i12 / (_n - 1) * (_a2 - _a), lx = p1x + cos$2(_a3) * lw, ly = p1y + sin$1(_a3) * lw;
                    this._vset(lx, ly, 0), this._vset(p1x, p1y, 0);
                }
                this._vset(p1x + dlx1 * rw, p1y + dly1 * rw), this._vset(rx1, ry1);
            }
        },
        _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
            var rx0 = 0, ry0 = 0, rx1 = 0, ry1 = 0, lx0 = 0, ly0 = 0, lx1 = 0, ly1 = 0, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
            if (p1.flags & PointFlags.PT_LEFT) {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
                lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], this._vset(lx0, ly0, 0), 
                this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw, 0), this._vset(lx1, ly1, 0), this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw, 0);
            } else {
                var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
                rx0 = _out2[0], ry0 = _out2[1], rx1 = _out2[2], ry1 = _out2[3], this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw, 0), 
                this._vset(rx0, ry0), this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw, 0), this._vset(rx1, ry1);
            }
        },
        _vset: function _vset(x, y) {
            if (_renderData) {
                var meshbuffer = _renderData, dataOffset = 9 * meshbuffer.vertexStart, vData = meshbuffer.vData;
                vData[dataOffset++] = x, vData[dataOffset++] = y, vData[dataOffset++] = 0, vData[dataOffset++] = 1, 
                vData[dataOffset++] = 1, color4.array(vData, _curColor, dataOffset), meshbuffer.vertexStart++;
            }
        }
    }, graphicsAssemblerManager = {
        getAssembler: function getAssembler(sprite) {
            return graphicsAssembler;
        }
    };
    GraphicsComponent.Assembler = graphicsAssemblerManager;
    var vec3_temp = vec3.create(), _worldMatrix$2 = new Mat4();
    function fillVertices3D(node, renderer, renderData, color) {
        var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexId = indiceOffset = vertexCount = 0);
        var vbuf = buffer.vData;
        node.getWorldMatrix(_worldMatrix$2);
        for (var i = 0; i < vertexCount; i++) {
            var vert = datas[i];
            vec3.set(vec3_temp, vert.x, vert.y, 0), vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$2), 
            vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
            vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, color4.array(vbuf, color, vertexOffset), 
            vertexOffset += 4;
        }
        for (var ibuf = buffer.iData, _i2 = 0; _i2 < renderData.dataLength; _i2++) ibuf[indiceOffset + _i2] = vertexId + _i2;
    }
    function fillMeshVertices3D(node, renderer, renderData, color) {
        var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexId = indiceOffset = vertexCount = 0);
        var vbuf = buffer.vData, ibuf = buffer.iData;
        node.getWorldMatrix(_worldMatrix$2);
        for (var i = 0; i < vertexCount; i++) {
            var vert = datas[i];
            vec3.set(vec3_temp, vert.x, vert.y, 0), vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$2), 
            vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
            vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, color4.array(vbuf, color, vertexOffset), 
            vertexOffset += 4;
        }
        for (var _i3 = 0, count = vertexCount / 4; _i3 < count; _i3++) {
            var start = vertexId + 4 * _i3;
            ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 2, 
            ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 3, ibuf[indiceOffset++] = start + 2;
        }
    }
    function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
        var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexId = indiceOffset = vertexCount = 0);
        for (var vbuf = buffer.vData, i = 0; i < vertexCount; i++) {
            var vert = datas[i];
            vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
            vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, color4.array(vbuf, color, vertexOffset), 
            vertexOffset += 4;
        }
        var ibuf = buffer.iData;
        ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
        ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2;
    }
    var FontLetterDefinition = function FontLetterDefinition() {
        _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.width = 0, 
        this.height = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.validDefinition = !1, 
        this.xAdvance = 0;
    }, FontAtlas = function() {
        function FontAtlas(fntConfig) {
            _classCallCheck(this, FontAtlas), this._letterDefinitions = {};
        }
        return _createClass(FontAtlas, [ {
            key: "letterDefinitions",
            get: function get() {
                return this._letterDefinitions;
            }
        } ]), _createClass(FontAtlas, [ {
            key: "addLetterDefinitions",
            value: function addLetterDefinitions(letter, letterDefinition) {
                this._letterDefinitions[letter] = letterDefinition;
            }
        }, {
            key: "cloneLetterDefinition",
            value: function cloneLetterDefinition() {
                for (var copyLetterDefinitions = {}, _arr = Object.keys(this._letterDefinitions), _i = 0; _i < _arr.length; _i++) {
                    var _key = _arr[_i], value = new FontLetterDefinition();
                    cc.js.mixin(value, this._letterDefinitions[_key]), copyLetterDefinitions[_key] = value;
                }
                return copyLetterDefinitions;
            }
        }, {
            key: "assignLetterDefinitions",
            value: function assignLetterDefinitions(letterDefinition) {
                for (var _arr2 = Object.keys(this._letterDefinitions), _i2 = 0; _i2 < _arr2.length; _i2++) {
                    var _key2 = _arr2[_i2], newValue = letterDefinition[_key2], oldValue = this._letterDefinitions[_key2];
                    cc.js.mixin(oldValue, newValue);
                }
            }
        }, {
            key: "scaleFontLetterDefinition",
            value: function scaleFontLetterDefinition(scaleFactor) {
                for (var _arr3 = Object.keys(this._letterDefinitions), _i3 = 0; _i3 < _arr3.length; _i3++) {
                    var fontDefinition = _arr3[_i3], letterDefinitions = this._letterDefinitions[fontDefinition];
                    letterDefinitions.width *= scaleFactor, letterDefinitions.height *= scaleFactor, 
                    letterDefinitions.offsetX *= scaleFactor, letterDefinitions.offsetY *= scaleFactor, 
                    letterDefinitions.xAdvance *= scaleFactor;
                }
            }
        }, {
            key: "getLetterDefinitionForChar",
            value: function getLetterDefinitionForChar(char) {
                return this._letterDefinitions.hasOwnProperty(char.charCodeAt(0)) ? this._letterDefinitions[char.charCodeAt(0)] : null;
            }
        } ]), FontAtlas;
    }();
    cc.FontAtlas = FontAtlas;
    var LetterInfo = function LetterInfo() {
        _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.positionX = 0, 
        this.positionY = 0, this.lineIndex = 0;
    }, _tmpRect = new Rect(), _comp = null, _horizontalKernings = [], _lettersInfo = [], _linesWidth = [], _linesOffsetX = [], _labelDimensions = new Size(), _fontAtlas = null, _fntConfig = null, _numberOfLines = 0, _textDesiredHeight = 0, _letterOffsetY = 0, _tailoredTopY = 0, _tailoredBottomY = 0, _bmfontScale = 1, _spriteFrame = null, _string = "", _fontSize$1 = 0, _originFontSize = 0, _contentSize = new Size(), _hAlign = 0, _vAlign = 0, _spacingX = 0, _lineHeight = 0, _overflow = 0, _isWrapText = !1, _labelWidth = 0, _labelHeight = 0, _maxLineWidth = 0, bmfontUtils = {
        updateRenderData: function updateRenderData(comp) {
            comp.renderData && comp.renderData.vertDirty && _comp !== comp && (_comp = comp, 
            this._updateProperties(), this._updateContent(), _comp.actualFontSize = _fontSize$1, 
            _comp.node.setContentSize(_contentSize), _comp.renderData.vertDirty = _comp.renderData.uvDirty = !1, 
            _comp = null, this._resetProperties());
        },
        _updateFontScale: function _updateFontScale() {
            _bmfontScale = _fontSize$1 / _originFontSize;
        },
        _updateProperties: function _updateProperties() {
            if (_comp) {
                var fontAsset = _comp.font;
                if (fontAsset) {
                    if (_spriteFrame = fontAsset.spriteFrame, _fntConfig = fontAsset.fntConfig, !(_fontAtlas = _comp.fontAtlas)) {
                        _fontAtlas = new FontAtlas(_fntConfig);
                        for (var fontDict = _fntConfig.fontDefDictionary, _arr4 = Object.keys(fontDict), _i4 = 0; _i4 < _arr4.length; _i4++) {
                            var fontDef = _arr4[_i4], letterDefinition = new FontLetterDefinition(), rect = fontDict[fontDef].rect;
                            letterDefinition.offsetX = fontDict[fontDef].xOffset, letterDefinition.offsetY = fontDict[fontDef].yOffset, 
                            letterDefinition.width = rect.width, letterDefinition.height = rect.height, letterDefinition.u = rect.x, 
                            letterDefinition.v = rect.y, letterDefinition.textureID = 0, letterDefinition.validDefinition = !0, 
                            letterDefinition.xAdvance = fontDict[fontDef].xAdvance, _fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                        }
                        _comp.fontAtlas = _fontAtlas;
                    }
                    _string = _comp.string.toString(), _fontSize$1 = _comp.fontSize, _originFontSize = _fntConfig.fontSize;
                    var contentSize = _comp.node.getContentSize();
                    _contentSize.width = contentSize.width, _contentSize.height = contentSize.height, 
                    _hAlign = _comp.horizontalAlign, _vAlign = _comp.verticalAlign, _spacingX = _comp.spacingX, 
                    _overflow = _comp.overflow, _lineHeight = _comp.lineHeight, _isWrapText = _overflow !== exports.Overflow.NONE && (_overflow === exports.Overflow.RESIZE_HEIGHT || _comp.enableWrapText), 
                    this._setupBMFontOverflowMetrics();
                }
            }
        },
        _resetProperties: function _resetProperties() {
            _spriteFrame = _fntConfig = _fontAtlas = null;
        },
        _updateContent: function _updateContent() {
            this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
            for (var string = _string, stringLen = string.length, kerningDict = _fntConfig.kerningDict, horizontalKernings = _horizontalKernings, prev = -1, i = 0; i < stringLen; ++i) {
                var _key3 = string.charCodeAt(i), kerningAmount = kerningDict[prev << 16 | 65535 & _key3] || 0;
                horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0, prev = _key3;
            }
        },
        _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
            var textLen = _string.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2();
            this._updateFontScale();
            for (var letterDefinitions = _fontAtlas.letterDefinitions, index = 0; index < textLen; ) {
                var character = _string.charAt(index);
                if ("\n" !== character) {
                    for (var tokenLen = nextTokenFunc(_string, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                        var letterIndex = index + tmp;
                        if ("\r" !== (character = _string.charAt(letterIndex))) if (letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)) {
                            var letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
                            if (_isWrapText && 0 < _maxLineWidth && 0 < nextTokenX && letterX + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                                _linesWidth.push(letterRight), lineIndex++, nextTokenY -= _lineHeight * _bmfontScale + (nextTokenX = letterRight = 0), 
                                newLine = !0;
                                break;
                            }
                            letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale, 
                            this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex), 
                            letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]), 
                            nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, tokenRight = letterPosition.x + letterDef.width * _bmfontScale, 
                            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.height * _bmfontScale);
                        } else this._recordPlaceholderInfo(letterIndex, character), console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character); else this._recordPlaceholderInfo(letterIndex, character);
                    }
                    newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                    tokenLowestY < lowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                    index += tokenLen);
                } else _linesWidth.push(letterRight), lineIndex++, nextTokenY -= _lineHeight * _bmfontScale + (nextTokenX = letterRight = 0), 
                this._recordPlaceholderInfo(index, character), index++;
            }
            return _linesWidth.push(letterRight), _textDesiredHeight = (_numberOfLines = lineIndex + 1) * _lineHeight * _bmfontScale, 
            1 < _numberOfLines && (_textDesiredHeight += 0 * (_numberOfLines - 1)), _contentSize.width = _labelWidth, 
            _contentSize.height = _labelHeight, _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2))), 
            _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2))), 
            _tailoredTopY = _contentSize.height, (_tailoredBottomY = 0) < highestY && (_tailoredTopY = _contentSize.height + highestY), 
            lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY), 
            !0;
        },
        _getFirstCharLen: function _getFirstCharLen() {
            return 1;
        },
        _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
            var character = text.charAt(startIndex);
            if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
            var len = 1, letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character);
            if (!letterDef) return len;
            for (var nextLetterX = letterDef._xAdvance * _bmfontScale + _spacingX, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
            letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)); ++index) {
                if (nextLetterX + letterDef._offsetX * _bmfontScale + letterDef._width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && 0 < _maxLineWidth) return len;
                if (nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                len++;
            }
            return len;
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
            return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
            return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, char) {
            if (letterIndex >= _lettersInfo.length) {
                var tmpInfo = new LetterInfo();
                _lettersInfo.push(tmpInfo);
            }
            _lettersInfo[letterIndex].char = char, _lettersInfo[letterIndex].valid = !1;
        },
        _recordLetterInfo: function _recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
            if (letterIndex >= _lettersInfo.length) {
                var tmpInfo = new LetterInfo();
                _lettersInfo.push(tmpInfo);
            }
            var cIndex = character.charCodeAt(0);
            _lettersInfo[letterIndex].lineIndex = lineIndex, _lettersInfo[letterIndex].char = character, 
            _lettersInfo[letterIndex].valid = letterDefinitions[cIndex].validDefinition, _lettersInfo[letterIndex].positionX = letterPosition.x, 
            _lettersInfo[letterIndex].positionY = letterPosition.y;
        },
        _alignText: function _alignText() {
            _textDesiredHeight = 0, _linesWidth.length = 0, this._multilineTextWrapByWord(), 
            this._computeAlignmentOffset(), _overflow === exports.Overflow.SHRINK && 0 < _fontSize$1 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), 
            this._updateQuads() || _overflow === exports.Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
            var shouldUpdateContent = !0;
            fontSize || (shouldUpdateContent = !(fontSize = .1)), _fontSize$1 = fontSize, shouldUpdateContent && this._updateContent();
        },
        _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
            for (var fontSize = _fontSize$1, originalLineHeight = _lineHeight, fontAtlas = _fontAtlas, i = 0, tempLetterDefinition = fontAtlas ? fontAtlas.cloneLetterDefinition() : {}, flag = !0; lambda(); ) {
                var newFontSize = fontSize - ++i;
                if (flag = !1, newFontSize <= 0) break;
                var scale = newFontSize / fontSize;
                fontAtlas && (fontAtlas.assignLetterDefinitions(tempLetterDefinition), fontAtlas.scaleFontLetterDefinition(scale)), 
                _lineHeight = originalLineHeight * scale, this._multilineTextWrapByWord(), this._computeAlignmentOffset();
            }
            _lineHeight = originalLineHeight, fontAtlas && fontAtlas.assignLetterDefinitions(tempLetterDefinition), 
            flag || 0 <= fontSize - i && this._scaleFontSizeDown(fontSize - i);
        },
        _isVerticalClamp: function _isVerticalClamp() {
            return _textDesiredHeight > _contentSize.height;
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
            if (_fontAtlas) {
                for (var letterDefinitions = _fontAtlas.letterDefinitions, letterClamp = !1, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                    var letterInfo = _lettersInfo[ctr];
                    if (letterInfo.valid) {
                        var letterDef = letterDefinitions[letterInfo.char], px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale, lineIndex = letterInfo.lineIndex;
                        if (0 < _labelWidth) if (_isWrapText) {
                            if (_linesWidth[lineIndex] > _contentSize.width && (px > _contentSize.width || px < 0)) {
                                letterClamp = !0;
                                break;
                            }
                        } else if (px > _contentSize.width) {
                            letterClamp = !0;
                            break;
                        }
                    }
                }
                return letterClamp;
            }
        },
        _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
            var wordWidth = _linesWidth[lineIndex], letterOverClamp = px > _contentSize.width || px < 0;
            return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
        },
        _updateQuads: function _updateQuads() {
            if (!_comp) return !1;
            var letterDefinitions = _fontAtlas ? _fontAtlas.letterDefinitions : {}, texture = _spriteFrame, node = _comp.node, renderData = _comp.renderData;
            renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
            for (var anchorPoint = node.getAnchorPoint(), contentSize = _contentSize, appx = anchorPoint.x * contentSize.width, appy = anchorPoint.y * contentSize.height, ret = !0, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo[ctr];
                if (letterInfo.valid) {
                    var letterDef = letterDefinitions[letterInfo.char.charCodeAt(0)];
                    if (letterDef) {
                        _tmpRect.height = letterDef.height, _tmpRect.width = letterDef.width, _tmpRect.x = letterDef.u, 
                        _tmpRect.y = letterDef.v;
                        var py = letterInfo.positionY + _letterOffsetY;
                        if (0 < _labelHeight) {
                            if (_tailoredTopY < py) {
                                var clipTop = py - _tailoredTopY;
                                _tmpRect.y += clipTop, _tmpRect.height -= clipTop, py -= clipTop;
                            }
                            py - letterDef.height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
                        }
                        var lineIndex = letterInfo.lineIndex, px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
                        if (0 < _labelWidth && this._isHorizontalClamped(px, lineIndex)) if (_overflow === exports.Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === exports.Overflow.SHRINK) {
                            if (_contentSize.width > letterDef.width) {
                                ret = !1;
                                break;
                            }
                            _tmpRect.width = 0;
                        }
                        if (_spriteFrame && 0 < _tmpRect.height && 0 < _tmpRect.width) {
                            var isRotated = _spriteFrame.isRotated(), originalSize = _spriteFrame.getOriginalSize(), rect = _spriteFrame.getRect(), offset = _spriteFrame.getOffset(), trimmedLeft = offset.x + (originalSize.width - rect.width) / 2, trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                            if (isRotated) {
                                var originalX = _tmpRect.x;
                                _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop, _tmpRect.y = originalX + rect.y - trimmedLeft, 
                                _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
                            } else _tmpRect.x += rect.x - trimmedLeft, _tmpRect.y += rect.y + trimmedTop;
                            var letterPositionX = letterInfo.positionX + _linesOffsetX[letterInfo.lineIndex];
                            this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appx, py - appy, _bmfontScale);
                        }
                    } else console.warn("Can't find letter in this bitmap-font");
                }
            }
            return ret;
        },
        appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
        _computeAlignmentOffset: function _computeAlignmentOffset() {
            switch (_linesOffsetX.length = 0, _hAlign) {
              case exports.HorizontalTextAlignment.LEFT:
                for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
                break;

              case exports.HorizontalTextAlignment.CENTER:
                for (var _i5 = 0, l = _linesWidth.length; _i5 < l; _i5++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i5]) / 2);
                break;

              case exports.HorizontalTextAlignment.RIGHT:
                for (var _i6 = 0, _l = _linesWidth.length; _i6 < _l; _i6++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i6]);
            }
            switch (_vAlign) {
              case exports.VerticalTextAlignment.TOP:
                _letterOffsetY = _contentSize.height;
                break;

              case exports.VerticalTextAlignment.CENTER:
                _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
                break;

              case exports.VerticalTextAlignment.BOTTOM:
                _letterOffsetY = _textDesiredHeight;
            }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
            var newWidth = _contentSize.width, newHeight = _contentSize.height;
            _overflow === exports.Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow === exports.Overflow.NONE && (newHeight = newWidth = 0), 
            _labelWidth = newWidth, _labelHeight = newHeight, _labelDimensions.width = newWidth, 
            _labelDimensions.height = newHeight, _maxLineWidth = newWidth;
        }
    }, bmfont = {
        createData: function createData(comp) {
            return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            fillMeshVertices3D(comp.node, renderer, comp.renderData, comp.color);
        },
        appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {
            var renderData = comp.renderData;
            if (renderData) {
                var dataOffset = renderData.dataLength;
                renderData.dataLength += 4, renderData.vertexCount = renderData.dataLength, renderData.indiceCount = renderData.dataLength / 2 * 3;
                var datas = renderData.datas, texw = texture.width, texh = texture.height, rectWidth = rect.width, rectHeight = rect.height, l = 0, b = 0, t = 0, r = 0;
                datas[dataOffset + 3].v = rotated ? (l = rect.x / texw, r = (rect.x + rectHeight) / texw, 
                b = (rect.y + rectWidth) / texh, t = rect.y / texh, datas[dataOffset].u = l, datas[dataOffset].v = t, 
                datas[dataOffset + 1].u = l, datas[dataOffset + 1].v = b, datas[dataOffset + 2].u = r, 
                datas[dataOffset + 2].v = t, datas[dataOffset + 3].u = r, b) : (l = rect.x / texw, 
                r = (rect.x + rectWidth) / texw, b = (rect.y + rectHeight) / texh, t = rect.y / texh, 
                datas[dataOffset].u = l, datas[dataOffset].v = b, datas[dataOffset + 1].u = r, datas[dataOffset + 1].v = b, 
                datas[dataOffset + 2].u = l, datas[dataOffset + 2].v = t, datas[dataOffset + 3].u = r, 
                t), datas[dataOffset].x = x, datas[dataOffset].y = y - rectHeight * scale, datas[dataOffset + 1].x = x + rectWidth * scale, 
                datas[dataOffset + 1].y = y - rectHeight * scale, datas[dataOffset + 2].x = x, datas[dataOffset + 2].y = y, 
                datas[dataOffset + 3].x = x + rectWidth * scale, datas[dataOffset + 3].y = y;
            }
        }
    };
    addon(bmfont, bmfontUtils);
    var Overflow = LabelComponent.Overflow, WHITE = Color.WHITE, TextAlignment = LabelComponent.HorizontalAlign, VerticalTextAlignment = LabelComponent.VerticalAlign, LetterInfo$1 = function LetterInfo() {
        _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.x = 0, 
        this.y = 0, this.line = 0, this.hash = "";
    }, FontLetterDefinition$1 = function FontLetterDefinition() {
        _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.w = 0, 
        this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, 
        this.xAdvance = 0;
    }, LetterTexture = function() {
        function LetterTexture(char, labelInfo) {
            _classCallCheck(this, LetterTexture), this.texture = null, this.labelInfo = void 0, 
            this.char = void 0, this.data = null, this.canvas = null, this.context = null, this.width = 0, 
            this.height = 0, this.hash = void 0, this.char = char, this.labelInfo = labelInfo, 
            this.hash = char.charCodeAt(0) + labelInfo.hash;
        }
        return _createClass(LetterTexture, [ {
            key: "updateRenderData",
            value: function updateRenderData() {
                this._updateProperties(), this._updateTexture();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.texture.destroy(), this.texture = null;
            }
        }, {
            key: "_updateProperties",
            value: function _updateProperties() {
                if (this.texture = new SpriteFrame(), this.data = LabelComponent.CanvasPool.get(), 
                this.canvas = this.data.canvas, this.context = this.data.context, this.context) {
                    this.context.font = this.labelInfo.fontDesc;
                    var width = safeMeasureText(this.context, this.char);
                    this.width = parseFloat(width.toFixed(2)), this.height = this.labelInfo.fontSize;
                }
                this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height);
                var image = new ImageAsset(this.canvas);
                this.texture.image = image;
            }
        }, {
            key: "_updateTexture",
            value: function _updateTexture() {
                if (this.context && this.canvas) {
                    var context = this.context, labelInfo = this.labelInfo, width = this.canvas.width, height = this.canvas.height;
                    context.textAlign = "center", context.textBaseline = "middle", context.clearRect(0, 0, width, height), 
                    context.fillStyle = "rgba(255, 255, 255, 0.005)", context.fillRect(0, 0, width, height), 
                    context.font = labelInfo.fontDesc;
                    var startX = width / 2, startY = height / 2, color = labelInfo.color;
                    if (context.lineJoin = "round", context.fillStyle = "rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ", 1, ")"), 
                    labelInfo.isOutlined) {
                        var strokeColor = labelInfo.out || WHITE;
                        context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                        context.lineWidth = 2 * labelInfo.margin, context.strokeText(this.char, startX, startY);
                    }
                    context.fillText(this.char, startX, startY), this.texture.updateImage();
                }
            }
        } ]), LetterTexture;
    }(), LetterRenderTexture = function(_Texture2D) {
        function LetterRenderTexture() {
            return _classCallCheck(this, LetterRenderTexture), _possibleConstructorReturn(this, _getPrototypeOf(LetterRenderTexture).apply(this, arguments));
        }
        return _inherits(LetterRenderTexture, Texture2D), _createClass(LetterRenderTexture, [ {
            key: "initWithSize",
            value: function initWithSize(width, height) {
                var format = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.RGBA8;
                this.destroy();
                var gfxDevice = this._getGlobalDevice();
                if (gfxDevice) {
                    var texInfo = this._getTextureCreateInfo();
                    texInfo.width = width, texInfo.height = height, texInfo.format = format, this._texture = gfxDevice.createTexture(texInfo), 
                    this._textureView = gfxDevice.createTextureView(this._getTextureViewCreateInfo()), 
                    this.loaded = !0, this.emit("load");
                } else console.warn("Unable to get device");
            }
        }, {
            key: "drawTextureAt",
            value: function drawTextureAt(texture, x, y) {
                if (texture.image && this._texture) {
                    var gfxDevice = this._getGlobalDevice();
                    if (gfxDevice) {
                        var region = {
                            buffOffset: 0,
                            buffStride: 0,
                            buffTexHeight: 0,
                            texOffset: {
                                x: x,
                                y: y,
                                z: 0
                            },
                            texExtent: {
                                width: texture.image.width,
                                height: texture.image.height,
                                depth: 1
                            },
                            texSubres: {
                                baseMipLevel: 0,
                                levelCount: 1,
                                baseArrayLayer: 0,
                                layerCount: 1
                            }
                        };
                        gfxDevice.copyTexImagesToTexture([ texture.image.data ], this._texture, [ region ]);
                    } else console.warn("Unable to get device");
                }
            }
        } ]), LetterRenderTexture;
    }(), LetterAtlas = function() {
        function LetterAtlas(width, height) {
            _classCallCheck(this, LetterAtlas), this.texture = void 0, this._x = 2, this._y = 2, 
            this._nexty = 2, this._width = 0, this._height = 0, this._letterDefinitions = new Map(), 
            this._imageAssets = [], this._dirty = !1, this.texture = new LetterRenderTexture(), 
            this.texture.initWithSize(width, height), this._width = width, this._height = height, 
            cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }
        return _createClass(LetterAtlas, [ {
            key: "width",
            get: function get$$1() {
                return this._width;
            }
        }, {
            key: "height",
            get: function get$$1() {
                return this._height;
            }
        } ]), _createClass(LetterAtlas, [ {
            key: "insertLetterTexture",
            value: function insertLetterTexture(letterTexture) {
                var texture = letterTexture.texture, device = cc.director.root.device;
                if (!(texture && this.texture && device && texture.image)) return null;
                var width = texture.width, height = texture.height;
                if (this._x + width + 2 > this._width && (this._x = 2, this._y = this._nexty), this._y + height > this._nexty && (this._nexty = this._y + height + 2), 
                this._nexty > this._height) return null;
                this.texture.drawTextureAt(texture, this._x, this._y), this._dirty = !0;
                var letterDefinition = new FontLetterDefinition$1();
                return letterDefinition.u = this._x, letterDefinition.v = this._y, letterDefinition.texture = this.texture, 
                letterDefinition.valid = !0, letterDefinition.w = letterTexture.width, letterDefinition.h = letterTexture.height, 
                letterDefinition.xAdvance = letterTexture.width, this._x += width + 2, this._letterDefinitions.set(letterTexture.hash, letterDefinition), 
                letterDefinition;
            }
        }, {
            key: "update",
            value: function update() {
                this._dirty && (this._dirty = !1);
            }
        }, {
            key: "reset",
            value: function reset() {
                this._x = 2, this._y = 2, this._nexty = 2, this._letterDefinitions.clear();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.reset(), this.texture && this.texture.destroy();
            }
        }, {
            key: "beforeSceneLoad",
            value: function beforeSceneLoad() {
                this.destroy();
                var texture = new LetterRenderTexture();
                texture.initWithSize(this._width, this._height), this.texture = texture;
            }
        }, {
            key: "getLetter",
            value: function getLetter(key) {
                return this._letterDefinitions.get(key);
            }
        }, {
            key: "addLetterDefinitions",
            value: function addLetterDefinitions(key, letterDefinition) {
                this._letterDefinitions[key] = letterDefinition;
            }
        }, {
            key: "cloneLetterDefinition",
            value: function cloneLetterDefinition() {
                for (var copyLetterDefinitions = {}, _arr = Object.keys(this._letterDefinitions), _i = 0; _i < _arr.length; _i++) {
                    var key = _arr[_i], value$$1 = new FontLetterDefinition$1();
                    mixin(value$$1, this._letterDefinitions[key]), copyLetterDefinitions[key] = value$$1;
                }
                return copyLetterDefinitions;
            }
        }, {
            key: "assignLetterDefinitions",
            value: function assignLetterDefinitions(letterDefinitions) {
                var _this = this;
                letterDefinitions.forEach(function(value$$1, key) {
                    mixin(_this._letterDefinitions[key], value$$1);
                });
            }
        }, {
            key: "scaleFontLetterDefinition",
            value: function scaleFontLetterDefinition(scaleFactor) {
                for (var _arr2 = Object.keys(this._letterDefinitions), _i2 = 0; _i2 < _arr2.length; _i2++) {
                    var fontDefinition = _arr2[_i2], letterDefinitions = this._letterDefinitions[fontDefinition];
                    letterDefinitions.w *= scaleFactor, letterDefinitions.h *= scaleFactor, letterDefinitions.offsetX *= scaleFactor, 
                    letterDefinitions.offsetY *= scaleFactor, letterDefinitions.xAdvance *= scaleFactor;
                }
            }
        }, {
            key: "getLetterDefinitionForChar",
            value: function getLetterDefinitionForChar(char, labelInfo) {
                var hash = char.charCodeAt(0) + labelInfo.hash, letterDefinition = this._letterDefinitions.get(hash);
                if (!letterDefinition) {
                    var temp = new LetterTexture(char, labelInfo);
                    temp.updateRenderData(), letterDefinition = this.insertLetterTexture(temp), temp.destroy();
                }
                return letterDefinition;
            }
        } ]), LetterAtlas;
    }(), _tmpRect$1 = new Rect(), _comp$1 = null, _horizontalKernings$1 = [], _lettersInfo$1 = [], _linesWidth$1 = [], _linesOffsetX$1 = [], _labelDimensions$1 = new Size(), _fontAtlas$1 = null, _numberOfLines$1 = 0, _textDesiredHeight$1 = 0, _letterOffsetY$1 = 0, _tailoredTopY$1 = 0, _tailoredBottomY$1 = 0, _bmfontScale$1 = 1, _string$1 = "", _fontSize$2 = 0, _originFontSize$1 = 0, _contentSize$1 = new Size(), _hAlign$1 = 0, _vAlign$1 = 0, _spacingX$1 = 0, _lineHeight$1 = 0, _overflow$1 = 0, _isWrapText$1 = !1, _labelWidth$1 = 0, _labelHeight$1 = 0, _maxLineWidth$1 = 0, _fontFamily = "", _isBold = !1, _labelInfo = {
        fontSize: 0,
        lineHeight: 0,
        hash: "",
        fontFamily: "",
        fontDesc: "Arial",
        hAlign: 0,
        vAlign: 0,
        color: WHITE,
        isOutlined: !1,
        out: WHITE,
        margin: 0
    }, letterFont = {
        getAssemblerData: function getAssemblerData() {
            return _fontAtlas$1 || (_fontAtlas$1 = new LetterAtlas(1024, 1024)), _fontAtlas$1.texture;
        },
        updateRenderData: function updateRenderData(comp) {
            comp.renderData && comp.renderData.vertDirty && _comp$1 !== comp && (_comp$1 = comp, 
            this._updateFontFamily(comp), _labelInfo.fontFamily = _fontFamily, this._updateProperties(), 
            _labelInfo.fontDesc = this._getFontDesc(), this._updateContent(), _comp$1.actualFontSize = _fontSize$2, 
            _comp$1.node.setContentSize(_contentSize$1), _comp$1.renderData.vertDirty = _comp$1.renderData.uvDirty = !1, 
            _comp$1 = null, this._resetProperties());
        },
        _updateFontScale: function _updateFontScale() {
            _bmfontScale$1 = _fontSize$2 / _originFontSize$1;
        },
        _updateProperties: function _updateProperties() {
            if (_comp$1) {
                _string$1 = _comp$1.string.toString(), _fontSize$2 = _comp$1.fontSize, _originFontSize$1 = _fontSize$2;
                var contentSize = _comp$1.node.getContentSize();
                _contentSize$1.width = contentSize.width, _contentSize$1.height = contentSize.height, 
                _hAlign$1 = _comp$1.horizontalAlign, _vAlign$1 = _comp$1.verticalAlign, _spacingX$1 = _comp$1.spacingX, 
                _overflow$1 = _comp$1.overflow, _lineHeight$1 = _comp$1.lineHeight, _isBold = _comp$1.isBold, 
                _isWrapText$1 = _overflow$1 !== Overflow.NONE && (_overflow$1 === Overflow.RESIZE_HEIGHT || _comp$1.enableWrapText);
                var outline = _comp$1.getComponent(LabelOutlineComponent);
                outline && outline.enabled ? (_labelInfo.isOutlined = !0, _labelInfo.margin = outline.width, 
                _labelInfo.out = outline.color, _labelInfo.out.a = outline.color.a * _comp$1.color.a / 255) : (_labelInfo.isOutlined = !1, 
                _labelInfo.margin = 0), _labelInfo.lineHeight = _lineHeight$1, _labelInfo.fontSize = _fontSize$2, 
                _labelInfo.fontFamily = _fontFamily, _labelInfo.color = _comp$1.color, _labelInfo.hash = this._computeHash(_labelInfo), 
                this._setupBMFontOverflowMetrics();
            }
        },
        _updateFontFamily: function _updateFontFamily(comp) {
            comp.useSystemFont ? _fontFamily = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily = comp.font._nativeAsset : (_fontFamily = cc.loader.getRes(comp.font.nativeUrl)) || cc.loader.load(comp.font.nativeUrl, function(err, fontFamily) {
                _fontFamily = fontFamily || "Arial", comp.font && (comp.font._nativeAsset = fontFamily), 
                comp.updateRenderData(!0);
            }) : _fontFamily = "Arial";
        },
        _computeHash: function _computeHash(labelInfo) {
            var color = labelInfo.color.toHEX("#rrggbb"), out = "";
            return labelInfo.isOutlined && (out = labelInfo.out.toHEX("#rrggbb")), "" + labelInfo.fontSize + labelInfo.fontFamily + color + out;
        },
        _getFontDesc: function _getFontDesc() {
            var fontDesc = _fontSize$2.toString() + "px ";
            return fontDesc += _fontFamily, _isBold && (fontDesc = "bold " + fontDesc), fontDesc;
        },
        _resetProperties: function _resetProperties() {},
        _updateContent: function _updateContent() {
            this._updateFontScale(), this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
        _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
            var textLen = _string$1.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2(0, 0);
            this._updateFontScale();
            for (var index = 0; index < textLen; ) {
                var character = _string$1.charAt(index);
                if ("\n" !== character) {
                    for (var tokenLen = nextTokenFunc(_string$1, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                        var letterIndex = index + tmp;
                        if ("\r" !== (character = _string$1.charAt(letterIndex))) if (letterDef = _fontAtlas$1 && _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)) {
                            var letterX = nextLetterX + letterDef.offsetX * _bmfontScale$1;
                            if (_isWrapText$1 && 0 < _maxLineWidth$1 && 0 < nextTokenX && letterX + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character)) {
                                _linesWidth$1.push(letterRight), lineIndex++, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + (nextTokenX = letterRight = 0), 
                                newLine = !0;
                                break;
                            }
                            letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale$1, 
                            this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex), letterIndex + 1 < _horizontalKernings$1.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings$1[letterIndex + 1]), 
                            nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, tokenRight = letterPosition.x + letterDef.w * _bmfontScale$1, 
                            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale$1 && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale$1);
                        } else this._recordPlaceholderInfo(letterIndex, character); else this._recordPlaceholderInfo(letterIndex, character);
                    }
                    newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                    tokenLowestY < lowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                    index += tokenLen);
                } else _linesWidth$1.push(letterRight), lineIndex++, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + (nextTokenX = letterRight = 0), 
                this._recordPlaceholderInfo(index, character), index++;
            }
            return _linesWidth$1.push(letterRight), _textDesiredHeight$1 = (_numberOfLines$1 = lineIndex + 1) * _lineHeight$1 * _bmfontScale$1, 
            1 < _numberOfLines$1 && (_textDesiredHeight$1 += 0 * (_numberOfLines$1 - 1)), _contentSize$1.width = _labelWidth$1, 
            _contentSize$1.height = _labelHeight$1, _labelWidth$1 <= 0 && (_contentSize$1.width = parseFloat(longestLine.toFixed(2))), 
            _labelHeight$1 <= 0 && (_contentSize$1.height = parseFloat(_textDesiredHeight$1.toFixed(2))), 
            _tailoredTopY$1 = _contentSize$1.height, (_tailoredBottomY$1 = 0) < highestY && (_tailoredTopY$1 = _contentSize$1.height + highestY), 
            lowestY < -_textDesiredHeight$1 && (_tailoredBottomY$1 = _textDesiredHeight$1 + lowestY), 
            !0;
        },
        _getFirstCharLen: function _getFirstCharLen() {
            return 1;
        },
        _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
            var character = text.charAt(startIndex);
            if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
            if (_fontAtlas$1) {
                var len = 1, letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo);
                if (!letterDef) return len;
                for (var nextLetterX = letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
                letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)); ++index) {
                    if (nextLetterX + letterDef.offsetX * _bmfontScale$1 + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character) && 0 < _maxLineWidth$1) return len;
                    if (nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                    len++;
                }
                return len;
            }
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
            return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
            return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, char) {
            if (letterIndex >= _lettersInfo$1.length) {
                var tmpInfo = new LetterInfo$1();
                _lettersInfo$1.push(tmpInfo);
            }
            _lettersInfo$1[letterIndex].char = char, _lettersInfo$1[letterIndex].hash = char.charCodeAt(0) + _labelInfo.hash, 
            _lettersInfo$1[letterIndex].valid = !1;
        },
        _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
            if (letterIndex >= _lettersInfo$1.length) {
                var tmpInfo = new LetterInfo$1();
                _lettersInfo$1.push(tmpInfo);
            }
            var key = character.charCodeAt(0) + _labelInfo.hash;
            _lettersInfo$1[letterIndex].line = lineIndex, _lettersInfo$1[letterIndex].char = character, 
            _lettersInfo$1[letterIndex].hash = key;
            var fontLetter = _fontAtlas$1 && _fontAtlas$1.getLetter(key);
            _lettersInfo$1[letterIndex].valid = !!fontLetter && !!fontLetter.valid, _lettersInfo$1[letterIndex].x = letterPosition.x, 
            _lettersInfo$1[letterIndex].y = letterPosition.y;
        },
        _alignText: function _alignText() {
            _textDesiredHeight$1 = 0, _linesWidth$1.length = 0, this._multilineTextWrapByWord(), 
            this._computeAlignmentOffset(), this._updateQuads();
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
            var shouldUpdateContent = !0;
            fontSize || (shouldUpdateContent = !(fontSize = .1)), _fontSize$2 = fontSize, shouldUpdateContent && this._updateContent();
        },
        _isVerticalClamp: function _isVerticalClamp() {
            return _textDesiredHeight$1 > _contentSize$1.height;
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
            for (var letterClamp = !1, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo$1[ctr];
                if (letterInfo.valid) {
                    var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                    if (!letterDef) continue;
                    var px = letterInfo.x + letterDef.w * _bmfontScale$1, lineIndex = letterInfo.line;
                    if (0 < _labelWidth$1) if (_isWrapText$1) {
                        if (_linesWidth$1[lineIndex] > _contentSize$1.width && (px > _contentSize$1.width || px < 0)) {
                            letterClamp = !0;
                            break;
                        }
                    } else if (px > _contentSize$1.width) {
                        letterClamp = !0;
                        break;
                    }
                }
            }
            return letterClamp;
        },
        _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
            var wordWidth = _linesWidth$1[lineIndex], letterOverClamp = px > _contentSize$1.width || px < 0;
            return _isWrapText$1 ? wordWidth > _contentSize$1.width && letterOverClamp : letterOverClamp;
        },
        _updateQuads: function _updateQuads() {
            if (_comp$1 && _fontAtlas$1) {
                var texture = _fontAtlas$1.texture, node = _comp$1.node, renderData = _comp$1.renderData;
                renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
                for (var contentSize = _contentSize$1, ap = node.getAnchorPoint(), appx = ap.x * contentSize.width, appy = ap.y * contentSize.height, ret = !0, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                    var letterInfo = _lettersInfo$1[ctr];
                    if (letterInfo.valid) {
                        var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                        if (letterDef) {
                            _tmpRect$1.height = letterDef.h, _tmpRect$1.width = letterDef.w, _tmpRect$1.x = letterDef.u, 
                            _tmpRect$1.y = letterDef.v;
                            var py = letterInfo.y + _letterOffsetY$1;
                            if (0 < _labelHeight$1) {
                                if (_tailoredTopY$1 < py) {
                                    var clipTop = py - _tailoredTopY$1;
                                    _tmpRect$1.y += clipTop, _tmpRect$1.height -= clipTop, py -= clipTop;
                                }
                                py - letterDef.h * _bmfontScale$1 < _tailoredBottomY$1 && (_tmpRect$1.height = py < _tailoredBottomY$1 ? 0 : py - _tailoredBottomY$1);
                            }
                            var lineIndex = letterInfo.line, px = letterInfo.x + letterDef.w / 2 * _bmfontScale$1 + _linesOffsetX$1[lineIndex];
                            if (0 < _labelWidth$1 && this._isHorizontalClamped(px, lineIndex)) if (_overflow$1 === Overflow.CLAMP) _tmpRect$1.width = 0; else if (_overflow$1 === Overflow.SHRINK) {
                                if (_contentSize$1.width > letterDef.w) {
                                    ret = !1;
                                    break;
                                }
                                _tmpRect$1.width = 0;
                            }
                            if (0 < _tmpRect$1.height && 0 < _tmpRect$1.width) {
                                var letterPositionX = letterInfo.x + _linesOffsetX$1[letterInfo.line];
                                this.appendQuad(renderData, texture, _tmpRect$1, !1, letterPositionX - appx, py - appy, _bmfontScale$1);
                            }
                        }
                    }
                }
                return ret;
            }
        },
        appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {},
        _computeAlignmentOffset: function _computeAlignmentOffset() {
            switch (_linesOffsetX$1.length = 0, _hAlign$1) {
              case TextAlignment.LEFT:
                for (var i = 0; i < _numberOfLines$1; ++i) _linesOffsetX$1.push(0);
                break;

              case TextAlignment.CENTER:
                for (var _i3 = 0, l = _linesWidth$1.length; _i3 < l; _i3++) _linesOffsetX$1.push((_contentSize$1.width - _linesWidth$1[_i3]) / 2);
                break;

              case TextAlignment.RIGHT:
                for (var _i4 = 0, _l = _linesWidth$1.length; _i4 < _l; _i4++) _linesOffsetX$1.push(_contentSize$1.width - _linesWidth$1[_i4]);
            }
            switch (_vAlign$1) {
              case VerticalTextAlignment.TOP:
                _letterOffsetY$1 = _contentSize$1.height;
                break;

              case VerticalTextAlignment.CENTER:
                _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$2) / 2;
                break;

              case VerticalTextAlignment.BOTTOM:
                _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$2);
            }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
            var newWidth = _contentSize$1.width, newHeight = _contentSize$1.height;
            _overflow$1 === Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow$1 === Overflow.NONE && (newHeight = newWidth = 0), 
            _labelWidth$1 = newWidth, _labelHeight$1 = newHeight, _labelDimensions$1.width = newWidth, 
            _labelDimensions$1.height = newHeight, _maxLineWidth$1 = newWidth;
        }
    }, WHITE$1 = cc.color(255, 255, 255, 255), letter = {
        createData: function createData(comp) {
            return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            if (comp.renderData) {
                var node = comp.node;
                WHITE$1.a = comp.color.a, fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
            }
        },
        appendQuad: bmfont.appendQuad
    };
    addon(letter, letterFont);
    var Overflow$1 = LabelComponent.Overflow, WHITE$2 = Color.WHITE, OUTLINE_SUPPORTED = cc.js.isChildClassOf(LabelOutlineComponent, Component), _context = null, _canvas = null, _texture = null, _fontDesc = "", _string$2 = "", _fontSize$3 = 0, _drawFontsize = 0, _splitedStrings = [], _canvasSize = new Size(), _lineHeight$2 = 0, _hAlign$2 = 0, _vAlign$2 = 0, _color = new Color(), _fontFamily$1 = "", _overflow$2 = Overflow$1.NONE, _isWrapText$2 = !1, _isOutlined = !1, _outlineColor = new Color(), _outlineWidth = 0, _margin = 0, _isBold$1 = !1, _isItalic = !1, _isUnderline = !1, _canvasPool = new CanvasPool(), ttfUtils = {
        getAssemblerData: function getAssemblerData() {
            var labelCanvas = document.createElement("canvas"), sharedLabelData = {
                canvas: labelCanvas,
                context: labelCanvas.getContext("2d")
            };
            return sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1, sharedLabelData;
        },
        resetAssemblerData: function resetAssemblerData(assemblerData) {
            cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && assemblerData && _canvasPool.put(assemblerData);
        },
        updateRenderData: function updateRenderData(comp) {
            comp.renderData && comp.renderData.vertDirty && (this._updateFontFamly(comp), this._updateProperties(comp), 
            this._calculateLabelFont(), this._calculateSplitedStrings(), this._updateLabelDimensions(), 
            this._calculateTextBaseline(), this._updateTexture(), comp.actualFontSize = _fontSize$3, 
            comp.node.setContentSize(_canvasSize), this.updateVerts(comp), comp.markForUpdateRenderData(!1), 
            _texture = _canvas = _context = null);
        },
        updateVerts: function updateVerts(comp) {},
        _updateFontFamly: function _updateFontFamly(comp) {
            comp.useSystemFont ? _fontFamily$1 = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily$1 = comp.font._nativeAsset : cc.loader.load(comp.font.nativeUrl, function(err, fontFamily) {
                _fontFamily$1 = fontFamily || "Arial", comp.updateRenderData(!0);
            }) : _fontFamily$1 = "Arial";
        },
        _updateProperties: function _updateProperties(comp) {
            var assemblerData = comp.assemblerData;
            if (assemblerData) {
                _context = assemblerData.context, _canvas = assemblerData.canvas, _texture = comp.spriteFrame, 
                _string$2 = comp.string.toString(), _fontSize$3 = comp.fontSize, _drawFontsize = _fontSize$3, 
                _overflow$2 = comp.overflow, _canvasSize.width = comp.node.width, _canvasSize.height = comp.node.height, 
                _lineHeight$2 = comp.lineHeight, _hAlign$2 = comp.horizontalAlign, _vAlign$2 = comp.verticalAlign, 
                _color = comp.color, _isBold$1 = comp.isBold, _isItalic = comp.isItalic, _isUnderline = comp.isUnderline, 
                _isWrapText$2 = _overflow$2 !== Overflow$1.NONE && (_overflow$2 === Overflow$1.RESIZE_HEIGHT || comp.enableWrapText);
                var outline = OUTLINE_SUPPORTED && comp.getComponent(LabelOutlineComponent);
                outline && outline.enabled ? (_isOutlined = !0, _margin = _outlineWidth = outline.width, 
                (_outlineColor = outline.color.clone()).a = _outlineColor.a * comp.color.a / 255) : (_isOutlined = !1, 
                _margin = 0);
            }
        },
        _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
            var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
            return labelX = _hAlign$2 === exports.HorizontalTextAlignment.RIGHT ? _canvasSize.width - _margin : _hAlign$2 === exports.HorizontalTextAlignment.CENTER ? _canvasSize.width / 2 : 0 + _margin, 
            firstLinelabelY = _vAlign$2 === exports.VerticalTextAlignment.TOP ? 0 : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
            cc.v2(labelX, firstLinelabelY);
        },
        _updateTexture: function _updateTexture() {
            if (_context && _canvas) {
                _context.clearRect(0, 0, _canvas.width, _canvas.height), _context.font = _fontDesc;
                var underlineStartPosition, startPosition = this._calculateFillTextStartPosition(), lineHeight = this._getLineHeight();
                _context.lineJoin = "round", _context.fillStyle = "rgba(".concat(_color.r, ", ").concat(_color.g, ", ").concat(_color.b, ", ").concat(_color.a / 255, ")");
                for (var i = 0; i < _splitedStrings.length; ++i) {
                    if (_isOutlined) {
                        var strokeColor = _outlineColor || WHITE$2;
                        _context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                        _context.lineWidth = 2 * _outlineWidth, _context.strokeText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                    }
                    _context.fillText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight), 
                    _isUnderline && (underlineStartPosition = this._calculateUnderlineStartPosition(), 
                    _context.save(), _context.beginPath(), _context.lineWidth = _fontSize$3 / 8, _context.strokeStyle = "rgba(".concat(_color.r, ", ").concat(_color.g, ", ").concat(_color.b, ", ").concat(_color.a / 255, ")"), 
                    _context.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1), 
                    _context.lineTo(underlineStartPosition.x + _canvas.width, underlineStartPosition.y + i * lineHeight - 1), 
                    _context.stroke(), _context.restore());
                }
                _texture && (_texture.mipmaps = [ _texture.image ]);
            }
        },
        _calculateUnderlineStartPosition: function _calculateUnderlineStartPosition() {
            var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
            return labelX = 0 + _margin, firstLinelabelY = _vAlign$2 === exports.VerticalTextAlignment.TOP ? _fontSize$3 : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + _fontSize$3 / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
            cc.v2(labelX, firstLinelabelY);
        },
        _updateLabelDimensions: function _updateLabelDimensions() {
            if (_context) {
                var paragraphedStrings = _string$2.split("\n");
                if (_overflow$2 === Overflow$1.RESIZE_HEIGHT) _canvasSize.height = _splitedStrings.length * this._getLineHeight(); else if (_overflow$2 === Overflow$1.NONE) {
                    var canvasSizeX = 0, canvasSizeY = 0, _iterator = _splitedStrings = paragraphedStrings, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var paraLength = safeMeasureText(_context, _ref);
                        canvasSizeX = paraLength < canvasSizeX ? canvasSizeX : paraLength;
                    }
                    canvasSizeY = _splitedStrings.length * this._getLineHeight(), _canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * _margin, 
                    _canvasSize.height = parseFloat(canvasSizeY.toFixed(2)), _isItalic && (_canvasSize.width += _drawFontsize * Math.tan(.20943951));
                }
                _canvas && (_canvas.width = _canvasSize.width, _canvas.height = _canvasSize.height);
            }
        },
        _calculateTextBaseline: function _calculateTextBaseline() {
            var hAlign, vAlign;
            hAlign = _hAlign$2 === exports.HorizontalTextAlignment.RIGHT ? "right" : _hAlign$2 === exports.HorizontalTextAlignment.CENTER ? "center" : "left", 
            vAlign = _vAlign$2 === exports.VerticalTextAlignment.TOP ? "top" : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? "middle" : "bottom", 
            _context && (_context.textAlign = hAlign, _context.textBaseline = vAlign);
        },
        _calculateSplitedStrings: function _calculateSplitedStrings() {
            if (_context) {
                var paragraphedStrings = _string$2.split("\n");
                if (_isWrapText$2) {
                    _splitedStrings = [];
                    var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, _iterator2 = paragraphedStrings, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var textFragment = fragmentText(_ref2, safeMeasureText(_context, _ref2), canvasWidthNoMargin, this._measureText(_context));
                        _splitedStrings = _splitedStrings.concat(textFragment);
                    }
                } else _splitedStrings = paragraphedStrings;
            }
        },
        _getFontDesc: function _getFontDesc() {
            var fontDesc = _fontSize$3.toString() + "px ";
            return fontDesc += _fontFamily$1, _isBold$1 && (fontDesc = "bold " + fontDesc), 
            _isItalic && (fontDesc = "italic " + fontDesc), fontDesc;
        },
        _getLineHeight: function _getLineHeight() {
            var nodeSpacingY = _lineHeight$2;
            return 0 | (nodeSpacingY = 0 === nodeSpacingY ? _fontSize$3 : nodeSpacingY * _fontSize$3 / _drawFontsize);
        },
        _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
            var paragraphLength = [], _iterator3 = paragraphedStrings, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var width = safeMeasureText(ctx, _ref3);
                paragraphLength.push(width);
            }
            return paragraphLength;
        },
        _measureText: function _measureText(ctx) {
            return function(string) {
                return safeMeasureText(ctx, string);
            };
        },
        _calculateLabelFont: function _calculateLabelFont() {
            if (_context && (_fontDesc = this._getFontDesc(), _context.font = _fontDesc, _overflow$2 === Overflow$1.SHRINK)) {
                var paragraphedStrings = _string$2.split("\n"), paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
                _splitedStrings = paragraphedStrings;
                var i = 0, totalHeight = 0, maxLength = 0;
                if (_isWrapText$2) {
                    var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, canvasHeightNoMargin = _canvasSize.height - 2 * _margin;
                    if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) return _fontDesc = this._getFontDesc(), 
                    void (_context.font = _fontDesc);
                    totalHeight = canvasHeightNoMargin + 1, maxLength = canvasWidthNoMargin + 1;
                    for (var actualFontSize = _fontSize$3 + 1, textFragment = [], tryDivideByTwo = !0, startShrinkFontSize = 0 | actualFontSize; canvasHeightNoMargin < totalHeight || canvasWidthNoMargin < maxLength; ) {
                        if (tryDivideByTwo ? actualFontSize = startShrinkFontSize / 2 | 0 : startShrinkFontSize = actualFontSize = startShrinkFontSize - 1, 
                        actualFontSize <= 0) {
                            cc.logID(4003);
                            break;
                        }
                        for (_fontSize$3 = actualFontSize, _fontDesc = this._getFontDesc(), _context.font = _fontDesc, 
                        _splitedStrings = [], i = totalHeight = 0; i < paragraphedStrings.length; ++i) {
                            var j = 0, allWidth = safeMeasureText(_context, paragraphedStrings[i]);
                            for (textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context)); j < textFragment.length; ) {
                                maxLength = safeMeasureText(_context, textFragment[j]), totalHeight += this._getLineHeight(), 
                                ++j;
                            }
                            _splitedStrings = _splitedStrings.concat(textFragment);
                        }
                        tryDivideByTwo && (canvasHeightNoMargin < totalHeight ? startShrinkFontSize = 0 | actualFontSize : (tryDivideByTwo = !1, 
                        totalHeight = canvasHeightNoMargin + 1));
                    }
                } else {
                    for (totalHeight = paragraphedStrings.length * this._getLineHeight(), i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
                    var scaleX = (_canvasSize.width - 2 * _margin) / maxLength, scaleY = _canvasSize.height / totalHeight;
                    _fontSize$3 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0, _fontDesc = this._getFontDesc(), 
                    _context.font = _fontDesc;
                }
            }
        }
    }, WHITE$3 = Color.WHITE, ttf = {
        useModel: !1,
        createData: function createData(comp) {
            var renderData = comp.requestRenderData();
            renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6;
            var datas = renderData.datas;
            return datas[0].u = 0, datas[0].v = 1, datas[1].u = 1, datas[1].v = 1, datas[2].u = 0, 
            datas[2].v = 0, datas[3].u = 1, datas[3].v = 0, renderData;
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            fillMeshVertices3D(comp.node, renderer, comp.renderData, WHITE$3);
        },
        updateVerts: function updateVerts(comp) {
            var renderData = comp.renderData;
            if (renderData) {
                var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, datas = renderData.datas;
                datas[0].x = -appx, datas[0].y = -appy, datas[1].x = width - appx, datas[1].y = -appy, 
                datas[2].x = -appx, datas[2].y = height - appy, datas[3].x = width - appx, datas[3].y = height - appy;
            }
        }
    };
    addon(ttf, ttfUtils);
    var Stage, labelAssembler = {
        getAssembler: function getAssembler(comp) {
            var assembler = ttf;
            return comp.font instanceof BitmapFont ? assembler = bmfont : comp.cacheMode === LabelComponent.CacheMode.CHAR && (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? cc.warn("sorry, subdomain does not support CHAR mode currently!") : assembler = letter), 
            assembler;
        }
    };
    LabelComponent.Assembler = labelAssembler, function(Stage) {
        Stage[Stage.DISABLED = 0] = "DISABLED", Stage[Stage.CLEAR = 1] = "CLEAR", Stage[Stage.ENTER_LEVEL = 2] = "ENTER_LEVEL", 
        Stage[Stage.ENABLED = 3] = "ENABLED", Stage[Stage.EXIT_LEVEL = 4] = "EXIT_LEVEL";
    }(Stage || (Stage = {}));
    var StencilManager = function() {
        function StencilManager() {
            _classCallCheck(this, StencilManager), this.stage = Stage.DISABLED, this._maskStack = [], 
            this._stencilPattern = {
                stencilTest: !0,
                func: GFXComparisonFunc.ALWAYS,
                stencilMask: 4294967295,
                writeMask: 4294967295,
                failOp: GFXStencilOp.KEEP,
                zFailOp: GFXStencilOp.KEEP,
                passOp: GFXStencilOp.KEEP,
                ref: 1
            }, this._defaultPipelineState = {
                depthStencilState: {},
                rasterizerState: {},
                blendState: {}
            };
        }
        return _createClass(StencilManager, [ {
            key: "pushMask",
            value: function pushMask(mask) {
                this._maskStack.push(mask);
            }
        }, {
            key: "clear",
            value: function clear() {
                this.stage = Stage.CLEAR;
            }
        }, {
            key: "enterLevel",
            value: function enterLevel() {
                this.stage = Stage.ENTER_LEVEL;
            }
        }, {
            key: "enableMask",
            value: function enableMask() {
                this.stage = Stage.ENABLED;
            }
        }, {
            key: "exitMask",
            value: function exitMask() {
                0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = Stage.DISABLED : this.stage = Stage.ENABLED);
            }
        }, {
            key: "handleMaterial",
            value: function handleMaterial(mat) {
                var pattern = this._stencilPattern;
                this.stage === Stage.DISABLED ? (pattern.stencilTest = !1, pattern.func = GFXComparisonFunc.ALWAYS, 
                pattern.failOp = GFXStencilOp.KEEP, pattern.stencilMask = pattern.writeMask = 4294967295, 
                pattern.ref = 1) : (pattern.stencilTest = !0, this.stage === Stage.ENABLED ? (pattern.func = GFXComparisonFunc.EQUAL, 
                pattern.failOp = GFXStencilOp.KEEP, pattern.stencilMask = pattern.ref = this.getStencilRef(), 
                pattern.writeMask = this.getWriteMask()) : this.stage === Stage.CLEAR ? (pattern.func = GFXComparisonFunc.NEVER, 
                pattern.failOp = GFXStencilOp.ZERO, pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask()) : this.stage === Stage.ENTER_LEVEL && (pattern.func = GFXComparisonFunc.NEVER, 
                pattern.failOp = GFXStencilOp.REPLACE, pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask()));
                var pass = mat.passes[0];
                if (this._changed(pass)) {
                    var state = this._stencilPattern;
                    return this._defaultPipelineState.depthStencilState = {
                        stencilTestFront: state.stencilTest,
                        stencilFuncFront: state.func,
                        stencilReadMaskFront: state.stencilMask,
                        stencilWriteMaskFront: state.writeMask,
                        stencilFailOpFront: state.failOp,
                        stencilZFailOpFront: state.zFailOp,
                        stencilPassOpFront: state.passOp,
                        stencilRefFront: state.ref,
                        stencilTestBack: state.stencilTest,
                        stencilFuncBack: state.func,
                        stencilReadMaskBack: state.stencilMask,
                        stencilWriteMaskBack: state.writeMask,
                        stencilFailOpBack: state.failOp,
                        stencilZFailOpBack: state.zFailOp,
                        stencilPassOpBack: state.passOp,
                        stencilRefBack: state.ref
                    }, this._defaultPipelineState.blendState = pass.blendState, this._defaultPipelineState.rasterizerState = pass.rasterizerState, 
                    mat.overridePipelineStates(this._defaultPipelineState), !0;
                }
                return !1;
            }
        }, {
            key: "getWriteMask",
            value: function getWriteMask() {
                return 1 << this._maskStack.length - 1;
            }
        }, {
            key: "getExitWriteMask",
            value: function getExitWriteMask() {
                return 1 << this._maskStack.length;
            }
        }, {
            key: "getStencilRef",
            value: function getStencilRef() {
                for (var result = 0, i = 0; i < this._maskStack.length; ++i) result += 1 << i;
                return result;
            }
        }, {
            key: "getInvertedRef",
            value: function getInvertedRef() {
                for (var result = 0, i = 0; i < this._maskStack.length - 1; ++i) result += 1 << i;
                return result;
            }
        }, {
            key: "reset",
            value: function reset() {
                this._maskStack.length = 0, this.stage = Stage.DISABLED;
            }
        }, {
            key: "_changed",
            value: function _changed(pass) {
                var stencilState = pass.depthStencilState, pattern = this._stencilPattern;
                return pattern.stencilTest !== stencilState.stencilTestFront || pattern.func !== stencilState.stencilFuncFront || pattern.failOp !== stencilState.stencilFailOpFront || pattern.zFailOp !== stencilState.stencilZFailOpFront || pattern.passOp !== stencilState.stencilPassOpFront || pattern.stencilMask !== stencilState.stencilReadMaskFront || pattern.writeMask !== stencilState.stencilWriteMaskFront || pattern.ref !== stencilState.stencilRefFront;
            }
        } ]), StencilManager;
    }();
    StencilManager.sharedManager = null, StencilManager.sharedManager = new StencilManager();
    var _stencilManager = StencilManager.sharedManager, maskAssembler = {
        createData: function createData(mask) {
            var renderData = mask.requestRenderData();
            return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
            renderData;
        },
        updateRenderData: function updateRenderData(mask) {
            var renderData = mask.renderData;
            renderData && renderData.vertDirty && this.updateVerts && this.updateVerts(mask);
        },
        updateVerts: function updateVerts(mask) {
            var renderData = mask.renderData;
            if (renderData) {
                var l, b, r, t, node = mask.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch;
                l = -appx, b = -appy, r = cw - appx, t = ch - appy, datas[0].x = l, datas[0].y = b, 
                datas[3].x = r, datas[3].y = t, renderData.vertDirty = !1;
            }
        },
        fillBuffers: function fillBuffers(mask, renderer) {
            _stencilManager.pushMask(mask), _stencilManager.clear(), mask.clearGraphics.updateAssembler(renderer), 
            _stencilManager.enterLevel(), mask.graphics.updateAssembler(renderer), _stencilManager.enableMask();
        }
    }, maskEndAssembler = {
        fillBuffers: function fillBuffers(mask, ui) {
            _stencilManager.exitMask();
        }
    }, StartAssembler = {
        getAssembler: function getAssembler() {
            return maskAssembler;
        }
    }, PostAssembler = {
        getAssembler: function getAssembler() {
            return maskEndAssembler;
        }
    };
    MaskComponent.Assembler = StartAssembler, MaskComponent.PostAssembler = PostAssembler;
    var FillType$1 = SpriteComponent.FillType, matrix = new Mat4(), barFilled = {
        useModel: !1,
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            if (renderData && frame) {
                var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
                if (!uvDirty && !vertDirty) return;
                var fillStart = sprite.fillStart, fillRange = sprite.fillRange;
                fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange), fillRange = (fillRange = 1 < (fillRange = fillStart + fillRange) ? 1 : fillRange) < 0 ? 0 : fillRange;
                var fillEnd = (fillStart = (fillStart = 1 < fillStart ? 1 : fillStart) < 0 ? 0 : fillStart) + (fillRange = (fillRange -= fillStart) < 0 ? 0 : fillRange);
                fillEnd = 1 < fillEnd ? 1 : fillEnd, uvDirty && this.updateUVs(sprite, fillStart, fillEnd), 
                vertDirty && (this.updateVerts && this.updateVerts(sprite, fillStart, fillEnd), 
                this.updateWorldVerts(sprite));
            }
        },
        updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
            var spriteFrame = sprite.spriteFrame, renderData = sprite.renderData, datas = renderData.datas, atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), ul = 0, vb = 0, quadUV0 = 0, quadUV1 = 0, quadUV2 = 0, quadUV3 = 0, quadUV4 = 0, quadUV5 = 0, quadUV6 = 0, quadUV7 = 0;
            switch (spriteFrame.isRotated() ? (ul = textureRect.x / atlasWidth, vb = (textureRect.y + textureRect.width) / atlasHeight, 
            quadUV0 = quadUV2 = ul, quadUV4 = quadUV6 = (textureRect.x + textureRect.height) / atlasWidth, 
            quadUV3 = quadUV7 = vb, quadUV1 = quadUV5 = textureRect.y / atlasHeight) : (ul = textureRect.x / atlasWidth, 
            vb = (textureRect.y + textureRect.height) / atlasHeight, quadUV0 = quadUV4 = ul, 
            quadUV2 = quadUV6 = (textureRect.x + textureRect.width) / atlasWidth, quadUV1 = quadUV3 = vb, 
            quadUV5 = quadUV7 = textureRect.y / atlasHeight), sprite.fillType) {
              case FillType$1.HORIZONTAL:
                datas[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart, 
                datas[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd, datas[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd, 
                datas[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart, datas[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart, 
                datas[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd, datas[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                break;

              case FillType$1.VERTICAL:
                datas[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart, 
                datas[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart, datas[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart, 
                datas[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd, datas[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd, 
                datas[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd, datas[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                break;

              default:
                cc.errorID(2626);
            }
            renderData.uvDirty = !1;
        },
        updateVerts: function updateVerts(sprite, fillStart, fillEnd) {
            var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, progressEnd = 0;
            switch (sprite.fillType) {
              case FillType$1.HORIZONTAL:
                progressEnd = l + (r - l) * fillEnd, l = l + (r - l) * fillStart, r = progressEnd;
                break;

              case FillType$1.VERTICAL:
                progressEnd = b + (t - b) * fillEnd, b = b + (t - b) * fillStart, t = progressEnd;
                break;

              default:
                cc.errorID(2626);
            }
            datas[4].x = l, datas[4].y = b, datas[5].x = r, datas[5].y = b, datas[6].x = l, 
            datas[6].y = t, datas[7].x = r, datas[7].y = t, renderData.vertDirty = !1;
        },
        createData: function createData(sprite) {
            var renderData = sprite.requestRenderData();
            renderData.dataLength = 8, renderData.vertexCount = 4, renderData.indiceCount = 6;
            var _iterator = renderData.datas, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.z = 0;
            }
            return renderData;
        },
        updateWorldVerts: function updateWorldVerts(sprite) {
            var node = sprite.node, datas = sprite.renderData.datas;
            node.getWorldMatrix(matrix);
            for (var i = 0; i < 4; i++) {
                var local = datas[i + 4], world = datas[i];
                vec3.transformMat4(world, local, matrix);
            }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            sprite.node.hasChanged && this.updateWorldVerts(sprite);
            sprite.node;
            fillVerticesWithoutCalc3D(0, renderer, sprite.renderData, sprite.color);
        }
    }, PI_2 = 2 * Math.PI, _vertPos = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _vertices = new Array(4), _uvs$1 = new Array(8), _intersectPoint_1 = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _intersectPoint_2 = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _center = new Vec2(), _triangles = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ];
    function _calcInsectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
        var sinAngle = Math.sin(angle);
        sinAngle = 1e-6 < Math.abs(sinAngle) ? sinAngle : 0;
        var cosAngle = Math.cos(angle), tanAngle = 0, cotAngle = 0;
        if (0 !== (cosAngle = 1e-6 < Math.abs(cosAngle) ? cosAngle : 0)) {
            if (tanAngle = sinAngle / cosAngle, 0 < (left - center.x) * cosAngle) {
                var yleft = center.y + tanAngle * (left - center.x);
                intersectPoints[0].x = left, intersectPoints[0].y = yleft;
            }
            if (0 < (right - center.x) * cosAngle) {
                var yright = center.y + tanAngle * (right - center.x);
                intersectPoints[2].x = right, intersectPoints[2].y = yright;
            }
        }
        if (0 !== sinAngle) {
            if (cotAngle = cosAngle / sinAngle, 0 < (top - center.y) * sinAngle) {
                var xtop = center.x + cotAngle * (top - center.y);
                intersectPoints[3].x = xtop, intersectPoints[3].y = top;
            }
            if (0 < (bottom - center.y) * sinAngle) {
                var xbottom = center.x + cotAngle * (bottom - center.y);
                intersectPoints[1].x = xbottom, intersectPoints[1].y = bottom;
            }
        }
    }
    function _getVertAngle(start, end) {
        var placementX = end.x - start.x, placementY = end.y - start.y;
        if (0 === placementX && 0 === placementY) return 0;
        if (0 === placementX) return 0 < placementY ? .5 * Math.PI : 1.5 * Math.PI;
        var angle = Math.atan(placementY / placementX);
        return placementX < 0 && (angle += Math.PI), angle;
    }
    function _generateTriangle(datas, offset, vert0, vert1, vert2) {
        var vertices = _vertices, v0x = vertices[0], v0y = vertices[1], v1x = vertices[2], v1y = vertices[3];
        datas[offset].x = vert0.x, datas[offset].y = vert0.y, datas[offset + 1].x = vert1.x, 
        datas[offset + 1].y = vert1.y, datas[offset + 2].x = vert2.x, datas[offset + 2].y = vert2.y;
        _generateUV((vert0.x - v0x) / (v1x - v0x), (vert0.y - v0y) / (v1y - v0y), datas, offset), 
        _generateUV((vert1.x - v0x) / (v1x - v0x), (vert1.y - v0y) / (v1y - v0y), datas, offset + 1), 
        _generateUV((vert2.x - v0x) / (v1x - v0x), (vert2.y - v0y) / (v1y - v0y), datas, offset + 2);
    }
    function _generateUV(progressX, progressY, data, offset) {
        var uvs = _uvs$1, px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX, px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX, py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX, py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX, uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY, uv.v = py1 + (py2 - py1) * progressY;
    }
    for (var radialFilled = {
        useModel: !1,
        createData: function createData(sprite) {
            return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            if (renderData && frame && (renderData.vertDirty || renderData.uvDirty)) {
                var datas = renderData.datas, fillStart = sprite.fillStart, fillRange = sprite.fillRange;
                for (fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange); 1 <= fillStart; ) fillStart -= 1;
                for (;fillStart < 0; ) fillStart += 1;
                var fillEnd = (fillStart *= PI_2) + (fillRange *= PI_2);
                !function _calculateVertices(sprite) {
                    var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, vertices = _vertices;
                    vertices[0] = l, vertices[1] = b, vertices[2] = r, vertices[3] = t;
                    var fillCenter = sprite.fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
                    _vertPos[0].x = _vertPos[3].x = l, _vertPos[1].x = _vertPos[2].x = r, _vertPos[0].y = _vertPos[1].y = b, 
                    _vertPos[2].y = _vertPos[3].y = t;
                    for (var _i = 0; _i < _triangles.length; _i++) {
                        var num = _triangles[_i];
                        vec2.set(num, 0, 0);
                    }
                    cx !== vertices[0] && vec2.set(_triangles[0], 3, 0), cx !== vertices[2] && vec2.set(_triangles[2], 1, 2), 
                    cy !== vertices[1] && vec2.set(_triangles[1], 0, 1), cy !== vertices[3] && vec2.set(_triangles[3], 2, 3);
                }(sprite), function _calculateUVs(spriteFrame) {
                    var atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), u0 = 0, u1 = 0, v0 = 0, v1 = 0, uvs = _uvs$1;
                    spriteFrame.isRotated() ? (u0 = textureRect.x / atlasWidth, u1 = (textureRect.x + textureRect.height) / atlasWidth, 
                    v0 = textureRect.y / atlasHeight, v1 = (textureRect.y + textureRect.width) / atlasHeight, 
                    uvs[0] = uvs[2] = u0, uvs[4] = uvs[6] = u1, uvs[3] = uvs[7] = v1, uvs[1] = uvs[5] = v0) : (u0 = textureRect.x / atlasWidth, 
                    u1 = (textureRect.x + textureRect.width) / atlasWidth, v0 = textureRect.y / atlasHeight, 
                    v1 = (textureRect.y + textureRect.height) / atlasHeight, uvs[0] = uvs[4] = u0, uvs[2] = uvs[6] = u1, 
                    uvs[1] = uvs[3] = v1, uvs[5] = uvs[7] = v0);
                }(frame), _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1), 
                _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
                for (var offset = 0, triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                    var triangle = _triangles[triangleIndex];
                    if (triangle) if (PI_2 <= fillRange) renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]), 
                    offset += 3; else {
                        var startAngle = _getVertAngle(_center, _vertPos[triangle.x]), endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
                        endAngle < startAngle && (endAngle += PI_2), startAngle -= PI_2, endAngle -= PI_2;
                        for (var testIndex = 0; testIndex < 3; ++testIndex) fillEnd <= startAngle || (fillStart <= startAngle ? (renderData.dataLength = offset + 3, 
                        _generateTriangle(datas, offset, _center, _vertPos[triangle.x], fillEnd <= endAngle ? _intersectPoint_2[triangleIndex] : _vertPos[triangle.y]), 
                        offset += 3) : endAngle <= fillStart || (endAngle <= fillEnd ? (renderData.dataLength = offset + 3, 
                        _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y])) : (renderData.dataLength = offset + 3, 
                        _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex])), 
                        offset += 3)), startAngle += PI_2, endAngle += PI_2;
                    }
                }
                renderData.indiceCount = renderData.vertexCount = offset, renderData.vertDirty = renderData.uvDirty = !1;
            }
        },
        fillBuffers: function fillBuffers(comp, renderer) {
            fillVertices3D(comp.node, renderer, comp.renderData, comp.color);
        }
    }, matrix$1 = cc.mat4(), vec3_temps$1 = [], i$3 = 0; i$3 < 4; i$3++) vec3_temps$1.push(new Vec3());
    var simple = {
        createData: function createData(sprite) {
            var renderData = sprite.requestRenderData();
            return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
            renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            renderData && frame && renderData.vertDirty && this.updateVerts && this.updateVerts(sprite);
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            if (null !== sprite) {
                var datas = sprite.renderData.datas, node = sprite.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
                buffer.request(4, 6) || (buffer = renderer.currBufferBatch, vertexId = indiceOffset = vertexOffset = 0);
                var vbuf = buffer.vData, ibuf = buffer.iData, data0 = datas[0], data3 = datas[3];
                vec3.set(vec3_temps$1[0], data0.x, data0.y, data0.z), vec3.set(vec3_temps$1[1], data3.x, data0.y, data0.z), 
                vec3.set(vec3_temps$1[2], data0.x, data3.y, data0.z), vec3.set(vec3_temps$1[3], data3.x, data3.y, data0.z);
                var uv = sprite.spriteFrame.uv;
                node.getWorldMatrix(matrix$1);
                for (var _i = 0; _i < 4; _i++) {
                    var vertex = vec3_temps$1[_i];
                    vec3.transformMat4(vertex, vertex, matrix$1), vbuf[vertexOffset++] = vertex.x, vbuf[vertexOffset++] = vertex.y, 
                    vbuf[vertexOffset++] = vertex.z;
                    var uvOffset = 2 * _i;
                    vbuf[vertexOffset++] = uv[0 + uvOffset], vbuf[vertexOffset++] = uv[1 + uvOffset], 
                    color4.array(vbuf, sprite.color, vertexOffset), vertexOffset += 4;
                }
                ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
                ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2;
            }
        },
        updateVerts: function updateVerts(sprite) {
            var renderData = sprite.renderData;
            if (renderData) {
                var node = sprite.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = 0, b = 0, r = 0, t = 0;
                if (sprite.trim) l = -appx, b = -appy, r = cw - appx, t = ch - appy; else {
                    var frame = sprite.spriteFrame, originSize = frame.getOriginalSize(), rect = frame.getRect(), ow = originSize.width, oh = originSize.height, rw = rect.width, rh = rect.height, offset = frame.getOffset(), scaleX = cw / ow, scaleY = ch / oh, trimLeft = offset.x + (ow - rw) / 2, trimRight = offset.x - (ow - rw) / 2;
                    l = trimLeft * scaleX - appx, b = (offset.y + (oh - rh) / 2) * scaleY - appy, r = cw + trimRight * scaleX - appx, 
                    t = ch + (offset.y - (oh - rh) / 2) * scaleY - appy;
                }
                datas[0].x = l, datas[0].y = b, datas[0].z = 0, datas[3].x = r, datas[3].y = t, 
                datas[3].z = 0, renderData.vertDirty = !1;
            }
        }
    }, vec3_temp$1 = vec3.create(), matrix$2 = new Mat4(), sliced = {
        useModel: !1,
        createData: function createData(sprite) {
            var renderData = sprite.requestRenderData();
            return renderData.dataLength = 20, renderData.vertexCount = 16, renderData.indiceCount = 54, 
            renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
            var frame = sprite.spriteFrame, renderData = sprite.renderData;
            renderData && frame && (renderData.vertDirty && (this.updateVerts(sprite), this.updateWorldVerts(sprite)));
        },
        updateVerts: function updateVerts(sprite) {
            var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, frame = sprite.spriteFrame, leftWidth = frame.insetLeft, rightWidth = frame.insetRight, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, sizableWidth = width - leftWidth - rightWidth, sizableHeight = height - topHeight - bottomHeight, xScale = width / (leftWidth + rightWidth), yScale = height / (topHeight + bottomHeight);
            xScale = isNaN(xScale) || 1 < xScale ? 1 : xScale, yScale = isNaN(yScale) || 1 < yScale ? 1 : yScale, 
            sizableWidth = sizableWidth < 0 ? 0 : sizableWidth, sizableHeight = sizableHeight < 0 ? 0 : sizableHeight, 
            datas[0].x = -appx, datas[0].y = -appy, datas[1].x = leftWidth * xScale - appx, 
            datas[1].y = bottomHeight * yScale - appy, datas[2].x = datas[1].x + sizableWidth, 
            datas[2].y = datas[1].y + sizableHeight, datas[3].x = width - appx, datas[3].y = height - appy, 
            renderData.vertDirty = !1;
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
            sprite.node.hasChanged && this.updateWorldVerts(sprite);
            var buffer = renderer.currBufferBatch, renderData = sprite.renderData, datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset, uvSliced = sprite.spriteFrame.uvSliced;
            buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexId = indiceOffset = vertexOffset = 0);
            for (var vbuf = buffer.vData, ibuf = buffer.iData, i = 4; i < 20; ++i) {
                var vert = datas[i], uvs = uvSliced[i - 4];
                vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                vbuf[vertexOffset++] = uvs.u, vbuf[vertexOffset++] = uvs.v, color4.array(vbuf, sprite.color, vertexOffset), 
                vertexOffset += 4;
            }
            for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
                var start = vertexId + 4 * r + c;
                ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 4, 
                ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 5, ibuf[indiceOffset++] = start + 4;
            }
        },
        updateWorldVerts: function updateWorldVerts(sprite) {
            var node = sprite.node, datas = sprite.renderData.datas;
            node.getWorldMatrix(matrix$2);
            for (var row = 0; row < 4; ++row) for (var rowD = datas[row], col = 0; col < 4; ++col) {
                var colD = datas[col], world = datas[4 + 4 * row + col];
                vec3.set(vec3_temp$1, colD.x, rowD.y, 0), vec3.transformMat4(world, vec3_temp$1, matrix$2);
            }
        }
    }, SpriteType$1 = SpriteComponent.Type, FillType$2 = SpriteComponent.FillType, spriteAssembler = {
        getAssembler: function getAssembler(sprite) {
            var util = simple, comp = sprite;
            switch (comp.type) {
              case SpriteType$1.SLICED:
                util = sliced;
                break;

              case SpriteType$1.FILLED:
                util = comp.fillType === FillType$2.RADIAL ? radialFilled : barFilled;
            }
            return util;
        }
    };
    SpriteComponent.Assembler = spriteAssembler;
    var Assembler = Object.freeze({
        graphicsAssemblerManager: graphicsAssemblerManager,
        labelAssembler: labelAssembler,
        ttfUtils: ttfUtils,
        bmfontUtils: bmfontUtils,
        CanvasPool: CanvasPool,
        get Stage() {
            return Stage;
        },
        StencilManager: StencilManager,
        spriteAssembler: spriteAssembler,
        fillVertices: function fillVertices(node, buffer, renderData, color) {
            var data = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount;
            buffer.request(vertexCount, renderData.indiceCount);
            var vbuf = buffer.vData;
            node.getWorldMatrix(_worldMatrix$2);
            for (var matrix = _worldMatrix$2, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13, i = 0; i < vertexCount; i++) {
                var vert = data[i];
                vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx, vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty, 
                vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, color4.array(vbuf, color, vertexOffset), 
                vertexOffset += 4;
            }
        },
        fillMeshVertices: function fillMeshVertices(node, buffer, renderData, color) {
            var datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request(vertexCount, renderData.indiceCount);
            var vbuf = buffer.vData, ibuf = buffer.iData;
            node.getWorldMatrix(_worldMatrix$2);
            for (var matrix = _worldMatrix$2, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13, i = 0; i < vertexCount; i++) {
                var vert = datas[i];
                vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx, vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty, 
                vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, color4.array(vbuf, color, vertexOffset), 
                vertexOffset += 4;
            }
            for (var _i = 0, count = vertexCount / 4; _i < count; _i++) {
                var start = vertexId + 4 * _i;
                ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 2, 
                ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 3, ibuf[indiceOffset++] = start + 2;
            }
        },
        fillVertices3D: fillVertices3D,
        fillMeshVertices3D: fillMeshVertices3D,
        fillVerticesWithoutCalc: function fillVerticesWithoutCalc(node, buffer, renderData, color) {
            var datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount;
            buffer.request(vertexCount, renderData.indiceCount);
            for (var vbuf = buffer.vData, i = 0; i < vertexCount; i++) {
                var vert = datas[i];
                vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.u, 
                vbuf[vertexOffset++] = vert.v, color4.array(vbuf, color, vertexOffset), vertexOffset += 4;
            }
        },
        fillVerticesWithoutCalc3D: fillVerticesWithoutCalc3D
    }), MeshBuffer = function() {
        function MeshBuffer(batcher) {
            _classCallCheck(this, MeshBuffer), this.batcher = void 0, this.vData = null, this.iData = null, 
            this.vb = null, this.ib = null, this.ia = null, this.byteStart = 0, this.byteOffset = 0, 
            this.indiceStart = 0, this.indiceOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, 
            this.dirty = !1, this._vertexFormatBytes = 9 * Float32Array.BYTES_PER_ELEMENT, this._initVDataCount = 256 * this._vertexFormatBytes, 
            this._initIDataCount = 1536, this._outofCallback = null, this.batcher = batcher;
        }
        return _createClass(MeshBuffer, [ {
            key: "initialize",
            value: function initialize(attrs, outofCallback) {
                this._outofCallback = outofCallback;
                var vbStride = 9 * Float32Array.BYTES_PER_ELEMENT;
                this.vb = this.vb || this.batcher.device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: 0,
                    stride: vbStride
                });
                var ibStride = Uint16Array.BYTES_PER_ELEMENT;
                this.ib = this.ib || this.batcher.device.createBuffer({
                    usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: 0,
                    stride: ibStride
                }), this.ia = this.ia || this.batcher.device.createInputAssembler({
                    attributes: attrs,
                    vertexBuffers: [ this.vb ],
                    indexBuffer: this.ib
                }), this._reallocBuffer();
            }
        }, {
            key: "request",
            value: function request(vertexCount, indiceCount) {
                var byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes, indiceOffset = this.indiceOffset + indiceCount;
                if (65535 < vertexCount + this.vertexOffset) return this.batcher.autoMergeBatches(), 
                this._outofCallback && this._outofCallback.call(this.batcher, vertexCount, indiceCount), 
                !1;
                var byteLength = this.vData.byteLength, indiceLength = this.iData.length;
                if (byteLength < byteOffset || indiceLength < indiceOffset) {
                    for (;byteLength < byteOffset || indiceLength < indiceOffset; ) this._initVDataCount *= 2, 
                    this._initIDataCount *= 2, byteLength = 4 * this._initVDataCount, indiceLength = this._initIDataCount;
                    this._reallocBuffer();
                }
                return this.vertexOffset += vertexCount, this.indiceOffset += indiceCount, this.byteOffset = byteOffset, 
                this.dirty = !0;
            }
        }, {
            key: "reset",
            value: function reset() {
                this.byteStart = 0, this.byteOffset = 0, this.indiceStart = 0, this.indiceOffset = 0, 
                this.vertexStart = 0, this.vertexOffset = 0, this.dirty = !1;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.ib.destroy(), this.vb.destroy(), this.ia.destroy(), this.ib = null, this.vb = null, 
                this.ia = null;
            }
        }, {
            key: "uploadData",
            value: function uploadData() {
                if (0 !== this.byteOffset && this.dirty) {
                    var vertexsData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2), indicesData = new Uint16Array(this.iData.buffer, 0, this.indiceOffset);
                    this.byteOffset > this.vb.size && this.vb.resize(this.byteOffset), this.vb.update(vertexsData), 
                    2 * this.indiceOffset > this.ib.size && this.ib.resize(2 * this.indiceOffset), this.ib.update(indicesData);
                }
            }
        }, {
            key: "_reallocBuffer",
            value: function _reallocBuffer() {
                this._reallocVData(!0), this._reallocIData(!0);
            }
        }, {
            key: "_reallocVData",
            value: function _reallocVData(copyOldData) {
                var oldVData;
                if (this.vData && (oldVData = new Uint8Array(this.vData.buffer)), this.vData = new Float32Array(this._initVDataCount), 
                oldVData && copyOldData) for (var newData = new Uint8Array(this.vData.buffer), i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
            }
        }, {
            key: "_reallocIData",
            value: function _reallocIData(copyOldData) {
                var oldIData = this.iData;
                if (this.iData = new Uint16Array(this._initIDataCount), oldIData && copyOldData) for (var iData = this.iData, i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
            }
        } ]), MeshBuffer;
    }();
    function cullSphereLight(light, model) {
        return !intersect.aabb_aabb(model.worldBounds, light.aabb);
    }
    function cullSpotLight(light, model) {
        return !intersect.aabb_aabb(model.worldBounds, light.aabb) || !intersect.aabb_frustum(model.worldBounds, light.frustum);
    }
    cc.UI = {
        Assembler: Assembler,
        MeshBuffer: MeshBuffer
    }, cc.geometry = geometry, cc.primitives = primitives, cc.utils = utils;
    (lightFrustum = new frustum()).accurate = !0;
    var lightFrustum, calcDirectionalLightCullFrustum = function() {
        var lightPos = cc.v3(), lightViewCenter = cc.v3(), lightRot = cc.quat(), camFrustum = new frustum();
        camFrustum.accurate = !0;
        var lightViewMat = cc.mat4(), lightVeiwMatInv = cc.mat4(), minBoxCorner = cc.v3(), maxBoxCorner = cc.v3();
        return function(out, sceneCamera, light, near, far, nearBias) {
            mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), sceneCamera.node.getWorldPosition(lightPos)), 
            mat4.invert(lightVeiwMatInv, lightViewMat), sceneCamera.getSplitFrustum(camFrustum, near, far), 
            camFrustum.transform(lightVeiwMatInv), vec3.set(minBoxCorner, camFrustum.vertices[0].x, camFrustum.vertices[0].y, camFrustum.vertices[0].z), 
            vec3.copy(maxBoxCorner, minBoxCorner);
            for (var i = 1; i < camFrustum.vertices.length; i++) minBoxCorner.x = Math.min(minBoxCorner.x, camFrustum.vertices[i].x), 
            minBoxCorner.y = Math.min(minBoxCorner.y, camFrustum.vertices[i].y), minBoxCorner.z = Math.min(minBoxCorner.z, camFrustum.vertices[i].z), 
            maxBoxCorner.x = Math.max(maxBoxCorner.x, camFrustum.vertices[i].x), maxBoxCorner.y = Math.max(maxBoxCorner.y, camFrustum.vertices[i].y), 
            maxBoxCorner.z = Math.max(maxBoxCorner.z, camFrustum.vertices[i].z);
            vec3.set(lightViewCenter, (minBoxCorner.x + maxBoxCorner.x) / 2, (minBoxCorner.y + maxBoxCorner.y) / 2, maxBoxCorner.z), 
            lightViewCenter.z += nearBias, vec3.transformMat4(lightPos, lightViewCenter, lightViewMat), 
            mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), lightPos), frustum.createOrtho(out, maxBoxCorner.x - minBoxCorner.x, maxBoxCorner.y - minBoxCorner.y, 0, minBoxCorner.z - nearBias - maxBoxCorner.z, lightViewMat);
        };
    }(), RenderFlow = function() {
        function RenderFlow(pipeline) {
            _classCallCheck(this, RenderFlow), this._device = void 0, this._pipeline = void 0, 
            this._name = "", this._priority = 0, this._stages = [], this._material = new Material(), 
            this._device = pipeline.device, this._pipeline = pipeline;
        }
        return _createClass(RenderFlow, [ {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "pipeline",
            get: function get() {
                return this._pipeline;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            }
        }, {
            key: "stages",
            get: function get() {
                return this._stages;
            }
        }, {
            key: "material",
            get: function get() {
                return this._material;
            }
        } ]), _createClass(RenderFlow, [ {
            key: "resize",
            value: function resize(width, height) {
                var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.resize(width, height);
                }
            }
        }, {
            key: "render",
            value: function render(view) {
                var _iterator2 = this._stages, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.render(view);
                }
            }
        }, {
            key: "createStage",
            value: function createStage(clazz, info) {
                var stage = new clazz(this);
                return stage.initialize(info) ? (this._stages.push(stage), this._stages.sort(function(a, b) {
                    return a.priority - b.priority;
                }), stage) : null;
            }
        }, {
            key: "destroyStages",
            value: function destroyStages() {
                var _iterator3 = this._stages, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.destroy();
                }
                this._stages = [];
            }
        } ]), RenderFlow;
    }(), RenderStage = function() {
        function RenderStage(flow) {
            if (_classCallCheck(this, RenderStage), this._flow = void 0, this._pipeline = void 0, 
            this._device = void 0, this._name = "", this._priority = 0, this._framebuffer = null, 
            this._cmdBuff = null, this._clearColors = void 0, this._clearDepth = 1, this._clearStencil = 0, 
            this._renderArea = void 0, this._pass = null, this._pso = null, this._flow = flow, 
            this._pipeline = flow.pipeline, this._device = flow.device, !this._flow.pipeline.root.device) throw new Error("");
            this._device = this._flow.pipeline.root.device, this._clearColors = [ {
                r: .3,
                g: .6,
                b: .9,
                a: 1
            } ], this._renderArea = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
        }
        return _createClass(RenderStage, [ {
            key: "flow",
            get: function get() {
                return this._flow;
            }
        }, {
            key: "pipeline",
            get: function get() {
                return this._pipeline;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            }
        }, {
            key: "framebuffer",
            get: function get() {
                return this._framebuffer;
            }
        } ]), _createClass(RenderStage, [ {
            key: "setClearColor",
            value: function setClearColor(color) {
                0 < this._clearColors.length ? this._clearColors[0] = color : this._clearColors.push(color);
            }
        }, {
            key: "setClearColors",
            value: function setClearColors(colors) {
                this._clearColors = colors;
            }
        }, {
            key: "setClearDepth",
            value: function setClearDepth(depth) {
                this._clearDepth = depth;
            }
        }, {
            key: "setClearStencil",
            value: function setClearStencil(stencil) {
                this._clearStencil = stencil;
            }
        }, {
            key: "setRenderArea",
            value: function setRenderArea(width, height) {
                this._renderArea.width = width, this._renderArea.height = height;
            }
        } ]), RenderStage;
    }(), SMAABlendStage = function(_RenderStage) {
        function SMAABlendStage(flow) {
            var _this;
            return _classCallCheck(this, SMAABlendStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SMAABlendStage).call(this, flow)))._areaTexImage = new Image(), 
            _this._searchTexImage = new Image(), _this._areaTexAsset = new Texture2D(), _this._searchTexAsset = new Texture2D(), 
            _this._hEdgeTexSampler = 0, _this._hAreaTexSampler = 0, _this._hSearchTexSampler = 0, 
            _this._isAreaImageLoaded = !1, _this._isSearchImageLoaded = !1, _this._isLoaded = !1, 
            _this._bindingLayout = null, _this;
        }
        return _inherits(SMAABlendStage, RenderStage), _createClass(SMAABlendStage, [ {
            key: "initialize",
            value: function initialize(info) {
                var _this2 = this;
                void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: GFXCommandBufferType.PRIMARY
                }), this._pass = this._flow.material.passes[1], this._hEdgeTexSampler = this._pass.getBinding("u_edgeTexSampler"), 
                this._hAreaTexSampler = this._pass.getBinding("u_areaTexSampler"), this._hSearchTexSampler = this._pass.getBinding("u_searchTexSampler");
                var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
                return this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
                this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hEdgeTexSampler, this._pipeline.smaaEdgeTexView), 
                this._pass.update(), this._bindingLayout.update(), this._areaTexImage.src = this.getAreaTexEncode(), 
                this._areaTexImage.onload = function() {
                    _this2._isAreaImageLoaded = !0, _this2.bindTextures();
                }, this._searchTexImage.src = this.getSearchTexEncode(), this._searchTexImage.onload = function() {
                    _this2._isSearchImageLoaded = !0, _this2.bindTextures();
                }, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._areaTexAsset.destroy(), this._searchTexAsset.destroy(), this._cmdBuff && (this._cmdBuff.destroy(), 
                this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                if (this._isLoaded) {
                    var camera = view.camera;
                    this._cmdBuff && (this._renderArea.width = camera.width, this._renderArea.height = camera.height, 
                    this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, GFXClearFlag.ALL, [ {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._bindingLayout), 
                    this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                    this._cmdBuff.endRenderPass(), this._cmdBuff.end()), this._device.queue.submit([ this._cmdBuff ]);
                }
            }
        }, {
            key: "bindTextures",
            value: function bindTextures() {
                this._isAreaImageLoaded && this._isSearchImageLoaded && (this._areaTexAsset.image = new ImageAsset(this._areaTexImage), 
                this._searchTexAsset.image = new ImageAsset(this._searchTexImage), this._pass.bindTextureView(this._hAreaTexSampler, this._areaTexAsset.getGFXTextureView()), 
                this._pass.bindTextureView(this._hSearchTexSampler, this._searchTexAsset.getGFXTextureView()), 
                this._pass.update(), this._bindingLayout.update(), this._isLoaded = !0);
            }
        }, {
            key: "getAreaTexEncode",
            value: function getAreaTexEncode() {
                return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
            }
        }, {
            key: "getSearchTexEncode",
            value: function getSearchTexEncode() {
                return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
            }
        } ]), SMAABlendStage;
    }(), SMAAEdgeStage = function(_RenderStage) {
        function SMAAEdgeStage(flow) {
            var _this;
            return _classCallCheck(this, SMAAEdgeStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SMAAEdgeStage).call(this, flow)))._hTexSampler = 0, 
            _this._bindingLayout = null, _this;
        }
        return _inherits(SMAAEdgeStage, RenderStage), _createClass(SMAAEdgeStage, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: GFXCommandBufferType.PRIMARY
                }), this._pass = this._flow.material.passes[0], this._hTexSampler = this._pass.getBinding("u_texSampler");
                var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
                return this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
                this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hTexSampler, this._pipeline.curShadingTexView), 
                this._pass.update(), this._bindingLayout.update(), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                var camera = view.camera;
                this._cmdBuff && (this._renderArea.width = camera.width, this._renderArea.height = camera.height, 
                this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, GFXClearFlag.ALL, [ {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._bindingLayout), 
                this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                this._cmdBuff.endRenderPass(), this._cmdBuff.end()), this._device.queue.submit([ this._cmdBuff ]);
            }
        } ]), SMAAEdgeStage;
    }(), SMAAEdgeFlow = function(_RenderFlow) {
        function SMAAEdgeFlow(pipeline) {
            return _classCallCheck(this, SMAAEdgeFlow), _possibleConstructorReturn(this, _getPrototypeOf(SMAAEdgeFlow).call(this, pipeline));
        }
        return _inherits(SMAAEdgeFlow, RenderFlow), _createClass(SMAAEdgeFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._name = info.name), this._priority = info.priority;
                var smaaMtl = this._material;
                return smaaMtl._uuid = "smaa-material", smaaMtl.initialize({
                    effectName: "pipeline/smaa"
                }), this.createStage(SMAAEdgeStage, {
                    name: "SMAAEdgeStage",
                    priority: 0,
                    framebuffer: this._pipeline.smaaEdgeFBO
                }), this.createStage(SMAABlendStage, {
                    name: "SMAABlendStage",
                    priority: 0,
                    framebuffer: this._pipeline.smaaBlendFBO
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._material && this._material.destroy(), this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {}
        } ]), SMAAEdgeFlow;
    }(), ToneMapStage = function(_RenderStage) {
        function ToneMapStage(flow) {
            var _this;
            return _classCallCheck(this, ToneMapStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ToneMapStage).call(this, flow)))._hTexSampler = 0, 
            _this._hBlendTexSampler = 0, _this._bindingLayout = null, _this;
        }
        return _inherits(ToneMapStage, RenderStage), _createClass(ToneMapStage, [ {
            key: "initialize",
            value: function initialize(info) {
                return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: GFXCommandBufferType.PRIMARY
                }), this.rebuild(), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {
                this._pass = this._flow.material.passes[0], this._hTexSampler = this._pass.getBinding("u_texSampler");
                var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
                this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
                this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hTexSampler, this._pipeline.curShadingTexView), 
                this._pipeline.useSMAA && (this._hBlendTexSampler = this._pass.getBinding("u_blendTexSampler"), 
                this._pass.bindTextureView(this._hBlendTexSampler, this._pipeline.smaaBlendTexView)), 
                this._pass.update(), this._bindingLayout.update();
            }
        }, {
            key: "render",
            value: function render(view) {
                var camera = view.camera;
                if (this._cmdBuff) {
                    this._renderArea.width = camera.width, this._renderArea.height = camera.height;
                    var framebuffer = view.window.framebuffer;
                    this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(framebuffer, this._renderArea, GFXClearFlag.ALL, [ {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._pso.pipelineLayout.layouts[0]), 
                    this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                    this._cmdBuff.endRenderPass(), this._cmdBuff.end();
                }
                this._device.queue.submit([ this._cmdBuff ]);
            }
        } ]), ToneMapStage;
    }(), ToneMapFlow = function(_RenderFlow) {
        function ToneMapFlow(pipeline) {
            return _classCallCheck(this, ToneMapFlow), _possibleConstructorReturn(this, _getPrototypeOf(ToneMapFlow).call(this, pipeline));
        }
        return _inherits(ToneMapFlow, RenderFlow), _createClass(ToneMapFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                this._material.initialize({
                    effectName: "pipeline/tonemap",
                    defines: {
                        CC_USE_SMAA: this._pipeline.useSMAA
                    }
                });
                var framebuffer = this._pipeline.root.mainWindow.framebuffer;
                return this.createStage(ToneMapStage, {
                    name: "ToneMapStage",
                    priority: 0,
                    framebuffer: framebuffer
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._material && this._material.destroy(), this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {
                this._material && (this._material.destroy(), this._material.initialize({
                    effectName: "pipeline/tonemap",
                    defines: {
                        CC_USE_SMAA: this._pipeline.useSMAA
                    }
                }));
                var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.rebuild();
                }
            }
        } ]), ToneMapFlow;
    }(), _vec4Array = new Float32Array(4), _vec4ArrayZero = [ 0, 0, 0, 0 ], _mat4Array = new Float32Array(16), _outMat = new Mat4(), _v3tmp = new Vec3(), RenderPipeline = function() {
        function RenderPipeline(root) {
            _classCallCheck(this, RenderPipeline), this._root = void 0, this._device = void 0, 
            this._name = "BasePipeline", this._renderObjects = [], this._renderPasses = new Map(), 
            this._flows = [], this._isHDRSupported = !1, this._isHDR = !1, this._lightMeterScale = 1e4, 
            this._shadingPass = null, this._fboCount = 1, this._msaaShadingTex = null, this._msaaShadingTexView = null, 
            this._msaaDepthStencilTex = null, this._msaaDepthStencilTexView = null, this._msaaShadingFBO = null, 
            this._colorFmt = exports.GFXFormat.UNKNOWN, this._depthStencilFmt = exports.GFXFormat.UNKNOWN, 
            this._shadingTextures = [], this._shadingTexViews = [], this._depthStencilTex = null, 
            this._depthStencilTexView = null, this._shadingFBOs = [], this._shadingWidth = 0, 
            this._shadingHeight = 0, this._shadingScale = 1, this._curIdx = 0, this._prevIdx = 1, 
            this._usePostProcess = !1, this._useMSAA = !1, this._useSMAA = !1, this._smaaPass = null, 
            this._smaaEdgeFBO = null, this._smaaEdgeTex = null, this._smaaEdgeTexView = null, 
            this._smaaBlendFBO = null, this._smaaBlendTex = null, this._smaaBlendTexView = null, 
            this._quadVB = null, this._quadIB = null, this._quadIA = null, this._defaultUboGlobal = new UBOGlobal(), 
            this._globalBindings = new Map(), this._defaultTex = null, this._defaultTexView = null, 
            this._fpScale = 1 / 1024, this._fpScaleInv = 1024, this._macros = {}, this._root = root, 
            this._device = root.device;
        }
        return _createClass(RenderPipeline, [ {
            key: "root",
            get: function get() {
                return this._root;
            }
        }, {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "renderObjects",
            get: function get() {
                return this._renderObjects;
            }
        }, {
            key: "flows",
            get: function get() {
                return this._flows;
            }
        }, {
            key: "usePostProcess",
            get: function get() {
                return this._usePostProcess;
            }
        }, {
            key: "isHDRSupported",
            get: function get() {
                return this._isHDRSupported;
            }
        }, {
            key: "isHDR",
            get: function get() {
                return this._isHDR;
            }
        }, {
            key: "shadingScale",
            get: function get() {
                return this._shadingScale;
            }
        }, {
            key: "lightMeterScale",
            set: function set(scale) {
                this._lightMeterScale = scale;
            },
            get: function get() {
                return this._lightMeterScale;
            }
        }, {
            key: "depthStencilTexView",
            get: function get() {
                return this._depthStencilTexView;
            }
        }, {
            key: "curShadingTexView",
            get: function get() {
                return this._shadingTexViews[this._curIdx];
            }
        }, {
            key: "prevShadingTexView",
            get: function get() {
                return this._shadingTexViews[this._prevIdx];
            }
        }, {
            key: "curShadingFBO",
            get: function get() {
                return this._shadingFBOs[this._curIdx];
            }
        }, {
            key: "prevShadingFBO",
            get: function get() {
                return this._shadingFBOs[this._prevIdx];
            }
        }, {
            key: "msaaShadingFBO",
            get: function get() {
                return this._msaaShadingFBO;
            }
        }, {
            key: "useMSAA",
            get: function get() {
                return this._useMSAA;
            }
        }, {
            key: "useSMAA",
            get: function get() {
                return this._useSMAA;
            }
        }, {
            key: "smaaEdgeTexView",
            get: function get() {
                return this._smaaEdgeTexView;
            }
        }, {
            key: "smaaEdgeFBO",
            get: function get() {
                return this._smaaEdgeFBO;
            }
        }, {
            key: "smaaBlendTexView",
            get: function get() {
                return this._smaaBlendTexView;
            }
        }, {
            key: "smaaBlendFBO",
            get: function get() {
                return this._smaaBlendFBO;
            }
        }, {
            key: "quadIA",
            get: function get() {
                return this._quadIA;
            }
        }, {
            key: "globalBindings",
            get: function get() {
                return this._globalBindings;
            }
        }, {
            key: "defaultTexture",
            get: function get() {
                return this._defaultTex;
            }
        }, {
            key: "fpScale",
            get: function get() {
                return this._fpScale;
            }
        }, {
            key: "fpScaleInv",
            get: function get() {
                return this._fpScaleInv;
            }
        }, {
            key: "macros",
            get: function get() {
                return this._macros;
            }
        }, {
            key: "defaultGlobalUBOData",
            get: function get() {
                return this._defaultUboGlobal.view;
            }
        } ]), _createClass(RenderPipeline, [ {
            key: "rebuild",
            value: function rebuild() {
                this.updateMacros();
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                var w = Math.floor(width * this._shadingScale), h = Math.floor(height * this._shadingScale);
                (w > this._shadingWidth || h > this._shadingHeight) && this.resizeFBOs(w, h);
                var _iterator = this._flows, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.resize(width, height);
                }
            }
        }, {
            key: "render",
            value: function render(view) {
                view.camera.update(), this.sceneCulling(view), this.updateUBOs(view);
                var _iterator2 = view.flows, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.render(view);
                }
            }
        }, {
            key: "swapFBOs",
            value: function swapFBOs() {
                var temp = this._curIdx;
                this._curIdx = this._prevIdx, this._prevIdx = temp;
            }
        }, {
            key: "addRenderPass",
            value: function addRenderPass(stage, renderPass) {
                renderPass && this._renderPasses.set(stage, renderPass);
            }
        }, {
            key: "getRenderPass",
            value: function getRenderPass(stage) {
                var renderPass = this._renderPasses.get(stage);
                return renderPass || null;
            }
        }, {
            key: "removeRenderPass",
            value: function removeRenderPass(stage) {
                this._renderPasses.delete(stage);
            }
        }, {
            key: "clearRenderPasses",
            value: function clearRenderPasses() {
                this._renderPasses.clear();
            }
        }, {
            key: "createFlow",
            value: function createFlow(clazz, info) {
                var flow = new clazz(this);
                return flow.initialize(info) ? (this._flows.push(flow), this._flows.sort(function(a, b) {
                    return a.priority - b.priority;
                }), flow) : null;
            }
        }, {
            key: "destroyFlows",
            value: function destroyFlows() {
                var _iterator3 = this._flows, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.destroy();
                }
                this._flows = [];
            }
        }, {
            key: "getFlow",
            value: function getFlow(name) {
                var _iterator4 = this._flows, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var flow = _ref4;
                    if (flow.name === name) return flow;
                }
                return null;
            }
        }, {
            key: "_initialize",
            value: function _initialize(info) {
                void 0 !== info.enablePostProcess ? this._usePostProcess = info.enablePostProcess : (cc.sys.platform, 
                cc.sys.WECHAT_GAME, this._usePostProcess = !0), this._usePostProcess && ((this._device.hasFeature(GFXFeature.FORMAT_R11G11B10F) || this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT) || this._device.hasFeature(GFXFeature.TEXTURE_FLOAT)) && (this._isHDRSupported = !0), 
                this._fboCount = 1, this._shadingTextures = new Array(this._fboCount), this._shadingTexViews = new Array(this._fboCount), 
                this._shadingFBOs = new Array(this._fboCount), this._isHDR = void 0 === info.enableHDR || info.enableHDR, 
                this._useSMAA = void 0 !== info.enableSMAA && info.enableSMAA, this._useMSAA = void 0 !== info.enableMSAA && info.enableMSAA, 
                this._useMSAA && (this._useMSAA = this.device.hasFeature(GFXFeature.MSAA))), this._isHDR && this._isHDRSupported && (this._device.hasFeature(GFXFeature.COLOR_HALF_FLOAT) && this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT_LINEAR) ? this._device.hasFeature(GFXFeature.FORMAT_R11G11B10F) ? (this._colorFmt = exports.GFXFormat.R11G11B10F, 
                this._isHDR = !0) : this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT) && (this._colorFmt = exports.GFXFormat.RGBA16F, 
                this._isHDR = !0) : this._device.hasFeature(GFXFeature.COLOR_FLOAT) && this._device.hasFeature(GFXFeature.TEXTURE_FLOAT_LINEAR) && this._device.hasFeature(GFXFeature.TEXTURE_FLOAT) && (this._colorFmt = exports.GFXFormat.RGBA32F, 
                this._isHDR = !0), this._isHDR = !1), this._isHDR || (this._colorFmt = exports.GFXFormat.RGBA8), 
                24 === this._device.depthBits ? 8 === this._device.stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : this._depthStencilFmt = exports.GFXFormat.D16, 
                this.updateMacros(), this._shadingScale = 1, this._shadingWidth = Math.floor(this._device.nativeWidth), 
                this._shadingHeight = Math.floor(this._device.nativeHeight), console.info("USE_POST_PROCESS: " + this._usePostProcess), 
                this._usePostProcess && (console.info("USE_MSAA: " + this._useMSAA), console.info("USE_SMAA: " + this._useSMAA), 
                console.info("USE_HDR: " + this._isHDR)), console.info("SHADING_SIZE: " + this._shadingWidth + " x " + this._shadingHeight), 
                console.info("SHADING_SCALE: " + this._shadingScale.toFixed(4)), console.info("SHADING_COLOR_FORMAT: " + GFXFormatInfos[this._colorFmt].name), 
                console.info("SHADING_DEPTH_FORMAT: " + GFXFormatInfos[this._depthStencilFmt].name), 
                this._shadingPass = this._device.createRenderPass({
                    colorAttachments: [ {
                        format: this._colorFmt,
                        loadOp: GFXLoadOp.CLEAR,
                        storeOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                    } ],
                    depthStencilAttachment: {
                        format: this._depthStencilFmt,
                        depthLoadOp: GFXLoadOp.CLEAR,
                        depthStoreOp: GFXStoreOp.STORE,
                        stencilLoadOp: GFXLoadOp.CLEAR,
                        stencilStoreOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                    }
                }), this._useMSAA && (this._msaaShadingTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._colorFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._msaaShadingTexView = this._device.createTextureView({
                    texture: this._msaaShadingTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                }), this._msaaDepthStencilTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._depthStencilFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._msaaDepthStencilTexView = this._device.createTextureView({
                    texture: this._msaaDepthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                }), this._msaaShadingFBO = this._device.createFramebuffer({
                    renderPass: this._shadingPass,
                    colorViews: [ this._msaaShadingTexView ],
                    depthStencilView: this._msaaDepthStencilTexView
                })), this._depthStencilTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._depthStencilFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._depthStencilTexView = this._device.createTextureView({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                });
                for (var i = 0; i < this._fboCount; ++i) this._shadingTextures[i] = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._colorFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._shadingTexViews[i] = this._device.createTextureView({
                    texture: this._shadingTextures[i],
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                }), this._shadingFBOs[i] = this._device.createFramebuffer({
                    renderPass: this._shadingPass,
                    colorViews: [ this._shadingTexViews[i] ],
                    depthStencilView: this._depthStencilTexView
                });
                if (this._useSMAA) {
                    var smaaColorFmt = exports.GFXFormat.RGBA8;
                    this._smaaPass = this._device.createRenderPass({
                        colorAttachments: [ {
                            format: smaaColorFmt,
                            loadOp: GFXLoadOp.CLEAR,
                            storeOp: GFXStoreOp.STORE,
                            sampleCount: 1,
                            beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                            endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                        } ]
                    }), this._smaaEdgeTex = this._device.createTexture({
                        type: GFXTextureType.TEX2D,
                        usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                        format: smaaColorFmt,
                        width: this._shadingWidth,
                        height: this._shadingHeight
                    }), this._smaaEdgeTexView = this._device.createTextureView({
                        texture: this._smaaEdgeTex,
                        type: GFXTextureViewType.TV2D,
                        format: smaaColorFmt
                    }), this._smaaEdgeFBO = this._device.createFramebuffer({
                        renderPass: this._smaaPass,
                        colorViews: [ this._smaaEdgeTexView ],
                        depthStencilView: null
                    }), this._smaaBlendTex = this._device.createTexture({
                        type: GFXTextureType.TEX2D,
                        usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                        format: smaaColorFmt,
                        width: this._shadingWidth,
                        height: this._shadingHeight
                    }), this._smaaBlendTexView = this._device.createTextureView({
                        texture: this._smaaBlendTex,
                        type: GFXTextureViewType.TV2D,
                        format: smaaColorFmt
                    }), this._smaaBlendFBO = this._device.createFramebuffer({
                        renderPass: this._smaaPass,
                        colorViews: [ this._smaaBlendTexView ],
                        depthStencilView: null
                    });
                }
                return !!this.createQuadInputAssembler() && !!this.createUBOs();
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                this.destroyFlows(), this.clearRenderPasses(), this.destroyQuadInputAssembler(), 
                this.destroyUBOs(), this._smaaEdgeTexView && (this._smaaEdgeTexView.destroy(), this._smaaEdgeTexView = null), 
                this._smaaEdgeTex && (this._smaaEdgeTex.destroy(), this._smaaEdgeTex = null), this._smaaEdgeFBO && (this._smaaEdgeFBO.destroy(), 
                this._smaaEdgeFBO = null), this._smaaBlendTexView && (this._smaaBlendTexView.destroy(), 
                this._smaaBlendTexView = null), this._smaaBlendTex && (this._smaaBlendTex.destroy(), 
                this._smaaBlendTex = null), this._smaaBlendFBO && (this._smaaBlendFBO.destroy(), 
                this._smaaBlendFBO = null), this._msaaShadingTexView && (this._msaaShadingTexView.destroy(), 
                this._msaaShadingTexView = null), this._msaaShadingTex && (this._msaaShadingTex.destroy(), 
                this._msaaShadingTex = null), this._msaaDepthStencilTexView && (this._msaaDepthStencilTexView.destroy(), 
                this._msaaDepthStencilTexView = null), this._msaaDepthStencilTex && (this._msaaDepthStencilTex.destroy(), 
                this._msaaDepthStencilTex = null), this._msaaShadingFBO && (this._msaaShadingFBO.destroy(), 
                this._msaaShadingFBO = null);
                for (var i = 0; i < this._shadingTexViews.length; ++i) this._shadingTexViews[i] && this._shadingTexViews[i].destroy(), 
                this._shadingTextures[i] && this._shadingTextures[i].destroy(), this._shadingFBOs[i] && this._shadingFBOs[i].destroy();
                this._shadingTexViews.splice(0), this._shadingTextures.splice(0), this._shadingFBOs.splice(0), 
                this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
                this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
                this._shadingPass && (this._shadingPass.destroy(), this._shadingPass = null);
            }
        }, {
            key: "resizeFBOs",
            value: function resizeFBOs(width, height) {
                this._shadingWidth = width, this._shadingHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
                this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                }));
                for (var i = 0; i < this._fboCount; ++i) this._shadingTextures[i].resize(width, height), 
                this._shadingTexViews[i].destroy(), this._shadingTexViews[i].initialize({
                    texture: this._shadingTextures[i],
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                }), this._shadingFBOs[i].destroy(), this._shadingFBOs[i].initialize({
                    renderPass: this._shadingPass,
                    colorViews: [ this._shadingTexViews[i] ],
                    depthStencilView: this._depthStencilTexView
                });
                if (this._useMSAA && (this._msaaShadingTex.resize(width, height), this._msaaShadingTexView.destroy(), 
                this._msaaShadingTexView.initialize({
                    texture: this._msaaShadingTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                }), this._msaaDepthStencilTex.resize(width, height), this._msaaDepthStencilTexView.destroy(), 
                this._msaaDepthStencilTexView.initialize({
                    texture: this._msaaDepthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                }), this._msaaShadingFBO.destroy(), this._msaaShadingFBO.initialize({
                    renderPass: this._shadingPass,
                    colorViews: [ this._msaaShadingTexView ],
                    depthStencilView: this._msaaDepthStencilTexView
                })), this._useSMAA) {
                    var smaaColorFmt = this._smaaEdgeTex.format;
                    this._smaaEdgeTex.resize(width, height), this._smaaEdgeTexView.destroy(), this._smaaEdgeTexView.initialize({
                        texture: this._smaaEdgeTex,
                        type: GFXTextureViewType.TV2D,
                        format: smaaColorFmt
                    }), this._smaaEdgeFBO.destroy(), this._smaaEdgeFBO.initialize({
                        renderPass: this._smaaPass,
                        colorViews: [ this._smaaEdgeTexView ],
                        depthStencilView: null
                    }), this._smaaBlendTex.resize(width, height), this._smaaBlendTexView.destroy(), 
                    this._smaaBlendTexView.initialize({
                        texture: this._smaaBlendTex,
                        type: GFXTextureViewType.TV2D,
                        format: smaaColorFmt
                    }), this._smaaBlendFBO.destroy(), this._smaaBlendFBO.initialize({
                        renderPass: this._smaaPass,
                        colorViews: [ this._smaaBlendTexView ],
                        depthStencilView: null
                    });
                }
                console.info("Resizing shading fbos: " + this._shadingWidth + "x" + this._shadingHeight);
            }
        }, {
            key: "updateMacros",
            value: function updateMacros() {
                this._macros.CC_USE_HDR = this._isHDR, programLib.destroyShaderByDefines(this._macros);
                var _iterator5 = this._root.scenes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.onPipelineChange();
                }
            }
        }, {
            key: "createQuadInputAssembler",
            value: function createQuadInputAssembler() {
                var vbStride = 4 * Float32Array.BYTES_PER_ELEMENT, vbSize = 4 * vbStride;
                if (this._quadVB = this._device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: vbSize,
                    stride: vbStride
                }), !this._quadVB) return !1;
                var verts = new Float32Array(16), n = 0;
                verts[n++] = -1, verts[n++] = -1, verts[n++] = 0, verts[n++] = 0, verts[n++] = 1, 
                verts[n++] = -1, verts[n++] = 1, verts[n++] = 0, verts[n++] = -1, verts[n++] = 1, 
                verts[n++] = 0, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, 
                verts[n++] = 1, this._quadVB.update(verts);
                var ibStride = Uint8Array.BYTES_PER_ELEMENT, ibSize = 6 * ibStride;
                if (this._quadIB = this._device.createBuffer({
                    usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: ibSize,
                    stride: ibStride
                }), !this._quadIB) return !1;
                var indices = new Uint8Array(6);
                indices[0] = 0, indices[1] = 1, indices[2] = 2, indices[3] = 1, indices[4] = 3, 
                indices[5] = 2, this._quadIB.update(indices);
                var attributes = [ {
                    name: "a_position",
                    format: exports.GFXFormat.RG32F
                }, {
                    name: "a_texCoord",
                    format: exports.GFXFormat.RG32F
                } ];
                return this._quadIA = this._device.createInputAssembler({
                    attributes: attributes,
                    vertexBuffers: [ this._quadVB ],
                    indexBuffer: this._quadIB
                }), !0;
            }
        }, {
            key: "destroyQuadInputAssembler",
            value: function destroyQuadInputAssembler() {
                this._quadVB && (this._quadVB.destroy(), this._quadVB = null), this._quadIB && (this._quadIB.destroy(), 
                this._quadIB = null), this._quadIA && (this._quadIA.destroy(), this._quadIA = null);
            }
        }, {
            key: "createUBOs",
            value: function createUBOs() {
                if (!this._globalBindings.get(UBOGlobal.BLOCK.name)) {
                    var globalUBO = this._root.device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: UBOGlobal.SIZE
                    });
                    if (!globalUBO) return !1;
                    this._globalBindings.set(UBOGlobal.BLOCK.name, {
                        type: GFXBindingType.UNIFORM_BUFFER,
                        blockInfo: UBOGlobal.BLOCK,
                        buffer: globalUBO
                    });
                }
                if (!this._globalBindings.get(UBOShadow.BLOCK.name)) {
                    var shadowUBO = this._root.device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: UBOShadow.SIZE
                    });
                    if (!shadowUBO) return !1;
                    this._globalBindings.set(UBOShadow.BLOCK.name, {
                        type: GFXBindingType.UNIFORM_BUFFER,
                        blockInfo: UBOShadow.BLOCK,
                        buffer: shadowUBO
                    });
                }
                return !0;
            }
        }, {
            key: "destroyUBOs",
            value: function destroyUBOs() {
                var globalUBO = this._globalBindings.get(UBOGlobal.BLOCK.name);
                globalUBO && (globalUBO.buffer.destroy(), this._globalBindings.delete(UBOGlobal.BLOCK.name));
                var shadowUBO = this._globalBindings.get(UBOShadow.BLOCK.name);
                shadowUBO && (shadowUBO.buffer.destroy(), this._globalBindings.delete(UBOShadow.BLOCK.name));
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs(view) {
                var camera = view.camera, scene = camera.scene, device = this._root.device, mainLight = scene.mainLight, ambient = scene.ambient;
                _vec4Array[0] = this._root.cumulativeTime, _vec4Array[1] = 0, _vec4Array[2] = 0, 
                _vec4Array[3] = 0, this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.TIME_OFFSET), 
                _vec4Array[0] = device.width, _vec4Array[1] = device.height, _vec4Array[2] = 1 / _vec4Array[0], 
                _vec4Array[3] = 1 / _vec4Array[1], this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.SCREEN_SIZE_OFFSET), 
                _vec4Array[0] = camera.width / this._shadingWidth * this._shadingScale, _vec4Array[1] = camera.height / this._shadingHeight * this._shadingScale, 
                _vec4Array[2] = 1 / _vec4Array[0], _vec4Array[3] = 1 / _vec4Array[1], this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.SCREEN_SCALE_OFFSET), 
                _vec4Array[0] = this._shadingWidth, _vec4Array[1] = this._shadingHeight, _vec4Array[2] = 1 / _vec4Array[0], 
                _vec4Array[3] = 1 / _vec4Array[1], this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.NATIVE_SIZE_OFFSET), 
                mat4.array(_mat4Array, camera.matView), this._defaultUboGlobal.view.set(_mat4Array, UBOGlobal.MAT_VIEW_OFFSET), 
                mat4.invert(_outMat, camera.matView), mat4.array(_mat4Array, _outMat), this._defaultUboGlobal.view.set(_mat4Array, UBOGlobal.MAT_VIEW_INV_OFFSET), 
                mat4.array(_mat4Array, camera.matProj), this._defaultUboGlobal.view.set(_mat4Array, UBOGlobal.MAT_PROJ_OFFSET), 
                mat4.invert(_outMat, camera.matProj), mat4.array(_mat4Array, _outMat), this._defaultUboGlobal.view.set(_mat4Array, UBOGlobal.MAT_PROJ_INV_OFFSET), 
                mat4.array(_mat4Array, camera.matViewProj), this._defaultUboGlobal.view.set(_mat4Array, UBOGlobal.MAT_VIEW_PROJ_OFFSET), 
                mat4.array(_mat4Array, camera.matViewProjInv), this._defaultUboGlobal.view.set(_mat4Array, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET), 
                vec3.array(_vec4Array, camera.position), _vec4Array[3] = 1, this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.CAMERA_POS_OFFSET);
                var exposure = camera.exposure;
                if (_vec4Array[0] = exposure, _vec4Array[1] = 1 / exposure, _vec4Array[2] = this._isHDR ? 1 : 0, 
                _vec4Array[3] = this._fpScale / exposure, this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.EXPOSURE_OFFSET), 
                vec3.array(_vec4Array, mainLight.direction), this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.MAIN_LIT_DIR_OFFSET), 
                mainLight.enabled) {
                    if (vec3.array(_vec4Array, mainLight.color), mainLight.useColorTemperature) {
                        var colorTempRGB = mainLight.colorTemperatureRGB;
                        _vec4Array[0] *= colorTempRGB.x, _vec4Array[1] *= colorTempRGB.y, _vec4Array[2] *= colorTempRGB.z;
                    }
                    this._isHDR ? _vec4Array[3] = mainLight.illuminance * this._fpScale : _vec4Array[3] = mainLight.illuminance * exposure;
                } else _vec4Array.set(_vec4ArrayZero);
                this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.MAIN_LIT_COLOR_OFFSET), _vec4Array.set(ambient.skyColor), 
                this._isHDR ? _vec4Array[3] = ambient.skyIllum * this._fpScale : _vec4Array[3] = ambient.skyIllum * exposure, 
                this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.AMBIENT_SKY_OFFSET), _vec4Array.set(ambient.groundAlbedo), 
                this._defaultUboGlobal.view.set(_vec4Array, UBOGlobal.AMBIENT_GROUND_OFFSET), this._globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this._defaultUboGlobal.view.buffer);
                var planarShadow = scene.planarShadow;
                planarShadow.enabled && this._globalBindings.get(UBOShadow.BLOCK.name).buffer.update(planarShadow.data);
            }
        }, {
            key: "sceneCulling",
            value: function sceneCulling(view) {
                var camera = view.camera, scene = camera.scene;
                this._renderObjects.splice(0);
                var mainLight = scene.mainLight;
                mainLight && mainLight.enabled && mainLight.update();
                var planarShadow = scene.planarShadow;
                planarShadow.enabled && planarShadow.updateDirLight(scene.mainLight), scene.skybox.enabled && this.addVisibleModel(scene.skybox, camera);
                var _iterator6 = scene.models, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    var model = _ref6;
                    model._resetUBOUpdateFlag(), 0 < view.visibility && model.viewID !== view.visibility || !model.enabled || (model.updateTransform(), 
                    model.worldBounds && !intersect.aabb_frustum(model.worldBounds, camera.frustum) || (model.updateUBOs(), 
                    this.addVisibleModel(model, camera)));
                }
            }
        }, {
            key: "addVisibleModel",
            value: function addVisibleModel(model, camera) {
                var depth = 0;
                model.node && (model.node.getWorldPosition(_v3tmp), vec3.subtract(_v3tmp, _v3tmp, camera.position), 
                depth = vec3.dot(_v3tmp, camera.forward)), this._renderObjects.push({
                    model: model,
                    depth: depth
                });
            }
        } ]), RenderPipeline;
    }();
    function opaqueCompareFn(a, b) {
        return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : a.depth - b.depth : a.hash - b.hash;
    }
    function transparentCompareFn(a, b) {
        return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : b.depth - a.depth : a.hash - b.hash;
    }
    var RenderQueue$1 = function() {
        function RenderQueue(desc) {
            _classCallCheck(this, RenderQueue), this.queue = void 0, this.cmdBuffs = void 0, 
            this.cmdBuffCount = 0, this._passDesc = void 0, this._passDesc = desc, this.cmdBuffs = new CachedArray(64), 
            this.queue = new CachedArray(64, this._passDesc.sortFunc);
        }
        return _createClass(RenderQueue, [ {
            key: "clear",
            value: function clear() {
                this.queue.clear(), this.cmdBuffCount = 0;
            }
        }, {
            key: "insertRenderPass",
            value: function insertRenderPass(renderObj, modelIdx, passIdx) {
                var subModel = renderObj.model.getSubModel(modelIdx), pass = subModel.passes[passIdx], pso = subModel.psos[passIdx];
                if (pso.blendState.targets[0].blend !== this._passDesc.isTransparent || !(pass.phase & this._passDesc.phases)) return !1;
                var hash = 0 | pass.priority << 16 | subModel.priority << 8 | passIdx;
                return this.queue.push({
                    hash: hash,
                    depth: renderObj.depth,
                    shaderId: pso.shader.id,
                    subModel: subModel,
                    cmdBuff: subModel.commandBuffers[passIdx]
                }), !0;
            }
        }, {
            key: "sort",
            value: function sort() {
                this.queue.sort(), this.cmdBuffCount = this.queue.length;
                for (var i = 0; i < this.queue.length; ++i) this.cmdBuffs.array[i] = this.queue.array[i].cmdBuff;
            }
        } ]), RenderQueue;
    }(), bufs = [], UIStage = function(_RenderStage) {
        function UIStage(flow) {
            var _this;
            return _classCallCheck(this, UIStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIStage).call(this, flow)))._uiQueue = void 0, 
            _this._uiQueue = new RenderQueue$1({
                isTransparent: !0,
                phases: getPhaseID("default"),
                sortFunc: transparentCompareFn
            }), _this;
        }
        return _inherits(UIStage, RenderStage), _createClass(UIStage, [ {
            key: "initialize",
            value: function initialize(info) {
                return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: GFXCommandBufferType.PRIMARY
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                this._uiQueue.clear();
                var _iterator = this._pipeline.renderObjects, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    for (var ro = _ref, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._uiQueue.insertRenderPass(ro, i, j);
                }
                this._uiQueue.sort();
                var framebuffer = view.window.framebuffer, cmdBuff = this._cmdBuff, camera = view.camera;
                this._renderArea.width = this.flow.pipeline.root.device.width, this._renderArea.height = this.flow.pipeline.root.device.height, 
                cmdBuff.begin(), cmdBuff.beginRenderPass(framebuffer, this._renderArea, GFXClearFlag.DEPTH_STENCIL, [], camera.clearDepth, camera.clearStencil), 
                cmdBuff.execute(this._uiQueue.cmdBuffs.array, this._uiQueue.cmdBuffCount), cmdBuff.endRenderPass(), 
                cmdBuff.end(), bufs[0] = cmdBuff, this._device.queue.submit(bufs);
            }
        } ]), UIStage;
    }(), UIFlow = function(_RenderFlow) {
        function UIFlow(pipeline) {
            return _classCallCheck(this, UIFlow), _possibleConstructorReturn(this, _getPrototypeOf(UIFlow).call(this, pipeline));
        }
        return _inherits(UIFlow, RenderFlow), _createClass(UIFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                void 0 !== info.name && (this._name = info.name), this._priority = info.priority;
                var mainWindow = this._pipeline.root.mainWindow;
                return !(!mainWindow || !mainWindow.framebuffer) && (this.createStage(UIStage, {
                    name: "UIStage",
                    priority: 0,
                    framebuffer: mainWindow.framebuffer
                }), !0);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                var isHDR = this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2];
                this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = 0, this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer), 
                _get(_getPrototypeOf(UIFlow.prototype), "render", this).call(this, view), this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = isHDR, 
                this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer);
            }
        } ]), UIFlow;
    }();
    var ForwardStagePriority, colors$1 = [], bufs$1 = [], ForwardStage = function(_RenderStage) {
        function ForwardStage(flow) {
            var _this;
            return _classCallCheck(this, ForwardStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardStage).call(this, flow)))._opaqueQueue = void 0, 
            _this._transparentQueue = void 0, _this._opaqueQueue = new RenderQueue$1({
                isTransparent: !1,
                phases: getPhaseID("default"),
                sortFunc: opaqueCompareFn
            }), _this._transparentQueue = new RenderQueue$1({
                isTransparent: !0,
                phases: getPhaseID("default") | getPhaseID("planarShadow"),
                sortFunc: transparentCompareFn
            }), _this;
        }
        return _inherits(ForwardStage, RenderStage), _createClass(ForwardStage, [ {
            key: "initialize",
            value: function initialize(info) {
                return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                this._cmdBuff = this._device.createCommandBuffer({
                    allocator: this._device.commandAllocator,
                    type: GFXCommandBufferType.PRIMARY
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
            }
        }, {
            key: "resize",
            value: function resize(width, height) {}
        }, {
            key: "rebuild",
            value: function rebuild() {}
        }, {
            key: "render",
            value: function render(view) {
                this._opaqueQueue.clear(), this._transparentQueue.clear();
                var _iterator = this._pipeline.renderObjects, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    for (var ro = _ref, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._opaqueQueue.insertRenderPass(ro, i, j), 
                    this._transparentQueue.insertRenderPass(ro, i, j);
                }
                this._opaqueQueue.sort(), this._transparentQueue.sort();
                var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
                if (this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
                this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
                camera.clearFlag & GFXClearFlag.COLOR) {
                    if (colors$1[0] = camera.clearColor, this._pipeline.isHDR) {
                        colors$1[0] = function SRGBToLinear(gamma) {
                            return {
                                r: Math.pow(gamma.r, 2.2),
                                g: Math.pow(gamma.g, 2.2),
                                b: Math.pow(gamma.b, 2.2),
                                a: 1
                            };
                        }(colors$1[0]);
                        var scale = this._pipeline.fpScale / camera.exposure;
                        colors$1[0].r *= scale, colors$1[0].g *= scale, colors$1[0].b *= scale;
                    }
                    colors$1.length = 1;
                }
                this._pipeline.usePostProcess ? this._pipeline.useMSAA ? this._framebuffer = this._pipeline.msaaShadingFBO : this._framebuffer = this._pipeline.curShadingFBO : this._framebuffer = view.window.framebuffer, 
                cmdBuff.begin(), cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, colors$1, camera.clearDepth, camera.clearStencil), 
                cmdBuff.execute(this._opaqueQueue.cmdBuffs.array, this._opaqueQueue.cmdBuffCount), 
                cmdBuff.execute(this._transparentQueue.cmdBuffs.array, this._transparentQueue.cmdBuffCount), 
                cmdBuff.endRenderPass(), cmdBuff.end(), bufs$1[0] = cmdBuff, this._device.queue.submit(bufs$1), 
                this._pipeline.useMSAA && this._device.blitFramebuffer(this._framebuffer, this._pipeline.curShadingFBO, this._renderArea, this._renderArea, GFXFilter.POINT);
            }
        } ]), ForwardStage;
    }();
    !function(ForwardStagePriority) {
        ForwardStagePriority[ForwardStagePriority.FORWARD = 0] = "FORWARD";
    }(ForwardStagePriority || (ForwardStagePriority = {}));
    var ForwardFlowPriority, ForwardFlow = function(_RenderFlow) {
        function ForwardFlow(pipeline) {
            return _classCallCheck(this, ForwardFlow), _possibleConstructorReturn(this, _getPrototypeOf(ForwardFlow).call(this, pipeline));
        }
        return _inherits(ForwardFlow, RenderFlow), _createClass(ForwardFlow, [ {
            key: "initialize",
            value: function initialize(info) {
                return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
                this.createStage(ForwardStage, {
                    name: "ForwardStage",
                    priority: ForwardStagePriority.FORWARD
                }), !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyStages();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {}
        } ]), ForwardFlow;
    }();
    !function(ForwardFlowPriority) {
        ForwardFlowPriority[ForwardFlowPriority.FORWARD = 0] = "FORWARD", ForwardFlowPriority[ForwardFlowPriority.UI = 10] = "UI";
    }(ForwardFlowPriority || (ForwardFlowPriority = {}));
    var RenderViewPriority, _vec4Array$1 = new Float32Array(4), _sphere = sphere.create(0, 0, 0, 1), _tempLightIndex = [], _tempLightDist = [], _tempVec3 = v3(), ForwardPipeline = function(_RenderPipeline) {
        function ForwardPipeline(root) {
            var _this;
            return _classCallCheck(this, ForwardPipeline), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardPipeline).call(this, root)))._uboLights = new UBOForwardLight(), 
            _this._lightsUBO = null, _this._validLights = void 0, _this._lightIndexOffset = void 0, 
            _this._lightIndices = void 0, _this._validLights = [], _this._lightIndexOffset = [], 
            _this._lightIndices = [], _this;
        }
        return _inherits(ForwardPipeline, RenderPipeline), _createClass(ForwardPipeline, [ {
            key: "lightsUBO",
            get: function get$$1() {
                return this._lightsUBO;
            }
        } ]), _createClass(ForwardPipeline, [ {
            key: "initialize",
            value: function initialize(info) {
                if (!this._initialize(info)) return !1;
                if (this._name = "ForwardPipeline", !this._globalBindings.get(UBOForwardLight.BLOCK.name)) {
                    var lightsUBO = this._root.device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: UBOForwardLight.SIZE
                    });
                    if (!lightsUBO) return !1;
                    this._globalBindings.set(UBOForwardLight.BLOCK.name, {
                        type: GFXBindingType.UNIFORM_BUFFER,
                        blockInfo: UBOForwardLight.BLOCK,
                        buffer: lightsUBO
                    });
                }
                var mainWindow = this._root.mainWindow, windowPass = null;
                return mainWindow && (windowPass = mainWindow.renderPass), windowPass ? (this.addRenderPass(RenderPassStage.DEFAULT, windowPass), 
                this.createFlow(ForwardFlow, {
                    name: "ForwardFlow",
                    priority: ForwardFlowPriority.FORWARD
                }), this._usePostProcess && (this._useSMAA && this.createFlow(SMAAEdgeFlow, {
                    name: "SMAAFlow",
                    priority: 0
                }), this.createFlow(ToneMapFlow, {
                    name: "ToneMapFlow",
                    priority: 0
                })), this.createFlow(UIFlow, {
                    name: "UIFlow",
                    priority: ForwardFlowPriority.UI
                }), !0) : (console.error("RenderPass of main window is null."), !1);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var lightsUBO = this._globalBindings.get(UBOForwardLight.BLOCK.name);
                lightsUBO && (lightsUBO.buffer.destroy(), this._globalBindings.delete(UBOForwardLight.BLOCK.name)), 
                this._destroy();
            }
        }, {
            key: "rebuild",
            value: function rebuild() {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "rebuild", this).call(this);
                var _iterator = this._flows, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.rebuild();
                }
            }
        }, {
            key: "updateUBOs",
            value: function updateUBOs(view) {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "updateUBOs", this).call(this, view);
                for (var exposure = view.camera.exposure, i = 0; i < this._renderObjects.length; i++) {
                    this._uboLights.view.fill(0);
                    var nextLightIndex = i + 1 < this._renderObjects.length ? this._lightIndexOffset[i + 1] : this._lightIndices.length;
                    if (this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name)) {
                        for (var sphereNum = 0, spotNum = 0, l = this._lightIndexOffset[i]; l < nextLightIndex; l++) {
                            var light = this._validLights[this._lightIndices[l]];
                            if (light && light.enabled) switch (light.type) {
                              case LightType.SPHERE:
                                if (UBOForwardLight.MAX_SPHERE_LIGHTS <= sphereNum) continue;
                                var sphereLit = light;
                                if (vec3.array(_vec4Array$1, sphereLit.position), this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_POS_OFFSET + 4 * sphereNum), 
                                _vec4Array$1[0] = sphereLit.size, _vec4Array$1[1] = sphereLit.range, _vec4Array$1[2] = 0, 
                                this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET + 4 * sphereNum), 
                                vec3.array(_vec4Array$1, light.color), light.useColorTemperature) {
                                    var tempRGB = light.colorTemperatureRGB;
                                    _vec4Array$1[0] *= tempRGB.x, _vec4Array$1[1] *= tempRGB.y, _vec4Array$1[2] *= tempRGB.z;
                                }
                                _vec4Array$1[3] = sphereLit.luminance * this._lightMeterScale, this._isHDR ? _vec4Array$1[3] = sphereLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array$1[3] = sphereLit.luminance * exposure * this._lightMeterScale, 
                                this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET + 4 * sphereNum), 
                                sphereNum++;
                                break;

                              case LightType.SPOT:
                                if (UBOForwardLight.MAX_SPOT_LIGHTS <= spotNum) continue;
                                var spotLit = light;
                                if (vec3.array(_vec4Array$1, spotLit.position), _vec4Array$1[3] = spotLit.size, 
                                this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_POS_OFFSET + 4 * spotNum), 
                                _vec4Array$1[0] = spotLit.size, _vec4Array$1[1] = spotLit.range, _vec4Array$1[2] = spotLit.spotAngle, 
                                this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * spotNum), 
                                vec3.array(_vec4Array$1, spotLit.direction), this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_DIR_OFFSET + 4 * spotNum), 
                                vec3.array(_vec4Array$1, light.color), light.useColorTemperature) {
                                    var _tempRGB = light.colorTemperatureRGB;
                                    _vec4Array$1[0] *= _tempRGB.x, _vec4Array$1[1] *= _tempRGB.y, _vec4Array$1[2] *= _tempRGB.z;
                                }
                                this._isHDR ? _vec4Array$1[3] = spotLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array$1[3] = spotLit.luminance * exposure * this._lightMeterScale, 
                                this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET + 4 * spotNum), 
                                spotNum++;
                            }
                        }
                        this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name).buffer.update(this._uboLights.view);
                    }
                }
            }
        }, {
            key: "sceneCulling",
            value: function sceneCulling(view) {
                _get(_getPrototypeOf(ForwardPipeline.prototype), "sceneCulling", this).call(this, view), 
                this._validLights.splice(0);
                var _iterator2 = view.camera.scene.sphereLights, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var light = _ref2;
                    light.enabled && (light.update(), sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range), 
                    intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(light));
                }
                var _iterator3 = view.camera.scene.spotLights, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _light = _ref3;
                    _light.enabled && (_light.update(), sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range), 
                    intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(_light));
                }
                this._lightIndexOffset.splice(0), this._lightIndices.splice(0);
                for (var i = 0; i < this._renderObjects.length; i++) this._lightIndexOffset[i] = this._lightIndices.length, 
                this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name) && this.cullLightPerModel(this._renderObjects[i].model);
            }
        }, {
            key: "cullLightPerModel",
            value: function cullLightPerModel(model) {
                var _this$_lightIndices;
                _tempLightIndex.splice(0);
                for (var i = 0; i < this._validLights.length; i++) {
                    var isCulled = !1;
                    switch (this._validLights[i].type) {
                      case LightType.DIRECTIONAL:
                        this._validLights[i], isCulled = !1;
                        break;

                      case LightType.SPHERE:
                        isCulled = cullSphereLight(this._validLights[i], model);
                        break;

                      case LightType.SPOT:
                        isCulled = cullSpotLight(this._validLights[i], model);
                    }
                    isCulled || (_tempLightIndex.push(i), this._validLights[i].type === LightType.DIRECTIONAL ? _tempLightDist[i] = 0 : _tempLightDist[i] = vec3.distance(this._validLights[i].position, model.node.getWorldPosition(_tempVec3)));
                }
                _tempLightIndex.sort(this.sortLight), (_this$_lightIndices = this._lightIndices).push.apply(_this$_lightIndices, _tempLightIndex);
            }
        }, {
            key: "sortLight",
            value: function sortLight(a, b) {
                return _tempLightDist[a] - _tempLightDist[b];
            }
        } ]), ForwardPipeline;
    }();
    !function(RenderViewPriority) {
        RenderViewPriority[RenderViewPriority.GENERAL = 100] = "GENERAL";
    }(RenderViewPriority || (RenderViewPriority = {}));
    var RenderView = function() {
        function RenderView(root, camera) {
            _classCallCheck(this, RenderView), this._root = void 0, this._name = "", this._window = null, 
            this._priority = 0, this._visibility = 0, this._camera = void 0, this._isEnable = !0, 
            this._isUI = !1, this._flows = [], this._root = root, this._camera = camera;
        }
        return _createClass(RenderView, [ {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "window",
            get: function get() {
                return this._window;
            },
            set: function set(val) {
                this._window = val;
            }
        }, {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(val) {
                this._priority = val, this.isUI && (this._priority |= 1 << 30);
            }
        }, {
            key: "visibility",
            set: function set(vis) {
                this._visibility = vis;
            },
            get: function get() {
                return this._visibility;
            }
        }, {
            key: "camera",
            get: function get() {
                return this._camera;
            }
        }, {
            key: "isEnable",
            get: function get() {
                return this._isEnable;
            }
        }, {
            key: "isUI",
            get: function get() {
                return this._isUI;
            }
        }, {
            key: "flows",
            get: function get() {
                return this._flows;
            }
        } ], [ {
            key: "registerCreateFunc",
            value: function registerCreateFunc(root) {
                root._createViewFun = function(_root, _camera) {
                    return new RenderView(_root, _camera);
                };
            }
        } ]), _createClass(RenderView, [ {
            key: "initialize",
            value: function initialize(info) {
                this._name = info.name, this._isUI = info.isUI, this.priority = info.priority, info.flows || (info.flows = [ "ForwardFlow", "ToneMapFlow", "SMAAFlow" ]);
                var _iterator = cc.director.root.pipeline.flows, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var f = _ref;
                    -1 !== info.flows.indexOf(f.name) && this.flows.push(f);
                }
                return !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._window = null, this._priority = 0;
            }
        }, {
            key: "enable",
            value: function enable(isEnable) {
                this._isEnable = isEnable;
            }
        } ]), RenderView;
    }(), _forward = new Vec3(0, 0, -1), _v3$1 = new Vec3(), _qt$1 = new Quat(), DirectionalLight = function(_Light) {
        function DirectionalLight(scene, name, node) {
            var _this;
            return _classCallCheck(this, DirectionalLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).call(this, scene, name, node)))._dir = new Vec3(1, -1, -1), 
            _this._illum = 65e3, _this._type = LightType.DIRECTIONAL, _this;
        }
        return _inherits(DirectionalLight, Light), _createClass(DirectionalLight, [ {
            key: "direction",
            set: function set(dir) {
                this._dir = dir, vec3.normalize(this._dir, this._dir);
            },
            get: function get() {
                return this._dir;
            }
        }, {
            key: "illuminance",
            set: function set(illum) {
                this._illum = illum;
            },
            get: function get() {
                return this._illum;
            }
        } ]), _createClass(DirectionalLight, [ {
            key: "update",
            value: function update() {
                this._node && (this._dir = vec3.transformQuat(_v3$1, _forward, this._node.getWorldRotation(_qt$1)), 
                vec3.normalize(this._dir, this._dir));
            }
        } ]), DirectionalLight;
    }(), _forward$1 = new Vec3(0, 0, -1), _v3$2 = new Vec3(), _qt$2 = new Quat(), PlanarShadow = function() {
        function PlanarShadow(scene) {
            _classCallCheck(this, PlanarShadow), this._scene = void 0, this._enabled = !1, this._normal = new Vec3(0, 1, 0), 
            this._distance = 0, this._matLight = new Mat4(), this._data = Float32Array.from([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, .3, .3, .3, 1 ]), 
            this._scene = scene;
        }
        return _createClass(PlanarShadow, [ {
            key: "enabled",
            set: function set(enable) {
                this._enabled = enable;
            },
            get: function get() {
                return this._enabled;
            }
        }, {
            key: "normal",
            set: function set(val) {
                vec3.copy(this._normal, val);
            },
            get: function get() {
                return this._normal;
            }
        }, {
            key: "distance",
            set: function set(val) {
                this._distance = val;
            },
            get: function get() {
                return this._distance;
            }
        }, {
            key: "shadowColor",
            set: function set(color) {
                color4.array(this._data, color, UBOShadow.SHADOW_COLOR_OFFSET);
            }
        }, {
            key: "matLight",
            get: function get() {
                return this._matLight;
            }
        }, {
            key: "data",
            get: function get() {
                return this._data;
            }
        } ]), _createClass(PlanarShadow, [ {
            key: "updateSphereLight",
            value: function updateSphereLight(light) {
                light.node.getWorldPosition(_v3$2);
                var n = this._normal, d = this._distance, NdL = vec3.dot(n, _v3$2), lx = _v3$2.x, ly = _v3$2.y, lz = _v3$2.z, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
                m.m00 = NdL - d - lx * nx, m.m01 = -ly * nx, m.m02 = -lz * nx, m.m03 = -nx, m.m04 = -lx * ny, 
                m.m05 = NdL - d - ly * ny, m.m06 = -lz * ny, m.m07 = -ny, m.m08 = -lx * nz, m.m09 = -ly * nz, 
                m.m10 = NdL - d - lz * nz, m.m11 = -nz, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
                m.m15 = NdL, mat4.array(this.data, this._matLight);
            }
        }, {
            key: "updateDirLight",
            value: function updateDirLight(light) {
                if (light.node.hasChanged) {
                    light.node.getWorldRotation(_qt$2), vec3.transformQuat(_v3$2, _forward$1, _qt$2);
                    var n = this._normal, d = this._distance, scale = 1 / vec3.dot(n, _v3$2), lx = _v3$2.x * scale, ly = _v3$2.y * scale, lz = _v3$2.z * scale, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
                    m.m00 = 1 - nx * lx, m.m01 = -nx * ly, m.m02 = -nx * lz, m.m03 = 0, m.m04 = -ny * lx, 
                    m.m05 = 1 - ny * ly, m.m06 = -ny * lz, m.m07 = 0, m.m08 = -nz * lx, m.m09 = -nz * ly, 
                    m.m10 = 1 - nz * lz, m.m11 = 0, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
                    m.m15 = 1, mat4.array(this.data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET);
                }
            }
        } ]), PlanarShadow;
    }(), Skybox = function(_Model) {
        function Skybox(scene) {
            var _this;
            _classCallCheck(this, Skybox), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Skybox).call(this, scene, null)))._default = builtinResMgr.get("default-cube-texture"), 
            _this._cubemap = _this._default, _this._isRGBE = !1, _this._material = new Material(), 
            _this._scene = scene, _this._material.initialize({
                effectName: "builtin-skybox",
                defines: {
                    USE_RGBE_CUBEMAP: _this._isRGBE
                }
            }), _this._material.setProperty("cubeMap", _this._cubemap);
            var subMeshData = createMesh(box({
                width: 2,
                height: 2,
                length: 2
            })).renderingMesh.getSubmesh(0);
            return _this.initSubModel(0, subMeshData, _this._material), _this._updateBindingLayout(), 
            _this;
        }
        return _inherits(Skybox, Model), _createClass(Skybox, [ {
            key: "cubemap",
            set: function set(val) {
                var newCubemap = val || this._default;
                this._cubemap = newCubemap, this._material.setProperty("cubeMap", this._cubemap), 
                this._updateBindingLayout();
            },
            get: function get() {
                return this._cubemap;
            }
        }, {
            key: "isRGBE",
            set: function set(val) {
                val !== this._isRGBE && (this._isRGBE = val, this._material.recompileShaders({
                    USE_RGBE_CUBEMAP: this._isRGBE
                }), this.setSubModelMaterial(0, this._material), this._updateBindingLayout());
            },
            get: function get() {
                return this._isRGBE;
            }
        } ]), _createClass(Skybox, [ {
            key: "_updateBindingLayout",
            value: function _updateBindingLayout() {
                this._matPSORecord.get(this._material)[0].pipelineLayout.layouts[0].update();
            }
        } ]), Skybox;
    }(), SphereLight = function(_Light) {
        function SphereLight(scene, name, node) {
            var _this;
            return _classCallCheck(this, SphereLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLight).call(this, scene, name, node)))._size = .15, 
            _this._range = 1, _this._luminance = 1700 / nt2lm(_this._size), _this._pos = void 0, 
            _this._aabb = void 0, _this._type = LightType.SPHERE, _this._aabb = aabb.create(), 
            _this._pos = new Vec3(), _this;
        }
        return _inherits(SphereLight, Light), _createClass(SphereLight, [ {
            key: "position",
            get: function get() {
                return this._pos;
            }
        }, {
            key: "size",
            set: function set(size) {
                this._size = size;
            },
            get: function get() {
                return this._size;
            }
        }, {
            key: "range",
            set: function set(range) {
                this._range = range;
            },
            get: function get() {
                return this._range;
            }
        }, {
            key: "luminance",
            set: function set(lum) {
                this._luminance = lum;
            },
            get: function get() {
                return this._luminance;
            }
        }, {
            key: "aabb",
            get: function get() {
                return this._aabb;
            }
        } ]), _createClass(SphereLight, [ {
            key: "update",
            value: function update() {
                this._node && (this._node.getWorldPosition(this._pos), aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range));
            }
        } ]), SphereLight;
    }(), _forward$2 = new Vec3(0, 0, -1), _v3$3 = new Vec3(), _qt$3 = new Quat(), _matView = new Mat4(), _matProj = new Mat4(), _matViewProj = new Mat4(), _matViewProjInv = new Mat4(), SpotLight = function(_Light) {
        function SpotLight(scene, name, node) {
            var _this;
            return _classCallCheck(this, SpotLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this, scene, name, node)))._dir = new Vec3(1, -1, -1), 
            _this._size = .15, _this._range = 5, _this._luminance = 1700 / nt2lm(_this._size), 
            _this._spotAngle = Math.cos(Math.PI / 6), _this._pos = void 0, _this._aabb = void 0, 
            _this._frustum = void 0, _this._angle = 0, _this._type = LightType.SPOT, _this._aabb = aabb.create(), 
            _this._frustum = frustum.create(), _this._pos = v3(), _this;
        }
        return _inherits(SpotLight, Light), _createClass(SpotLight, [ {
            key: "position",
            get: function get() {
                return this._pos;
            }
        }, {
            key: "size",
            set: function set(size) {
                this._size = size;
            },
            get: function get() {
                return this._size;
            }
        }, {
            key: "range",
            set: function set(range) {
                this._range = range;
            },
            get: function get() {
                return this._range;
            }
        }, {
            key: "luminance",
            set: function set(lum) {
                this._luminance = lum;
            },
            get: function get() {
                return this._luminance;
            }
        }, {
            key: "direction",
            get: function get() {
                return this._dir;
            }
        }, {
            key: "spotAngle",
            get: function get() {
                return this._spotAngle;
            },
            set: function set(val) {
                this._angle = .5 * val, this._spotAngle = Math.cos(.5 * val);
            }
        }, {
            key: "aabb",
            get: function get() {
                return this._aabb;
            }
        }, {
            key: "frustum",
            get: function get() {
                return this._frustum;
            }
        } ]), _createClass(SpotLight, [ {
            key: "update",
            value: function update() {
                this._node && (this._node.getWorldPosition(this._pos), this._dir = vec3.transformQuat(_v3$3, _forward$2, this._node.getWorldRotation(_qt$3)), 
                vec3.normalize(this._dir, this._dir), aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
                this._node.getWorldRT(_matView), mat4.invert(_matView, _matView), mat4.perspective(_matProj, this._angle, 1, .001, this._range), 
                mat4.multiply(_matViewProj, _matProj, _matView), mat4.invert(_matViewProjInv, _matViewProj), 
                this._frustum.update(_matViewProj, _matViewProjInv));
            }
        } ]), SpotLight;
    }(), RenderScene = function() {
        function RenderScene(root) {
            _classCallCheck(this, RenderScene), this._root = void 0, this._name = "", this._cameras = [], 
            this._ambient = void 0, this._skybox = void 0, this._planarShadow = void 0, this._mainLight = void 0, 
            this._defaultMainLightNode = void 0, this._sphereLights = [], this._spotLights = [], 
            this._models = [], this._modelId = 0, this._root = root, this._ambient = new Ambient(this), 
            this._defaultMainLightNode = new Node$1("Main Light"), this._mainLight = new DirectionalLight(this, "Main Light", this._defaultMainLightNode), 
            this._mainLight.illuminance = Ambient.SUN_ILLUM, this._mainLight.enabled = !0, this._ambient = new Ambient(this), 
            this._skybox = new Skybox(this), this._planarShadow = new PlanarShadow(this);
        }
        return _createClass(RenderScene, [ {
            key: "root",
            get: function get() {
                return this._root;
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }, {
            key: "cameras",
            get: function get() {
                return this._cameras;
            }
        }, {
            key: "ambient",
            get: function get() {
                return this._ambient;
            }
        }, {
            key: "skybox",
            get: function get() {
                return this._skybox;
            }
        }, {
            key: "planarShadow",
            get: function get() {
                return this._planarShadow;
            }
        }, {
            key: "defaultMainLightNode",
            get: function get() {
                return this._defaultMainLightNode;
            }
        }, {
            key: "mainLight",
            get: function get() {
                return this._mainLight;
            }
        }, {
            key: "sphereLights",
            get: function get() {
                return this._sphereLights;
            }
        }, {
            key: "spotLights",
            get: function get() {
                return this._spotLights;
            }
        }, {
            key: "models",
            get: function get() {
                return this._models;
            }
        } ], [ {
            key: "registerCreateFunc",
            value: function registerCreateFunc(root) {
                root._createSceneFun = function(_root) {
                    return new RenderScene(_root);
                };
            }
        } ]), _createClass(RenderScene, [ {
            key: "initialize",
            value: function initialize(info) {
                return this._name = info.name, !0;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyCameras(), this.destroyPointLights(), this.destroySpotLights(), this.destroyModels();
            }
        }, {
            key: "createCamera",
            value: function createCamera(info) {
                var camera = new Camera(this, info);
                return this._cameras.push(camera), camera;
            }
        }, {
            key: "destroyCamera",
            value: function destroyCamera(camera) {
                for (var i = 0; i < this._cameras.length; ++i) if (this._cameras[i] === camera) return camera.destroy(), 
                void this._cameras.splice(i, 1);
            }
        }, {
            key: "destroyCameras",
            value: function destroyCameras() {
                var _iterator = this._cameras, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.destroy();
                }
                this._cameras.splice(0);
            }
        }, {
            key: "createSphereLight",
            value: function createSphereLight(name, node) {
                var light = new SphereLight(this, name, node);
                return this._sphereLights.push(light), light;
            }
        }, {
            key: "destroySphereLight",
            value: function destroySphereLight(light) {
                for (var i = 0; i < this._sphereLights.length; ++i) if (this._sphereLights[i] === light) return void this._sphereLights.splice(i, 1);
            }
        }, {
            key: "createSpotLight",
            value: function createSpotLight(name, node) {
                var light = new SpotLight(this, name, node);
                return this._spotLights.push(light), light;
            }
        }, {
            key: "destroySpotLight",
            value: function destroySpotLight(light) {
                for (var i = 0; i < this._spotLights.length; ++i) if (this._spotLights[i] === light) return void this._spotLights.splice(i, 1);
            }
        }, {
            key: "destroyPointLights",
            value: function destroyPointLights() {
                this._sphereLights = [];
            }
        }, {
            key: "destroySpotLights",
            value: function destroySpotLights() {
                this._spotLights = [];
            }
        }, {
            key: "createModel",
            value: function createModel(clazz, node) {
                var model = new clazz(this, node);
                return this._models.push(model), model;
            }
        }, {
            key: "destroyModel",
            value: function destroyModel(model) {
                for (var i = 0; i < this._models.length; ++i) if (this._models[i] === model) return void this._models.splice(i, 1)[0].destroy();
            }
        }, {
            key: "destroyModels",
            value: function destroyModels() {
                var _iterator2 = this._models, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.destroy();
                }
                this._models = [];
            }
        }, {
            key: "onPipelineChange",
            value: function onPipelineChange() {
                var _iterator3 = this._models, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.onPipelineChange();
                }
                this._skybox.onPipelineChange();
            }
        }, {
            key: "generateModelId",
            value: function generateModelId() {
                return this._modelId++;
            }
        }, {
            key: "raycast",
            value: function raycast(worldRay) {
                var mask = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : Layers.RaycastMask;
                pool$1.reset();
                var _iterator4 = this._models, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var m = _ref4, transform = m.transform;
                    if (transform && m.enabled && cc.Layers.check(m.node.layer, mask) && m.modelBounds && (mat4.invert(m4, transform.getWorldMatrix(m4)), 
                    vec3.transformMat4(modelRay.o, worldRay.o, m4), vec3.normalize(modelRay.d, vec3.transformMat4Normal(modelRay.d, worldRay.d, m4)), 
                    !((distance$1 = intersect.ray_aabb(modelRay, m.modelBounds)) <= 0))) for (var i = 0; i < m.subModelNum; ++i) {
                        var subModel = m.getSubModel(i).subMeshData;
                        if (subModel && subModel.geometricInfo) {
                            var _subModel$geometricIn = subModel.geometricInfo, vb = _subModel$geometricIn.positions, ib = _subModel$geometricIn.indices, sides = _subModel$geometricIn.doubleSided;
                            narrowphase(vb, ib, subModel.primitiveMode, sides);
                        }
                        if (distance$1 < 1 / 0) {
                            var r = pool$1.add();
                            r.node = m.node, r.distance = distance$1 * vec3.magnitude(vec3.multiply(v3$1, modelRay.d, transform.worldScale)), 
                            results[pool$1.length - 1] = r;
                        }
                    }
                }
                return results.length = pool$1.length, results;
            }
        }, {
            key: "raycastUI",
            value: function raycastUI(worldRay) {
                var mask = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : Layers.UI;
                poolUI.reset();
                var canvasComs = cc.director.getScene().getComponentsInChildren(cc.CanvasComponent);
                if (null != canvasComs && 0 < canvasComs.length) {
                    var canvasNode = canvasComs[0].node;
                    null != canvasNode && canvasNode.active && this._raycastUINodeRecursiveChildren(worldRay, mask, canvasNode);
                }
                return resultUIs.length = poolUI.length, resultUIs;
            }
        }, {
            key: "raycastUINode",
            value: function raycastUINode(worldRay) {
                var mask = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : Layers.UI, uiNode = 2 < arguments.length ? arguments[2] : void 0, uiTransfrom = uiNode.uiTransfromComp;
                if (null != uiTransfrom && cc.Layers.check(uiNode.layer, mask) && (uiTransfrom.getComputeAABB(aabbUI), 
                !((distance$1 = intersect.ray_aabb(worldRay, aabbUI)) <= 0))) {
                    var r = poolUI.add();
                    return r.node = uiNode, r.distance = distance$1, r;
                }
            }
        }, {
            key: "_raycastUINodeRecursiveChildren",
            value: function _raycastUINodeRecursiveChildren(worldRay, mask, parent) {
                var result = this.raycastUINode(worldRay, mask, parent);
                null != result && (resultUIs[poolUI.length - 1] = result);
                var _iterator5 = parent.children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    var _node = _ref5;
                    null != _node && _node.active && this._raycastUINodeRecursiveChildren(worldRay, mask, _node);
                }
            }
        } ]), RenderScene;
    }(), modelRay = ray.create(), v3$1 = new Vec3(), m4 = new Mat4(), distance$1 = 1 / 0, tri = triangle.create(), pool$1 = new RecyclePool(function() {
        return {
            node: null,
            distance: 1 / 0
        };
    }, 8), results = [], aabbUI = new aabb(), poolUI = new RecyclePool(function() {
        return {
            node: null,
            distance: 1 / 0
        };
    }, 8), resultUIs = [], narrowphase = function narrowphase(vb, ib, pm, sides) {
        if (distance$1 = 1 / 0, pm === exports.GFXPrimitiveMode.TRIANGLE_LIST) for (var cnt = ib.length, j = 0; j < cnt; j += 3) {
            var i0 = 3 * ib[j], i1 = 3 * ib[j + 1], i2 = 3 * ib[j + 2];
            vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]), vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]), 
            vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
            var dist = intersect.ray_triangle(modelRay, tri, sides);
            dist <= 0 || distance$1 < dist || (distance$1 = dist);
        } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_STRIP) for (var _cnt = ib.length - 2, rev = 0, _j = 0; _j < _cnt; _j += 1) {
            var _i6 = 3 * ib[_j - rev], _i7 = 3 * ib[_j + rev + 1], _i8 = 3 * ib[_j + 2];
            vec3.set(tri.a, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]), vec3.set(tri.b, vb[_i7], vb[_i7 + 1], vb[_i7 + 2]), 
            vec3.set(tri.c, vb[_i8], vb[_i8 + 1], vb[_i8 + 2]), rev = ~rev;
            var _dist = intersect.ray_triangle(modelRay, tri, sides);
            _dist <= 0 || distance$1 < _dist || (distance$1 = _dist);
        } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_FAN) {
            var _cnt2 = ib.length - 1, _i9 = 3 * ib[0];
            vec3.set(tri.a, vb[_i9], vb[_i9 + 1], vb[_i9 + 2]);
            for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                var _i10 = 3 * ib[_j2], _i11 = 3 * ib[_j2 + 1];
                vec3.set(tri.b, vb[_i10], vb[_i10 + 1], vb[_i10 + 2]), vec3.set(tri.c, vb[_i11], vb[_i11 + 1], vb[_i11 + 2]);
                var _dist2 = intersect.ray_triangle(modelRay, tri, sides);
                _dist2 <= 0 || distance$1 < _dist2 || (distance$1 = _dist2);
            }
        }
    }, Root = function() {
        function Root(device) {
            _classCallCheck(this, Root), this._createSceneFun = void 0, this._createViewFun = void 0, 
            this._device = void 0, this._windows = [], this._mainWindow = null, this._curWindow = null, 
            this._pipeline = null, this._ui = null, this._scenes = [], this._views = [], this._time = 0, 
            this._frameTime = 0, this._fpsTime = 0, this._frameCount = 0, this._fps = 0, this._device = device, 
            RenderScene.registerCreateFunc(this), RenderView.registerCreateFunc(this);
        }
        return _createClass(Root, [ {
            key: "device",
            get: function get() {
                return this._device;
            }
        }, {
            key: "mainWindow",
            get: function get() {
                return this._mainWindow;
            }
        }, {
            key: "curWindow",
            get: function get() {
                return this._curWindow;
            }
        }, {
            key: "windows",
            get: function get() {
                return this._windows;
            }
        }, {
            key: "pipeline",
            get: function get() {
                return this._pipeline;
            }
        }, {
            key: "ui",
            get: function get() {
                return this._ui;
            }
        }, {
            key: "scenes",
            get: function get() {
                return this._scenes;
            }
        }, {
            key: "views",
            get: function get() {
                return this._views;
            }
        }, {
            key: "cumulativeTime",
            get: function get() {
                return this._time;
            }
        }, {
            key: "frameTime",
            get: function get() {
                return this._frameTime;
            }
        }, {
            key: "frameCount",
            get: function get() {
                return this._frameCount;
            }
        }, {
            key: "fps",
            get: function get() {
                return this._fps;
            }
        } ]), _createClass(Root, [ {
            key: "initialize",
            value: function initialize(info) {
                var _this = this;
                return !!this._device.mainWindow && (this._mainWindow = this._device.mainWindow, 
                this._curWindow = this._mainWindow, builtinResMgr.initBuiltinRes(this._device), 
                this._pipeline = new ForwardPipeline(this), this._pipeline.initialize(info) ? (this._ui = new UI(this), 
                this._ui.initialize() ? (cc.view.on("design-resolution-changed", function() {
                    var width = cc.game.canvas.width, height = cc.game.canvas.height;
                    _this.resize(width, height);
                }, this), !0) : (this.destroy(), !1)) : (this.destroy(), !1));
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.destroyViews(), this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), 
                this._pipeline = null), this._ui && (this._ui.destroy(), this._ui = null), this._curWindow = null, 
                this._mainWindow = null;
            }
        }, {
            key: "resize",
            value: function resize(width, height) {
                this._device.resize(width, height), this._mainWindow.resize(width, height);
                var _iterator = this._windows, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.resize(width, height);
                }
                this._pipeline && this._pipeline.resize(width, height);
                var _iterator2 = this._views, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var view = _ref2;
                    view.camera.isWindowSize && view.camera.resize(width, height);
                }
            }
        }, {
            key: "activeWindow",
            value: function activeWindow(window) {
                this._curWindow = window;
            }
        }, {
            key: "resetCumulativeTime",
            value: function resetCumulativeTime() {
                this._time = 0;
            }
        }, {
            key: "frameMove",
            value: function frameMove(deltaTime) {
                this._frameTime = deltaTime, ++this._frameCount, this._time += this._frameTime, 
                this._fpsTime += this._frameTime, 1 < this._fpsTime && (this._fps = this._frameCount, 
                this._frameCount = 0, this._fpsTime = 0);
                var _iterator3 = this._views, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var view = _ref3;
                    view.isEnable && view.window === this._curWindow && this._pipeline.render(view);
                }
            }
        }, {
            key: "createWindow",
            value: function createWindow(info) {
                if (this._device) {
                    var window = this._device.createWindow(info);
                    if (window) return this._windows.push(window), window;
                }
                return null;
            }
        }, {
            key: "destroyWindow",
            value: function destroyWindow(window) {
                for (var i = 0; i < this._windows.length; ++i) if (this._windows[i] === window) return window.destroy(), 
                void this._windows.splice(i, 1);
            }
        }, {
            key: "destroyWindows",
            value: function destroyWindows() {
                var _iterator4 = this._windows, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.destroy();
                }
                this._windows = [];
            }
        }, {
            key: "createScene",
            value: function createScene(info) {
                var scene = this._createSceneFun(this);
                return scene.initialize(info), this._scenes.push(scene), scene;
            }
        }, {
            key: "destroyScene",
            value: function destroyScene(scene) {
                for (var i = 0; i < this._scenes.length; ++i) if (this._scenes[i] === scene) return scene.destroy(), 
                void this._scenes.splice(i, 1);
            }
        }, {
            key: "destroyScenes",
            value: function destroyScenes() {
                var _iterator5 = this._scenes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.destroy();
                }
                this._scenes = [];
            }
        }, {
            key: "createView",
            value: function createView(info) {
                var view = this._createViewFun(this, info.camera);
                return view.initialize(info), this._views.push(view), this._views.sort(function(a, b) {
                    return a.priority - b.priority;
                }), view;
            }
        }, {
            key: "destroyView",
            value: function destroyView(view) {
                for (var i = 0; i < this._views.length; ++i) if (this._views[i] === view) return this._views.splice(i, 1), 
                void view.destroy();
            }
        }, {
            key: "destroyViews",
            value: function destroyViews() {
                var _iterator6 = this._views, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    _ref6.destroy();
                }
                this._views = [];
            }
        } ]), Root;
    }(), Director = function(_EventTarget) {
        function Director() {
            var _this;
            _classCallCheck(this, Director), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Director).call(this))).invalid = void 0, 
            _this._paused = void 0, _this._purgeDirectorInNextLoop = void 0, _this._root = void 0, 
            _this._loadingScene = void 0, _this._scene = void 0, _this._totalFrames = void 0, 
            _this._lastUpdate = void 0, _this._deltaTime = void 0, _this._scheduler = void 0, 
            _this._compScheduler = void 0, _this._nodeActivator = void 0, _this._physicsSystem = void 0, 
            _this._systems = void 0, _this._animationManager = void 0, _this.invalid = !1, _this._paused = !1, 
            _this._purgeDirectorInNextLoop = !1, _this._root = null, _this._loadingScene = "", 
            _this._scene = null, _this._totalFrames = 0, _this._lastUpdate = 0, _this._deltaTime = 0, 
            _this._scheduler = new Scheduler(), _this._compScheduler = new ComponentScheduler(), 
            _this._nodeActivator = new NodeActivator(), _this._physicsSystem = null, _this._systems = [];
            var self = _assertThisInitialized(_assertThisInitialized(_this));
            return cc.game.on(Game.EVENT_SHOW, function() {
                self._lastUpdate = performance.now();
            }), cc.game.once(Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_assertThisInitialized(_this))), 
            _this;
        }
        return _inherits(Director, EventTarget), _createClass(Director, [ {
            key: "init",
            value: function init() {
                this._totalFrames = 0, this._lastUpdate = performance.now(), this._paused = !1, 
                this._purgeDirectorInNextLoop = !1, this.sharedInit(), this._root = new Root(cc.game._gfxDevice);
                return !!this._root.initialize({});
            }
        }, {
            key: "sharedInit",
            value: function sharedInit() {
                eventManager && eventManager.setEnabled(!0), cc.AnimationManager ? (this._animationManager = new cc.AnimationManager(), 
                this._scheduler.scheduleUpdate(this._animationManager, Scheduler.PRIORITY_SYSTEM, !1)) : this._animationManager = null, 
                widgetManager && widgetManager.init(this), this._physicsSystem = new PhysicsSystem(), 
                cc.loader.init(this);
            }
        }, {
            key: "calculateDeltaTime",
            value: function calculateDeltaTime() {
                var now = performance.now();
                this._deltaTime = (now - this._lastUpdate) / 1e3, this._lastUpdate = now;
            }
        }, {
            key: "convertToGL",
            value: function convertToGL(uiPoint) {
                var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, x = view._devicePixelRatio * (uiPoint.x - left), y = view._devicePixelRatio * (top + box.height - uiPoint.y);
                return view._isRotated ? cc.v2(view._viewportRect.width - y, x) : cc.v2(x, y);
            }
        }, {
            key: "convertToUI",
            value: function convertToUI(glPoint) {
                var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, uiPoint = cc.v2(0, 0);
                return view._isRotated ? (uiPoint.x = left + glPoint.y / view._devicePixelRatio, 
                uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio) : (uiPoint.x = left + glPoint.x * view._devicePixelRatio, 
                uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio), uiPoint;
            }
        }, {
            key: "end",
            value: function end() {
                this._purgeDirectorInNextLoop = !0;
            }
        }, {
            key: "getWinSize",
            value: function getWinSize() {
                return cc.size(cc.winSize);
            }
        }, {
            key: "getWinSizeInPixels",
            value: function getWinSizeInPixels() {
                return cc.size(cc.winSize);
            }
        }, {
            key: "pause",
            value: function pause() {
                this._paused || (this._paused = !0);
            }
        }, {
            key: "purgeCachedData",
            value: function purgeCachedData() {
                cc.loader.releaseAll();
            }
        }, {
            key: "purgeDirector",
            value: function purgeDirector() {
                this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), 
                eventManager && eventManager.setEnabled(!1), cc.isValid(this._scene) && this._scene.destroy(), 
                this._scene = null, this.stopAnimation(), null != this._root && this._root.destroy(), 
                this._root = null, cc.loader.releaseAll();
            }
        }, {
            key: "reset",
            value: function reset() {
                var _this2 = this;
                this.purgeDirector(), eventManager && eventManager.setEnabled(!0), this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, !1), 
                this._systems.forEach(function(sys) {
                    _this2._scheduler.scheduleUpdate(sys, sys._priority, !1);
                }), this.startAnimation();
            }
        }, {
            key: "runSceneImmediate",
            value: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
                cc.assertID(scene instanceof cc.Scene, 1216);
                var uuid = cc.loader._getReferenceKey(scene.uuid);
                cc.loader.removeItem(uuid), scene._load();
                for (var persistNodeList = Object.keys(cc.game._persistRootNodes).map(function(x) {
                    return cc.game._persistRootNodes[x];
                }), i = 0; i < persistNodeList.length; i++) {
                    var node = persistNodeList[i];
                    node.emit(cc.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                    var existNode = scene.getChildByUuid(node.uuid);
                    if (existNode) {
                        var index = existNode.getSiblingIndex();
                        existNode._destroyImmediate(), scene.insertChild(node, index);
                    } else node.parent = scene;
                }
                var oldScene = this._scene;
                (function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
                    var releaseSettings = cc.loader._autoReleaseSetting, excludeMap = createMap();
                    if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = !0;
                    for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
                    if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
                        var key = oldSceneAssets[_i3];
                        !1 === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
                    }
                    for (var keys = Object.keys(releaseSettings), _i4 = 0; _i4 < keys.length; _i4++) {
                        var _key = keys[_i4];
                        !0 !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
                    }
                })(oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets, scene.dependAssets, persistNodeList), 
                cc.isValid(oldScene) && oldScene.destroy(), this._scene = null, CCObject._deferredDestroy(), 
                onBeforeLoadScene && onBeforeLoadScene(), this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene), 
                (this._scene = scene)._activate(), this._root && this._root.resetCumulativeTime(), 
                this.startAnimation(), onLaunched && onLaunched(null, scene), this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
            }
        }, {
            key: "runScene",
            value: function runScene(scene, onBeforeLoadScene, onLaunched) {
                var _this3 = this;
                cc.assertID(scene, 1205), cc.assertID(scene instanceof cc.Scene, 1216), scene._load(), 
                this.once(cc.Director.EVENT_AFTER_UPDATE, function() {
                    _this3.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                });
            }
        }, {
            key: "_getSceneUuid",
            value: function _getSceneUuid(key) {
                var scenes = cc.game._sceneInfos;
                if ("string" == typeof key) {
                    key.endsWith(".scene") || (key += ".scene"), "/" === key[0] || key.startsWith("db://") || (key = "/" + key);
                    for (var i = 0; i < scenes.length; i++) {
                        var info = scenes[i];
                        if (info.url.endsWith(key)) return info;
                    }
                } else if ("number" == typeof key) {
                    if (0 <= key && key < scenes.length) return scenes[key];
                    cc.errorID(1206, key);
                } else cc.errorID(1207, key);
                return null;
            }
        }, {
            key: "loadScene",
            value: function loadScene(sceneName, onLaunched, _onUnloaded) {
                if (this._loadingScene) return cc.errorID(1208, sceneName, this._loadingScene), 
                !1;
                var info = this._getSceneUuid(sceneName);
                if (info) {
                    var uuid = info.uuid;
                    return this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), this._loadingScene = sceneName, 
                    this._loadSceneByUuid(uuid, onLaunched, _onUnloaded), !0;
                }
                return cc.errorID(1209, sceneName), !1;
            }
        }, {
            key: "preloadScene",
            value: function preloadScene(sceneName, onProgress, onLoaded) {
                void 0 === onLoaded && (onLoaded = onProgress, onProgress = null);
                var info = this._getSceneUuid(sceneName);
                if (info) this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), cc.loader.load({
                    uuid: info.uuid,
                    type: "uuid"
                }, onProgress, function(error, asset) {
                    error && cc.errorID(1210, sceneName, error.message), onLoaded && onLoaded(error, asset);
                }); else {
                    var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
                    onLoaded(new Error(error)), cc.error("preloadScene: " + error);
                }
            }
        }, {
            key: "_loadSceneByUuid",
            value: function _loadSceneByUuid(uuid) {
                var onLaunched = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null, onUnloaded = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                3 < arguments.length && arguments[3];
                console.time("LoadScene " + uuid), cc.AssetLibrary.loadAsset(uuid, function(error, sceneAsset) {
                    console.timeEnd("LoadScene " + uuid);
                    var self = cc.director;
                    if (self._loadingScene = "", error) error = "Failed to load scene: " + error, cc.error(error); else {
                        if (sceneAsset instanceof cc.SceneAsset) {
                            var scene = sceneAsset.scene;
                            return scene._id = sceneAsset._uuid, scene._name = sceneAsset._name, void self.runSceneImmediate(scene, onUnloaded, onLaunched);
                        }
                        error = "The asset " + uuid + " is not a scene", cc.error(error);
                    }
                    onLaunched && onLaunched(error);
                });
            }
        }, {
            key: "resume",
            value: function resume() {
                this._paused && (this._lastUpdate = performance.now(), this._lastUpdate || cc.logID(1200), 
                this._paused = !1, this._deltaTime = 0);
            }
        }, {
            key: "setDepthTest",
            value: function setDepthTest(value$$1) {
                cc.Camera.main && (cc.Camera.main.depth = !!value$$1);
            }
        }, {
            key: "setClearColor",
            value: function setClearColor(clearColor) {
                cc.Camera.main && (cc.Camera.main.backgroundColor = clearColor);
            }
        }, {
            key: "getRunningScene",
            value: function getRunningScene() {
                return this._scene;
            }
        }, {
            key: "getScene",
            value: function getScene() {
                return this._scene;
            }
        }, {
            key: "getAnimationInterval",
            value: function getAnimationInterval() {
                return 1e3 / cc.game.getFrameRate();
            }
        }, {
            key: "setAnimationInterval",
            value: function setAnimationInterval(value$$1) {
                cc.game.setFrameRate(Math.round(1e3 / value$$1));
            }
        }, {
            key: "getDeltaTime",
            value: function getDeltaTime() {
                return this._deltaTime;
            }
        }, {
            key: "getTotalFrames",
            value: function getTotalFrames() {
                return this._totalFrames;
            }
        }, {
            key: "isPaused",
            value: function isPaused() {
                return this._paused;
            }
        }, {
            key: "getScheduler",
            value: function getScheduler() {
                return this._scheduler;
            }
        }, {
            key: "setScheduler",
            value: function setScheduler(scheduler) {
                this._scheduler !== scheduler && (this._scheduler = scheduler);
            }
        }, {
            key: "registerSystem",
            value: function registerSystem(name, cls, compClsNames, priority) {
                var sys = new cls();
                return sys._id = name, sys._priority = priority, compClsNames.forEach(function(compName) {
                    getClassByName(compName).system = sys;
                }), this._scheduler.scheduleUpdate(sys, priority, !1), sys.init(), this._systems.push(sys), 
                sys;
            }
        }, {
            key: "getSystem",
            value: function getSystem(name) {
                return this._systems.find(function(sys) {
                    return sys._id === name;
                });
            }
        }, {
            key: "getAnimationManager",
            value: function getAnimationManager() {
                return this._animationManager;
            }
        }, {
            key: "startAnimation",
            value: function startAnimation() {
                this.invalid = !1, this._lastUpdate = performance.now();
            }
        }, {
            key: "stopAnimation",
            value: function stopAnimation() {
                this.invalid = !0;
            }
        }, {
            key: "mainLoop",
            value: function mainLoop() {
                this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || (this.calculateDeltaTime(), 
                this._paused || (this.emit(cc.Director.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), 
                this._compScheduler.updatePhase(this._deltaTime), this._scheduler.update(this._deltaTime), 
                this._compScheduler.lateUpdatePhase(this._deltaTime), this.emit(cc.Director.EVENT_AFTER_UPDATE), 
                CCObject._deferredDestroy()), this._physicsSystem.update(this._deltaTime), this.emit(cc.Director.EVENT_BEFORE_DRAW), 
                this._root.frameMove(this._deltaTime), this.emit(cc.Director.EVENT_AFTER_DRAW), 
                eventManager.frameUpdateListeners(), this._scene && this._scene.resetHasChanged(), 
                this._totalFrames++, this._root.device.present());
            }
        }, {
            key: "__fastOn",
            value: function __fastOn(type, callback, target) {
                this.add(type, callback, target);
            }
        }, {
            key: "__fastOff",
            value: function __fastOff(type, callback, target) {
                this.remove(type, callback, target);
            }
        }, {
            key: "root",
            get: function get$$1() {
                return this._root;
            }
        } ]), Director;
    }();
    Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", 
    Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", Director.EVENT_BEFORE_UPDATE = "director_before_update", 
    Director.EVENT_AFTER_UPDATE = "director_after_update", Director.EVENT_BEFORE_DRAW = "director_before_draw", 
    Director.EVENT_AFTER_DRAW = "director_after_draw";
    cc.director = new Director();
    cc.Director = Director, cc.vmath = vmath;
    var _temp_vec3_1$1 = new Vec3();
    cc.pipelineUtils = {
        WorldNode3DToLocalNodeUI: function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
            out || (out = new Vec3()), mainCamera.worldToScreen(wpos, _temp_vec3_1$1), _temp_vec3_1$1.x = _temp_vec3_1$1.x / cc.view.getScaleX(), 
            _temp_vec3_1$1.y = _temp_vec3_1$1.y / cc.view.getScaleY();
            var cmp = uiNode.getComponent(UITransformComponent);
            if (!cmp) return out;
            cmp.convertToNodeSpaceAR(_temp_vec3_1$1, out);
            var targetPos = uiNode.getPosition();
            return out.addSelf(targetPos), out;
        },
        WorldNode3DToWorldNodeUI: function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
            return out || (out = new Vec3()), mainCamera.worldToScreen(wpos, out), out.x = out.x / cc.view.getScaleX(), 
            out.y = out.y / cc.view.getScaleY(), out;
        }
    }, cc.RenderPassStage = RenderPassStage;
    var NodePool = function() {
        function NodePool(poolHandlerComp) {
            _classCallCheck(this, NodePool), this.poolHandlerComp = void 0, this._pool = void 0, 
            this.poolHandlerComp = poolHandlerComp, this._pool = [];
        }
        return _createClass(NodePool, [ {
            key: "size",
            value: function size() {
                return this._pool.length;
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var count = this._pool.length, i = 0; i < count; ++i) this._pool[i].destroy();
                this._pool.length = 0;
            }
        }, {
            key: "put",
            value: function put(obj) {
                if (obj && -1 === this._pool.indexOf(obj)) {
                    obj.removeFromParent(!1);
                    var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                    handler && handler.unuse && handler.unuse(), this._pool.push(obj);
                }
            }
        }, {
            key: "get",
            value: function get() {
                var last = this._pool.length - 1;
                if (last < 0) return null;
                var obj = this._pool[last];
                this._pool.length = last;
                var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                if (handler && handler.reuse) {
                    for (var _handler$reuse, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    (_handler$reuse = handler.reuse).apply.apply(_handler$reuse, [ handler ].concat(args));
                }
                return obj;
            }
        } ]), NodePool;
    }();
    cc.NodePool = NodePool, cc.renderer = renderer;
    var cclegacy = cc;
    return exports.renderer = renderer, exports.cclegacy = cclegacy, exports.vmath = vmath, 
    exports.js = js, exports.path = path, exports.profiler = profiler, exports.BUILTIN_CLASSID_RE = BUILTIN_CLASSID_RE, 
    exports.BASE64_VALUES = BASE64_VALUES, exports.propertyDefine = propertyDefine, 
    exports.nextPOT = nextPOT, exports.pushToMap = pushToMap, exports.clampf = clampf, 
    exports.clamp01 = clamp01$1, exports.lerp = lerp$1, exports.degreesToRadians = degreesToRadians, 
    exports.radiansToDegrees = radiansToDegrees, exports.contains = contains$1, exports.isDomNode = isDomNode, 
    exports.callInNextTick = callInNextTick, exports.tryCatchFunctor_EDITOR = tryCatchFunctor_EDITOR, 
    exports.isPlainEmptyObj_DEV = isPlainEmptyObj_DEV, exports.cloneable_DEV = cloneable_DEV, 
    exports.isUnicodeCJK = isUnicodeCJK, exports.isUnicodeSpace = isUnicodeSpace, exports.safeMeasureText = safeMeasureText, 
    exports.fragmentText = fragmentText, exports.HtmlTextParser = HtmlTextParser, exports.PrefabInfo = PrefabInfo, 
    exports._decorator = _decorator, exports.CCClass = CCClass, exports.CCObject = CCObject, 
    exports.deserialize = deserialize, exports.instantiate = instantiate, exports.CCInteger = CCInteger, 
    exports.CCFloat = CCFloat, exports.CCBoolean = CCBoolean, exports.CCString = CCString, 
    exports.Event = Event, exports.EventTarget = EventTarget, exports.screen = screen$1, 
    exports.macro = macro, exports.eventManager = eventManager, exports.SystemEvent = SystemEvent, 
    exports.systemEvent = systemEvent, exports.EventMouse = EventMouse, exports.EventTouch = EventTouch, 
    exports.EventAcceleration = EventAcceleration, exports.EventKeyboard = EventKeyboard, 
    exports.Enum = Enum, exports.ValueType = ValueType, exports.Vec2 = Vec2, exports.Vec3 = Vec3, 
    exports.Vec4 = Vec4, exports.Quat = Quat, exports.Mat4 = Mat4, exports.AffineTransform = AffineTransform, 
    exports.Size = Size, exports.Rect = Rect, exports.Color = Color, exports.BaseNode = BaseNode, 
    exports.Node = Node$1, exports.Scene = Scene, exports.Layers = Layers, exports.find = find, 
    exports.PrivateNode = PrivateNode, exports.NodeActivator = NodeActivator, exports.textureUtil = textureUtil, 
    exports.RawAsset = RawAsset, exports.Asset = Asset, exports.Prefab = Prefab, exports.SceneAsset = SceneAsset, 
    exports.SpriteAtlas = SpriteAtlas, exports.TextAsset = TextAsset, exports.JsonAsset = JsonAsset, 
    exports.AssetLibrary = AssetLibrary, exports.ImageAsset = ImageAsset, exports.Texture2D = Texture2D, 
    exports.TTFFont = TTFFont, exports.LabelAtlas = LabelAtlas, exports.BitmapFont = BitmapFont, 
    exports.Font = Font, exports.Script = Script, exports.JavaScript = JavaScript, exports.TypeScript = TypeScript, 
    exports.SpriteFrame = SpriteFrame, exports.easing = easing, exports.bezier = bezier, 
    exports.bezierByTime = bezierByTime, exports.Curve = Curve, exports.Bezier = Bezier, 
    exports.sampleMotionPaths = function sampleMotionPaths(motionPaths, data, duration, fps) {
        var createControlPoints = function createControlPoints(array) {
            return array instanceof Vec2 ? {
                in: array,
                pos: array,
                out: array
            } : Array.isArray(array) && 6 === array.length ? {
                in: new Vec2(array[2], array[3]),
                pos: new Vec2(array[0], array[1]),
                out: new Vec2(array[4], array[5])
            } : {
                in: Vec2.ZERO,
                pos: Vec2.ZERO,
                out: Vec2.ZERO
            };
        }, values = data.values = data.values.map(function(value) {
            return Array.isArray(value) && (value = 2 === value.length ? cc.v2(value[0], value[1]) : cc.v3(value[0], value[1], value[2])), 
            value;
        });
        if (0 !== motionPaths.length && 0 !== values.length) {
            for (var motionPathValid = !1, i = 0; i < motionPaths.length; i++) {
                var motionPath = motionPaths[i];
                if (motionPath && !checkMotionPath(motionPath) && (errorID(3904, "", "position", i), 
                motionPath = void 0), motionPath && 0 < motionPath.length) {
                    motionPathValid = !0;
                    break;
                }
            }
            if (motionPathValid && 1 !== values.length) {
                for (var types = data.types, ratios = data.ratioSampler ? data.ratioSampler.ratios : [], newValues = data.values = [], newTypes = data.types = [], newRatios = data.ratios = [], startRatioOffset = 0, newType = AnimCurve.Linear, _i2 = 0, l = motionPaths.length; _i2 < l - 1; _i2++) {
                    var _motionPath = motionPaths[_i2], ratio = ratios[_i2], betweenRatio = ratios[_i2 + 1] - ratio, value = values[_i2], nextValue = values[_i2 + 1], type = types[_i2], results = [], progress = startRatioOffset / betweenRatio, speed = 1 / (betweenRatio * duration * fps), finalProgress = void 0;
                    if (_motionPath && 0 < _motionPath.length) {
                        var _points = [];
                        _points.push(createControlPoints(value));
                        for (var j = 0, l2 = _motionPath.length; j < l2; j++) {
                            var controlPoints = createControlPoints(_motionPath[j]);
                            _points.push(controlPoints);
                        }
                        _points.push(createControlPoints(nextValue));
                        var curve = new Curve(_points);
                        curve.computeBeziers();
                        for (var progresses = curve.progresses; 1e-6 < 1 - progress; ) {
                            var _pos = void 0;
                            if ((finalProgress = computeRatioByType(finalProgress = progress, type)) < 0) {
                                var _bezier3 = curve.beziers[0], length = (0 - finalProgress) * _bezier3.getLength(), normal = _bezier3.start.sub(_bezier3.endCtrlPoint).normalize();
                                _pos = _bezier3.start.add(normal.mul(length));
                            } else if (1 < finalProgress) {
                                var _bezier4 = curve.beziers[curve.beziers.length - 1], _length = (finalProgress - 1) * _bezier4.getLength(), _normal = _bezier4.end.sub(_bezier4.startCtrlPoint).normalize();
                                _pos = _bezier4.end.add(_normal.mul(_length));
                            } else {
                                var bezierIndex = binarySearchEpsilon(progresses, finalProgress);
                                bezierIndex < 0 && (bezierIndex = ~bezierIndex), finalProgress -= 0 < bezierIndex ? progresses[bezierIndex - 1] : 0, 
                                finalProgress /= curve.ratios[bezierIndex], _pos = curve.beziers[bezierIndex].getPointAt(finalProgress);
                            }
                            results.push(_pos), progress += speed;
                        }
                    } else for (;1e-6 < 1 - progress; ) finalProgress = computeRatioByType(finalProgress = progress, type), 
                    results.push(value.lerp(nextValue, finalProgress)), progress += speed;
                    newType = "constant" === type ? type : AnimCurve.Linear;
                    for (var _j = 0, _l = results.length; _j < _l; _j++) {
                        var newRatio = ratio + startRatioOffset + speed * _j * betweenRatio;
                        addNewDatas(results[_j], newType, newRatio);
                    }
                    startRatioOffset = 1e-6 < Math.abs(progress - 1) ? (progress - 1) * betweenRatio : 0;
                }
                ratios[ratios.length - 1] !== newRatios[newRatios.length - 1] && addNewDatas(values[values.length - 1], newType, ratios[ratios.length - 1]);
            }
        }
        function addNewDatas(value, type, ratio) {
            newValues.push(value), newTypes.push(type), newRatios.push(ratio);
        }
    }, exports.RatioSampler = RatioSampler, exports.AnimCurve = AnimCurve, exports.EventInfo = EventInfo, 
    exports.computeRatioByType = computeRatioByType, exports.AnimationClip = AnimationClip, 
    exports.AnimationManager = AnimationManager, exports.AnimationState = AnimationState, 
    exports.CubicSplineVec2Value = CubicSplineVec2Value, exports.CubicSplineVec3Value = CubicSplineVec3Value, 
    exports.CubicSplineVec4Value = CubicSplineVec4Value, exports.CubicSplineQuatValue = CubicSplineQuatValue, 
    exports.CubicSplineNumberValue = CubicSplineNumberValue, exports.url = url, exports.Downloader = Downloader, 
    exports.Loader = Loader, exports.LoadingItems = LoadingItems, exports.Pipeline = Pipeline, 
    exports.loader = loader, exports.Component = Component, exports.EventHandler = EventHandler, 
    exports.MissingScript = MissingScript, exports.AnimationComponent = AnimationComponent, 
    exports.utils = utils, exports.primitives = primitives, exports.geometry = geometry, 
    exports.AudioClip = AudioClip, exports.EffectAsset = EffectAsset, exports.Material = Material, 
    exports.Mesh = Mesh, exports.Skeleton = Skeleton, exports.PhysicsMaterial = PhysicsMaterial, 
    exports.effects = effects$1, exports.builtinResMgr = builtinResMgr, exports.AudioSourceComponent = AudioSourceComponent, 
    exports.CameraComponent = CameraComponent, exports.LightComponent = LightComponent, 
    exports.ModelComponent = ModelComponent, exports.SkinningModelComponent = SkinningModelComponent, 
    exports.AvatarModelComponent = AvatarModelComponent, exports.AvatarUnit = AvatarUnit, 
    exports.BatchedSkinningModelComponent = BatchedSkinningModelComponent, exports.SkinningModelUnit = SkinningModelUnit, 
    exports.ParticleSystemComponent = ParticleSystemComponent, exports.BillboardComponent = BillboardComponent, 
    exports.LineComponent = LineComponent, exports.RenderableComponent = RenderableComponent, 
    exports.ColliderComponent = ColliderComponent, exports.BoxColliderComponent = BoxColliderComponent, 
    exports.SphereColliderComponent = SphereColliderComponent, exports.RigidBodyComponent = RigidBodyComponent, 
    exports.PhysicsSystem = PhysicsSystem, exports.CircularPool = CircularPool, exports.FixedArray = FixedArray, 
    exports.LinkedArray = LinkedArray, exports.Pool = Pool$1, exports.RecyclePool = RecyclePool, 
    exports.TypedArrayPool = typedArrayPool, exports.Assembler = Assembler, exports.MeshBuffer = MeshBuffer, 
    exports.CanvasComponent = CanvasComponent, exports.DebugCanvasComponent = DebugCanvasComponent, 
    exports.UIComponent = UIComponent, exports.ButtonComponent = ButtonComponent, exports.EditBoxComponent = EditBoxComponent, 
    exports.LayoutComponent = LayoutComponent, exports.MaskComponent = MaskComponent, 
    exports.ProgressBarComponent = ProgressBarComponent, exports.RichTextComponent = RichTextComponent, 
    exports.ScrollBarComponent = ScrollBarComponent, exports.ScrollViewComponent = ScrollViewComponent, 
    exports.SliderComponent = SliderComponent, exports.SpriteComponent = SpriteComponent, 
    exports.ToggleComponent = ToggleComponent, exports.ToggleContainerComponent = ToggleContainerComponent, 
    exports.UIModelComponent = UIModelComponent, exports.UIRenderComponent = UIRenderComponent, 
    exports.UITransformComponent = UITransformComponent, exports.ViewGroupComponent = ViewGroupComponent, 
    exports.WebviewComponent = WebviewComponent, exports.WidgetComponent = WidgetComponent, 
    exports.LabelOutlineComponent = LabelOutlineComponent, exports.GraphicsComponent = GraphicsComponent, 
    exports.widgetManager = widgetManager, exports.LabelComponent = LabelComponent, 
    exports.NodePool = NodePool, exports;
}({});